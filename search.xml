<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法（十五） 背包dp</title>
      <link href="/posts/2707a2f4.html"/>
      <url>/posts/2707a2f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="基础背包"><a href="#基础背包" class="headerlink" title="基础背包"></a>基础背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[weight+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=weight;j&gt;=nums[i-<span class="number">1</span>];j--)&#123;</span><br><span class="line">        dp[j] = Math.max(dp[j-nums[i-<span class="number">1</span>]]+nums[i-<span class="number">1</span>],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[weight];</span><br></pre></td></tr></table></figure><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>leetcode 494</p><p>思路：见代码注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新思路，转化为01背包问题</span></span><br><span class="line"><span class="comment">// 思考1:</span></span><br><span class="line"><span class="comment">// 虽然题目说nums是非负数组，但即使nums中有负数比如[3,-4,2]</span></span><br><span class="line"><span class="comment">// 因为能在每个数前面用+或者-号</span></span><br><span class="line"><span class="comment">// 所以[3,-4,2]其实和[3,4,2]会达成一样的结果</span></span><br><span class="line"><span class="comment">// 所以即使nums中有负数，也可以把负数直接变成正数，也不会影响结果</span></span><br><span class="line"><span class="comment">// 思考2:</span></span><br><span class="line"><span class="comment">// 如果nums都是非负数，并且所有数的累加和是sum</span></span><br><span class="line"><span class="comment">// 那么如果target&gt;sum，很明显没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line"><span class="comment">// 思考3:</span></span><br><span class="line"><span class="comment">// nums内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性</span></span><br><span class="line"><span class="comment">// 所以，如果所有数的累加和是sum，并且与target的奇偶性不一样</span></span><br><span class="line"><span class="comment">// 那么没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line"><span class="comment">// 思考4(最重要):</span></span><br><span class="line"><span class="comment">// 比如说给定一个数组, nums = [1, 2, 3, 4, 5] 并且 target = 3</span></span><br><span class="line"><span class="comment">// 其中一个方案是 : +1 -2 +3 -4 +5 = 3</span></span><br><span class="line"><span class="comment">// 该方案中取了正的集合为A = &#123;1，3，5&#125;</span></span><br><span class="line"><span class="comment">// 该方案中取了负的集合为B = &#123;2，4&#125;</span></span><br><span class="line"><span class="comment">// 所以任何一种方案，都一定有 sum(A) - sum(B) = target</span></span><br><span class="line"><span class="comment">// 现在我们来处理一下这个等式，把左右两边都加上sum(A) + sum(B)，那么就会变成如下：</span></span><br><span class="line"><span class="comment">// sum(A) - sum(B) + sum(A) + sum(B) = target + sum(A) + sum(B)</span></span><br><span class="line"><span class="comment">// 2 * sum(A) = target + 数组所有数的累加和</span></span><br><span class="line"><span class="comment">// sum(A) = (target + 数组所有数的累加和) / 2</span></span><br><span class="line"><span class="comment">// 也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2</span></span><br><span class="line"><span class="comment">// 那么就一定对应一种target的方式</span></span><br><span class="line"><span class="comment">// 比如非负数组nums，target = 1, nums所有数累加和是11</span></span><br><span class="line"><span class="comment">// 求有多少方法组成1，其实就是求，有多少种子集累加和达到6的方法，(1+11)/2=6</span></span><br><span class="line"><span class="comment">// 因为，子集累加和6 - 另一半的子集累加和5 = 1(target)</span></span><br><span class="line"><span class="comment">// 所以有多少个累加和为6的不同集合，就代表有多少个target==1的表达式数量</span></span><br><span class="line"><span class="comment">// 至此已经转化为01背包问题了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">sum += n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> subsets(nums, (target + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求非负数组nums有多少个子序列累加和是t</span></span><br><span class="line"><span class="comment">// 01背包问题(子集累加和严格是t) + 空间压缩</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123; <span class="comment">// i省略了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= num; j--) &#123;</span><br><span class="line">dp[j] += dp[j - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h2><p>leetcode 1049</p><p>思路：转化为找出一个数组中最接近和的一半的子序列和。答案就是sum - 2 * 子序列和，找最接近和的一半的子序列和就是01背包问题。背包容量为一半，然后找出价值最高的子序列和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">        sum+=stone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">near</span> <span class="operator">=</span> findLSW(stones,sum/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> sum - near - near;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLSW</span><span class="params">(<span class="type">int</span>[] stones, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=stone;j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-stone]+stone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>同一个组的物品只能选一个，求最大价值。</p><p>思路：还是分为要跟不要。但是要的情况需要讨论要一组里的哪一个。所以dp[i][j] 中的i表示物品组，j表示背包容量。开始时可以按组号排序，一组一组处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">teams</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i - <span class="number">1</span>][<span class="number">2</span>] != arr[i][<span class="number">2</span>]) &#123;</span><br><span class="line">teams++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组的编号1~teams</span></span><br><span class="line"><span class="comment">// dp[i][j] : 1~i是组的范围，每个组的物品挑一件，容量不超过j的情况下，最大收益</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[teams + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// dp[0][....] = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>, i = <span class="number">1</span>; start &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start ... end-1 -&gt; i组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="comment">// arr[start...end-1]是当前组，组号一样</span></span><br><span class="line"><span class="comment">// 其中的每一件商品枚举一遍</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line"><span class="comment">// k是组内的一个商品编号</span></span><br><span class="line"><span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - arr[k][<span class="number">0</span>]] + arr[k][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start去往下一组的第一个物品</span></span><br><span class="line"><span class="comment">// 继续处理剩下的组</span></span><br><span class="line">start = end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[teams][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][...] = 0</span></span><br><span class="line">Arrays.fill(dp, <span class="number">0</span>, m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>; start &lt;= n;) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start....end-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], arr[k][<span class="number">1</span>] + dp[j - arr[k][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">start = end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从栈中取出k个硬币的最大面值和"><a href="#从栈中取出k个硬币的最大面值和" class="headerlink" title="从栈中取出k个硬币的最大面值和"></a>从栈中取出k个硬币的最大面值和</h2><p>leetcode 2218</p><p>思路：以一个栈里面的硬币为分组。一组里面的元素就是拿一个硬币，两个硬币，三个硬币…得到的面值。一组我也只能拿一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// piles是一组一组的硬币</span></span><br><span class="line"><span class="comment">// m是容量，表示一定要进行m次操作</span></span><br><span class="line"><span class="comment">// dp[i][j] : 1~i组上，一共拿走j个硬币的情况下，获得的最大价值</span></span><br><span class="line"><span class="comment">// 1) 不要i组的硬币 : dp[i-1][j]</span></span><br><span class="line"><span class="comment">// 2) i组里尝试每一种方案</span></span><br><span class="line"><span class="comment">// 比如，i组里拿走前k个硬币的方案 : dp[i-1][j-k] + 从顶部开始前k个硬币的价值和</span></span><br><span class="line"><span class="comment">// 枚举每一个k，选出最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins1</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.size();</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">// i从1组开始（我们的设定），但是题目中的piles是从下标0开始的</span></span><br><span class="line"><span class="comment">// 所以来到i的时候，piles.get(i-1)是当前组</span></span><br><span class="line">List&lt;Integer&gt; team = piles.get(i - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.min(team.size(), m);</span><br><span class="line"><span class="comment">// 预处理前缀和，为了加速计算</span></span><br><span class="line"><span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">sum += team.get(j);</span><br><span class="line">preSum[j + <span class="number">1</span>] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新动态规划表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="comment">// 当前组一个硬币也不拿的方案</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= Math.min(t, j); k++) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k] + preSum[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (List&lt;Integer&gt; team : piles) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.min(team.size(), m);</span><br><span class="line"><span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">sum += team.get(j);</span><br><span class="line">preSum[j + <span class="number">1</span>] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= Math.min(t, j); k++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - k] + preSum[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="模板题-1"><a href="#模板题-1" class="headerlink" title="模板题"></a>模板题</h2><p>一个物品可以重复取，求最大价值。</p><p>dp[i][j] = Max(dp[i-1][j],dp[i][j-w[i]]+v[i]) //拿了之后i也不减一，就可以拿多次。空间压缩需要正着遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// 会空间不够，导致无法通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][.....] = 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="comment">// 可以通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>, t + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cost[i]; j &lt;= t; j++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（十四）动态规划</title>
      <link href="/posts/915e2077.html"/>
      <url>/posts/915e2077.html</url>
      
        <content type="html"><![CDATA[<p>关于动态规划内容很多，这里只列举一些我觉都有意思的题目。</p><h1 id="二维简单动态规划"><a href="#二维简单动态规划" class="headerlink" title="二维简单动态规划"></a>二维简单动态规划</h1><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>leetcode 64</p><p>思路：状态转移方程：f[i][j] = Math.min(f[i-1][j],f[i][j-1]) + grid[i][j] 因为一个位置只能从上或者左转移过来，所以状态转移方程就是这个样子的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i] = grid[<span class="number">0</span>][i]+dp[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>]+=grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">           dp[j] = Math.min(dp[j-<span class="number">1</span>],dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>leetcode 1143</p><p>思路：状态转移方程：f[i][j] = if(s1[i]==s2[j]) f[i-1][j-1]+1 else max(f[i-1][j],f[i][j-1])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s1 = text1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] s2 = text2.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>s1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>leetcode 516</p><p>思路：第一种思路，把原字符串翻转，然后求最长子序列。</p><p>第二种思路，二维dp,记录从l到r的回文子序列的长度。 初始化dp[i][i] = 1;,dp[i][i+1] = s[i] == s[i+1] ? 2 : 1; 每个格子依赖于左下，下，左边的格子。于是dp的顺序就是从下到上，从左到右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n-<span class="number">1</span>;l&gt;=<span class="number">0</span>;l--)&#123;</span><br><span class="line">        dp[l][l] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            dp[l][l+<span class="number">1</span>] = c[l] == c[l+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l+<span class="number">2</span>;r&lt;n;r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[r] == c[l])&#123;</span><br><span class="line">                dp[l][r] = dp[l+<span class="number">1</span>][r-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[l][r] = Math.max(dp[l+<span class="number">1</span>][r],dp[l][r-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>leetcode 115</p><p>思路：dp[i][j] 表示s1的前i个字符，s2的前j个字符，有多少个不同的子序列。 那么当s1[i]==s2[j] 时，dp[i][j] = dp[i-1][j-1]+dp[i-1][j] 否则dp[i][j] = dp[i-1][j]<br>然后初始化dp[i][0] = 1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= Math.min(i,n-<span class="number">1</span>); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.min(i,n); j &gt;=<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>leetcode 72 在此基础上新增了每种操作的代价。</p><p>思路：dp[i][j]含义为需要多少代价才能使得s1前i个字符和s2前j个字符相等。当s1[i] == s2[j]时，dp[i][j] = dp[i-1][j-1] 此时不用任何操作。如果不相等，就可以进行三种操作。</p><ol><li>插入s1[i]， 但需要s1前i个字符和s2前j-1个字符相等。就是dp[i][j-1]。最后加上插入代价 + a</li><li>删除s1[i]， 但需要s1前i-1个字符和s2前j个字符相等。就是dp[i-1][j]。最后加上删除代价 + b</li><li>替换s1[i]， 但需要s1前i-1个字符和s2前j-1个字符相等。就是dp[i-1][j-1]。最后加上替换代价 + c</li></ol><p>初始化时dp[0][j] = j <em> a（因为从空字符串到s2只能插入）; dp[i][0] = i </em> b（从s1到空字符串只能删除）;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistance2</span><span class="params">(String str1, String str2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line"><span class="comment">// dp[i][j] :</span></span><br><span class="line"><span class="comment">// s1[前缀长度为i]想变成s2[前缀长度为j]，至少付出多少代价</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + b, dp[i][j - <span class="number">1</span>] + a), dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//空间压缩</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fff</span><span class="params">(<span class="type">char</span>[] s1, <span class="type">char</span>[] s2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">           dp[i] = i*a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">leftup</span> <span class="operator">=</span> dp[<span class="number">0</span>] ,backup;</span><br><span class="line">           dp[<span class="number">0</span>] = i*b;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">               backup = dp[j];</span><br><span class="line">               <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                   dp[j] = leftup;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   dp[j] = Math.min(Math.min(dp[j-<span class="number">1</span>]+a,dp[j]+b),leftup+c);</span><br><span class="line">               &#125;</span><br><span class="line">               leftup = backup;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h2><p>leetcode 97</p><p>思路： dp[i][j]表示s1的前i个字符和s2的前j个字符是否可以交错组成s3的前i+j个字符。然后判断</p><ol><li>如果s1[i-1] == s3[i+j-1]，说明是s1提供了最后一个字符，那么此时我就保证s1的前i-1个字符和s2的前j个字符可以交错组成s3的前i+j-1个字符。即dp[i-1][j];</li><li>如果s2[j-1] == s3[i+j-1]，说明是s2提供了最后一个字符，那么此时我就保证s1的前i个字符和s2的前j-1个字符可以交错组成s3的前i+j-1个字符。即dp[i][j-1];</li></ol><p>初始化： dp[i][0] 表示 s2不参与拼接，就是纯靠s1去拼接s3的前i个字符。 dp[0][j] 表示 s1不参与拼接，就是纯靠s2去拼接s3的前j个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave1</span><span class="params">(String str1, String str2, String str3)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str1.length() + str2.length() != str3.length()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s3 = str3.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line"><span class="comment">// dp[i][j]:</span></span><br><span class="line"><span class="comment">// s1[前缀长度为i]和s2[前缀长度为j]，能否交错组成出s3[前缀长度为i+j]</span></span><br><span class="line"><span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i - <span class="number">1</span>] != s3[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s2[j - <span class="number">1</span>] != s3[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[i][j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子数组和相关问题"><a href="#子数组和相关问题" class="headerlink" title="子数组和相关问题"></a>子数组和相关问题</h1><h2 id="子数组最大和"><a href="#子数组最大和" class="headerlink" title="子数组最大和"></a>子数组最大和</h2><p>leetcode 53</p><p>思路：dp[i]表示以i为结尾的子数组的和最大是多少。那么dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// dp[i] : 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和</span></span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre = nums[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">pre = Math.max(nums[i], pre + nums[i]);</span><br><span class="line">ans = Math.max(ans, pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环数组中子数组的最大和"><a href="#循环数组中子数组的最大和" class="headerlink" title="循环数组中子数组的最大和"></a>循环数组中子数组的最大和</h2><p>leetcode 918</p><p>思路：求子数组最大和跟最小和即可。用sum - minSum 就是分开的子数组的最大和。 但需要特判一下是不是全是负数的情况.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>] ,minSum = nums[<span class="number">0</span>],preMax=nums[<span class="number">0</span>],preMin=nums[<span class="number">0</span>],sum=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        preMax = Math.max(preMax+nums[i],nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum,preMax);</span><br><span class="line">        preMin = Math.min(preMin+nums[i],nums[i]);</span><br><span class="line">        minSum = Math.min(minSum,preMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == minSum ? maxSum : (Math.max(maxSum, sum - minSum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍2"><a href="#打家劫舍2" class="headerlink" title="打家劫舍2"></a>打家劫舍2</h2><p>leetcode 213</p><p>思路：分开讨论即可，要么不偷第一家，在2-n之间偷，要么偷第一家，在1-n-1之间偷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分开讨论</span></span><br><span class="line">    <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不拿第一家</span></span><br><span class="line">    dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp1[<span class="number">2</span>] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不拿最后一家</span></span><br><span class="line">    dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp2[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp1[n],dp2[n-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍4"><a href="#打家劫舍4" class="headerlink" title="打家劫舍4"></a>打家劫舍4</h2><p>leetcode 2560</p><p>思路：二分+dp。 转化为给定能力，小偷最多偷多少家即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCapability</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        max = Math.max(nums[i],max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>max;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f(nums,mid,k))&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> cap,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = cap &gt;= nums[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &gt; cap)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] &gt;= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>leetcode 152</p><p>思路：dp1[i] 表示以i为结尾的子数组乘积最大是多少。dp2[i] 表示以i为结尾的子数组乘积最小是多少。 每次正在一个位置比较最小值乘以自己，最大值乘以自己，跟自己的大小即可。并且更新dp1[i]，dp2[i]。  代码直接给出空间压缩版本.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        temp = max;</span><br><span class="line">        temp = Math.max(Math.max(max*nums[i],min*nums[i]),nums[i]);</span><br><span class="line">        min = Math.min(Math.min(min*nums[i],max*nums[i]),nums[i]);</span><br><span class="line">        max = temp;</span><br><span class="line">        ans = Math.max(max,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="被7整除的最大子序列和"><a href="#被7整除的最大子序列和" class="headerlink" title="被7整除的最大子序列和"></a>被7整除的最大子序列和</h2><p>思路：dp[i][j] 表示以第i个数为结尾，模数为j的子序列和最大是多少。那么dp[i][j] = dp[i-1][j]  或者 dp[i-1][(j+7-nums[i-1]%7)%7] + nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// dp[i][j] : nums[0...i-1]</span></span><br><span class="line"><span class="comment">// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j</span></span><br><span class="line"><span class="comment">// 这样的子序列最大累加和是多少</span></span><br><span class="line"><span class="comment">// 注意 : dp[i][j] == -1代表不存在这样的子序列</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">7</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, x, cur, need; i &lt;= n; i++) &#123;</span><br><span class="line">x = nums[i - <span class="number">1</span>];</span><br><span class="line">cur = nums[i - <span class="number">1</span>] % <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="comment">// 这里求need是核心</span></span><br><span class="line">need = cur &lt;= j ? (j - cur) : (j - cur + <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 或者如下这种写法也对</span></span><br><span class="line"><span class="comment">// need = (7 + j - cur) % 7;</span></span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][need] != -<span class="number">1</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][need] + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以翻转1次的情况下子数组最大累加和"><a href="#可以翻转1次的情况下子数组最大累加和" class="headerlink" title="可以翻转1次的情况下子数组最大累加和"></a>可以翻转1次的情况下子数组最大累加和</h2><p>给定一个数组nums，</p><p>现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整</p><p>比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]</p><p>返回必须随意翻转1次之后，子数组的最大累加和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumReverse2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// start[i] : 所有必须以i开头的子数组中，最大累加和是多少</span></span><br><span class="line"><span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">start[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// nums[i]</span></span><br><span class="line"><span class="comment">// nums[i] + start[i+1]</span></span><br><span class="line">start[i] = Math.max(nums[i], nums[i] + start[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> start[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// end : 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// maxEnd :</span></span><br><span class="line"><span class="comment">// 0~i-1范围上，</span></span><br><span class="line"><span class="comment">// 子数组必须以0结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// 子数组必须以1结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// 所有情况中，最大的那个累加和就是maxEnd</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// maxend   i....</span></span><br><span class="line"><span class="comment">// 枚举划分点 i...</span></span><br><span class="line">ans = Math.max(ans, maxEnd + start[i]);</span><br><span class="line"><span class="comment">// 子数组必须以i结尾，其中的最大累加和</span></span><br><span class="line">end = Math.max(nums[i], end + nums[i]);</span><br><span class="line">maxEnd = Math.max(maxEnd, end);</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(ans, maxEnd);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最长递增子序列相关题目"><a href="#最长递增子序列相关题目" class="headerlink" title="最长递增子序列相关题目"></a>最长递增子序列相关题目</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>leetcode 300</p><p>思路：最基础的复杂度O(n^2)，优化版本</p><p>维护一个ends[]数组，表示ends[i]表示长度为i+1的递增子序列的最小末尾元素。那么以后我要新增一个元素，那么我需要二分找到大于等于这个元素的最左位置，然后更新这个位置的元素为这个元素。如果没找到，那么就插入到数组末尾。并且len++。最后返回len即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n * logn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line"><span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">find = bs1(ends, len, nums[i]);</span><br><span class="line"><span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">ends[len++] = nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ends[find] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line"><span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line"><span class="comment">// 如果不存在返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="俄罗斯套娃信封"><a href="#俄罗斯套娃信封" class="headerlink" title="俄罗斯套娃信封"></a>俄罗斯套娃信封</h2><p>leetcode 354</p><p>思路：先将宽高进行排序，按宽度升序，高度降序。然后对于高度求最长递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    Arrays.sort(envelopes,(a,b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> bs1(ends,len,envelopes[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(find == -<span class="number">1</span>)&#123;</span><br><span class="line">            ends[len++] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ends[find] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ends[mid] &gt;= target)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长对数链"><a href="#最长对数链" class="headerlink" title="最长对数链"></a>最长对数链</h2><p>leetcode 646</p><p>思路：每个数对按第一个数降序排列。然后求最长递增子序列。但是注意，这里在二分查找的时候，查找跟放入的不是一个数。按开始位置进行查找，但是放入自己的结束位置，所以不能直接放入，应该判断跟原位置的大小（因为这里只能知道开始的值是小于等于找到的位置的，结束值跟这个位置的大小关系不确定）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ends[mid] &gt;= target)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLongestChain</span><span class="params">(<span class="type">int</span>[][] pairs)</span> &#123;</span><br><span class="line">    Arrays.sort(pairs,(a,b)-&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>pairs.length;</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//根据开始值进行二分查找 找个大于等于自己的最左位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> bs1(ends,len,pairs[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(find == -<span class="number">1</span>)&#123;</span><br><span class="line">            ends[len++] = pairs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里不能直接放入 而是应该判断跟原位置的大小关系</span></span><br><span class="line">            ends[find] = Math.min(pairs[i][<span class="number">1</span>],ends[find]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们讨论分布式中的一致性到底是什么</title>
      <link href="/posts/2db9d40c.html"/>
      <url>/posts/2db9d40c.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？"><a href="#分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？" class="headerlink" title="分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？"></a>分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？</h1><p>在技术圈里摸爬滚打，你一定听过无数次“分布式系统”这个词，也背过无数次 CAP 定理、BASE 理论。</p><p>但你是否在某个深夜调试代码时感到困惑：</p><ul><li><em>“为什么 Seata 的文档里在谈一致性，Raft 的论文里也在谈一致性，但我总感觉它们说的不是一回事？”</em></li><li><em>“微服务拆分后的一致性，和 Redis 集群的一致性，是一样的吗？”</em></li></ul><p>其实，你的直觉是对的。<strong>“分布式系统”这个词是个大筐，里面装了两个完全不同的流派。</strong> 它们虽然都叫分布式，都追求一致性，但它们的灵魂截然不同。</p><p>今天，我们就把这两个流派拆开来看一看。</p><hr><h2 id="流派一：为了“分工与解耦”-——-分布式计算-服务化"><a href="#流派一：为了“分工与解耦”-——-分布式计算-服务化" class="headerlink" title="流派一：为了“分工与解耦” —— 分布式计算/服务化"></a>流派一：为了“分工与解耦” —— 分布式计算/服务化</h2><p>这个流派的典型代表是 <strong>微服务架构（Spring Cloud, Dubbo, gRPC）</strong>。</p><h3 id="1-它的本质：从“一个人干”变成“一群人干”"><a href="#1-它的本质：从“一个人干”变成“一群人干”" class="headerlink" title="1. 它的本质：从“一个人干”变成“一群人干”"></a>1. 它的本质：从“一个人干”变成“一群人干”</h3><p>在这个流派里，我们把一个巨大的单体应用（Monolith）拆成了订单服务、库存服务、支付服务。</p><ul><li><strong>目的：</strong> 为了解耦，为了让不同的团队开发不同的模块，为了逻辑清晰。</li><li><strong>物理形态：</strong> 哪怕每个服务只部署在一台机器上（没有副本），它依然是标准的分布式系统。</li></ul><h3 id="2-这个流派的“痛点”：事务（Transaction）"><a href="#2-这个流派的“痛点”：事务（Transaction）" class="headerlink" title="2. 这个流派的“痛点”：事务（Transaction）"></a>2. 这个流派的“痛点”：事务（Transaction）</h3><p>因为业务逻辑被拆散到了不同的机器上，原本在单机数据库里一个 <code>Begin Transaction ... Commit</code> 就能搞定的事，现在变成了跨越网络的难题。</p><ul><li><strong>场景：</strong> 支付服务扣了钱，库存服务却因为报错没扣库存。</li><li><strong>后果：</strong> 账不平了，老板发火了。</li></ul><h3 id="3-这里的一致性：事务一致性-ACID"><a href="#3-这里的一致性：事务一致性-ACID" class="headerlink" title="3. 这里的一致性：事务一致性 (ACID)"></a>3. 这里的一致性：事务一致性 (ACID)</h3><p>当我们在这个流派下讨论“一致性”时，我们指的是 <strong>“多步操作的原子性”</strong>。</p><ul><li><strong>核心定义：</strong> 一连串的操作，要么全做完，要么全不做，不能停在中间。</li><li><strong>学术术语：</strong> <strong>可串行化 (Serializability)</strong>。</li><li><strong>解决方案：</strong><ul><li><strong>强一致性（刚性事务）：</strong> 比如 <strong>XA/2PC</strong>。通过长时间加锁，保证在事务结束前，外界谁也看不见中间状态。</li><li><strong>最终一致性（柔性事务）：</strong> 比如 <strong>Seata 的 AT/TCC 模式</strong>，或者基于消息队列的 <strong>Saga 模式</strong>。为了性能，允许外界看到短暂的中间状态（脏读/预扣），但保证最终数据是对齐的。</li></ul></li></ul><blockquote><p><strong>一句话总结：</strong> 这里的“一致性”，是<strong>逻辑与时间</strong>的保卫战，防止业务逻辑跑偏。</p></blockquote><hr><h2 id="流派二：为了“生存与扩容”-——-分布式存储-副本"><a href="#流派二：为了“生存与扩容”-——-分布式存储-副本" class="headerlink" title="流派二：为了“生存与扩容” —— 分布式存储/副本"></a>流派二：为了“生存与扩容” —— 分布式存储/副本</h2><p>这个流派的典型代表是 <strong>Redis Cluster, HDFS, Cassandra, Zookeeper, TiDB</strong>。</p><h3 id="1-它的本质：从“一份数据”变成“多份副本”"><a href="#1-它的本质：从“一份数据”变成“多份副本”" class="headerlink" title="1. 它的本质：从“一份数据”变成“多份副本”"></a>1. 它的本质：从“一份数据”变成“多份副本”</h3><p>在这个流派里，我们要解决的不是逻辑复杂的问题，而是机器不可靠的问题。我们把同一份数据（State）复制到 A、B、C 三台机器上。</p><ul><li><strong>目的：</strong> 为了高可用（A 挂了 B 顶上）和高性能（读写分离）。</li><li><strong>物理形态：</strong> 必须是多节点集群，且持有数据副本。</li></ul><h3 id="2-这个流派的“痛点”：同步（Replication）"><a href="#2-这个流派的“痛点”：同步（Replication）" class="headerlink" title="2. 这个流派的“痛点”：同步（Replication）"></a>2. 这个流派的“痛点”：同步（Replication）</h3><p>既然有副本，就涉及到了“我改了 A，B 什么时候改”的问题。</p><ul><li><strong>场景：</strong> 用户在这个毫秒往主节点写了“x=10”，下一个毫秒去从节点读“x”。</li><li><strong>后果：</strong> 如果同步慢了，用户读到了旧值“x=5”，用户会觉得系统在骗人。</li></ul><h3 id="3-这里的一致性：数据一致性-CAP"><a href="#3-这里的一致性：数据一致性-CAP" class="headerlink" title="3. 这里的一致性：数据一致性 (CAP)"></a>3. 这里的一致性：数据一致性 (CAP)</h3><p>当我们在这个流派下讨论“一致性”时，我们指的是 <strong>“多个副本的实时同步”</strong>。</p><ul><li><strong>核心定义：</strong> 写入成功后，所有的副本是否能立刻读到最新值？</li><li><strong>学术术语：</strong> <strong>线性一致性 (Linearizability)</strong>。</li><li><strong>解决方案：</strong> 这就是 <strong>CAP 定理</strong> 的主场。<ul><li><strong>CP (强一致)：</strong> 像 <strong>Zookeeper, Etcd, TiKV</strong>。为了保证所有节点数据一样，必须使用 Paxos/Raft 协议，甚至在网络分区时牺牲可用性（拒绝服务）。</li><li><strong>AP (高可用)：</strong> 像 <strong>Eureka, Cassandra</strong>。为了保证服务永远能连上，允许不同节点暂时数据不一样（最终一致）。</li></ul></li></ul><blockquote><p><strong>一句话总结：</strong> 这里的“一致性”，是<strong>空间与物理</strong>的保卫战，防止数据分身乏术。</p></blockquote><hr><h2 id="终极对决：一张表看懂区别"><a href="#终极对决：一张表看懂区别" class="headerlink" title="终极对决：一张表看懂区别"></a>终极对决：一张表看懂区别</h2><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">流派一：微服务/分布式事务</th><th style="text-align:left">流派二：分布式存储/副本</th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left"><strong>怎么把事情做对？</strong> (Transaction)</td><td style="text-align:left"><strong>怎么把数据存对？</strong> (Storage)</td></tr><tr><td style="text-align:left"><strong>典型组件</strong></td><td style="text-align:left">Spring Cloud, Seata, RocketMQ</td><td style="text-align:left">Redis, Zookeeper, MySQL主从</td></tr><tr><td style="text-align:left"><strong>一致性学术名</strong></td><td style="text-align:left"><strong>Serializability (可串行化)</strong></td><td style="text-align:left"><strong>Linearizability (线性一致性)</strong></td></tr><tr><td style="text-align:left"><strong>关注点</strong></td><td style="text-align:left"><strong>原子性 (Atomicity)</strong> <br> 要么全成功，要么全失败。</td><td style="text-align:left"><strong>可见性 (Visibility)</strong> <br> 写完能不能立刻读到？</td></tr><tr><td style="text-align:left"><strong>指导理论</strong></td><td style="text-align:left"><strong>ACID, BASE</strong></td><td style="text-align:left"><strong>CAP, PACELC</strong></td></tr><tr><td style="text-align:left"><strong>强一致意味着</strong></td><td style="text-align:left">加锁，直到整个业务流程结束，别人<strong>看不见中间状态</strong>。</td><td style="text-align:left">同步，写入主节点成功后，从节点<strong>必须也是新值</strong>。</td></tr><tr><td style="text-align:left"><strong>常见算法</strong></td><td style="text-align:left">2PC, 3PC, TCC</td><td style="text-align:left">Paxos, Raft, Gossip</td></tr></tbody></table></div><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所以，下次当你和别人争论“这个系统是不是强一致性”的时候，先停下来问一句：</p><p><strong>“哥们，我们现在是在聊业务逻辑的原子性（流派一），还是在聊数据库副本的同步（流派二）？”</strong></p><ul><li>如果是前者，<strong>Seata 的 AT 模式</strong> 虽然叫“最终一致性”，但它解决的是<strong>业务</strong>的一致性。 <strong>Seata 的 XA 模式</strong> 是‘强一致性’，解决的是也是<strong>业务</strong>的强一致性。</li><li>如果是后者，<strong>Redis 的主从异步复制</strong> 虽然也叫“最终一致性”，但它解决的是<strong>数据副本</strong>的一致性。<strong>Raft算法</strong> 是‘强一致性’，解决的是<strong>数据副本</strong>的强一致性。</li></ul><p><strong>分布式系统没有银弹，只有权衡（Trade-off）。</strong> 理解了这两个流派的区别，你才能在架构设计中，准确地选择你手中的武器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（十三） 图</title>
      <link href="/posts/ad899ecc.html"/>
      <url>/posts/ad899ecc.html</url>
      
        <content type="html"><![CDATA[<h2 id="建图的几种方式-邻接矩阵、邻接表、链式前向星"><a href="#建图的几种方式-邻接矩阵、邻接表、链式前向星" class="headerlink" title="建图的几种方式 邻接矩阵、邻接表、链式前向星"></a>建图的几种方式 邻接矩阵、邻接表、链式前向星</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点的最大数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的最大数量</span></span><br><span class="line"><span class="comment">// 只有链式前向星方式建图需要这个数量</span></span><br><span class="line"><span class="comment">// 注意如果无向图的最大数量是m条边，数量要准备m*2</span></span><br><span class="line"><span class="comment">// 因为一条无向边要加两条有向边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵方式建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] graph1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表方式建图</span></span><br><span class="line"><span class="comment">// public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph2 = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星方式建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果边有权重，那么需要这个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵清空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">graph1[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表清空和准备</span></span><br><span class="line">graph2.clear();</span><br><span class="line"><span class="comment">// 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">graph2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星清空</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">Arrays.fill(head, <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星加边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line"><span class="comment">// u -&gt; v , 边权重是w</span></span><br><span class="line">next[cnt] = head[u];</span><br><span class="line">to[cnt] = v;</span><br><span class="line">weight[cnt] = w;</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种方式建立有向图带权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line"><span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line">graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种方式建立无向图带权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undirectGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">graph1[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line"><span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line"><span class="comment">// graph2.get(edge[1]).add(edge[0]);</span></span><br><span class="line">graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">graph2.get(edge[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">0</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;邻接矩阵遍历 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">System.out.print(graph1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;邻接表遍历 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : graph2.get(i)) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;(&quot;</span> + edge[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + edge[<span class="number">1</span>] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;链式前向星 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line"><span class="comment">// 注意这个for循环，链式前向星的方式遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[i]; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;(&quot;</span> + to[ei] + <span class="string">&quot;,&quot;</span> + weight[ei] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课程表二（拓扑排序）"><a href="#课程表二（拓扑排序）" class="headerlink" title="课程表二（拓扑排序）"></a>课程表二（拓扑排序）</h2><p>leetcode 210</p><p>思路：判断入度，每次找到入度为0的点，加入队列，然后遍历这个点的所有边，将边指向的点的入度减1，如果减1后为0，则加入队列。最后判断加入队列的数量是否等于n，如果等于n，则说明有解，否则无解。排序结果就是这个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边的编号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] weight)</span> &#123;</span><br><span class="line">    <span class="comment">//加边逻辑</span></span><br><span class="line">    next[cnt] = head[u];</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    <span class="comment">//入度加一</span></span><br><span class="line">    weight[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numCourses;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> prerequisites.length;</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        add(prerequisites[i][<span class="number">1</span>],prerequisites[i][<span class="number">0</span>],head,next,to,weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历得到所有0入度的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(weight[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            queue[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始消除所有0入度</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[i];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">toi</span> <span class="operator">=</span> to[ie];</span><br><span class="line">            <span class="keyword">if</span>(--weight[toi] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = toi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n ? queue : <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="火星词典"><a href="#火星词典" class="headerlink" title="火星词典"></a>火星词典</h2><p>leetcode LCR114</p><p>思路：依次比较相邻的两个字符串，从字符串开头依次比较两个的字符。直到遇到不同的字符，那么就说明就是因为这个位置上的字符让前面的字符排在前面。于是增加一条从前面的字符指向后面的字符的边。这样得到一个图之后，就可以进行拓扑排序了。拓扑排序的结果就是字典序.但返回答案之前要判断得到的字典序里面的字符个数是否等于出现的字符个数，少了说明存在环，返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] in)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alienOrder</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(cnt,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    cnt[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//开始遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">curNext</span> <span class="operator">=</span> words[i+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(cur.length(),curNext.length());</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.charAt(j)!=curNext.charAt(j))&#123;</span><br><span class="line">                    <span class="comment">//添加边</span></span><br><span class="line">                    add(cur.charAt(j) - <span class="string">&#x27;a&#x27;</span>,curNext.charAt(j)-<span class="string">&#x27;a&#x27;</span>,head,next,to,cnt);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j&lt;cur.length() &amp;&amp; j == curNext.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始拓扑排序</span></span><br><span class="line">        <span class="comment">//有多少个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出初始入度为0的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                kinds++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="type">char</span> <span class="variable">ansChar</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + temp);</span><br><span class="line">            kinds --;</span><br><span class="line">            sb.append(ansChar);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[temp];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--cnt[to[ie]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = to[ie];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kinds == <span class="number">0</span> ? sb.toString(): <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大食物链计数"><a href="#最大食物链计数" class="headerlink" title="最大食物链计数"></a>最大食物链计数</h2><p>思路：拓扑排序，只不过每次出队时的节点要把自己的信息告诉自己的邻居节点。(其实这道题也能用dfs,而且更简单)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_FoodLines</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的入度表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的推送信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] lines = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">Arrays.fill(indegree, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(lines, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(head, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">next[cnt] = head[u];</span><br><span class="line">to[cnt] = v;</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">n = (<span class="type">int</span>) in.nval;</span><br><span class="line">in.nextToken();</span><br><span class="line">m = (<span class="type">int</span>) in.nval;</span><br><span class="line">build(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, u, v; i &lt; m; i++) &#123;</span><br><span class="line">in.nextToken();</span><br><span class="line">u = (<span class="type">int</span>) in.nval;</span><br><span class="line">in.nextToken();</span><br><span class="line">v = (<span class="type">int</span>) in.nval;</span><br><span class="line">addEdge(u, v);</span><br><span class="line">indegree[v]++;</span><br><span class="line">&#125;</span><br><span class="line">out.println(ways());</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">queue[r++] = i;</span><br><span class="line">lines[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue[l++];</span><br><span class="line"><span class="keyword">if</span> (head[u] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 当前的u节点不再有后续邻居了</span></span><br><span class="line">ans = (ans + lines[u]) % MOD;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[u], v; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line"><span class="comment">// u -&gt; v</span></span><br><span class="line">v = to[ei];</span><br><span class="line">lines[v] = (lines[v] + lines[u]) % MOD;</span><br><span class="line"><span class="keyword">if</span> (--indegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">queue[r++] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="喧闹与富有"><a href="#喧闹与富有" class="headerlink" title="喧闹与富有"></a>喧闹与富有</h2><p>leetcode 851</p><p>思路：拓扑排序，但出队的时候把自己的答案推送到下一个节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] in)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] loudAndRich(<span class="type">int</span>[][] richer, <span class="type">int</span>[] quiet) &#123;</span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> quiet.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> richer.length;</span><br><span class="line">        <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            add(richer[i][<span class="number">0</span>],richer[i][<span class="number">1</span>],head,next,to,in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[pos];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextP</span> <span class="operator">=</span> to[ie];</span><br><span class="line">                <span class="comment">// 如果我的答案更好，推送给你进行更新，之后我就可以出队了</span></span><br><span class="line">                <span class="keyword">if</span>(quiet[ans[pos]] &lt; quiet[ans[nextP]])&#123;</span><br><span class="line">                    ans[nextP] = ans[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(--in[nextP] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = nextP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是图论基本内容，其实就是建图加拓扑排序。或者有简单的bfs或者dfs。 至于更复杂的图论，以后再学吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（十二）并查集</title>
      <link href="/posts/19844410.html"/>
      <url>/posts/19844410.html</url>
      
        <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-31%20172011.png" alt="用法"/></div><span class="image-caption">用法</span></div><h2 id="并查集模板-扁平化-小挂大"><a href="#并查集模板-扁平化-小挂大" class="headerlink" title="并查集模板 扁平化+小挂大"></a>并查集模板 扁平化+小挂大</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i号节点，往上一直找，找到代表节点返回！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="comment">// 沿途收集了几个点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != father[i]) &#123;</span><br><span class="line">stack[size++] = i;</span><br><span class="line">i = father[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 沿途节点收集好了，i已经跳到代表节点了</span></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">father[stack[--size]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line"><span class="comment">// fx是集合的代表：拿大小</span></span><br><span class="line"><span class="comment">// fy是集合的代表：拿大小</span></span><br><span class="line"><span class="keyword">if</span> (size[fx] &gt;= size[fy]) &#123;</span><br><span class="line">size[fx] += size[fy];</span><br><span class="line">father[fy] = fx;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">size[fy] += size[fx];</span><br><span class="line">father[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板2-只有扁平化"><a href="#模板2-只有扁平化" class="headerlink" title="模板2 只有扁平化"></a>模板2 只有扁平化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">father[find(x)] = find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情侣牵手"><a href="#情侣牵手" class="headerlink" title="情侣牵手"></a>情侣牵手</h2><p>leetcode 765</p><p>思路：把编号i，i+1的情侣看出编号为i/2的情侣对.按顺序每次让两个人的情侣编号两两进行合并，如果是一对情侣（情侣编号一样）那么集合个数不会变，如果不是比如第一个人属于第3对，第二个人属于第5对，那么把3，5合成一个集合。最后原始的情侣对数减去剩下的集合个数就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">        father[i] = find(father[i]); <span class="comment">// 路径压缩：递归更新父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        cnts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnts;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>row.length;</span><br><span class="line">    cnts = n/<span class="number">2</span>;</span><br><span class="line">    build(n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        union(row[i]/<span class="number">2</span>,row[i+<span class="number">1</span>]/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n/<span class="number">2</span> - cnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相似字符串组"><a href="#相似字符串组" class="headerlink" title="相似字符串组"></a>相似字符串组</h2><p>leetcode 839</p><p>思路：两层for循环每次判断两个字符串是否相似，相似的话就合并两个字符串的集合。最后返回集合个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sets = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">father[fx] = fy;</span><br><span class="line">sets--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSimilarGroups</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">build(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (find(i) != find(j)) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m &amp;&amp; diff &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (strs[i].charAt(k) != strs[j].charAt(k)) &#123;</span><br><span class="line">diff++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (diff == <span class="number">0</span> || diff == <span class="number">2</span>) &#123;</span><br><span class="line">union(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>leetcode 200</p><p>思路：其实这道题最优解是洪水填充，但是这里用并查集也可以做。把二维下标转为一维编号 i*n+j。然后依次遍历，如果自己是1 的话就 查看 右边 跟 下边是不是1，如果是的话就合并。最后返回集合个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    cnts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                father[i*n+j] = i*n+j;</span><br><span class="line">                cnts++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i != father[i])&#123;</span><br><span class="line">        father[i] = find(father[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        cnts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    build(grid,m,n);</span><br><span class="line">    <span class="comment">//合并岛屿</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//只用合并右边跟下边即可</span></span><br><span class="line">                <span class="keyword">if</span>( i!=m-<span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    union(i*n+j,(i+<span class="number">1</span>)*n+j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j!=n-<span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    union(i*n+j,i*n+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="专家开会"><a href="#专家开会" class="headerlink" title="专家开会"></a>专家开会</h2><p>leetcode 2092</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的标签信息 : 设置集合的一些属性</span></span><br><span class="line"><span class="comment">// 属性在哪？secret[代表元素] 代表集合的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] secret = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> first)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">secret[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">father[first] = <span class="number">0</span>;</span><br><span class="line">secret[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">father[fx] = fy;</span><br><span class="line">secret[fy] |= secret[fx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议排序 : m * log m</span></span><br><span class="line"><span class="comment">// 处理过程 : O(m)</span></span><br><span class="line"><span class="comment">// 收集答案 : O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">findAllPeople</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">build(n, first);</span><br><span class="line"><span class="comment">// &#123;0 : 专家   1 : 专家编号   2 : 时刻&#125;</span></span><br><span class="line">Arrays.sort(meetings, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> meetings.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r; l &lt; m;) &#123;</span><br><span class="line">r = l;</span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; m &amp;&amp; meetings[l][<span class="number">2</span>] == meetings[r + <span class="number">1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l....r这些会议，一定是一个时刻</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">union(meetings[i][<span class="number">0</span>], meetings[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有小的撤销行为，但这不是可撤销并查集</span></span><br><span class="line"><span class="comment">// 只是每一批没有知道秘密的专家重新建立集合而已</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, a, b; i &lt;= r; i++) &#123;</span><br><span class="line">a = meetings[i][<span class="number">0</span>];</span><br><span class="line">b = meetings[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!secret[find(a)]) &#123;</span><br><span class="line">father[a] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!secret[find(b)]) &#123;</span><br><span class="line">father[b] = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l = r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (secret[find(i)]) &#123;</span><br><span class="line">ans.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS是什么？</title>
      <link href="/posts/6079905e.html"/>
      <url>/posts/6079905e.html</url>
      
        <content type="html"><![CDATA[<h1 id="【Java并发】AQS详解：JUC包背后的“幕后大佬”"><a href="#【Java并发】AQS详解：JUC包背后的“幕后大佬”" class="headerlink" title="【Java并发】AQS详解：JUC包背后的“幕后大佬”"></a>【Java并发】AQS详解：JUC包背后的“幕后大佬”</h1><p>在 Java 并发编程（JUC）的世界里，我们经常使用 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 这些赫赫有名的工具类。</p><p>但你是否想过，这些功能各异的工具背后，其实共用着同一套“底盘”？</p><p>这就是我们今天要聊的主角——<strong>AQS (AbstractQueuedSynchronizer，抽象队列同步器)</strong>。它是 JUC 包的心脏，掌握了它，你就掌握了 Java 并发的半壁江山。</p><h2 id="一、-什么是-AQS？"><a href="#一、-什么是-AQS？" class="headerlink" title="一、 什么是 AQS？"></a>一、 什么是 AQS？</h2><p><strong>AQS 是一个用于构建锁和同步器的框架。</strong></p><p>如果把 <code>ReentrantLock</code>、<code>CountDownLatch</code> 等比作是<strong>成品的汽车</strong>（跑车、卡车、公交车），那么 AQS 就是通用的<strong>汽车底盘和引擎</strong>。</p><ul><li><strong>AQS 负责脏活累活</strong>：它处理了线程的排队、阻塞、唤醒、线程安全等最复杂的底层逻辑。</li><li><strong>同步器负责业务逻辑</strong>：具体的工具类只需要告诉 AQS，“什么时候算获取锁成功”，“资源一共有多少”，剩下的交给 AQS 即可。</li></ul><p>简单来说，<strong>AQS 是一个“原材料”，我们可以根据它加工出各种各样的同步器。</strong></p><h2 id="二、-AQS-的核心架构"><a href="#二、-AQS-的核心架构" class="headerlink" title="二、 AQS 的核心架构"></a>二、 AQS 的核心架构</h2><p>AQS 的内部并没有多么神秘，它的核心逻辑主要由三部分组成：</p><h3 id="1-核心资源：State-volatile-int"><a href="#1-核心资源：State-volatile-int" class="headerlink" title="1. 核心资源：State (volatile int)"></a>1. 核心资源：State (volatile int)</h3><p>AQS 内部维护了一个 <code>state</code> 变量，用来表示<strong>“同步状态”</strong>。</p><ul><li>这是一个 <code>volatile</code> 修饰的 <code>int</code> 变量，保证了多线程下的可见性。</li><li>AQS 提供了 CAS (Compare And Swap) 方法来原子性地修改这个值。</li></ul><p><strong>这个 state 具体代表什么？AQS 不关心，由子类定义：</strong></p><ul><li>在 <strong>ReentrantLock</strong> 中，<code>state=0</code> 代表没锁，<code>state=1</code> 代表上锁。</li><li>在 <strong>CountDownLatch</strong> 中，<code>state</code> 代表倒计时的数值。</li><li>在 <strong>Semaphore</strong> 中，<code>state</code> 代表剩余的许可证数量。</li></ul><h3 id="2-等待队列：CLH-队列"><a href="#2-等待队列：CLH-队列" class="headerlink" title="2. 等待队列：CLH 队列"></a>2. 等待队列：CLH 队列</h3><p>如果有线程想抢资源（修改 state）失败了怎么办？总不能让它一直死循环空转（自旋）吧？</p><p>AQS 会把这些竞争失败的线程包装成一个 <strong>Node 节点</strong>，加入到一个<strong>双向链表</strong>（CLH队列）的尾部，并将线程<strong>阻塞</strong>（Park）。等待持有资源的线程释放后，再唤醒队列头部的线程。</p><h3 id="3-阻塞与唤醒工具"><a href="#3-阻塞与唤醒工具" class="headerlink" title="3. 阻塞与唤醒工具"></a>3. 阻塞与唤醒工具</h3><p>AQS 底层利用 <code>LockSupport</code> 类中的 <code>park()</code> 和 <code>unpark()</code> 方法，真正实现了操作系统的线程挂起和唤醒。</p><hr><h2 id="三、-AQS-是如何工作的？（以抢锁为例）"><a href="#三、-AQS-是如何工作的？（以抢锁为例）" class="headerlink" title="三、 AQS 是如何工作的？（以抢锁为例）"></a>三、 AQS 是如何工作的？（以抢锁为例）</h2><p>我们可以把 AQS 的工作流程想象成<strong>“去银行柜台办理业务”</strong>：</p><ol><li><strong>尝试获取 (TryAcquire)</strong>：<ul><li>线程 A 来了，看到柜台窗口（State）是空的（0），立马坐下办理，把窗口状态改为“忙碌”（1）。</li></ul></li><li><strong>入队 (Enqueue)</strong>：<ul><li>线程 B 来了，发现窗口状态是“忙碌”（1）。</li><li>AQS 这位大堂经理就会把线程 B 领到旁边的<strong>等待区（CLH 队列）</strong>，让它排在队伍后面，并告诉它：“你先睡会儿（Block），轮到你了叫你”。</li></ul></li><li><strong>释放与唤醒 (Release &amp; Unpark)</strong>：<ul><li>线程 A 办完业务了，离开柜台，把窗口状态改回“空闲”（0）。</li><li>AQS 大堂经理发现窗口空了，就去等待区叫醒排在最前面的线程 B：“醒醒，轮到你了”。</li><li>线程 B 醒来，高高兴兴去柜台办理业务。</li></ul></li></ol><hr><h2 id="四、-AQS-的设计模式：模板方法模式"><a href="#四、-AQS-的设计模式：模板方法模式" class="headerlink" title="四、 AQS 的设计模式：模板方法模式"></a>四、 AQS 的设计模式：模板方法模式</h2><p>AQS 之所以强大，是因为它使用了<strong>模板方法设计模式</strong>。</p><p>AQS 把“排队”、“阻塞”、“唤醒”这些通用的逻辑都写死了（<code>acquire</code>、<code>release</code> 方法）。但是，<strong>“如何判断资源是否足够”</strong>、<strong>“如何修改 state”</strong> 这些逻辑是留给子类去实现的。</p><p><strong>作为开发者，我们如果想自定义一个锁，只需要继承 AQS 并重写以下几个“钩子方法”：</strong></p><ul><li><code>tryAcquire(int)</code>: 独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li><code>tryRelease(int)</code>: 独占方式。尝试释放资源。</li><li><code>tryAcquireShared(int)</code>: 共享方式。尝试获取资源。</li><li><code>tryReleaseShared(int)</code>: 共享方式。尝试释放资源。</li><li><code>isHeldExclusively()</code>: 该线程是否正在独占资源。</li></ul><h2 id="五、-AQS-的“成品”展示"><a href="#五、-AQS-的“成品”展示" class="headerlink" title="五、 AQS 的“成品”展示"></a>五、 AQS 的“成品”展示</h2><p>让我们看看 Java 大佬们是如何利用 AQS 这个“原材料”加工出著名工具类的：</p><h3 id="1-ReentrantLock（可重入锁）"><a href="#1-ReentrantLock（可重入锁）" class="headerlink" title="1. ReentrantLock（可重入锁）"></a>1. ReentrantLock（可重入锁）</h3><ul><li><strong>模式</strong>：独占模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为 0。</li><li>线程 A 抢锁，通过 CAS 把 <code>state</code> 变成 1。</li><li>如果是同一个线程 A 再次抢锁（重入），就把 <code>state</code> 加 1（变成 2, 3…）。</li><li>释放锁时，<code>state</code> 减 1，直到减为 0 时才真正释放。</li></ul></li></ul><h3 id="2-CountDownLatch（倒计时器）"><a href="#2-CountDownLatch（倒计时器）" class="headerlink" title="2. CountDownLatch（倒计时器）"></a>2. CountDownLatch（倒计时器）</h3><ul><li><strong>模式</strong>：共享模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为 N（比如 5）。</li><li>主线程调用 <code>await()</code>，如果 <code>state &gt; 0</code>，就进入队列等待。</li><li>其他线程调用 <code>countDown()</code>，通过 CAS 把 <code>state</code> 减 1。</li><li>当 <code>state</code> 减到 0 时，AQS 唤醒队列里所有等待的主线程。</li></ul></li></ul><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong>模式</strong>：共享模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为许可证数量（比如 3）。</li><li>线程来获取许可，<code>state</code> 减 1。</li><li>如果 <code>state</code> 变为负数或者不足，线程进入队列等待。</li><li>释放许可时，<code>state</code> 加 1。</li></ul></li></ul><hr><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>AQS 是 Java 并发编程的基石。</p><ul><li><strong>宏观上</strong>：它是一个框架，通过<strong>State（资源状态）</strong>和<strong>CLH Queue（等待队列）</strong>来管理线程的同步。</li><li><strong>设计上</strong>：它采用了模板方法模式，将复杂的队列管理封装起来，只暴露简单的状态修改接口给子类。</li><li><strong>应用上</strong>：它是 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等工具类的父类（的内部实现）。</li></ul><p>理解了 AQS，你就理解了 Java 锁机制的灵魂。下次面试官问你：“ReentrantLock 是怎么实现的？”你就可以自信地从 AQS 的 <code>state</code> 和队列讲起了！</p><p>AQS的具体原理可以参考： <a href="https://javaguide.cn/java/concurrent/aqs.html">https://javaguide.cn/java/concurrent/aqs.html</a></p><hr><p><em>希望这篇文章能帮你彻底搞懂 AQS！如果有帮助，欢迎点赞收藏。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（十一） 单调队列</title>
      <link href="/posts/435449ef.html"/>
      <url>/posts/435449ef.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1><p>配合滑动窗口，可以快速得到滑动窗口内的最大值或者最小值。如果要最大值，那维护一个大到小队列（存的是下标），如果要最小值，那维护一个小到大的队列。</p><p>拿最大值举例：</p><p>扩大窗口的时候，判断新加入的元素跟队尾元素的大小，只要队尾元素小于等于新值，则队尾元素出队，直到队尾元素大于新值或者队列为空。然后这个新值的下标从队尾入队</p><p>缩小窗口时，判断这个要出去的元素下标跟单调队列队头的下标是否相等，如果相等则队头元素出队。l++.否则就不移除队头。</p><p>如果要最大值，就是数组的队头元素位置的值。 nums[deque[l]]</p><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>leetcode 239</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">h = t = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="comment">// 先形成长度为k-1的窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 大 -&gt; 小</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[i]) &#123;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line">deque[t++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - k + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="comment">// 当前窗口k-1长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k - <span class="number">1</span>; l &lt; m; l++, r++) &#123;</span><br><span class="line"><span class="comment">// 少一个，要让r位置的数进来</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[r]) &#123;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line">deque[t++] = r;</span><br><span class="line"><span class="comment">// 收集答案</span></span><br><span class="line">ans[l] = arr[deque[h]];</span><br><span class="line"><span class="comment">// l位置的数出去</span></span><br><span class="line"><span class="keyword">if</span> (deque[h] == l) &#123;</span><br><span class="line">h++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绝对差不超过限制的最长连续数组"><a href="#绝对差不超过限制的最长连续数组" class="headerlink" title="绝对差不超过限制的最长连续数组"></a>绝对差不超过限制的最长连续数组</h2><p>leetcode 1438</p><p>思路：利用两个单调队列，一个记录窗口的最小值，一个记录窗口的最大值。窗口开始滑动，每新加一个元素，就维护队列。然后一直缩窗口直到窗口内最大值和最小值之差小于等于limit。之后记录答案，j-i+1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    l2 = <span class="number">0</span>;</span><br><span class="line">    r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">        <span class="comment">//进队</span></span><br><span class="line">        <span class="keyword">while</span>( r &gt; l &amp;&amp; nums[queue[r-<span class="number">1</span>]] &lt;= nums[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="keyword">while</span>( r2 &gt; l2 &amp;&amp; nums[queue2[r2-<span class="number">1</span>]] &gt;= nums[j])&#123;</span><br><span class="line">            r2--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue2[r2++] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( nums[queue[l]] - nums[queue2[l2]] &gt; limit )&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue2[l2] == i)&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(j - i + <span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非经典用法"><a href="#非经典用法" class="headerlink" title="非经典用法"></a>非经典用法</h1><h2 id="和至少为K的最短子数组"><a href="#和至少为K的最短子数组" class="headerlink" title="和至少为K的最短子数组"></a>和至少为K的最短子数组</h2><p>leetcode 862</p><p>思路：计算以每个位置结尾的最小长度。这里最关键的是如果已经算出一个答案的时候，你的窗口右扩，你想找到更短的就只能左缩窗口才行（不用从头开始缩）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以一个位置结尾，向前面走多远能达标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="comment">//加入窗口</span></span><br><span class="line">        <span class="keyword">while</span>( l&lt;r &amp;&amp; prefix[queue[r-<span class="number">1</span>]] &gt;= prefix[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="comment">//看当前是否满足</span></span><br><span class="line">        <span class="keyword">if</span>(prefix[j] - prefix[queue[l]] &gt;= k)&#123;</span><br><span class="line">            <span class="comment">//缩小窗口，直到不行</span></span><br><span class="line">            <span class="keyword">while</span> (prefix[j] - prefix[queue[l]] &gt;= k)&#123;</span><br><span class="line">                <span class="comment">//左边缩小</span></span><br><span class="line">                <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i前面那个位置就是至少的位置</span></span><br><span class="line">            ans = Math.min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="满足不等式的最大值"><a href="#满足不等式的最大值" class="headerlink" title="满足不等式的最大值"></a>满足不等式的最大值</h2><p>leetcode 1499</p><p>给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 &lt;= i &lt; j &lt;= points.length 的前提下， xi &lt; xj 总成立。</p><p>请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| &lt;= k 且 1 &lt;= i &lt; j &lt;= points.length。</p><p>题目测试数据保证至少存在一对能够满足 |xi - xj| &lt;= k 的点。</p><p>思路：还是以每个点为结尾。窗口左边从0下标开始，判断是否合法，不合法就左缩窗口，直到合法。这个过程一直记录窗口内点的y-x的最大值。合法之后，用结尾的点加上这个窗口内的最大值就是这个点的对应的最大值，然后把这个点也加入窗口，并且更新单调队列，单调队列以y-x为单调递减。即头部为y-x最大的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxValueOfEquation</span><span class="params">(<span class="type">int</span>[][] points, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>points.length;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//把第一个点放进去</span></span><br><span class="line">    queue[r++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//缩小窗口到合法</span></span><br><span class="line">        <span class="keyword">while</span>( j&gt;i &amp;&amp; points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>] &gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到答案</span></span><br><span class="line">        <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> queue[l];</span><br><span class="line">            ans = Math.max(ans,points[j][<span class="number">0</span>]+points[j][<span class="number">1</span>]-points[best][<span class="number">0</span>]+points[best][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 j 加入</span></span><br><span class="line">        <span class="keyword">while</span> ( l&lt;r &amp;&amp; (points[j][<span class="number">1</span>] - points[j][<span class="number">0</span>]) &gt;= (points[queue[r-<span class="number">1</span>]][<span class="number">1</span>]-points[queue[r-<span class="number">1</span>]][<span class="number">0</span>]))&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预算内最多机器人的数目"><a href="#预算内最多机器人的数目" class="headerlink" title="预算内最多机器人的数目"></a>预算内最多机器人的数目</h2><p>leetcode 2389</p><p>思路：单调队列算窗口内的最大值，前缀和算窗口的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue  =<span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRobots</span><span class="params">(<span class="type">int</span>[] chargeTimes, <span class="type">int</span>[] runningCosts, <span class="type">long</span> budget)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chargeTimes.length;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//搞一个前缀和，快速计算子数组的和</span></span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        prefix[i+<span class="number">1</span>] = prefix[i] + runningCosts[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始滑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//把 j 放进去</span></span><br><span class="line">        <span class="keyword">while</span> ( l&lt;r &amp;&amp; chargeTimes[queue[r-<span class="number">1</span>]] &lt;= chargeTimes[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="comment">// 左移直到合法</span></span><br><span class="line">        <span class="keyword">while</span>( i&lt;=j &amp;&amp; chargeTimes[queue[l]]+ (<span class="type">long</span>) (j - i + <span class="number">1</span>) *(prefix[j+<span class="number">1</span>]-prefix[i]) &gt; budget)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计答案</span></span><br><span class="line">        ans = Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三个无重叠子数组的最大和"><a href="#三个无重叠子数组的最大和" class="headerlink" title="三个无重叠子数组的最大和"></a>三个无重叠子数组的最大和</h2><p>leetcode 689</p><p>思路：化成三个部分，中间部分一定为i…i+k-1,左边为0….i-1 右边为i+k…n-1。此时只要知道截至到i位置最大的开始下标就可以知道前面的最大值。知道从i位置到n-1的最大值开始下标就可以确定后面最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSumOfThreeSubarrays(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sumNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//求sum[] 代表从i位置开始连续k个数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">        sumNum+=nums[r];</span><br><span class="line">        <span class="keyword">if</span>(r-l+<span class="number">1</span> == k)&#123;</span><br><span class="line">            sum[l] = sumNum;</span><br><span class="line">            sumNum-=nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求一个prefix[]  prefix[i]代表从0.....i 连续k个数和最大的开始下标</span></span><br><span class="line">    <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    queue[r++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; sum[queue[l]] &lt; sum[i-k+<span class="number">1</span>])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = i-k+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//为最小下标</span></span><br><span class="line">        prefix[i] = queue[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求suffix[]  suffix[]代表从 i....n-1 连续k个数和最大的开始下标</span></span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    suffix[n-k] = n-k;</span><br><span class="line">    queue[r++] = n-k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; sum[queue[l]] &lt;= sum[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = i;</span><br><span class="line">        suffix[i] = queue[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//借助这三个数组开始解答</span></span><br><span class="line">    <span class="comment">// （0....) (i...i+k-1) (i+k....n-1) 三个部分 中间部分和确定，只需要考虑前面跟后面即可</span></span><br><span class="line">    <span class="comment">// 它们的结果又从prefix 和 suffix可以拿到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= k,j=k*<span class="number">2</span>-<span class="number">1</span>;j&lt;n-k;i++,j++)&#123;</span><br><span class="line">        <span class="comment">//前面最大的开始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> prefix[i-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//后面最大的开始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> suffix[j+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> sum[m] + sum[i] + sum[p];</span><br><span class="line">        <span class="keyword">if</span>(all &gt; max)&#123;</span><br><span class="line">            max = all;</span><br><span class="line">            a=m;</span><br><span class="line">            b=i;</span><br><span class="line">            c=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（十） 单调栈</title>
      <link href="/posts/b11a54f5.html"/>
      <url>/posts/b11a54f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1><p>单调栈问题，就是当你分析问题时，需要你找到一个索引左右两边大于或者小于自己的最近索引时，就使用单调栈！</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-29%20232614.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="每日最高温度"><a href="#每日最高温度" class="headerlink" title="每日最高温度"></a>每日最高温度</h2><p>leetcode 739</p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>思路：将下标一次放入栈，但遵循以下要求，如果当前的温度大于栈顶的温度，则栈顶的索引出栈，并记录当前索引与栈顶索引的差值，即当前索引与栈顶索引的差值就是当前索引对应的天数。循环弹出，直到栈为空或者栈顶的索引对应的温度大于等于当前索引对应的温度。则当前索引入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>( size&gt;<span class="number">0</span> &amp;&amp; temperatures[stack[size-<span class="number">1</span>]] &lt; temperatures[i])&#123;</span><br><span class="line">            ans[stack[size-<span class="number">1</span>]] = i - stack[size-<span class="number">1</span>];</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子数组的最小值之和"><a href="#子数组的最小值之和" class="headerlink" title="子数组的最小值之和"></a>子数组的最小值之和</h2><p>leetcode 907</p><p>思路：根据单调栈，可以知道每个索引左边跟右边小于他的最近索引，那么对于每个索引，左边小于它的最近索引为left[i]，右边小于它的最近索引为right[i]，则对于索引i，最小值之和为(right[i] - i) <em> (i - left[i]) </em> arr[i]。（这就是包含了i的且i为最小值的所有子数组的最小值之和）。最后剩在栈里面的它的右边索引就在n的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注意课上讲的相等情况的修正</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[stack[r - <span class="number">1</span>]] &gt;= arr[i]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = (ans + (<span class="type">long</span>) (cur - left) * (i - cur) * arr[cur]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = (ans + (<span class="type">long</span>) (cur - left) * (arr.length - cur) * arr[cur]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h2><p>leetcode 84</p><p>思路：单调栈，对于每个索引，左边小于它最近索引为left[i]，右边小于它最近索引为right[i]，则对于索引i，最大矩形为(right[i] - left[i] - 1) * heights[i]。这道题就是一个非常标准的单调栈问题。</p><p>标准模板<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>heights.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span> &amp;&amp; heights[stack[size-<span class="number">1</span>]] &gt;= heights[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">            ansArr[temp][<span class="number">0</span>] = size == <span class="number">0</span> ? -<span class="number">1</span> : stack[size-<span class="number">1</span>];</span><br><span class="line">            ansArr[temp][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">        ansArr[temp][<span class="number">0</span>] = size==<span class="number">0</span>? -<span class="number">1</span> :stack[size-<span class="number">1</span>];</span><br><span class="line">        ansArr[temp][<span class="number">1</span>] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修正右边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansArr[i][<span class="number">1</span>] != n &amp;&amp; heights[ansArr[i][<span class="number">1</span>]] == heights[i])&#123;</span><br><span class="line">            ansArr[i][<span class="number">1</span>] = ansArr[ansArr[i][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans = Math.max((ansArr[i][<span class="number">1</span>] - ansArr[i][<span class="number">0</span>] -<span class="number">1</span>)*heights[i],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简化分析相等情况  因为就算相等你也给我弹出，可能这时你无法得到你对应的最大值。但你的那个最后一个相等的就会帮你结算你的最大值！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>heights.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span> &amp;&amp; heights[stack[size-<span class="number">1</span>]] &gt;= heights[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> size == <span class="number">0</span> ? -<span class="number">1</span> : stack[size-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            ans = Math.max((right-left-<span class="number">1</span>)*heights[temp],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> size==<span class="number">0</span>? -<span class="number">1</span> :stack[size-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        ans = Math.max((right-left-<span class="number">1</span>)*heights[temp],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>leetcode 85</p><p>思路：压缩数组！把问题转化为以每一行作为底部时的最大矩形问题 跟上一题一样。每一个的高度就是从该行开始连续的1的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">Arrays.fill(height, <span class="number">0</span>, m, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 来到i行，长方形一定要以i行做底！</span></span><br><span class="line"><span class="comment">// 加工高度数组(压缩数组)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">height[j] = grid[i][j] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : height[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(largestRectangleArea(m), ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, cur, left;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="comment">// i -&gt; arr[i]</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; height[stack[r - <span class="number">1</span>]] &gt;= height[i]) &#123;</span><br><span class="line">cur = stack[--r];</span><br><span class="line">left = r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = Math.max(ans, height[cur] * (i - left - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cur = stack[--r];</span><br><span class="line">left = r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = Math.max(ans, height[cur] * (m - left - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非经典用法"><a href="#非经典用法" class="headerlink" title="非经典用法"></a>非经典用法</h1><p><strong>下面的题目利用单调栈思想，而不是经典的用法。</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-29%20232336.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="最大宽度坡"><a href="#最大宽度坡" class="headerlink" title="最大宽度坡"></a>最大宽度坡</h2><p>leetcode 962</p><p>思路：先进行一次遍历把可能作为坡的起点的下标找到。怎么找？ 每次只入栈比当前栈顶元素更小的元素。为什么？因为如果我比栈顶大，我找到一个坡的终点，那么栈顶元素它比我的下标还要小，那他跟这个坡的终点构成的坡宽度肯定比我大，所以我没资格入栈。</p><p>然后倒着遍历找坡的终点。一旦栈顶的元素发现一个值可以作为自己终点那么弹出，并且这个坡就是以自己为起点的最大坡，为什么？因为当前终点已经是最靠右边的索引了，再往前遍历得到的结果只会更小！ 循环一直把栈里面的元素全部弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxWidthRamp</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    stack[size++] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找可能的起点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[stack[size-<span class="number">1</span>]])&#123;</span><br><span class="line">            stack[size++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒着遍历找终点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(size &gt; <span class="number">0</span> &amp;&amp; i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>( size &gt; <span class="number">0</span> &amp;&amp; nums[stack[size-<span class="number">1</span>]] &lt;= nums[i])&#123;</span><br><span class="line">            ans = Math.max(ans,i-stack[size-<span class="number">1</span>]);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h2><p>leetcode 316</p><p>思路： 单调栈大压小，遇到更小的尽量往前面走，但有条件限制，即被弹出的元素还有剩余。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line">Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(enter, <span class="literal">false</span>);</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : s) &#123;</span><br><span class="line">cnts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cur : s) &#123;</span><br><span class="line"><span class="comment">// 从左往右依次遍历字符，a -&gt; 0 b -&gt; 1 ... z -&gt; 25</span></span><br><span class="line"><span class="comment">// cur -&gt; cur - &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!enter[cur - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="comment">// 栈顶元素比当前元素大，并且栈顶元素还有剩余，那么弹出栈顶元素</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; stack[r - <span class="number">1</span>] &gt; cur &amp;&amp; cnts[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">enter[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = cur;</span><br><span class="line">enter[cur - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnts[cur - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(stack, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大鱼吃小鱼"><a href="#大鱼吃小鱼" class="headerlink" title="大鱼吃小鱼"></a>大鱼吃小鱼</h2><p>leetcode 2289</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Max</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] stackT = <span class="keyword">new</span> <span class="title class_">int</span>[Max][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSteps</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( r &gt; <span class="number">0</span> &amp;&amp; stackT[r-<span class="number">1</span>][<span class="number">0</span>] &lt; nums[i])&#123;</span><br><span class="line">            cnt = Math.max(cnt+<span class="number">1</span>,stackT[r-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        stackT[r][<span class="number">0</span>] = nums[i];</span><br><span class="line">        stackT[r++][<span class="number">1</span>] = cnt;</span><br><span class="line">        ans = Math.max(ans,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现基于raft算法的kv存储系统</title>
      <link href="/posts/6eb88918.html"/>
      <url>/posts/6eb88918.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java手写Raft篇：核心流程与并发模型优化"><a href="#Java手写Raft篇：核心流程与并发模型优化" class="headerlink" title="Java手写Raft篇：核心流程与并发模型优化"></a>Java手写Raft篇：核心流程与并发模型优化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇基于Java实现raft分布式KV存储系统的博客。本项目基于 <a href="https://github.com/stateIs0/lu-raft-kv">https://github.com/stateIs0/lu-raft-kv</a> 该开源项目进行的二次开发。主要按照Raft协议的生命周期（选主、日志复制、安全性、一致性读）进行了改造。本篇博客记录了我的改造思路，以及一些值得注意的地方。Raft 算法作为分布式一致性协议的标准解法，以其清晰的模块化设计著称。本文将基于我如何改造原开源项目，深入剖析其中的核心机制。从选主逻辑、日志复制的细节，到解决“幽灵复现”问题的 No-Op 日志，再到利用 <code>CompletableFuture</code> 对并发模型的重构，以此记录构建高一致性分布式存储系统的思考过程。</p><hr><h2 id="一、-选举机制-Leader-Election"><a href="#一、-选举机制-Leader-Election" class="headerlink" title="一、 选举机制 (Leader Election)"></a>一、 选举机制 (Leader Election)</h2><p>选主是集群启动或 Leader 宕机后的首要任务。在此阶段，不仅要保证票数过半，更要严格校验节点资格。</p><h3 id="1-状态流转与拉票"><a href="#1-状态流转与拉票" class="headerlink" title="1. 状态流转与拉票"></a>1. 状态流转与拉票</h3><p>当 Follower 的心跳倒计时结束（在一定范围内随机时间，我选择的是跟最大选举时间到它的两倍这个范围，避免同时存在多个候选人导致效率下降）仍未收到 Leader 消息时，将触发选举流程：</p><ul><li><strong>自增任期</strong>：将 <code>term + 1</code>，并将状态流转为 Candidate。</li><li><strong>给自己投票</strong>：先投自己一票，避免 split vote。</li><li><strong>广播请求</strong>：向所有节点发起拉票请求，请求中必须携带 <code>lastLogTerm</code> 和 <code>lastLogIndex</code>，以便其他节点校验“日志是否足够新”。</li></ul><h3 id="2-投票方逻辑与并发控制"><a href="#2-投票方逻辑与并发控制" class="headerlink" title="2. 投票方逻辑与并发控制"></a>2. 投票方逻辑与并发控制</h3><p>节点收到投票请求时的处理逻辑非常关键：</p><ul><li><strong>Term 更新</strong>：如果请求中的 Term 严格大于自身，需将之前的投票记录（votedFor）置空，防止因持有旧锁导致无法投票，这样也尽可能的保证在一个投票间隔中能选出Leader。</li><li><strong>加锁防重</strong>：整个投票判断过程需要上锁，避免高并发下的重复投票。</li><li><strong>资格校验</strong>：只有当请求者的 Term &gt;= 自身 Term，且日志比自己新（Log Completeness），且自己在本任期未投过票时，才予以投票。</li><li><strong>收尾</strong>：更新本地 Term 和投票信息，释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RvoteResult <span class="title function_">requestVote</span><span class="params">(RvoteParam param)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RvoteResult.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RvoteResult.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (!voteLock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.term(node.getCurrentTerm()).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对方任期没有自己新</span></span><br><span class="line">        <span class="keyword">if</span> (param.getTerm() &lt; node.getCurrentTerm()) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.term(node.getCurrentTerm()).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新的投票term来临，应该放弃之前的投票</span></span><br><span class="line">        <span class="keyword">if</span> (param.getTerm() &gt; node.getCurrentTerm()) &#123;</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line">            node.setVotedFor(<span class="literal">null</span>);</span><br><span class="line">            node.status = NodeStatus.FOLLOWER; <span class="comment">// 任期升级后回归Follower</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (当前节点并没有投票 或者 已经投票过了且是对方节点) &amp;&amp; 对方日志和自己一样新</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;node &#123;&#125; current vote for [&#123;&#125;], param candidateId : &#123;&#125;&quot;</span>, node.peerSet.getSelf(), node.getVotedFor(), param.getCandidateId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((StringUtil.isNullOrEmpty(node.getVotedFor()) || node.getVotedFor().equals(param.getCandidateId()))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.getLogModule().getLast() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 对方没有自己新</span></span><br><span class="line">                <span class="keyword">if</span> (node.getLogModule().getLast().getTerm() &gt; param.getLastLogTerm()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;节点&#123;&#125; 拒绝给 候选人 &#123;&#125; 投票,因为日志的term值更大&quot;</span>,node.peerSet.getSelf(),param.getCandidateId());</span><br><span class="line">                    <span class="keyword">return</span> RvoteResult.fail();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对方没有自己新</span></span><br><span class="line">                <span class="keyword">if</span> (node.getLogModule().getLastIndex() &gt; param.getLastLogIndex()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;节点&#123;&#125; 拒绝给 候选人 &#123;&#125; 投票,因为日志的Index更大&quot;</span>,node.peerSet.getSelf(),param.getCandidateId());</span><br><span class="line">                    <span class="keyword">return</span> RvoteResult.fail();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换状态</span></span><br><span class="line">            node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            node.peerSet.setLeader(<span class="keyword">new</span> <span class="title class_">Peer</span>(param.getCandidateId()));</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line">            node.setVotedFor(param.getCandidateId());</span><br><span class="line">            log.warn(<span class="string">&quot;节点 &#123;&#125; 在第 &#123;&#125; 轮中 ， 投给了 &#123;&#125; 节点&quot;</span>,node.peerSet.getSelf(),node.currentTerm,node.getVotedFor());</span><br><span class="line">            <span class="comment">// 返回成功</span></span><br><span class="line">            <span class="keyword">return</span> builder.term(node.currentTerm).voteGranted(<span class="literal">true</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.term(node.currentTerm).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        voteLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-异步并发模型的优化"><a href="#3-异步并发模型的优化" class="headerlink" title="3. 异步并发模型的优化"></a>3. 异步并发模型的优化</h3><p>在实现拉票请求时，我对并发模型进行了重构：</p><ul><li><strong>旧方案</strong>：<code>线程池 + Future + CountDownLatch</code>。<code>Future.get()</code> 会阻塞调用线程，且 CountDownLatch 代码冗余。</li><li><strong>新方案</strong>：<code>CompletableFuture + 线程池</code>。<ul><li>使用 <code>List&lt;CompletableFuture&lt;&gt;&gt;</code> 保存所有 RPC 请求。</li><li>利用 <code>CompletableFuture.allOf(...)</code> 实现多线程的非阻塞同步。</li><li>配合 <code>AtomicInteger</code> 记录获胜票数，线程安全且代码更优雅。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == NodeStatus.LEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 基于 RAFT 的随机时间,解决冲突.（范围为[electiontimeout, 2 * electiontimeout - 1]）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">myElectionTime</span> <span class="operator">=</span> electionTime + ThreadLocalRandom.current().nextInt(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (current - preElectionTime &lt; myElectionTime) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">status = NodeStatus.CANDIDATE;</span><br><span class="line">log.error(<span class="string">&quot;node &#123;&#125; will become CANDIDATE and start election leader, current term : [&#123;&#125;], LastEntry : [&#123;&#125;]&quot;</span>,</span><br><span class="line">        peerSet.getSelf(), currentTerm, logModule.getLast());</span><br><span class="line"></span><br><span class="line">preElectionTime = System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(<span class="number">200</span>) + <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">currentTerm = currentTerm + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 推荐自己.</span></span><br><span class="line">votedFor = peerSet.getSelf().getAddr();</span><br><span class="line"></span><br><span class="line">List&lt;Peer&gt; peers = peerSet.getPeersWithOutSelf();</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用CompletableFuture 改造</span></span><br><span class="line">ArrayList&lt;CompletableFuture&lt;RvoteResult&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//成功次数</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">NumberOfVotesInFavor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">log.info(<span class="string">&quot;peerList size : &#123;&#125;, peer list content : &#123;&#125;&quot;</span>, peers.size(), peers);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Peer peer : peers) &#123;</span><br><span class="line"></span><br><span class="line">    futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装自己最后一个日志的term</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">lastTerm</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">last</span> <span class="operator">=</span> logModule.getLast();</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">            lastTerm = last.getTerm();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以及最后一条日志的索引</span></span><br><span class="line">        <span class="type">RvoteParam</span> <span class="variable">param</span> <span class="operator">=</span> RvoteParam.builder().</span><br><span class="line">                term(currentTerm).</span><br><span class="line">                candidateId(peerSet.getSelf().getAddr()).</span><br><span class="line">                lastLogIndex(LongConvert.convert(logModule.getLastIndex())).</span><br><span class="line">                lastLogTerm(lastTerm).</span><br><span class="line">                build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> Request.builder()</span><br><span class="line">                .cmd(Request.R_VOTE)</span><br><span class="line">                .obj(param)</span><br><span class="line">                .url(peer.getAddr())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送投票请求，500ms超时</span></span><br><span class="line">            <span class="keyword">return</span> getRpcClient().&lt;RvoteResult&gt;send(request,<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RaftRemotingException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;ElectionTask RPC Fail , URL : &quot;</span> + request.getUrl());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,RaftThreadPool.giveMePool())</span><br><span class="line">            .whenComplete((result,throwable) -&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isVoteGranted</span> <span class="operator">=</span> result.isVoteGranted();</span><br><span class="line">                <span class="keyword">if</span> (isVoteGranted) &#123;</span><br><span class="line">                    <span class="comment">//增加选票</span></span><br><span class="line">                    NumberOfVotesInFavor.incrementAndGet();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对方拒绝投票。</span></span><br><span class="line">                    <span class="comment">// 更新自己的任期。</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">resTerm</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                    <span class="keyword">if</span> (resTerm &gt;= currentTerm) &#123;</span><br><span class="line">                        currentTerm = resTerm;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待所有结果出来</span></span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">//多个任务</span></span><br><span class="line">    CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">    CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">success</span> <span class="operator">=</span> NumberOfVotesInFavor.get();</span><br><span class="line">log.warn(<span class="string">&quot;node &#123;&#125; maybe become leader , success count = &#123;&#125; , status : &#123;&#125;&quot;</span>, peerSet.getSelf(), success, NodeStatus.Enum.value(status));</span><br><span class="line"><span class="comment">// 如果投票期间,有其他服务器发送 appendEntry 或者心跳 , 就可能变成 follower ,这时,应该停止.</span></span><br><span class="line"><span class="keyword">if</span> (status == NodeStatus.FOLLOWER) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;节点 &#123;&#125; 目前不是候选人 ，无法成为领导者&quot;</span>, peerSet.getSelf().getAddr());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加上自身.</span></span><br><span class="line"><span class="keyword">if</span> (success &gt;= (peers.size()+<span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;node &#123;&#125; become leader 他的选票有 &#123;&#125; 票&quot;</span>, peerSet.getSelf(),success+<span class="number">1</span>);</span><br><span class="line">    status = NodeStatus.LEADER;</span><br><span class="line">    peerSet.setLeader(peerSet.getSelf());</span><br><span class="line">    votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这个会马上插入一条空日志</span></span><br><span class="line">    becomeLeaderToDoThing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else 重新选举</span></span><br><span class="line">    votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    log.warn(<span class="string">&quot;节点 &#123;&#125; 在 &#123;&#125; 轮落选,他获得的选票有 &#123;&#125; 票&quot;</span>,peerSet.getSelf(),currentTerm,success+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次更新选举时间 随机更新</span></span><br><span class="line">preElectionTime = System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(<span class="number">200</span>) + <span class="number">150</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="二、-日志复制与心跳-Log-Replication-amp-Heartbeat"><a href="#二、-日志复制与心跳-Log-Replication-amp-Heartbeat" class="headerlink" title="二、 日志复制与心跳 (Log Replication &amp; Heartbeat)"></a>二、 日志复制与心跳 (Log Replication &amp; Heartbeat)</h2><p>Leader 确立后，进入正常的日志同步阶段。</p><h3 id="1-心跳与日志同步的合并"><a href="#1-心跳与日志同步的合并" class="headerlink" title="1. 心跳与日志同步的合并"></a>1. 心跳与日志同步的合并</h3><p>为了简化逻辑，我将“同步日志”与“发送心跳”合并处理：</p><ul><li>Leader 周期性遍历所有 Follower。</li><li><strong>判断同步需求</strong>：检查 <code>Leader.lastIndex &gt;= Follower.nextIndex</code>。<ul><li>如果满足，说明有新日志，发送从 <code>nextIndex</code> 开始的日志条目。</li><li>如果不满足，说明日志已经同步，仅发送空的心跳包保活(根据心跳结果，判断自己是否还能继续当leader)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != NodeStatus.LEADER) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (current - preHeartBeatTime &lt; heartBeatTick) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;=========== NextIndex =============&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Peer &#123;&#125; nextIndex=&#123;&#125;&quot;</span>, peer.getAddr(), nextIndexs.get(peer));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preHeartBeatTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            List&lt;CompletableFuture&lt;Boolean&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            List&lt;Boolean&gt; resultList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 日志跟心跳放在一起</span></span><br><span class="line">            <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">nextIndex</span> <span class="operator">=</span> nextIndexs.get(peer);</span><br><span class="line">                <span class="comment">//我的最后一条日志大于你应该写入的日志位置，那我就要复制给你日志</span></span><br><span class="line">                <span class="keyword">if</span>(logModule.getLastIndex() &gt;= nextIndex)&#123;</span><br><span class="line">                    CompletableFuture&lt;Boolean&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; replication(peer), RaftThreadPool.giveMePool()</span><br><span class="line">                    ).exceptionally( ex -&gt;&#123;</span><br><span class="line">                        log.error(<span class="string">&quot;&#123;&#125; 节点发送日志失败&quot;</span>, peer.getAddr());</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">                    ).whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                            resultList.add(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;&#123;&#125; 节点发送日志失败&quot;</span>, peer.getAddr());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    futureList.add(future);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//发送心跳</span></span><br><span class="line">                    <span class="type">AentryParam</span> <span class="variable">param</span> <span class="operator">=</span> AentryParam.builder()</span><br><span class="line">                            .entries(<span class="literal">null</span>)<span class="comment">// 心跳,空日志.</span></span><br><span class="line">                            .leaderId(peerSet.getSelf().getAddr())</span><br><span class="line">                            .serverId(peer.getAddr())</span><br><span class="line">                            .term(currentTerm)</span><br><span class="line">                            .leaderCommit(commitIndex) <span class="comment">// 心跳时与跟随者同步 commit index</span></span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                            Request.A_ENTRIES,</span><br><span class="line">                            param,</span><br><span class="line">                            peer.getAddr());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    CompletableFuture.supplyAsync(()-&gt; getRpcClient().&lt;AentryResult&gt;send(request,<span class="number">450</span>),RaftThreadPool.giveMePool())</span><br><span class="line">                            .exceptionally( ex -&gt; <span class="literal">null</span>).whenComplete((result, throwable)-&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                            log.error(<span class="string">&quot;无法收到&#123;&#125; 节点的心跳回应，该节点可能已经宕机&quot;</span>,peer.getAddr());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">term</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                        <span class="keyword">if</span> (term &gt; currentTerm) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;self will become follower, he&#x27;s term : &#123;&#125;, my term : &#123;&#125;&quot;</span>, term, currentTerm);</span><br><span class="line">                            currentTerm = term;</span><br><span class="line">                            votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            status = NodeStatus.FOLLOWER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待所有日志完成</span></span><br><span class="line">            <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="comment">//多个任务</span></span><br><span class="line">                CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">                CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在一个满足N &gt; commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，</span></span><br><span class="line">            <span class="comment">// 并且log[N].term == currentTerm成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</span></span><br><span class="line">            List&lt;Long&gt; matchIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchIndexs.values());</span><br><span class="line">            <span class="comment">// 小于 2, 没有意义</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (matchIndexList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                Collections.sort(matchIndexList);</span><br><span class="line">                median = matchIndexList.size() / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">N</span> <span class="operator">=</span> matchIndexList.get(median);</span><br><span class="line">            <span class="keyword">if</span> (N &gt; commitIndex) &#123;</span><br><span class="line">                <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> logModule.read(N);</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getTerm() == currentTerm) &#123;</span><br><span class="line">                    commitIndex = N;</span><br><span class="line">                    <span class="comment">// 应用到状态机</span></span><br><span class="line">                    RaftThreadPool.execute(()-&gt;&#123;</span><br><span class="line">                        commitLock.lock();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">myCommitIndex</span> <span class="operator">=</span> commitIndex;</span><br><span class="line">                            <span class="comment">//应该从lastApplied开始应用，直到异步开始时的commitIndex（防止重复提交）</span></span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= myCommitIndex; i++)&#123;</span><br><span class="line">                                getStateMachine().apply(logModule.read(i));</span><br><span class="line">                                log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                            &#125;</span><br><span class="line">                            lastApplied = myCommitIndex;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            commitLock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-批量发送与回溯"><a href="#2-批量发送与回溯" class="headerlink" title="2. 批量发送与回溯"></a>2. 批量发送与回溯</h3><ul><li><strong>批量优化</strong>：发送日志时，会把从 <code>nextIndex</code> 到 Leader <code>lastIndex</code> 的所有日志打包发送。Follower 匹配成功后可批量写入，极大提升同步吞吐。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AentryParam</span> <span class="variable">aentryParam</span> <span class="operator">=</span> AentryParam.builder().build();</span><br><span class="line">aentryParam.setTerm(currentTerm);</span><br><span class="line">aentryParam.setServerId(peer.getAddr());</span><br><span class="line">aentryParam.setLeaderId(peerSet.getSelf().getAddr());</span><br><span class="line"></span><br><span class="line">aentryParam.setLeaderCommit(commitIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以我这边为准。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">nextIndex</span> <span class="operator">=</span> nextIndexs.get(peer);</span><br><span class="line"><span class="type">Long</span> <span class="variable">myNewIndex</span> <span class="operator">=</span> logModule.getLastIndex();</span><br><span class="line">LinkedList&lt;LogEntry&gt; logEntries = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (myNewIndex &gt;= nextIndex) &#123;</span><br><span class="line">    <span class="comment">// 把nextIndex 到 自己的最后一条日志都复制给follower</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex; i &lt;= myNewIndex; i++) &#123;</span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">l</span> <span class="operator">=</span> logModule.read(i);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            logEntries.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的日志(如果nextIndex为0 ，会返回一条term为-1，index为-1的日志，follower收到后会跳过匹配因为已经到底了)</span></span><br><span class="line"><span class="type">LogEntry</span> <span class="variable">preLog</span> <span class="operator">=</span> getPreLog(logEntries.getFirst());</span><br><span class="line">aentryParam.setPreLogTerm(preLog.getTerm());</span><br><span class="line">aentryParam.setPrevLogIndex(preLog.getIndex());</span><br><span class="line"></span><br><span class="line">aentryParam.setEntries(logEntries.toArray(<span class="keyword">new</span> <span class="title class_">LogEntry</span>[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> Request.builder()</span><br><span class="line">        .cmd(Request.A_ENTRIES)</span><br><span class="line">        .obj(aentryParam)</span><br><span class="line">        .url(peer.getAddr())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></li></ul><p>getPreLog() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LogEntry <span class="title function_">getPreLog</span><span class="params">(LogEntry logEntry)</span> &#123;</span><br><span class="line"></span><br><span class="line">    LogEntry entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(logEntry.getIndex() == <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;已经匹配到底了，需要从头开始覆盖&quot;</span>);</span><br><span class="line">        entry = LogEntry.builder().index(-<span class="number">1L</span>).term(-<span class="number">1</span>).command(<span class="literal">null</span>).build();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        entry = logModule.read(logEntry.getIndex() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>失败回溯</strong>：发送请求会携带 <code>prevLogTerm</code> 和 <code>prevLogIndex</code>。如果 Follower 返回失败（日志不匹配或 Leader Term 过旧）：<ul><li>如果是Leader Term 过旧，那就降级为Follower。</li><li>如果不是因为Term过旧，Leader 就将该 Follower 的 <code>nextIndex</code> 减一。</li><li>下次心跳时重试前一条日志，直到找到匹配点（MatchIndex）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">AentryResult</span> <span class="variable">result</span> <span class="operator">=</span> getRpcClient().send(request,<span class="number">450</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;append follower entry success , follower=[&#123;&#125;], entry=[&#123;&#125;]&quot;</span>, peer, aentryParam.getEntries());</span><br><span class="line">        <span class="comment">// update 这两个追踪值</span></span><br><span class="line">        nextIndexs.put(peer, myNewIndex+<span class="number">1</span>);</span><br><span class="line">        matchIndexs.put(peer, myNewIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 对方比我大</span></span><br><span class="line">        <span class="keyword">if</span> (result.getTerm() &gt; currentTerm) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;follower [&#123;&#125;] term [&#123;&#125;] than more self, and my term = [&#123;&#125;], so, I will become follower&quot;</span>,</span><br><span class="line">                    peer, result.getTerm(), currentTerm);</span><br><span class="line">            currentTerm = result.getTerm();</span><br><span class="line">            <span class="comment">// 认怂, 变成跟随者</span></span><br><span class="line">            status = NodeStatus.FOLLOWER;</span><br><span class="line">        &#125; <span class="comment">// 没我大, 却失败了,说明 index 不对.或者 term 不对.</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将nextIndex 减一 下一次心跳继续匹配。</span></span><br><span class="line">            nextIndexs.put(peer, nextIndex - <span class="number">1</span>);</span><br><span class="line">            log.warn(<span class="string">&quot;follower &#123;&#125; nextIndex not match, will reduce nextIndex and retry RPC append, nextIndex : [&#123;&#125;]&quot;</span>, peer.getAddr(),</span><br><span class="line">                    nextIndex);</span><br><span class="line">            <span class="comment">// 下次心跳重来, 直到成功.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;当前接受节点 &#123;&#125; 已宕机&quot;</span>, peer.getAddr());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="3-Follower-的处理逻辑"><a href="#3-Follower-的处理逻辑" class="headerlink" title="3. Follower 的处理逻辑"></a>3. Follower 的处理逻辑</h3><p>Follower 在接收端的处理也做了细致的锁管理：</p><ul><li><strong>日志写入</strong>：收到日志后严格校验匹配性。匹配成功则<strong>加锁</strong>写入本地日志,之后根据leader 的 <code>commitIndex</code>跟自己的 <code>lastIndex</code> 更新自己 <code>commitIndex</code>，异步应用到状态机，并返回成功。</li><li><strong>心跳处理</strong>：收到心跳时，若 Leader Term 小于自己，则拒绝并告知对方退位。若 Term 合法，重置选举超时，转为 Follower（因为自己之前可能是候选人，或者分区之后又合区的老leader）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AentryResult <span class="title function_">appendEntries</span><span class="params">(AentryParam param)</span> &#123;</span><br><span class="line">        <span class="type">AentryResult</span> <span class="variable">result</span> <span class="operator">=</span> AentryResult.fail();</span><br><span class="line">        <span class="comment">// 原appendLock仅保护日志写入/删除等临界操作，锁范围缩小</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!appendLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.setTerm(node.getCurrentTerm());</span><br><span class="line">            <span class="comment">// 1. 任期检查：对方任期更小，直接返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (param.getTerm() &lt; node.getCurrentTerm()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 更新节点状态（Follower）和时间戳</span></span><br><span class="line">            node.preHeartBeatTime = System.currentTimeMillis();</span><br><span class="line">            node.preElectionTime = System.currentTimeMillis();</span><br><span class="line">            node.peerSet.setLeader(<span class="keyword">new</span> <span class="title class_">Peer</span>(param.getLeaderId()));</span><br><span class="line">            <span class="keyword">if</span> (param.getTerm() &gt;= node.getCurrentTerm()) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">&quot;node &#123;&#125; become FOLLOWER, currentTerm : &#123;&#125;, param Term : &#123;&#125;, param serverId = &#123;&#125;&quot;</span>,</span><br><span class="line">                        node.peerSet.getSelf(), node.currentTerm, param.getTerm(), param.getServerId());</span><br><span class="line">                <span class="comment">// 退为跟随者</span></span><br><span class="line">                node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            &#125;</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 处理心跳请求</span></span><br><span class="line">            <span class="keyword">if</span> (param.getEntries() == <span class="literal">null</span> || param.getEntries().length == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;node &#123;&#125; append heartbeat success , he&#x27;s term : &#123;&#125;, my term : &#123;&#125;&quot;</span>,</span><br><span class="line">                        param.getLeaderId(), param.getTerm(), node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 心跳仅更新commitIndex，状态机提交异步执行</span></span><br><span class="line">                <span class="keyword">if</span> (param.getLeaderCommit() &gt; node.getCommitIndex()) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">newCommitIndex</span> <span class="operator">=</span> Math.min(param.getLeaderCommit(), node.getLogModule().getLastIndex());</span><br><span class="line">                    node.setCommitIndex(newCommitIndex);</span><br><span class="line">                    <span class="comment">// 异步提交状态机（核心改造点）</span></span><br><span class="line">                    submitToStateMachineAsync();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 心跳直接返回成功，无需等待提交</span></span><br><span class="line">                <span class="keyword">return</span> AentryResult.newBuilder().term(node.getCurrentTerm()).success(<span class="literal">true</span>).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理真实日志同步请求</span></span><br><span class="line">            <span class="comment">// 4.1 前置日志检查：prevLogIndex/prevLogTerm不匹配则返回失败</span></span><br><span class="line">            <span class="comment">// 如果prevLogIndex=-1，则代表该日志是leader的第一条日志，此时不需要匹配，因为已经是第一个了。</span></span><br><span class="line">            <span class="keyword">if</span> (param.getPrevLogIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> node.getLogModule().read(param.getPrevLogIndex());</span><br><span class="line">                <span class="keyword">if</span> (logEntry == <span class="literal">null</span> || logEntry.getTerm() != param.getPreLogTerm()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 冲突日志处理：索引相同但任期不同则删除后续所有日志</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nextLogIndex</span> <span class="operator">=</span> param.getPrevLogIndex() + <span class="number">1</span>;</span><br><span class="line">            <span class="type">LogEntry</span> <span class="variable">existLog</span> <span class="operator">=</span> node.getLogModule().read(nextLogIndex);</span><br><span class="line">            <span class="keyword">if</span> (existLog != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existLog.getTerm() != param.getEntries()[<span class="number">0</span>].getTerm()) &#123;</span><br><span class="line">                    <span class="comment">// 删除冲突日志及后续</span></span><br><span class="line">                    node.getLogModule().removeOnStartIndex(nextLogIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 日志已存在，无需重复写入，直接返回成功</span></span><br><span class="line">                    result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">                    result.setTerm(node.getCurrentTerm());</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.3 写入日志（核心：写入完成即可返回成功）</span></span><br><span class="line">            <span class="keyword">for</span> (LogEntry entry : param.getEntries()) &#123;</span><br><span class="line">                node.getLogModule().write(entry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 日志写入成功，先标记结果为成功</span></span><br><span class="line">            result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">            result.setTerm(node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.4 更新commitIndex，状态机提交异步执行</span></span><br><span class="line">            <span class="keyword">if</span> (param.getLeaderCommit() &gt; node.getCommitIndex()) &#123;</span><br><span class="line">                <span class="comment">// 更新commitIndex为leaderCommit跟本节点的lastIndex取最小值</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">newCommitIndex</span> <span class="operator">=</span> Math.min(param.getLeaderCommit(), node.getLogModule().getLastIndex());</span><br><span class="line">                node.setCommitIndex(newCommitIndex);</span><br><span class="line">                <span class="comment">// 异步提交状态机（核心改造点）</span></span><br><span class="line">                submitToStateMachineAsync();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.5 立即返回成功，无需等待状态机提交</span></span><br><span class="line">            node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放日志操作锁</span></span><br><span class="line">            <span class="keyword">if</span> (appendLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                appendLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>异步应用 (Async Apply)</strong>：<ul><li>心跳包中包含 Leader 的 <code>commitIndex</code>。</li><li>Follower 取 <code>min(leaderCommit, lastLogIndex)</code> 作为本地提交点。</li><li><strong>优化点</strong>：写入本地日志后，或者更新 commitIndex 后，采用<strong>异步方式</strong>将日志应用（Apply）到状态机，避免阻塞 IO 线程，提升效率。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitToStateMachineAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提交到专用线程池，异步执行</span></span><br><span class="line">        commitExecutor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 加锁保证串行提交，避免重复/并发提交</span></span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 基于lastApplied计算下一个要提交的索引（断点续传核心）</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">nextCommit</span> <span class="operator">=</span> node.getLastApplied() + <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">commitIndex</span> <span class="operator">=</span> node.getCommitIndex();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextCommit &gt; commitIndex) &#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">&quot;暂无需要提交的日志，lastApplied=&#123;&#125;, commitIndex=&#123;&#125;&quot;</span>, nextCommit-<span class="number">1</span>, commitIndex);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOGGER.info(<span class="string">&quot;开始异步提交日志，从索引&#123;&#125;到&#123;&#125;&quot;</span>, nextCommit, commitIndex);</span><br><span class="line">                <span class="comment">// 循环提交日志到状态机</span></span><br><span class="line">                <span class="keyword">while</span> (nextCommit &lt;= commitIndex) &#123;</span><br><span class="line">                    <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> node.getLogModule().read(nextCommit);</span><br><span class="line">                    <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            node.stateMachine.apply(logEntry);</span><br><span class="line">                            <span class="comment">// 每提交一条更新一次lastApplied，保证断点续传</span></span><br><span class="line">                            node.setLastApplied(nextCommit);</span><br><span class="line">                            LOGGER.info(<span class="string">&quot;异步提交日志成功，索引=&#123;&#125;&quot;</span>, nextCommit);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOGGER.error(<span class="string">&quot;异步提交日志到状态机失败，索引=&#123;&#125;&quot;</span>, nextCommit, e);</span><br><span class="line">                            <span class="comment">// 提交失败则终止，避免后续日志错位</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOGGER.warn(<span class="string">&quot;日志不存在，索引=&#123;&#125;&quot;</span>, nextCommit);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextCommit++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放提交锁</span></span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、-CommitIndex-的计算与安全性"><a href="#三、-CommitIndex-的计算与安全性" class="headerlink" title="三、 CommitIndex 的计算与安全性"></a>三、 CommitIndex 的计算与安全性</h2><p>如何确定一条日志可以被安全提交？</p><h3 id="1-基于中位数的-CommitIndex-计算"><a href="#1-基于中位数的-CommitIndex-计算" class="headerlink" title="1. 基于中位数的 CommitIndex 计算"></a>1. 基于中位数的 CommitIndex 计算</h3><p>不再简单依赖单次 RPC 的成功率，而是基于全局视图：</p><ul><li>在每次心跳/日志发送完成（<code>CompletableFuture.allOf</code> 结束）后，统计所有节点的 <code>matchIndex</code>。</li><li><strong>求中位数</strong>：通过排序或统计算法，找出超过半数节点都拥有的最大索引值。</li><li><strong>任期检查</strong>：Raft 规定只能提交当前任期的日志。因此，计算出的索引对应的日志 term 必须等于 <code>currentTerm</code> 才能更新 <code>commitIndex</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待所有日志完成</span></span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">//多个任务</span></span><br><span class="line">    CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">    CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在一个满足N &gt; commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，</span></span><br><span class="line"><span class="comment">// 并且log[N].term == currentTerm成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</span></span><br><span class="line">List&lt;Long&gt; matchIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchIndexs.values());</span><br><span class="line"><span class="comment">// 小于 2, 没有意义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (matchIndexList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Collections.sort(matchIndexList);</span><br><span class="line">    median = matchIndexList.size() / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Long</span> <span class="variable">N</span> <span class="operator">=</span> matchIndexList.get(median);</span><br><span class="line"><span class="keyword">if</span> (N &gt; commitIndex) &#123;</span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> logModule.read(N);</span><br><span class="line">    <span class="comment">// 只能提交当前任期日志</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getTerm() == currentTerm) &#123;</span><br><span class="line">        commitIndex = N;</span><br><span class="line">        <span class="comment">// 异步应用到状态机</span></span><br><span class="line">        RaftThreadPool.execute(()-&gt;&#123;</span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">myCommitIndex</span> <span class="operator">=</span> commitIndex;</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到异步开始时的commitIndex（防止重复提交）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= myCommitIndex; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = myCommitIndex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-解决“幽灵复现”：No-Op-Log"><a href="#2-解决“幽灵复现”：No-Op-Log" class="headerlink" title="2. 解决“幽灵复现”：No-Op Log"></a>2. 解决“幽灵复现”：No-Op Log</h3><p>针对“只能提交当前任期日志”导致旧日志可能无法及时提交的问题（如果允许提交可能会导致同一个位置的日志重复提交），采用了<strong>插入空日志</strong>策略：</p><ul><li>新 Leader 上任后，立即append一条空日志（No-Op Log）。</li><li>一旦这条当前任期的空日志被提交，根据日志连续性原则，之前所有未提交的旧日志也会被间接提交。</li><li>初始化：新 Leader 将所有 Follower 的 <code>nextIndex</code> 初始化为 <code>lastIndex + 1</code>， <code>matchIndex</code> 初始化为 <code>0</code>。利用后续的心跳回溯机制自动对其。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">becomeLeaderToDoThing</span><span class="params">()</span> &#123;</span><br><span class="line">        nextIndexs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        matchIndexs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">            nextIndexs.put(peer, logModule.getLastIndex() + <span class="number">1</span>);</span><br><span class="line">            matchIndexs.put(peer, <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建[空日志]并提交，用于处理前任领导者未提交的日志</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> LogEntry.builder()</span><br><span class="line">                .command(<span class="literal">null</span>)</span><br><span class="line">                .term(currentTerm)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只用提交到本地日志 ， 同步操作在下一次发送心跳时进行。</span></span><br><span class="line">        logModule.write(logEntry);</span><br><span class="line">        log.info(<span class="string">&quot;write logModule success, logEntry info : &#123;&#125;, log index : &#123;&#125;&quot;</span>, logEntry, logEntry.getIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、-线性一致性读-Linearizable-Read"><a href="#四、-线性一致性读-Linearizable-Read" class="headerlink" title="四、 线性一致性读 (Linearizable Read)"></a>四、 线性一致性读 (Linearizable Read)</h2><p>为了防止读取到旧数据（Stale Read），实现了 Follower Read 和 Leader Read。</p><ul><li><strong>Leader Read</strong>：Leader 收到读请求后，不能直接返回。需先广播一轮心跳（同样使用 <code>CompletableFuture</code> 机制），确认自己仍持有过半数选票（未发生脑裂）。确认成功后，等待状态机应用到 <code>commitIndex</code> 后返回结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断自己是否还是leader</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isStillLeader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">Agree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        List&lt;CompletableFuture&lt;AentryResult&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">            <span class="type">AentryParam</span> <span class="variable">param</span> <span class="operator">=</span> AentryParam.builder()</span><br><span class="line">                    .entries(<span class="literal">null</span>)<span class="comment">// 心跳,空日志.</span></span><br><span class="line">                    .leaderId(peerSet.getSelf().getAddr())</span><br><span class="line">                    .serverId(peer.getAddr())</span><br><span class="line">                    .term(currentTerm)</span><br><span class="line">                    .leaderCommit(commitIndex) <span class="comment">// 心跳时与跟随者同步 commit index</span></span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                    Request.A_ENTRIES,</span><br><span class="line">                    param,</span><br><span class="line">                    peer.getAddr());</span><br><span class="line">            futureList.add(CompletableFuture.supplyAsync(()-&gt; getRpcClient().&lt;AentryResult&gt;send(request,<span class="number">300</span>)</span><br><span class="line">                    ,RaftThreadPool.giveMePool()).exceptionally(ex -&gt; <span class="literal">null</span>)</span><br><span class="line">                    .whenComplete((result,throwable)-&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                            log.error(<span class="string">&quot;无法收到 &#123;&#125; 节点的心跳回应，该节点可能已经宕机&quot;</span>,peer.getAddr());</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">term</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                            <span class="keyword">if</span>(term &gt; currentTerm)&#123;</span><br><span class="line">                                log.error(<span class="string">&quot;收到更大的term来自节点&#123;&#125;  当前节点&#123;&#125;目前已不适合当leader&quot;</span>,peer.getAddr(),peerSet.getSelf().getAddr());</span><br><span class="line">                                currentTerm = term;</span><br><span class="line">                                votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                                status = NodeStatus.FOLLOWER;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">//成功回复</span></span><br><span class="line">                                <span class="keyword">if</span>(result.isSuccess())&#123;</span><br><span class="line">                                    log.info(<span class="string">&quot;成功收到来自节点&#123;&#125;的心跳回复且合法&quot;</span>,peer.getAddr());</span><br><span class="line">                                    Agree.incrementAndGet();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有心跳回应</span></span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">            <span class="comment">//多个任务</span></span><br><span class="line">            CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">            CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断现在自己还是不是leader</span></span><br><span class="line">        <span class="keyword">if</span>(status!=NodeStatus.LEADER)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断收到的回复数是否大于等于一半（加上自己即大于一半）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">agreeNum</span> <span class="operator">=</span> Agree.get();</span><br><span class="line">        <span class="keyword">if</span>(agreeNum &gt;= (peerSet.getPeersWithOutSelf().size()+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Follower Read</strong>：<ol><li>Follower 收到读请求，向 Leader 发送 <code>ReadIndex</code> RPC。</li><li>Leader 收到后，执行上述“确认领导权”流程，返回当前的 <code>commitIndex</code>。</li><li>Follower 拿到 <code>commitIndex</code> 后，等待本地 <code>appliedIndex &gt;= commitIndex</code>，再将数据返回给客户端。</li></ol></li></ul><p>响应客户端请求的接口代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  ClientKVAck <span class="title function_">handlerClientRequest</span><span class="params">(ClientKVReq request)</span> &#123;</span><br><span class="line"></span><br><span class="line">    log.warn(<span class="string">&quot;handlerClientRequest handler &#123;&#125; operation,  and key : [&#123;&#125;], value : [&#123;&#125;]&quot;</span>,</span><br><span class="line">            ClientKVReq.Type.value(request.getType()), request.getKey(), request.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写请求必须转给leader</span></span><br><span class="line">    <span class="keyword">if</span> (status != NodeStatus.LEADER &amp;&amp; request.getType() == ClientKVReq.PUT) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;I not am leader , only invoke redirect write method, leader addr : &#123;&#125;, my addr : &#123;&#125;&quot;</span>,</span><br><span class="line">                peerSet.getLeader(), peerSet.getSelf().getAddr());</span><br><span class="line">        <span class="keyword">return</span> redirect(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader收到读请求。</span></span><br><span class="line">    <span class="comment">//为了满足顺序一致性要求，必须让lastApplied == commitIndex才行</span></span><br><span class="line">    <span class="keyword">if</span> (request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.LEADER) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断自己是否还是leader</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeader</span> <span class="operator">=</span> isStillLeader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLeader)&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证自己的lastApplied == commitIndex</span></span><br><span class="line">        <span class="keyword">if</span>(lastApplied != commitIndex)&#123;</span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到commitIndex</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= commitIndex; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = commitIndex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> stateMachine.get(request.getKey());</span><br><span class="line">        <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(logEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是follower收到读请求</span></span><br><span class="line">    <span class="comment">//可以实现follower read , follower向leader发送查询当前readIndex的请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.FOLLOWER)&#123;</span><br><span class="line">        <span class="comment">//向leader发送获取当前最新commitIndex的请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                Request.GET_READ_INDEX,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                peerSet.getLeader().getAddr());</span><br><span class="line"></span><br><span class="line">        GetCommitIndexResult result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             result = getRpcClient().send(request1,<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;无法与leader &#123;&#125; 取得连续，无法返回读请求&quot;</span>,peerSet.getLeader().getAddr());</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result.isSuccess())&#123;</span><br><span class="line">            <span class="comment">//说明当前发送的已经不是leader</span></span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">readIndex</span> <span class="operator">=</span> result.getReadIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须在2s内响应</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        commitLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">2</span>*<span class="number">1000</span>)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastIndex</span> <span class="operator">=</span> logModule.getLastIndex();</span><br><span class="line">                <span class="type">long</span> <span class="variable">shouldCommit</span> <span class="operator">=</span> Math.min(readIndex,lastIndex);</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到shouldCommit</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= shouldCommit; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = shouldCommit;</span><br><span class="line">                <span class="comment">//满足要求</span></span><br><span class="line">                <span class="keyword">if</span>(lastApplied == readIndex)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待一段时间，继续</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    commitLock.unlock();</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    log.error(<span class="string">&quot;同步 ReadIndex 时线程被中断&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    commitLock.lock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            commitLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2秒过后还是没同步</span></span><br><span class="line">        <span class="keyword">if</span>(lastApplied!=readIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> stateMachine.get(request.getKey());</span><br><span class="line">        <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(logEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是候选人响应读请求，则返回失败，因为自己是不稳定的</span></span><br><span class="line">    <span class="keyword">if</span>(request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.CANDIDATE)&#123;</span><br><span class="line">        <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是leader处理写请求，但他只会写入本地，同步日志在心跳时完成。</span></span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> LogEntry.builder()</span><br><span class="line">            .command(Command.builder().</span><br><span class="line">                    key(request.getKey()).</span><br><span class="line">                    value(request.getValue()).</span><br><span class="line">                    build())</span><br><span class="line">            .term(currentTerm)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到本地日志</span></span><br><span class="line">    logModule.write(logEntry);</span><br><span class="line">    log.info(<span class="string">&quot;write logModule success, logEntry info : &#123;&#125;, log index : &#123;&#125;&quot;</span>, logEntry, logEntry.getIndex());</span><br><span class="line">    <span class="keyword">return</span> ClientKVAck.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五、-原项目的一些问题"><a href="#五、-原项目的一些问题" class="headerlink" title="五、 原项目的一些问题"></a>五、 原项目的一些问题</h2><ol><li>原项目只有在有新日志来的时候才会进行日志同步，没有新日志来的时候不会进行日志同步，但是一个落后的节点恢复之后，应该让他同步日志，这样就不会同步及时，于是我改造成了每次心跳时进行日志同步。</li><li>原项目在多个异步线程的同步（比如拉票请求，使用多线程进行发送拉票，但必须都完成之后才开始统计）上使用了 线程池+future+countDownLatch 使用future.get()获得结果，然后使用countDownLatch.await()等待所有线程完成，但是future.get()这个方法会阻塞线程，导致无法进行下一步操作。于是我改造成了CompletableFuture+线程池的方式实现。具体见前文中的代码。</li><li>原项目把lastApplied初始化为0，我认为并不合理，因为这个就默认0位置的日志已经应用了。所以应该改为-1。（我看了一下原项目并没有说明0位置的日志是垃圾日志，并且写入日志也都是从0开始，所以0位置是有用的，不应该跳过）。</li><li>原项目没有对RPC请求进行超时限制。这样在投票中极有可能发生如下情况：一个节点发起拉票请求，但有一个节点宕机，其他节点都投了赞成票。这个宕机节点会导致RPC请求一直处于等待状态，在最后统计得票的时候，会在多个异步任务同步这里超时（一般设为3秒）。但就是在这个时候，其他节点也极有可能发起新一轮的拉票请求，这样本来第一次发送拉票的节点，本应该在他那一轮变成leader但是在3秒之后，虽然拿到了多数票数，但是自己状态是follower（这里参考前文写的节点处理拉票请求），于是失败。这样就会导致多轮无效投票，导致效率低。于是设置一个RPC超时时间（500ms）保证能快速结算票数，让其他节点发起新一轮投票的概率变小。（其实原项目在投票的时候跟我的实现有一定出入，他并未对新一轮投票作出管理（我在当新一轮投票来临时，把自己得投票人置为空，并且把自己变成follower），只有自己变成候选人，然后落选之后才会把投票人清空，我觉得这样效率不高）</li><li>针对第5点的补充说明，原项目只有自己变成候选人，然后落选之后才会把投票人清空。这样做的话，在一个周期内如果没选出来领导人，那就必须等到下一个周期（因为重置投票人会在一个周期后，而不是一个新的term）。而我的改进，让一个节点收到更大的term之后会让出自己的位置，并且释放投票人，这样在每次新的term中每个节点都可以进行投票。这样在一个选举周期内大概率可以成功选举。我这种方案的随机时间设置范围最好为[electiontimeout, 2 * electiontimeout - 1],避免冲突。 （其实我这个思路跟6.824 lab2思路一样）</li><li>原项目并未实现Follower Read。我的具体实现见前文</li></ol><hr><h2 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h2><p>以下是我的一些心得 共12条</p><ol><li>投票时，如果遇到更新的term则把之前的投票人置空，防止无法投票（投票时也需要上锁，避免重复投票），然后判断自己没有投过票，当前发送请求的候选人是否有资格，即持有比自己更新的日志，如果都满足这个followe节点就可以投票给该节点。并更新相应的信息，释放锁。</li><li>Follower收到日志时，判断日志是否匹配，不匹配返回失败，匹配则写入本地。写入本地之后，根据leader的commitIndex异步应用日志，提升效率。但都需要上锁（写入与提交都需要）</li><li>follower收到心跳时，判断leader的term是否小于自己，如果小于返回失败，并且告诉leader自己的term，让他退位。如果大于等于自己，则把自己的状态变为follower(因为节点的状态可能是候选人，或者分区之后又加入的老leader)。然后重置投票倒计时。然后每次心跳还会带有leader的commitIndex，把这个跟自己最后的日志索引取最小值，然后异步应用日志到这个位置，跟leader保持同步。</li><li>在learder中把同步日志到followe操作 跟 心跳放在一起，即每次判断不同的follower是否需要同步日志，如果不需要则发送心跳。通过判断自己的lastIndex&gt;=每个follower的nextIndex（对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一））。如果是则发送nextIndex对应的日志。</li><li>在发送日志阶段，每次发送会带上indexIndex的前一条日志的term和index用于日志匹配。如果follower拒收，那就是日志不匹配（也有可能是leader的term小了，那么leader就应该退为follower），那么就把他的nextIndex 减一。这样下次心跳时就会发送前一个日志给他。直到成功，更新他对应的nextIndex以及matchIndex（对于每一个服务器，已经复制给他的日志的最高索引值）</li><li>合并发送，每次发送日志时，会把nextindex对应日志一直到自己的lastIndex日志一起发送，这样follower一旦匹配就可以批量写入新日志，快速同步。</li><li>当一个节点的投票倒计时结束后，还没收到leader的心跳。自己则会把自己的term+1,把自己变成候选人，投自己一票，然后向所有其他节点发起拉票，这个请求会携带自己的term,最后一个日志的term,index。通过这个其他节点才能判断你是否有资格。</li><li>把实现发起拉票操作的 线程池+Future+CountDownLatch 改成了 CompletableFuture+线程池。因为Future的get方法会阻塞调用，性能不如直接使用CompletableFuture的whenComplete。并且使用一个List<CompletableFuture>去保存这些对象，使用CompletableFuture.allOf方法保持多个异步线程的同步，从而不使用CountDownLatch进行同步。使用AtomicInteger记录投票成功数量，保证安全性。</li><li>在确定Leader的commitIndex时，不再使用每次同步的结果来判断（如果大部分成功就提交）。因为现在是在心跳时同步日志，给每个follower同步的不一定是同一个索引的日志。而是在每次心跳（日志）发送完成之后（跟8一样必须在发送都完成之后），使用每个follower的matchIndex 来判断leade的commitIndex。转化为已知每个节点的最大匹配数，求超过一半的匹配索引（其实就是求中位数即可）。得到对应的commitIndex。判断当前commitIndex的日志是否是自己当前任期的，否则不能提交（防止幽灵复现问题，即重复提交同一个位置的日志），但是可以通过提交当前任期的日志顺带一并提交之前的，但是如果当前任期一直没新日志难道迟迟不提交吗？</li><li>插入空日志，插入空日志就是解决9中提到的幽灵复现问题。每次新leader上任就插入一条空日志，这样就可以实现顺带提交之前任期未提交的日志。也可以及时提交，不依赖于新的日志。新上任的leader初始化所有的 nextIndex 值为自己的最后一条日志的 index + 1，这样下次心跳如果不匹配就会跟第5步一样。</li><li>Leader发送心跳也是使用的CompletableFuture但是这时就不用同步了，根据follower的返回值中的term是否大于自己的term来判断自己是否还能继续当，否则变成follower。</li><li>实现线性一致性的follower read。如果是leader收到读请求，先广播请求来判断当前自己是否还是leader(具体实现还是跟拉票类似，CompletableFuture+线程池)，如果收到过半数的成功回复，则保证将日志应用至commitIndex的位置之后返回读取请求。如果失败则不响应或者返回失败。如果是follower收到了此次读请求，那么发送一个请求当前最新commitIndex(readIndex)的RPC给leader,leader收到请求也会先判断自己是否还是leader,之后返回当前的commitIndex。Follower拿到之后即保证应用至commitIndex位置之后返回读请求，否则返回失败。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（九） 二分</title>
      <link href="/posts/14894eda.html"/>
      <url>/posts/14894eda.html</url>
      
        <content type="html"><![CDATA[<h2 id="狒狒吃香蕉"><a href="#狒狒吃香蕉" class="headerlink" title="狒狒吃香蕉"></a>狒狒吃香蕉</h2><p>思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计答案，右侧二分寻找更大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : piles) &#123;</span><br><span class="line">        r = Math.max(r,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(fMinEatingSpeed(piles,mid) &lt;= h)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">fMinEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles,<span class="type">int</span> speed)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">        cnt += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割数组最大值"><a href="#分割数组最大值" class="headerlink" title="分割数组最大值"></a>分割数组最大值</h2><p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。</p><p>返回分割后最小的和的最大值。</p><p>子数组 是数组中连续的部份。</p><p>思路： 对答案进行二分，答案范围为[0,sum(nums)]。f函数为当最小值为limit的时候，我需要的最小划分数。如果这个最小划分数&lt;=k,则记录答案，并且去左侧二分，寻找更小的答案。反之，则去右侧二分，不记录答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0,sum]二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = sum, m, need; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// 中点m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 必须让数组每一部分的累加和 &lt;= m，请问划分成几个部分才够!</span></span><br><span class="line">need = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (need &lt;= k) &#123;</span><br><span class="line"><span class="comment">// 达标</span></span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须让数组arr每一部分的累加和 &lt;= limit，请问划分成几个部分才够!</span></span><br><span class="line"><span class="comment">// 返回需要的部分数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">parts</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &gt; limit) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum + num &gt; limit) &#123;</span><br><span class="line">parts++;</span><br><span class="line">sum = num;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出第k小的数对距离"><a href="#找出第k小的数对距离" class="headerlink" title="找出第k小的数对距离"></a>找出第k小的数对距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0, 最大-最小]，不停二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>], m, cnt; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// m中点，arr中任意两数的差值 &lt;= m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回数字对的数量</span></span><br><span class="line">cnt = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr中任意两数的差值 &lt;= limit</span></span><br><span class="line"><span class="comment">// 这样的数字配对，有几对？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line"><span class="comment">// l......r r+1</span></span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; arr.length &amp;&amp; arr[r + <span class="number">1</span>] - arr[l] &lt;= limit) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[l...r]范围上的数差值的绝对值都不超过limit</span></span><br><span class="line"><span class="comment">// arr[0...3]</span></span><br><span class="line"><span class="comment">// 0,1</span></span><br><span class="line"><span class="comment">// 0,2</span></span><br><span class="line"><span class="comment">// 0,3</span></span><br><span class="line">ans += r - l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同时运行n台电脑的最长时间"><a href="#同时运行n台电脑的最长时间" class="headerlink" title="同时运行n台电脑的最长时间"></a>同时运行n台电脑的最长时间</h2><p>leelcode2141</p><p>你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。</p><p>一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p><p>注意，你不能给电池充电。</p><p>请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</p><p>思路：还是二分答案。答案范围是[0,sum(batteries)]。f函数为当运行时间为m的时候，我能运行的最多电脑数量。如果这个数量大于等于规定的数量，那么我记录mid,然后去右边二分，寻找更长的时间。反之，不计入答案，去左侧二分。 还有一个贪心优化，可以减少二分的次数。详见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> batteries.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            r+=batteries[i];</span><br><span class="line">            max= Math.max(max,batteries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r&gt; (<span class="type">long</span>) max * n) &#123;</span><br><span class="line">            <span class="comment">// 所有电池的最大电量是max</span></span><br><span class="line">            <span class="comment">// 如果此时sum &gt; (long) max * n，</span></span><br><span class="line">            <span class="comment">// 说明 : 最终的供电时间一定在 &gt;= max，而如果最终的供电时间 &gt;= max</span></span><br><span class="line">            <span class="comment">// 说明 : 对于最终的答案X来说，所有电池都是课上讲的&quot;碎片拼接&quot;的概念</span></span><br><span class="line">            <span class="comment">// 那么寻找 ? * n &lt;= sum 的情况中，尽量大的 ? 即可</span></span><br><span class="line">            <span class="comment">// 即sum / n</span></span><br><span class="line">            <span class="keyword">return</span> r / n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        r = max;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f(batteries,mid);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= n )&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] batteries,<span class="type">long</span> maxTime)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxTime == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">litterTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;batteries.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(batteries[i]&lt;maxTime)&#123;</span><br><span class="line">                litterTime+=batteries[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="type">int</span>) (litterTime/maxTime);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二分总结"><a href="#二分总结" class="headerlink" title="二分总结"></a>二分总结</h1><p>二分答案法，其实都可以看成给了三个变量，数组，限制以及答案。正向推导需要我们根据数组以及限制得到答案。但现在根据二分答案法，我们可以先把答案确定下来，然后算出一个跟限制相关的东西，把这个东西跟原限制作比较（这里就观察单调性），来判断下一步应该去哪边找答案。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-28%20212134.png" alt="总结"/></div><span class="image-caption">总结</span></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（八）双指针</title>
      <link href="/posts/6fd57b4.html"/>
      <url>/posts/6fd57b4.html</url>
      
        <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-27%20160658.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="寻找重复数-leetcode-hot100-最后一题"><a href="#寻找重复数-leetcode-hot100-最后一题" class="headerlink" title="寻找重复数 leetcode hot100 最后一题"></a>寻找重复数 leetcode hot100 最后一题</h2><p>思路：当成链表找环处理。每到一个位置i 那下一次就到arr[i]对应的位置。显然入环节点就是重复的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kuai</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">man</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        kuai = nums[nums[kuai]];</span><br><span class="line">        man = nums[man];</span><br><span class="line">        <span class="keyword">if</span>(kuai == man)&#123;</span><br><span class="line">            kuai = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(kuai != man)&#123;</span><br><span class="line">                kuai = nums[kuai];</span><br><span class="line">                man = nums[man];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kuai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>思路：初始版，类似与前缀和跟后缀和，我开两个数组记录i左边的最大值和右边的最大值，然后求出当前位置能接的雨水。sum+=Math.max(0,Math.min(left[i],right[i])-nums[i])</p><p>优化: 双指针思路，左右两边各一个指针。并且维护两个变量记录，左指针左边的最大值和右指针右边的最大值。对于左指针来说左边的最大值肯定是确定的，右指针同理。所以只需要判断两边谁的最大值更小，那么这一边就可以结算了，并且移动指针，更新最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">1</span>,r=height.length-<span class="number">2</span>,lmax = height[<span class="number">0</span>],rmax = height[height.length-<span class="number">1</span>],sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lmax&gt;=rmax)&#123;</span><br><span class="line">            <span class="comment">//结算右边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,rmax-height[r]);</span><br><span class="line">            rmax = Math.max(rmax,height[r--]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//结算左边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,lmax-height[l]);</span><br><span class="line">            lmax= Math.max(lmax,height[l++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="胖娃坐船"><a href="#胖娃坐船" class="headerlink" title="胖娃坐船"></a>胖娃坐船</h2><p>给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回 承载所有人所需的最小船数 。</p><p>思路：排序，然后双指针，一个指针指向最轻的，一个指针指向最重的，如果最轻的+最重的&lt;=limit，那么可以一起载，两个指针同时移动，ans++。否则，最重的指针移动,ans++。即胖子自己一个船。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    Arrays.sort(people);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>people.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[r]+people[l] &lt;= limit)&#123;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种：如果要求两个的体重加起来等于偶数呢？ 很简单，分为奇偶两个数组，然后分别处理，把两个结果加起来即可。</p><h2 id="供暖器"><a href="#供暖器" class="headerlink" title="供暖器"></a>供暖器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">    Arrays.sort(houses);</span><br><span class="line">    Arrays.sort(heaters);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">heaterIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> house : houses) &#123;</span><br><span class="line">        <span class="comment">// 找到离当前房屋最近的加热器</span></span><br><span class="line">        <span class="keyword">while</span> (heaterIndex &lt; heaters.length - <span class="number">1</span> &amp;&amp; </span><br><span class="line">               Math.abs(heaters[heaterIndex] - house) &gt;= </span><br><span class="line">               Math.abs(heaters[heaterIndex + <span class="number">1</span>] - house)) &#123;</span><br><span class="line">            heaterIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(result, Math.abs(heaters[heaterIndex] - house));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><p>思路：我现在就想让每个位置都对应，即i位置上放的就是i+1。此时，我维护两个指针，l的左边是满足我这个条件的，r的右边是肯定不满足的垃圾。初始化l=0,r=n。</p><p>现在开始遍历：每次都观察l位置上的是否满足，如果满足那就l++。如果不满足判断它是不是我需要的，即它在不在当前l到r范围内（因为小于l的已经就位了，不需要你，大于r的已经超过了，不需要你）。关于为什么大于r就算超过这里解释一下。因为理想状态下我数组长度为n那么我就有1-n这些数，但一旦一个数不满足（r—），那我肯定到不了n了,最大就是r。还有一种情况，现在我需要你，但是在num[num[l]-1] 已经有一个相同的你了，说明你重复了。所以也会被当成垃圾。以上三种情况会被当成垃圾，跟—r位置交换。剩下最后一种情况，你是我需要的而且你还没到应该到的位置，于是我把你交换到对应的位置。下次循环，继续看i位置的数。 直到l&lt;r。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n)，额外空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="comment">// l的左边，都是做到i位置上放着i+1的区域</span></span><br><span class="line"><span class="comment">// 永远盯着l位置的数字看，看能不能扩充(l++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [r....]垃圾区</span></span><br><span class="line"><span class="comment">// 最好的状况下，认为1~r是可以收集全的，每个数字收集1个，不能有垃圾</span></span><br><span class="line"><span class="comment">// 有垃圾呢？预期就会变差(r--)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] == l + <span class="number">1</span>) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]) &#123;</span><br><span class="line">swap(arr, l, --r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, l, arr[l] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结（七） 滑动窗口</title>
      <link href="/posts/aad8ff6.html"/>
      <url>/posts/aad8ff6.html</url>
      
        <content type="html"><![CDATA[<h2 id="累加和大于等于k的最小长度子数组"><a href="#累加和大于等于k的最小长度子数组" class="headerlink" title="累加和大于等于k的最小长度子数组"></a>累加和大于等于k的最小长度子数组</h2><p>都是正数，所以滑动窗口具有单调性，加入新数肯定会导致累加和变大，减少数字会导致累加和变小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">sum += nums[r];</span><br><span class="line"><span class="keyword">while</span> (sum - nums[l] &gt;= target) &#123;</span><br><span class="line"><span class="comment">// sum : nums[l....r]</span></span><br><span class="line"><span class="comment">// 如果l位置的数从窗口出去，还能继续达标，那就出去</span></span><br><span class="line">sum -= nums[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">ans = Math.min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复子串的最长长度"><a href="#无重复子串的最长长度" class="headerlink" title="无重复子串的最长长度"></a>无重复子串的最长长度</h2><p>记录上次这个字符出现的位置，每次更新左边界，就用当前左边界跟（上次重复位置+1）的最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line"><span class="comment">// char -&gt; int -&gt; 0 ~ 255</span></span><br><span class="line"><span class="comment">// 每一种字符上次出现的位置</span></span><br><span class="line"><span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 所有字符都没有上次出现的位置</span></span><br><span class="line">Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 不含有重复字符的 最长子串 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">l = Math.max(l, last[s[r]] + <span class="number">1</span>);</span><br><span class="line">ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 更新当前字符上一次出现的位置</span></span><br><span class="line">last[s[r]] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>描述：给定两个字符串 s 和 t，长度分别是 m 和 n，返回 s 中的 最短窗口 子串，使得该子串包含 t 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 “”。</p><p>等到满足覆盖条件之后，再开始考虑移动左边界。，只有移动左边界不会导致覆盖条件失效，才能移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String str, String tar)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] t = tar.toCharArray();</span><br><span class="line"><span class="comment">// 每种字符的欠债情况</span></span><br><span class="line"><span class="comment">// cnts[i] = 负数，代表字符i有负债</span></span><br><span class="line"><span class="comment">// cnts[i] = 正数，代表字符i有盈余</span></span><br><span class="line"><span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : t) &#123;</span><br><span class="line">cnts[cha]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小覆盖子串的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// 从哪个位置开头，发现的最小覆盖子串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总债务</span></span><br><span class="line"><span class="type">int</span> <span class="variable">debt</span> <span class="operator">=</span> t.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length; r++) &#123;</span><br><span class="line"><span class="comment">// 窗口右边界向右，给出字符</span></span><br><span class="line"><span class="keyword">if</span> (cnts[s[r]]++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">debt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (debt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 窗口左边界向右，拿回字符</span></span><br><span class="line"><span class="keyword">while</span> (cnts[s[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnts[s[l++]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以r位置结尾的达标窗口，更新答案</span></span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">len = r - l + <span class="number">1</span>;</span><br><span class="line">start = l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : str.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换子串得到平衡字符串"><a href="#替换子串得到平衡字符串" class="headerlink" title="替换子串得到平衡字符串"></a>替换子串得到平衡字符串</h2><p>解释：有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>思路：跟最小覆盖子串思路一样。只需要找到哪些字符超过了多少，我们替换他即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        cnt[pos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">debat</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] &lt;= n/<span class="number">4</span>)&#123;</span><br><span class="line">            cnt[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cnt[i] = n/<span class="number">4</span> - cnt[i];</span><br><span class="line">            debat-=cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>;r&lt;s.length();r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(cnt[pos]++ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            debat--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">            c = s.charAt(l);</span><br><span class="line">            pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>( cnt[pos] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cnt[pos]--;</span><br><span class="line">                l++;</span><br><span class="line">                c = s.charAt(l);</span><br><span class="line">                pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans,r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K个不同整数的子数组"><a href="#K个不同整数的子数组" class="headerlink" title="K个不同整数的子数组"></a>K个不同整数的子数组</h2><p>描述：给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</p><p>如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</p><p>例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。<br>子数组 是数组的 连续 部分。</p><p>思路：转化为求不超过k个不同整数问题，用k 减去 k-1 对应的答案 就是刚好个数为k的个数。</p><p>对于不超过这个问题用滑动窗口解决，只要种类不超过就扩大窗口，否则缩小窗口直到种类不超过。然后统计以窗口右边结尾的子数组的个数。即r-l+1.每次累加这个结果即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 不超过k个不同整数</span></span><br><span class="line">    <span class="keyword">return</span> find(nums,k) - find(nums,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">20001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    Arrays.fill(cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;nums.length;r++)&#123;</span><br><span class="line">        <span class="comment">// 窗口右边界向右，给出字符,并判断是不是新的</span></span><br><span class="line">        <span class="keyword">if</span>(++cnt[nums[r]] == <span class="number">1</span>)&#123;</span><br><span class="line">            kinds++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (kinds &gt; k)&#123;</span><br><span class="line">            <span class="comment">// 窗口左边界向右，拿回字符，如果一个字符没有了，则种类减一</span></span><br><span class="line">            <span class="keyword">if</span>( -- cnt[nums[l++]] == <span class="number">0</span>)&#123;</span><br><span class="line">                kinds--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以r位置结尾的达标窗口，累加个数</span></span><br><span class="line">        sum+= r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚合与聚合根</title>
      <link href="/posts/6758315a.html"/>
      <url>/posts/6758315a.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。</p><p>1.只能通过聚合根来修改内部对象，不能绕过聚合根。</p><p>2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回！</p><p>3.只有聚合根有repository。（实体可以有factory）</p><p>4.设计聚合最好小而全，最好能做到一个实体就是聚合。但做不到也不强求，能满足要求即可，但切记不能过大，也不能太小。</p><p>5.聚合根不能在内部直接引用其他聚合根，只能根据唯一id去查询另一个聚合根，由服务进行统排。</p><p>6.一个事务只对一个聚合根保存生效。</p><p>7.跨聚合采用最终一致性（因为规定了第6条，所以在跨聚合中经常会对不同的表进行操作），具体可以由领域事件实现。</p><p>8.如果聚合根内部有一个实体列表（1：N关系）那么可以考虑把这个实体也变成聚合根，原聚合根只保留他的唯一id列表。如果是多对多关系，可以考虑再新建一个表示它们两个关系的聚合根。</p><p>9.为什么要拆分聚合根？ 因为一个聚合根保留的信息越多，那么在并发的情况下，保存聚合根时冲突的概率就越大。比如我的用户保留了资源列表，而且我是保留了完整的资源信息，那么可能资源的信息修改（只是修改了资源的更新日期），也会导致我的用户保存失败（乐观锁，数据不一样）。但如果把资源单独变成聚合根，用户聚合只保留资源id那么将会避免这种情况。同时考虑资源跟用户是多对多的关系，所以最好最新建一个角色跟资源绑定的聚合根，角色聚合根里面不会有任何资源相关的信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（六）前缀和</title>
      <link href="/posts/3fdde4bd.html"/>
      <url>/posts/3fdde4bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="一维前缀和（子数组相关问题）"><a href="#一维前缀和（子数组相关问题）" class="headerlink" title="一维前缀和（子数组相关问题）"></a>一维前缀和（子数组相关问题）</h1><h2 id="和等于k的最长子数组长度"><a href="#和等于k的最长子数组长度" class="headerlink" title="和等于k的最长子数组长度"></a>和等于k的最长子数组长度</h2><p>思路：前缀和+哈希表。哈希表存的是key是前缀和，value是出现的位置。但这个位置必须是最早出现的，而且必须预先插入一条 0 ,-1表示0一开始就是。<br>然后，依次遍历数组计算前缀和，用当前的前缀和减去k的值去哈希表里面查找，当前位置减去对应的位置就是以当前位置结尾的最长子数组长度。遍历求最大即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">map.clear();</span><br><span class="line"><span class="comment">// 重要 : 0这个前缀和，一个数字也没有的时候，就存在了</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - aim)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - aim));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找正负数相等的最长子数组"><a href="#找正负数相等的最长子数组" class="headerlink" title="找正负数相等的最长子数组"></a>找正负数相等的最长子数组</h2><p>思路： 构造前缀和，但是前缀和记录正负数数量的差值。正数为1，负数为-1，0为0.然后每到一个位置靠哈希表查询跟自己前缀和相同的位置，然后求长度，即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+= arr[i] == <span class="number">0</span> ? <span class="number">0</span> : arr[i]&lt;<span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cnt))&#123;</span><br><span class="line">              ans = Math.max(ans,i-map.get(cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(cnt))&#123;</span><br><span class="line">                map.put(cnt,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval"><a href="#表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval" class="headerlink" title="表现良好的最长时间段 链接： https://leetcode.cn/problems/longest-well-performing-interval/"></a>表现良好的最长时间段 链接： <a href="https://leetcode.cn/problems/longest-well-performing-interval/">https://leetcode.cn/problems/longest-well-performing-interval/</a></h2><p>思路：还是前缀和+哈希表。超过时长+1，小于时长-1。如果遇到前缀和为正数说明从一开始就是满足的，返回i+1.如果为负数或者0，那么就找前缀和-1的位置（拉格朗日中值定理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line"><span class="comment">// 某个前缀和，最早出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 0这个前缀和，最早出现在-1，一个数也没有的时候</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">sum += hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// sum &lt;= 0</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - <span class="number">1</span>)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="移除最少子数组长度使数组和可以被p整除"><a href="#移除最少子数组长度使数组和可以被p整除" class="headerlink" title="移除最少子数组长度使数组和可以被p整除"></a>移除最少子数组长度使数组和可以被p整除</h2><p>思路：以余数为前缀和，求出整个数组和的余数mod。然后在遍历过程中遇到当前余数curMod，我们就需要找到之前最后一个余数为 (curMod + p - mod)%p 的位置，然后求出长度。就是需要在当前位置移除的子数组的长度。需要最后判断长度是等于数组长度的时候，返回-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="comment">// 整体余数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">mod = (mod + num) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mod == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key : 前缀和%p的余数</span></span><br><span class="line"><span class="comment">// value : 最晚出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>, find; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="comment">// 0...i这部分的余数</span></span><br><span class="line">cur = (cur + nums[i]) % p;</span><br><span class="line">find = cur &gt;= mod ? (cur - mod) : (cur + p - mod);</span><br><span class="line"><span class="comment">// find = (cur + p - mod) % p;</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(find)) &#123;</span><br><span class="line">ans = Math.min(ans, i - map.get(find));</span><br><span class="line">&#125;</span><br><span class="line">map.put(cur, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == nums.length ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p>解释：现在要进行如下操作：</p><ol><li>给定一个数组，我要在给定区间加上一个同样的数。循环多次</li><li>加完之后返回给我每个位置上的值。</li></ol><p>一维差分：</p><ol><li>区间如果为l,r 要加上a,那么我在arr[l]+a,arr[r+1]-a.</li><li>之后对这个数组求前缀和，就是结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookings</span></span><br><span class="line"><span class="comment">// [1,5,6]</span></span><br><span class="line"><span class="comment">// [2,9,3]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line"><span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 设置差分数组，每一个操作对应两个设置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] book : bookings) &#123;</span><br><span class="line">cnt[book[<span class="number">0</span>]] += book[<span class="number">2</span>];</span><br><span class="line">cnt[book[<span class="number">1</span>] + <span class="number">1</span>] -= book[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加工前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans[i] = cnt[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="等差差分"><a href="#等差差分" class="headerlink" title="等差差分"></a>等差差分</h1><p>解释： 跟一维差分类似，但是我要从l到r 依次加上一个等差数列，而不是一个数。</p><p>结论： 假设这个等差数列 首项为 s , 公差为 d, 末项为 e。那对arr[l]+=s,arr[l+1]+=d-s,arr[r+1]-=d+e,arr[r+2]+=e; 然后进行两次前缀和即可。</p><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>公式： sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + arr[i][j]<br>计算从（a,b）到 （c,d）的子矩阵的和 : sum[c][d] - sum[a-1][d] - sum[c][b-1] + sum[a-1][b-1]</p><h2 id="最大以1为边界的正方形"><a href="#最大以1为边界的正方形" class="headerlink" title="最大以1为边界的正方形"></a>最大以1为边界的正方形</h2><p>描述：给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>核心思路：构造出二维前缀和，依次枚举以（i,j）为左上角的正方形是否合法。假设以(c,d)为右下角。这个正方形的和减去以(i+1,j+1),(c-1,d-1)为对角的正方形和的值应该等于他的（边长-1） * 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> g[<span class="number">0</span>].length;</span><br><span class="line">build(n, m, g);</span><br><span class="line"><span class="keyword">if</span> (sum(g, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, m - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到的最大合法正方形的边长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; m; b++) &#123;</span><br><span class="line"><span class="comment">// (a,b)所有左上角点</span></span><br><span class="line"><span class="comment">//     (c,d)更大边长的右下角点，k是当前尝试的边长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + ans, d = b + ans, k = ans + <span class="number">1</span>; c &lt; n &amp;&amp; d &lt; m; c++, d++, k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum(g, a, b, c, d) - sum(g, a + <span class="number">1</span>, b + <span class="number">1</span>, c - <span class="number">1</span>, d - <span class="number">1</span>) == (k - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>) &#123;</span><br><span class="line">ans = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g : 原始二维数组</span></span><br><span class="line"><span class="comment">// 把g变成原始二维数组的前缀和数组sum，复用自己</span></span><br><span class="line"><span class="comment">// 不能补0行，0列，都是0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">g[i][j] += get(g, i, j - <span class="number">1</span>) + get(g, i - <span class="number">1</span>, j) - get(g, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; c ? <span class="number">0</span> : (g[c][d] - get(g, c, b - <span class="number">1</span>) - get(g, a - <span class="number">1</span>, d) + get(g, a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) ? <span class="number">0</span> : g[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>跟一维差分差不多这里直接给公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维差分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">diff[a][b] += k;</span><br><span class="line">diff[c + <span class="number">1</span>][b] -= k;</span><br><span class="line">diff[a][d + <span class="number">1</span>] -= k;</span><br><span class="line">diff[c + <span class="number">1</span>][d + <span class="number">1</span>] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft与Paxos</title>
      <link href="/posts/b1c1c3b5.html"/>
      <url>/posts/b1c1c3b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？"><a href="#深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？" class="headerlink" title="[深度对比] 分布式共识的双雄：Paxos 与 Raft，为何 Raft 成为了工程界的宠儿？"></a>[深度对比] 分布式共识的双雄：Paxos 与 Raft，为何 Raft 成为了工程界的宠儿？</h1><p>在分布式系统的浩瀚宇宙中，<strong>“共识（Consensus）”</strong> 是最核心的难题之一。如何让一堆可能随时宕机、网络延迟的机器对某个值达成一致？这个问题困扰了计算机科学家几十年。</p><p>在这个领域，有两位绝对的主角：一个是理论界的“神” <strong>Paxos</strong>，另一个是工程界的“救世主” <strong>Raft</strong>。</p><p>很多开发者都知道，现在主流的分布式组件（如 Etcd, Consul, TiKV, Kafka的新版本）大多选择了 Raft。那么，Paxos 到底输在哪里？Raft 又为何如此容易实现？本文将带你深入剖析两者的区别与优劣。</p><hr><h2 id="一、-核心设计哲学的差异"><a href="#一、-核心设计哲学的差异" class="headerlink" title="一、 核心设计哲学的差异"></a>一、 核心设计哲学的差异</h2><p>要理解它们的区别，首先要看它们诞生的初衷：</p><ul><li><strong>Paxos (Leslie Lamport, 1990)</strong>：旨在发现共识问题的<strong>数学规律</strong>。它从数学角度证明了在分布式系统中达成一致的充要条件。它追求的是理论的完备性和一般性。</li><li><strong>Raft (Diego Ongaro &amp; John Ousterhout, 2013)</strong>：旨在提供一个<strong>可理解（Understandable）</strong>且<strong>易于实现</strong>的算法。它的设计目标非常明确：<strong>就是为了解决 Paxos 太难懂、太难实现的问题</strong>。</li></ul><p>如果把 Paxos 比作量子力学（解释了世界的本质，但很难直接用来造桥），那么 Raft 就是牛顿力学（在特定约束下，给了你一套造桥的标准公式）。</p><hr><h2 id="二、-为什么-Raft-更容易实现？"><a href="#二、-为什么-Raft-更容易实现？" class="headerlink" title="二、 为什么 Raft 更容易实现？"></a>二、 为什么 Raft 更容易实现？</h2><p>这是 Raft 能够后来居上的最大原因。Raft 并不是在理论上超越了 Paxos，而是通过<strong>增加约束</strong>和<strong>分解问题</strong>，极大地降低了工程落地的复杂度。</p><h3 id="1-问题的分解（Decomposition）"><a href="#1-问题的分解（Decomposition）" class="headerlink" title="1. 问题的分解（Decomposition）"></a>1. 问题的分解（Decomposition）</h3><p>Paxos 将选举、日志复制、确认提交等逻辑混杂在一起，牵一发而动全身。<br>Raft 强制将共识问题拆解为三个独立的子模块：</p><ul><li><strong>Leader Election（选主）</strong>：先选出老大，别的什么都不干。</li><li><strong>Log Replication（日志复制）</strong>：老大负责同步数据，Follower 负责接收。</li><li><strong>Safety（安全性）</strong>：确保数据一旦提交，就永远存在。</li></ul><p>这种解耦使得开发者可以独立编写和测试每个模块。</p><h3 id="2-强-Leader-模型（Strong-Leader）"><a href="#2-强-Leader-模型（Strong-Leader）" class="headerlink" title="2. 强 Leader 模型（Strong Leader）"></a>2. 强 Leader 模型（Strong Leader）</h3><p>这是 Raft 简化的杀手锏。</p><ul><li><strong>Paxos</strong>：允许所有节点同时发起提案（虽然 Multi-Paxos 也会优化为单 Leader，但协议本身允许并发）。这导致需要处理极其复杂的“冲突解决”和“日志乱序”问题。</li><li><strong>Raft</strong>：是<strong>独裁</strong>的。日志流向只能是 <code>Leader -&gt; Follower</code>。Follower 绝对不会修改 Leader 的日志，Leader 也永远不会覆盖自己的日志。这种单向数据流消除了大量边缘状态。</li></ul><h3 id="3-强制日志连续（Log-Continuity）"><a href="#3-强制日志连续（Log-Continuity）" class="headerlink" title="3. 强制日志连续（Log Continuity）"></a>3. 强制日志连续（Log Continuity）</h3><ul><li><strong>Paxos</strong>：允许日志有“空洞”。比如节点 A 确认了第 1、2、5 号日志，缺了 3 和 4。Paxos 允许这种情况存在，后续再通过复杂的逻辑把空洞补齐。</li><li><strong>Raft</strong>：<strong>不允许空洞</strong>。Follower 必须按顺序接收日志。如果 Follower 缺了第 4 号日志，Leader 绝不会发第 5 号给它，而是会强制回退（利用 <code>PrevLogIndex</code> 检查），直到找到一致的点，然后覆盖同步。这让状态机的实现变得极其简单——按顺序执行即可。</li></ul><h3 id="4-选主限制：拥有最新日志者才能当选"><a href="#4-选主限制：拥有最新日志者才能当选" class="headerlink" title="4. 选主限制：拥有最新日志者才能当选"></a>4. 选主限制：拥有最新日志者才能当选</h3><p>在 Paxos 中，任何节点都可能成为 Leader，哪怕它的数据很旧。上位后，它需要先学习历史数据，补全自己的知识，然后才能开始工作。<br>Raft 规定：<strong>只有拥有所有已提交日志的节点，才有资格当选 Leader。</strong> 这意味着新 Leader 上任的第一刻起，它就不需要去问别人“我是不是缺数据了”，直接接受新写入即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Raft 之所以容易实现，是因为它剥夺了节点的自由：</p><p>不准乱序提交（消灭了复杂的并发合并逻辑）。</p><p>不准 Follower 质疑 Leader（消灭了双向同步逻辑）。</p><p>不准旧节点当 Leader（消灭了 Leader 上位后的补数据逻辑）。</p><hr><h2 id="三、-Paxos-与-Raft-的优缺点权衡"><a href="#三、-Paxos-与-Raft-的优缺点权衡" class="headerlink" title="三、 Paxos 与 Raft 的优缺点权衡"></a>三、 Paxos 与 Raft 的优缺点权衡</h2><p>既然 Raft 这么好，Paxos 是不是一无是处？并非如此。两者在不同的维度各有千秋。</p><h3 id="1-Paxos-的优点（对比-Raft）"><a href="#1-Paxos-的优点（对比-Raft）" class="headerlink" title="1. Paxos 的优点（对比 Raft）"></a>1. Paxos 的优点（对比 Raft）</h3><ul><li><strong>理论的极致与通用性</strong>：Paxos 是共识算法的基石。Google 的 Chubby、Spanner 底层依然是 Paxos 的变种。事实上，Raft 可以被看作是 Paxos 的一个特定约束下的子集。</li><li><strong>更高的写入并发潜力</strong>：由于 Paxos 允许日志乱序确认（Out-of-Order Commit），在不依赖强顺序的场景下（或者使用 EPaxos 等变种），它的理论吞吐量可以高于 Raft。Raft 必须一个接一个顺序提交，存在队头阻塞（Head-of-Line Blocking）风险。</li><li><strong>无 Leader 的生存能力</strong>：Basic Paxos 不需要 Leader，在网络极其不稳定、无法维持稳定 Leader 的极端环境下，Basic Paxos 依然能工作，而 Raft 会陷入反复选主的死循环（不可用）。</li></ul><h3 id="2-Raft-的优点（对比-Paxos）"><a href="#2-Raft-的优点（对比-Paxos）" class="headerlink" title="2. Raft 的优点（对比 Paxos）"></a>2. Raft 的优点（对比 Paxos）</h3><ul><li><strong>可理解性（Understandability）</strong>：这是 Raft 的核心竞争力。一个普通的工程师阅读 Raft 论文两遍可能就能写出原型；而阅读 Paxos 论文十遍可能还是一头雾水。</li><li><strong>工程细节完备</strong>：Paxos 论文只讲了如何达成共识，没讲如何增删节点、如何压缩日志（Snapshot）。Raft 对这些工程痛点都给出了标准解决方案（如 Joint Consensus 成员变更算法）。</li><li><strong>调试与排错</strong>：由于 Raft 的状态转换路径非常清晰（且有限），当系统出现 Bug 时，更容易复现和定位。</li></ul><hr><h2 id="四、-总结：如何选择？"><a href="#四、-总结：如何选择？" class="headerlink" title="四、 总结：如何选择？"></a>四、 总结：如何选择？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Paxos (Multi-Paxos)</th><th style="text-align:left">Raft</th></tr></thead><tbody><tr><td style="text-align:left"><strong>设计目标</strong></td><td style="text-align:left">理论证明</td><td style="text-align:left">工程实现、可理解性</td></tr><tr><td style="text-align:left"><strong>日志结构</strong></td><td style="text-align:left">允许空洞，并发确认</td><td style="text-align:left">必须连续，顺序确认</td></tr><tr><td style="text-align:left"><strong>数据流向</strong></td><td style="text-align:left">多点可能（复杂）</td><td style="text-align:left">Leader 单向流向 Follower</td></tr><tr><td style="text-align:left"><strong>实现难度</strong></td><td style="text-align:left">极高（容易写出 Bug）</td><td style="text-align:left">中等（有标准参考）</td></tr><tr><td style="text-align:left"><strong>工业界现状</strong></td><td style="text-align:left">Google Spanner, Zookeeper (ZAB 类似)</td><td style="text-align:left">Etcd, Consul, TiKV, CockroachDB</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（五） 前缀树</title>
      <link href="/posts/38c6bd07.html"/>
      <url>/posts/38c6bd07.html</url>
      
        <content type="html"><![CDATA[<h2 id="前缀树结构"><a href="#前缀树结构" class="headerlink" title="前缀树结构"></a>前缀树结构</h2><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p><p>前缀树的基本操作</p><p>插入字符串：从根节点开始，依次插入字符串的每个字符。如果路径不存在，则创建新节点。最后一个节点标记为字符串的结束。</p><p>删除字符串：从根节点开始，依次减少路径上节点的计数。如果某节点的计数为零，则删除该节点。</p><p>查询字符串出现次数：沿路径遍历字符串，若路径完整且结束节点存在，则返回字符串的计数。</p><p>查询前缀数量：沿路径遍历前缀，若路径完整，则返回最后节点的通过计数。</p><h3 id="节点的结构"><a href="#节点的结构" class="headerlink" title="节点的结构"></a>节点的结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> pass;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"><span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">pass = <span class="number">0</span>;</span><br><span class="line">end = <span class="number">0</span>;</span><br><span class="line">nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">node.pass++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line">node.nexts[path] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">node.pass++;</span><br><span class="line">&#125;</span><br><span class="line">node.end++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询字符串出现次数"><a href="#查询字符串出现次数" class="headerlink" title="查询字符串出现次数"></a>查询字符串出现次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 查询前缀树里，word单词出现了几次</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询前缀数量"><a href="#查询前缀数量" class="headerlink" title="查询前缀数量"></a>查询前缀数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 查询前缀树里，有多少单词以pre做前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String pre)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 如果之前word插入过前缀树，那么此时删掉一次</span></span><br><span class="line"><span class="comment">// 如果之前word没有插入过前缀树，那么什么也不做</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (countWordsEqualTo(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">node.pass--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) &#123;</span><br><span class="line">node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line">node.end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用静态数组实现前缀树"><a href="#使用静态数组实现前缀树" class="headerlink" title="使用静态数组实现前缀树"></a>使用静态数组实现前缀树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 如果将来增加了数据量，就改大这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">150001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">pass[cur]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">pass[cur]++;</span><br><span class="line">&#125;</span><br><span class="line">end[cur]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String pre)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pass[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (search(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 下面这一行代码，讲课的时候没加</span></span><br><span class="line"><span class="comment">// 本题不会用到pass[1]的信息，所以加不加都可以，不过正确的写法是加上</span></span><br><span class="line">pass[cur]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (--pass[tree[cur][path]] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line">end[cur]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">end[i] = <span class="number">0</span>;</span><br><span class="line">pass[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="查询数组中两个数的异或最大值"><a href="#查询数组中两个数的异或最大值" class="headerlink" title="查询数组中两个数的异或最大值"></a>查询数组中两个数的异或最大值</h3><p>思路：我们使用每一个数，根据他的每一位去构建一个前缀树。然后依次遍历每一个数，从最高位开始遍历，我希望找到跟我不一样的位，于是我在前缀树里面查找。如果存在那么把这个位置变成1加入答案，如果不存在那么把这个位置变成0加入答案。然后跳到下一个节点树去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 前缀树的做法</span></span><br><span class="line"><span class="comment">// 好想</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaximumXOR1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">build(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">ans = Math.max(ans, maxXor(num));</span><br><span class="line">&#125;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备这么多静态空间就够了，实验出来的</span></span><br><span class="line"><span class="comment">// 如果测试数据升级了规模，就改大这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">3000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀树目前使用了多少空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字只需要从哪一位开始考虑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 找个最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">max = Math.max(num, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算数组最大值的二进制状态，有多少个前缀的0</span></span><br><span class="line"><span class="comment">// 可以忽略这些前置的0，从left位开始考虑</span></span><br><span class="line">high = <span class="number">31</span> - Integer.numberOfLeadingZeros(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">insert(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high, path; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxXor</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="comment">// 最终异或的结果(尽量大)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 前缀树目前来到的节点编号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high, status, want; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// status : num第i位的状态</span></span><br><span class="line">status = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// want : num第i位希望遇到的状态</span></span><br><span class="line">want = status ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][want] == <span class="number">0</span>) &#123; <span class="comment">// 询问前缀树，能不能达成</span></span><br><span class="line"><span class="comment">// 不能达成</span></span><br><span class="line">want ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// want变成真的往下走的路</span></span><br><span class="line">ans |= (status ^ want) &lt;&lt; i;</span><br><span class="line">cur = tree[cur][want];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">tree[i][<span class="number">0</span>] = tree[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在二维网格中，搜索单词组返回能找到的单词组"><a href="#在二维网格中，搜索单词组返回能找到的单词组" class="headerlink" title="在二维网格中，搜索单词组返回能找到的单词组"></a>在二维网格中，搜索单词组返回能找到的单词组</h3><p>思路：回溯+前缀树减枝</p><p>关键点：1.把走过的格子，标为0，这样不会重复走，但是需要恢复现场</p><p>2.利用前缀树减枝，首先利用单词组构建出前缀树。每次递归的时候根据前缀树有没有路径来判断这个格子里面的单词能不能要。除了路径还要判断这条路径下还有没有剩余的未探索单词（利用pass数组）。</p><p>3.巧用pass跟end数组。pass[i] 表示当前节点剩余还未收集的单词，end[i] 表示在当前节点完结的单词，可以直接加入ans。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">build(words);</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">dfs(board, i, j, <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// board : 二维网格</span></span><br><span class="line"><span class="comment">// i,j : 此时来到的格子位置，i行、j列</span></span><br><span class="line"><span class="comment">// t : 前缀树的编号</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; ans : 收集到了哪些字符串，都放入ans</span></span><br><span class="line"><span class="comment">// 返回值 : 收集到了几个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> t, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line"><span class="comment">// 越界 或者 走了回头路，直接返回0</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || board[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界 且 不是回头路</span></span><br><span class="line"><span class="comment">// 用tmp记录当前字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line"><span class="comment">// 路的编号</span></span><br><span class="line"><span class="comment">// a -&gt; 0</span></span><br><span class="line"><span class="comment">// b -&gt; 1</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// z -&gt; 25</span></span><br><span class="line"><span class="type">int</span> <span class="variable">road</span> <span class="operator">=</span> tmp - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">t = tree[t][road];</span><br><span class="line">       <span class="comment">// 不存在该路径，或者该路径下的单词已经被你找出来完了  其实应该写成 t==0 || pass[t]==0 但是初始化的时候pass就是从1开始，所以这里可以不用判断</span></span><br><span class="line"><span class="keyword">if</span> (pass[t] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i，j位置有必要来</span></span><br><span class="line"><span class="comment">// fix ：从当前i，j位置出发，一共收集到了几个字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">fix</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end[t] != <span class="literal">null</span>) &#123;</span><br><span class="line">fix++;</span><br><span class="line">ans.add(end[t]);</span><br><span class="line">end[t] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把i，j位置的字符，改成0，后续的过程，是不可以再来到i，j位置的！</span></span><br><span class="line">board[i][j] = <span class="number">0</span>;</span><br><span class="line">fix += dfs(board, i - <span class="number">1</span>, j, t, ans);</span><br><span class="line">fix += dfs(board, i + <span class="number">1</span>, j, t, ans);</span><br><span class="line">fix += dfs(board, i, j - <span class="number">1</span>, t, ans);</span><br><span class="line">fix += dfs(board, i, j + <span class="number">1</span>, t, ans);</span><br><span class="line">       <span class="comment">// 减去已经找到的单词数量</span></span><br><span class="line">pass[t] -= fix;</span><br><span class="line">       <span class="comment">// 恢复现场</span></span><br><span class="line">board[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> fix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] end = <span class="keyword">new</span> <span class="title class_">String</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">pass[cur]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">pass[cur]++;</span><br><span class="line">&#125;</span><br><span class="line">end[cur] = word;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">pass[i] = <span class="number">0</span>;</span><br><span class="line">end[i] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP中的一致性</title>
      <link href="/posts/5bb35c22.html"/>
      <url>/posts/5bb35c22.html</url>
      
        <content type="html"><![CDATA[<p>关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）</p><h2 id="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"><a href="#首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？" class="headerlink" title="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"></a>首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？</h2><p>这是一个非常经典且容易混淆的问题，因为“一致性”（Consistency）这个词在计算机科学的不同领域里，虽然名字一样，但含义却大相径庭。</p><p>这三个概念分别对应了：<strong>单机数据库理论（ACID）</strong>、<strong>分布式系统理论（CAP）</strong> 和 <strong>工程实践（分布式事务）</strong>。</p><p>我们可以用一句话概括它们的区别：</p><ul><li><strong>ACID 的一致性</strong>：关乎<strong>数据的“正确性”</strong>（符合业务约束）。</li><li><strong>CAP 的一致性</strong>：关乎<strong>数据的“新旧”</strong>（多副本同步）。</li><li><strong>分布式事务的一致性</strong>：关乎<strong>跨系统的“协调”</strong>（让多个独立系统的数据最终对齐）。</li></ul><hr><h3 id="1-事务的一致性-ACID-中的-C"><a href="#1-事务的一致性-ACID-中的-C" class="headerlink" title="1. 事务的一致性 (ACID 中的 C)"></a>1. 事务的一致性 (ACID 中的 C)</h3><p>这里的背景通常指<strong>单机数据库</strong>（如 MySQL）的本地事务。</p><ul><li><strong>定义</strong>：指事务执行前后，数据库必须从一个<strong>合法状态</strong>变换到另一个<strong>合法状态</strong>。</li><li><strong>核心关注点</strong>：<strong>业务逻辑与约束 (Business Logic &amp; Constraints)</strong>。</li><li><strong>详细解释</strong>：<br>“合法状态”是指数据必须符合预定义的规则。这些规则包括：<ul><li><strong>数据库约束</strong>：主键唯一、外键约束、字段类型、Check约束（例如余额不能小于0）。</li><li><strong>业务逻辑</strong>：例如 A 转账给 B 100元，那么 A 减去 100，B 加上 100，总金额必须不变。如果代码写错了，A 减了 100，B 却只加了 50，虽然数据库没崩溃（原子性满足），但<strong>一致性</strong>被破坏了，因为数据不再符合“总额守恒”的业务规则。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证数据不违背现实世界的业务规则。</strong></li></ul><hr><h3 id="2-分布式系统的一致性-CAP-中的-C"><a href="#2-分布式系统的一致性-CAP-中的-C" class="headerlink" title="2. 分布式系统的一致性 (CAP 中的 C)"></a>2. 分布式系统的一致性 (CAP 中的 C)</h3><p>这里的背景是指<strong>多副本的数据存储系统</strong>（如 Redis Cluster, Cassandra, ZooKeeper, HDFS）。</p><ul><li><strong>定义</strong>：在 CAP 理论中，C 代表 <strong>Linearizability (线性一致性)</strong> 或 <strong>Strong Consistency (强一致性)</strong>。意思是：<strong>所有的节点在同一时间看到的数据是完全相同的</strong>。</li><li><strong>核心关注点</strong>：<strong>多节点间的数据同步 (Synchronization &amp; Timing)</strong>。</li><li><strong>详细解释</strong>：<br>在分布式系统中，为了容灾，数据通常会有多个副本（Replica）。<ul><li>当你向节点 A 写入一个新值 <code>x = 1</code>。</li><li>紧接着向节点 B 读取 <code>x</code>。</li><li><strong>一致性</strong>要求：你必须读到 <code>1</code>。如果你读到了旧值 <code>0</code>，那么这个系统就不满足 CAP 中的 C。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证你读到的永远是最新写入的数据（就像只有一个副本一样）。</strong></li></ul><hr><h3 id="3-分布式事务中的一致性"><a href="#3-分布式事务中的一致性" class="headerlink" title="3. 分布式事务中的一致性"></a>3. 分布式事务中的一致性</h3><p>这里的背景是指<strong>微服务架构</strong>或<strong>跨数据库</strong>的操作（如 订单服务 + 库存服务 + 支付服务）。</p><ul><li><strong>定义</strong>：指在跨越多个独立服务或数据库的操作中，确保所有相关的数据最终能够达成一种<strong>逻辑上的对齐</strong>。它可以理解为事务的原子性，<strong>要么全部成功，要么全部失败</strong>。</li><li><strong>核心关注点</strong>：<strong>跨系统的原子性与最终状态 (Global Outcome)</strong>。</li><li><strong>详细解释</strong>：<br>由于分布式系统很难同时满足 CAP（通常为了可用性 A，必须牺牲强一致性 C），所以在分布式事务中，我们通常讨论两种一致性：<ol><li><strong>强一致性（刚性事务）</strong>：如 XA 协议、2PC（两阶段提交）。要求所有服务同时提交，立刻看到结果。这很像 ACID，但在分布式环境下性能极差。</li><li><strong>最终一致性（柔性事务，BASE理论）</strong>：如 TCC、Saga、消息队列。允许中间有一段时间数据是不一致的（例如订单已创建，但库存还没扣减完），但保证经过一段时间后，所有数据都会变对。</li></ol></li><li><strong>一句话总结</strong>：<strong>它保证多个独立系统的数据，虽然可能有延迟，但最终会“账目”对齐，不会出现“订单成功了但没扣库存”的烂账。</strong></li></ul><hr><h3 id="三者对比总结表"><a href="#三者对比总结表" class="headerlink" title="三者对比总结表"></a>三者对比总结表</h3><p>为了更清晰地理解，我们可以通过下表对比：</p><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">ACID 的一致性 (事务)</th><th style="text-align:left">CAP 的一致性 (分布式系统)</th><th style="text-align:left">分布式事务的一致性</th></tr></thead><tbody><tr><td style="text-align:left"><strong>侧重点</strong></td><td style="text-align:left"><strong>数据的正确性</strong> (逻辑约束)</td><td style="text-align:left"><strong>数据的可见性</strong> (时间同步)</td><td style="text-align:left"><strong>全局操作的协同</strong> (多方对齐)</td></tr><tr><td style="text-align:left"><strong>场景</strong></td><td style="text-align:left">单机数据库 (Oracle, MySQL)</td><td style="text-align:left">分布式存储 (Redis, ZK, NoSQL)</td><td style="text-align:left">微服务、跨库业务</td></tr><tr><td style="text-align:left"><strong>反例</strong></td><td style="text-align:left">转账后总金额变少了 (违反守恒)</td><td style="text-align:left">刚写完主库，读从库还是旧数据</td><td style="text-align:left">订单库显示“已支付”，库存库显示“未扣减”</td></tr><tr><td style="text-align:left"><strong>依赖对象</strong></td><td style="text-align:left">依赖数据库引擎的约束检查</td><td style="text-align:left">依赖共识算法 (Raft, Paxos) 或同步复制</td><td style="text-align:left">依赖协调器、MQ 或 补偿代码</td></tr><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left">“这笔数据合乎逻辑吗？”</td><td style="text-align:left">“我现在读到的是最新的吗？”</td><td style="text-align:left">“这几个系统的数据最后能对上吗？”</td></tr></tbody></table></div><h3 id="举个通俗的例子"><a href="#举个通俗的例子" class="headerlink" title="举个通俗的例子"></a>举个通俗的例子</h3><p>假设你要去买一杯奶茶：</p><ol><li><p><strong>ACID 一致性</strong>：你付了 20 元，店员必须给你一杯 20 元的奶茶。如果店员只给你一杯 10 元的水，或者没收钱就给你奶茶，这就违背了<strong>交易规则</strong>（ACID 破坏）。</p></li><li><p><strong>CAP 一致性</strong>：这家奶茶店有 3 个店员（副本）。店长（主节点）刚刚更新了菜单，把“珍珠奶茶”涨价到 25 元。你问店员 A，他说 25 元；你立刻问店员 B，如果店员 B 还说 20 元，那就是<strong>同步</strong>没做好（CAP 的 C 破坏）。</p></li><li><p><strong>分布式事务一致性</strong>：你在手机 App 上点单。</p><ul><li>你的支付宝扣了钱（支付服务）。</li><li>奶茶店的打印机出了小票（订单服务）。</li><li>如果支付宝扣了钱，但奶茶店没收到单子；或者奶茶店出了单子，支付宝没扣钱，这就是<strong>跨系统</strong>的不一致。分布式事务就是要保证：要么没扣钱也没单子，要么扣了钱也有单子（哪怕中间有几秒延迟）。</li></ul></li></ol><h2 id="线性一致性跟顺序一致性"><a href="#线性一致性跟顺序一致性" class="headerlink" title="线性一致性跟顺序一致性"></a>线性一致性跟顺序一致性</h2><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p><p>•    条件 I：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</p><p>•    条件 II：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>线性一致性的定义，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件 I 和条件 II 之外，还要同时满足一个条件：</p><p>•    条件 III：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>•    它们都试图让系统“表现得像只有一个副本”一样。</p><p>•    它们都保证了程序执行顺序不会被打乱。体现在条件 II 对于进程内各个操作的排序保持上。</p><p>•    线性一致性考虑了时间先后顺序，而顺序一致性没有。</p><p>•    满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</p><p>•    线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</p><p>•    在顺序一致性中，我们有可能读到旧版本的数据。</p><p>具体可以参考这篇博客 <a href="https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA">https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA</a></p><h2 id="最终一致性又是什么？"><a href="#最终一致性又是什么？" class="headerlink" title="最终一致性又是什么？"></a>最终一致性又是什么？</h2><p>其实最终一致性就不满足CAP理论的C,而是对于AP系统的扩充。</p><p><strong>最终一致性（Eventual Consistency）是 CAP 理论中选择了 AP（可用性 + 分区容错性）策略后，为了弥补缺失的 C（强一致性）而不得不采用的一种“妥协”方案。</strong></p><p>或者更简单点说：<strong>最终一致性是 AP 系统的核心特征。</strong></p><p>我们可以从以下几个层面来剖析这段关系：</p><h3 id="1-CAP-的必然性与“二选一”"><a href="#1-CAP-的必然性与“二选一”" class="headerlink" title="1. CAP 的必然性与“二选一”"></a>1. CAP 的必然性与“二选一”</h3><p>CAP 理论告诉我们，在分布式系统中，<strong>P（分区容错性）是不可避免的</strong>（网线总会断，节点总会挂）。所以我们只能在 C（强一致性/线性一致性）和 A（可用性）之间做选择：</p><ul><li><strong>选择 CP（放弃 A）</strong>：为了保证数据绝对一致，当网络出问题时，我宁愿报错拒绝服务，也不让你读到旧数据。<ul><li><em>结果</em>：这是<strong>强一致性</strong>系统（如 Zookeeper, HBase）。</li></ul></li><li><strong>选择 AP（放弃 C）</strong>：为了保证服务永远可用，哪怕网络出问题了，我也让你读，虽然读到的可能是旧数据。<ul><li><em>结果</em>：这就是<strong>最终一致性</strong>发挥作用的地方（如 DNS, Eureka, Cassandra）。</li></ul></li></ul><h3 id="2-最终一致性在-CAP-图谱中的位置"><a href="#2-最终一致性在-CAP-图谱中的位置" class="headerlink" title="2. 最终一致性在 CAP 图谱中的位置"></a>2. 最终一致性在 CAP 图谱中的位置</h3><p>如果把 CAP 画成一个三角形：</p><ul><li><strong>CAP 中的 C (Consistency)</strong>：指的是<strong>线性一致性</strong>（强一致性）。如果你追求 CAP 的 C，你就必须保证写完立刻能读到。</li><li><strong>最终一致性</strong>：它是<strong>弱一致性</strong>的一种特例。<strong>它不属于 CAP 的 C</strong>。相反，它是当我们<strong>抛弃了 CAP 的 C</strong> 之后，退而求其次追求的目标。</li></ul><blockquote><p><strong>关系公式</strong>：<br><strong>CAP (AP 模式)</strong> = <strong>Availability</strong> (高可用) + <strong>Partition Tolerance</strong> (分区容错) + <strong>Eventual Consistency</strong> (最终一致性)</p></blockquote><h3 id="3-为什么-AP-系统必然导致最终一致性？"><a href="#3-为什么-AP-系统必然导致最终一致性？" class="headerlink" title="3. 为什么 AP 系统必然导致最终一致性？"></a>3. 为什么 AP 系统必然导致最终一致性？</h3><p>让我们推演一下：</p><ol><li><strong>前提 (P)</strong>：系统有两个节点 Node A 和 Node B，它们之间的网络断了。</li><li><strong>抉择 (A)</strong>：我们选择了高可用（Availability），所以当用户向 Node A 写入 <code>x=1</code> 时，Node A 必须接受并返回成功，不能报错。</li><li><strong>后果</strong>：此时，Node A 的数据是 <code>x=1</code>，而 Node B 因为网络断了，数据还是 <code>x=0</code>。</li><li><strong>现状</strong>：此时系统已经<strong>不一致</strong>了（违反了 CAP 的 C）。</li><li><strong>补救 (最终一致性)</strong>：我们不能让 Node B 永远是 <code>0</code>。系统承诺：当网络恢复后，Node A 会后台把 <code>x=1</code> 同步给 Node B。经过一段时间（不确定多久），Node B 最终也会变成 <code>1</code>。</li></ol><p><strong>结论</strong>：因为选择了 A（允许在断网时继续写），必然导致数据暂时不一致。而“最终一致性”就是对这种暂时不一致的<strong>容忍</strong>和对未来的<strong>承诺</strong>。</p><h3 id="4-延伸：BASE-理论"><a href="#4-延伸：BASE-理论" class="headerlink" title="4. 延伸：BASE 理论"></a>4. 延伸：BASE 理论</h3><p>讲到最终一致性与 CAP 的关系，就不得不提 <strong>BASE 理论</strong>。它是对 CAP 中 AP 策略的工程化延伸。：</p><ul><li><strong>BA (Basically Available)</strong>：基本可用（允许响应时间慢一点，或者部分降级）。</li><li><strong>S (Soft state)</strong>：软状态（允许系统存在中间状态，即允许数据同步有延迟）。</li><li><strong>E (Eventual consistency)</strong>：最终一致性（数据最终会变对）。</li></ul><h3 id="5-总结表"><a href="#5-总结表" class="headerlink" title="5. 总结表"></a>5. 总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">CAP 的 C (强一致性)</th><th style="text-align:left">最终一致性 (弱一致性的一种)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CAP 选择</strong></td><td style="text-align:left"><strong>CP</strong> (放弃可用性)</td><td style="text-align:left"><strong>AP</strong> (放弃强一致性)</td></tr><tr><td style="text-align:left"><strong>核心逻辑</strong></td><td style="text-align:left">写操作完成后，所有节点<strong>立刻</strong>可见。</td><td style="text-align:left">写操作完成后，数据<strong>异步</strong>复制，经过一段时间才可见。</td></tr><tr><td style="text-align:left"><strong>用户体验</strong></td><td style="text-align:left">“要么读到最新的，要么系统告诉我报错/超时。”</td><td style="text-align:left">“我可能读到旧的，但系统保证随时能用。”</td></tr><tr><td style="text-align:left"><strong>典型场景</strong></td><td style="text-align:left">银行余额、库存扣减、分布式锁 (Etcd/ZK)</td><td style="text-align:left">社交网络点赞、DNS解析、电商商品浏览量</td></tr><tr><td style="text-align:left"><strong>关系</strong></td><td style="text-align:left"><strong>它是 CAP 定义的一致性标准</strong></td><td style="text-align:left"><strong>它是放弃 CAP 的 C 之后的替代方案</strong></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（四）递归</title>
      <link href="/posts/38e6282b.html"/>
      <url>/posts/38e6282b.html</url>
      
        <content type="html"><![CDATA[<h1 id="递归相关的题目"><a href="#递归相关的题目" class="headerlink" title="递归相关的题目"></a>递归相关的题目</h1><h2 id="找一个字符串的不重复的子序列"><a href="#找一个字符串的不重复的子序列" class="headerlink" title="找一个字符串的不重复的子序列"></a>找一个字符串的不重复的子序列</h2><p>递归的思路：每次按要这个位置的字符和不要这个位置的字符两种情况去递归，当i = s.length()时，保存当前的子序列。用hashSet去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String[] generatePermutation(String str) &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">f2(s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">char</span>[s.length], <span class="number">0</span>, set);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> set.size();</span><br><span class="line">String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[m];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String cur : set) &#123;</span><br><span class="line">ans[i++] = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// i是当前要处理的字符的索引,path是当前已经保存的路径，size是path的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">char</span>[] path, <span class="type">int</span> size, HashSet&lt;String&gt; set)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">set.add(String.valueOf(path, <span class="number">0</span>, size));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path[size] = s[i];</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size + <span class="number">1</span>, set);</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size, set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找一个数组中的所有子数组，顺序可以任意"><a href="#找一个数组中的所有子数组，顺序可以任意" class="headerlink" title="找一个数组中的所有子数组，顺序可以任意"></a>找一个数组中的所有子数组，顺序可以任意</h2><p>思路：先将数组排序，然后每次对同一个数讨论，要0个，要1个… 还需要知道对于这个数来说下一个跟自己不同的数的位置，然后调用递归从下个不同的数开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    findSubsetsWithDup(<span class="number">0</span>,nums,<span class="number">0</span>,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findSubsetsWithDup</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span> size,<span class="type">int</span>[] path,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">            temp.add(path[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找出下一个跟自己不同的数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; nums[j] == nums[i])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要0个</span></span><br><span class="line">        findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        <span class="comment">// 依次要多个</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++)&#123;</span><br><span class="line">            path[size++] = nums[i];</span><br><span class="line">            findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。"><a href="#给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。" class="headerlink" title="给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。"></a>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</h2><p>思路： 每次拿一个数跟当前下标的第一个数交换，然后递归调用将下标+1，递归完成后再交换回来。终止条件就算下标==nums.length</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    findPermute(nums,<span class="number">0</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPermute</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            temp.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            findPermute(nums,i+<span class="number">1</span>,ans);</span><br><span class="line">            <span class="comment">// 交换回来</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：如果有重复数字，则需要去重</p><p>思路： 每次递归的时候维护一个set这个set记录哪些数来到过我这个下标，如果发现一个数已经来到过，则不进行交换，也不递归跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">cur.add(num);</span><br><span class="line">&#125;</span><br><span class="line">ans.add(cur);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="comment">// nums[j]没有来到过i位置，才会去尝试</span></span><br><span class="line"><span class="keyword">if</span> (!set.contains(nums[j])) &#123;</span><br><span class="line">set.add(nums[j]);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">f(nums, i + <span class="number">1</span>, ans);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>思路：维护一个路径数组path[],path的第几个数的值表示第几行的皇后放在第几列，每次循环每一行的列去判断是否合法，如果合法则递归调用下一行，并且size++.终止条件是size == n 即找到合法的一个解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    findSolveNQueens(<span class="number">0</span>,n,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findSolveNQueens</span><span class="params">(<span class="type">int</span> size,<span class="type">int</span> n,<span class="type">int</span>[] path,List&lt;List&lt;String&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(size == n)&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span>path[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span> ;j&lt;pos;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> pos+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次尝试</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 尝试第i列</span></span><br><span class="line">            <span class="keyword">if</span>(isvalid(i,path,size))&#123;</span><br><span class="line">                <span class="comment">// 合法</span></span><br><span class="line">                path[size] = i;</span><br><span class="line">                findSolveNQueens(size+<span class="number">1</span>,n,path,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isvalid</span> <span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] path,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k&lt; size; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==path[k])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Math.abs(size-k) == Math.abs(i-path[k]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拓展： 利用位运算去判断当前位置是否合法。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-21%20162737.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalNQueens2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n = 5</span></span><br><span class="line"><span class="comment">// 1 &lt;&lt; 5 = 0...100000 - 1</span></span><br><span class="line"><span class="comment">// limit  = 0...011111; </span></span><br><span class="line"><span class="comment">// n = 7</span></span><br><span class="line"><span class="comment">// limit  = 0...01111111; </span></span><br><span class="line"><span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> f2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// limit : 当前是几皇后问题</span></span><br><span class="line"><span class="comment">// 之前皇后的列影响：col</span></span><br><span class="line"><span class="comment">// 之前皇后的右上 -&gt; 左下对角线影响：left</span></span><br><span class="line"><span class="comment">// 之前皇后的左上 -&gt; 右下对角线影响：right</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> col, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (col == limit) &#123;</span><br><span class="line"><span class="comment">// 所有皇后放完了！</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总限制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ban</span> <span class="operator">=</span> col | left | right;</span><br><span class="line"><span class="comment">// ~ban : 1可放皇后，0不能放</span></span><br><span class="line"><span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> limit &amp; (~ban);</span><br><span class="line"><span class="comment">// 放置皇后的尝试！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 一共有多少有效的方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (candidate != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 提取出最右侧的1</span></span><br><span class="line"><span class="comment">// 0 0 1 1 1 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 1 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 1 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line">place = candidate &amp; (-candidate);</span><br><span class="line">candidate ^= place;</span><br><span class="line">ans += f2(limit, col | place, (left | place) &gt;&gt; <span class="number">1</span>, (right | place) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结（四）二叉树</title>
      <link href="/posts/44956a51.html"/>
      <url>/posts/44956a51.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树相关的题目"><a href="#二叉树相关的题目" class="headerlink" title="二叉树相关的题目"></a>二叉树相关的题目</h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>思路：利用队列进行层序遍历，类似与BFS。</p><p>这里举一个锯齿形层序遍历的例子（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">l = r = <span class="number">0</span>;</span><br><span class="line">queue[r++] = root;</span><br><span class="line"><span class="comment">// false 代表从左往右</span></span><br><span class="line"><span class="comment">// true 代表从右往左</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// reverse == false, 左 -&gt; 右， l....r-1, 收集size个</span></span><br><span class="line"><span class="comment">// reverse == true,  右 -&gt; 左， r-1....l, 收集size个</span></span><br><span class="line"><span class="comment">// 左 -&gt; 右, i = i + 1</span></span><br><span class="line"><span class="comment">// 右 -&gt; 左, i = i - 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reverse ? r - <span class="number">1</span> : l, j = reverse ? -<span class="number">1</span> : <span class="number">1</span>, k = <span class="number">0</span>; k &lt; size; i += j, k++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[i];</span><br><span class="line">list.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line"><span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">queue[r++] = cur.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">queue[r++] = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.add(list);</span><br><span class="line">reverse = !reverse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h2><p>思路：利用队列进行层序遍历，并同步记录当前层节点的索引，将索引保存在数组中，最后计算每一层开始与结束的索引的差值，并返回最大值。想象为完全二叉树，对于节点i，其左子节点为2i，右子节点为2i+1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">3001</span>];</span><br><span class="line">    Long[] idQueue = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">3001</span>];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[r] = root;</span><br><span class="line">    idQueue[r++] = <span class="number">1L</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//每次遍历完成后，l 到 r-1，就是当前层所有节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r-l;</span><br><span class="line">        ans = Math.max(ans,(<span class="type">int</span>)(idQueue[r-<span class="number">1</span>]-idQueue[l]+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue[l];</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idQueue[l++];</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue[r] = node.left;</span><br><span class="line">                idQueue[r++] = id*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue[r] =node.right;</span><br><span class="line">                idQueue[r++] = id*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大深度跟最小深度"><a href="#最大深度跟最小深度" class="headerlink" title="最大深度跟最小深度"></a>最大深度跟最小深度</h2><p>思路：利用递归进行求解，对于每个节点，求左右子树的最大深度，并返回较大的值。（最小深度同理，但要处理根节点为空的情况，因为为空子问题返回0高度，但题目说的最小深度必须到叶节点，所以会干扰最小深度的计算，所以必须子节点不为空才能进行递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right ==<span class="literal">null</span> &amp;&amp; root.left ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lMin</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rMin</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lMin = minDepth(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        rMin = minDepth(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(lMin,rMin)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据中序遍历和前序遍历构建二叉树"><a href="#根据中序遍历和前序遍历构建二叉树" class="headerlink" title="根据中序遍历和前序遍历构建二叉树"></a>根据中序遍历和前序遍历构建二叉树</h2><p>思路：</p><p>确定根节点：<br>前序遍历的第一个元素一定是整个树的根节点。</p><p>划分左右子树：<br>根据根节点在中序遍历中的位置，可以将中序遍历序列划分为左子树和右子树的中序遍历序列。<br>左子树的中序遍历序列位于根节点的左边，右子树的中序遍历序列位于根节点的右边。</p><p>递归构建：<br>根据左子树和右子树的中序遍历序列长度，可以在前序遍历序列中划分出对应的左子树和右子树的前序遍历序列。<br>递归地对左右子树进行上述操作，直到遍历序列为空，返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(preorder,<span class="number">0</span>,len-<span class="number">1</span>,inorder,<span class="number">0</span>,len-<span class="number">1</span>,map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] pre ,<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span>[] in,<span class="type">int</span> l2,<span class="type">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1&gt;r1 || l2 &gt; r2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == r1)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[l1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[l1]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span>map.get(pre[l1]);</span><br><span class="line">    <span class="comment">// 划分左右子树 递归求解</span></span><br><span class="line">    head.left = build(pre,l1+<span class="number">1</span>,k-l2+l1,in,l2,k-<span class="number">1</span>,map);</span><br><span class="line">    head.right = build(pre,k-l2+l1+<span class="number">1</span>,r1,in,k+<span class="number">1</span>,r2,map);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>思路： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line"><span class="comment">// 遇到空，或者p，或者q，直接返回</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"><span class="keyword">if</span> (l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 左树也搜到，右树也搜到，返回root</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="literal">null</span> &amp;&amp; r == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 都没搜到返回空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l和r一个为空，一个不为空</span></span><br><span class="line"><span class="comment">// 返回不空的那个</span></span><br><span class="line"><span class="keyword">return</span> l != <span class="literal">null</span> ? l : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>思路：每个点必须大于左树的最大值，小于右树最小值。递归验证即可。但注意把最大值设为Long.MIN_VALUE，最小值设为Long.MAX_VALUE（为了不对结果造成干扰）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        max = Long.MIN_VALUE;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lok</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">    <span class="type">long</span> <span class="variable">lmax</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lmin</span> <span class="operator">=</span> min;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">rok</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">    <span class="type">long</span> <span class="variable">rmax</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">long</span> <span class="variable">rmin</span> <span class="operator">=</span> min;</span><br><span class="line">    max = Math.max(Math.max(lmax,rmax),root.val);</span><br><span class="line">    min = Math.min(Math.min(lmin,rmin),root.val);</span><br><span class="line">    <span class="keyword">return</span> lok &amp;&amp; rok &amp;&amp; root.val &gt; lmax &amp;&amp; root.val&lt; rmin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域事件的最佳实践</title>
      <link href="/posts/8f3b837f.html"/>
      <url>/posts/8f3b837f.html</url>
      
        <content type="html"><![CDATA[<h1 id="DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考"><a href="#DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考" class="headerlink" title="DDD 实战：关于领域事件（Domain Events）的设计抉择与工程落地思考"></a>DDD 实战：关于领域事件（Domain Events）的设计抉择与工程落地思考</h1><p>在领域驱动设计（DDD）的战术落地过程中，<strong>领域事件（Domain Event）</strong> 是连接各个子域、聚合以及限界上下文的“胶水”。它不仅解耦了复杂的业务逻辑，更是实现“最终一致性”架构的关键手段。</p><p>本文基于实际开发经验，总结领域事件的建模、生成、发布及可靠性投递的最佳实践，并探讨不同方案背后的权衡。</p><hr><h2 id="一、-什么是领域事件？"><a href="#一、-什么是领域事件？" class="headerlink" title="一、 什么是领域事件？"></a>一、 什么是领域事件？</h2><p>简单来说，领域事件是<strong>聚合内已发生的业务事实</strong>。</p><ul><li><strong>业务事实</strong>：意味着它是过去式。比如“用户已注册”、“订单已支付”。</li><li><strong>命名规范</strong>：推荐使用 <code>动词过去式</code>（如 <code>OrderPaid</code>, <code>AccountActivated</code>）。</li><li><strong>价值</strong>：<ol><li><strong>解耦</strong>：核心业务逻辑不需要知道谁在关注它。</li><li><strong>副作用处理</strong>：触发通知、大数据分析、报表生成等非核心逻辑。</li><li><strong>数据一致性</strong>：跨聚合、跨服务的状态同步。</li></ol></li></ul><hr><h2 id="二、-建模：胖消息-vs-瘦消息"><a href="#二、-建模：胖消息-vs-瘦消息" class="headerlink" title="二、 建模：胖消息 vs 瘦消息"></a>二、 建模：胖消息 vs 瘦消息</h2><p>领域事件通常被建模为<strong>不可变的值对象（Value Object）</strong>。但在设计消息体（Payload）时，我们面临一个经典抉择：</p><h3 id="1-瘦消息（Id-Only）"><a href="#1-瘦消息（Id-Only）" class="headerlink" title="1. 瘦消息（Id-Only）"></a>1. 瘦消息（Id-Only）</h3><p>消息体仅包含最基础的元数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MobileChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;entityId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eventId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uuid-001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eventTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1654156165&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>优点</strong>：消息极小，传输快。</li><li><strong>缺点</strong>：消费者（Subscriber）必须拿着 <code>entityId</code> 反查聚合根信息，导致<strong>读放大</strong>。</li></ul><h3 id="2-胖消息（Event-Enrichment-事件增强）"><a href="#2-胖消息（Event-Enrichment-事件增强）" class="headerlink" title="2. 胖消息（Event Enrichment / 事件增强）"></a>2. 胖消息（Event Enrichment / 事件增强）</h3><p>消息体包含消费者所需的业务数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MobileChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;beforeMobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13800000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;afterMobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18100000000&quot;</span> <span class="comment">// 增强字段</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>优点</strong>：消费者完全自治，无需反查，降低源端系统压力。</li><li><strong>缺点</strong>：消息体较大；可能包含消费者不应关心的敏感数据；存在数据时效性问题（如果消费者处理慢，消息里的数据可能是旧的）。</li></ul><blockquote><p><strong>💡 思考与建议</strong>：<br>在微服务架构下，为了减少跨服务调用带来的耦合与延迟，<strong>推荐适度的“事件增强”</strong>。即：包含消费者处理业务所必须的核心字段，而不是把整个聚合根都塞进去。</p></blockquote><hr><h2 id="三、-生成：如何优雅地创建事件？"><a href="#三、-生成：如何优雅地创建事件？" class="headerlink" title="三、 生成：如何优雅地创建事件？"></a>三、 生成：如何优雅地创建事件？</h2><p>在代码层面，何处创建、何处发布事件，直接影响代码的整洁度（Clean Code）。我们对比四种常见方案：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方案</th><th style="text-align:left">描述</th><th style="text-align:left">评价</th><th style="text-align:left">建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. Service层创建</strong></td><td style="text-align:left">业务执行完后，手动 <code>new Event()</code> 并发布</td><td style="text-align:left"><strong>简单粗暴</strong>。适合贫血模型，但容易导致Service层逻辑膨胀，容易遗漏。</td><td style="text-align:left">⭐️⭐️</td></tr><tr><td style="text-align:left"><strong>2. 聚合根依赖Infra</strong></td><td style="text-align:left">聚合根注入 <code>Publisher</code>，内部直接发布</td><td style="text-align:left"><strong>反模式</strong>。聚合根不应依赖基础设施，破坏了POJO的纯净性，且导致单一职责问题。</td><td style="text-align:left">🚫</td></tr><tr><td style="text-align:left"><strong>3. 聚合根返回事件</strong></td><td style="text-align:left">方法签名改为 <code>List&lt;Event&gt; doSomething()</code></td><td style="text-align:left"><strong>侵入性强</strong>。强行改变了业务方法签名，调用方处理繁琐。</td><td style="text-align:left">⭐️</td></tr><tr><td style="text-align:left"><strong>4. 聚合根暂存 + 抽取</strong></td><td style="text-align:left">聚合根内部 <code>List</code> 暂存，Repo保存时抽取</td><td style="text-align:left"><strong>最佳实践</strong>。保证了聚合根的纯净，同时利用基础设施层自动化处理发布，业务无感知。</td><td style="text-align:left">⭐️⭐️⭐️⭐️</td></tr></tbody></table></div><h3 id="推荐方案代码示例"><a href="#推荐方案代码示例" class="headerlink" title="推荐方案代码示例"></a>推荐方案代码示例</h3><p><strong>抽象聚合根基类：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAggregateRoot</span> &#123;</span><br><span class="line">    <span class="comment">// 暂存事件，不持久化到业务表</span></span><br><span class="line">    <span class="meta">@Transient</span> </span><br><span class="line">    <span class="keyword">private</span> List&lt;DomainEvent&gt; domainEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerEvent</span><span class="params">(DomainEvent event)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domainEvents.add(event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供给基础设施层调用</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;DomainEvent&gt; <span class="title function_">pollEvents</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;DomainEvent&gt; events = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.domainEvents);</span><br><span class="line">        <span class="built_in">this</span>.domainEvents.clear();</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>业务聚合根：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractAggregateRoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMobile</span><span class="params">(String newMobile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mobile = newMobile;</span><br><span class="line">        <span class="comment">// 仅仅是注册，不涉及IO操作</span></span><br><span class="line">        registerEvent(<span class="keyword">new</span> <span class="title class_">MobileChangedEvent</span>(<span class="built_in">this</span>.id, newMobile));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="四、-可靠投递：分布式事务的噩梦"><a href="#四、-可靠投递：分布式事务的噩梦" class="headerlink" title="四、 可靠投递：分布式事务的噩梦"></a>四、 可靠投递：分布式事务的噩梦</h2><p>最核心的工程难题在于：<strong>Database保存</strong> 与 <strong>MQ消息发送</strong> 是两个独立的操作。<br>如果 DB 提交了，但 MQ 挂了（或者反过来），就会导致数据不一致。</p><p>为了解决这个问题，我们必须引入<strong>本地消息表（Transactional Outbox Pattern）</strong>。</p><h3 id="1-核心机制"><a href="#1-核心机制" class="headerlink" title="1. 核心机制"></a>1. 核心机制</h3><p>利用关系型数据库的本地事务（ACID），将“业务数据保存”和“事件数据保存”放在同一个事务中提交。</p><ul><li><strong>Step 1</strong>: 开启事务。</li><li><strong>Step 2</strong>: Update 业务表。</li><li><strong>Step 3</strong>: Insert into <code>t_event</code> (状态：PENDING)。</li><li><strong>Step 4</strong>: 提交事务。</li></ul><p>此时，业务操作和事件记录要么同时成功，要么同时失败。</p><h3 id="2-发送与补偿策略"><a href="#2-发送与补偿策略" class="headerlink" title="2. 发送与补偿策略"></a>2. 发送与补偿策略</h3><p>保存到 <code>t_event</code> 后，如何发到 MQ？</p><ul><li><strong>方案 A：应用直接发 + 轮询补偿（适合中小规模）</strong><ul><li>应用在事务提交后，直接异步发送 MQ。发送成功则更新 <code>t_event</code> 为 <code>PUBLISHED</code>。</li><li>后台启动定时任务（Worker），扫描 <code>t_event</code> 中超过 1 分钟仍为 <code>PENDING</code> 的记录，进行重试。</li><li><em>缺点</em>：增加了数据库查询压力。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EventJdbcRepository eventJdbcRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span> <span class="params">(Command cmd)</span> &#123;</span><br><span class="line">        <span class="type">AggregateRoot</span> <span class="variable">root</span> <span class="operator">=</span> repository.load(bizId);</span><br><span class="line">        entity.doBusiness(cmd.getValue());</span><br><span class="line">        repository.save(root);</span><br><span class="line">        <span class="comment">// 发布领域事件</span></span><br><span class="line">        List&lt;DomainEvent&gt; domainEvents = entity.getDomainEvents();</span><br><span class="line">        publisher.publish(domainEvents);</span><br><span class="line">        <span class="comment">// 通过事件的EntityId更新EventStore中事件的状态为已发布</span></span><br><span class="line">        List&lt;String&gt; eventIds = domainEvents.stream()</span><br><span class="line">        .map(e-&gt;e.getEventId())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">     eventJdbcRepository.publishSuccess(eventIds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 1.扫描数据库超时未发布成功的领域事件</span></span><br><span class="line">    <span class="comment">// TODO 2.发布领域事件到消息中间件</span></span><br><span class="line">    <span class="comment">// TODO 3.修改数据库领域事件发布状态为已发布</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>方案 B：事务日志拖尾 / CDC（适合大规模）</strong><ul><li>应用只管写库，不发消息。</li><li>利用 <strong>Canal / Debezium</strong> 监听数据库的 Binlog。</li><li>CDC 组件解析 Binlog 中的 <code>t_event</code> 插入记录，自动投递到 MQ。</li><li><em>优点</em>：应用层完全解耦，性能极高。</li></ul></li></ul><hr><h2 id="五、-订阅：归属于哪一层？"><a href="#五、-订阅：归属于哪一层？" class="headerlink" title="五、 订阅：归属于哪一层？"></a>五、 订阅：归属于哪一层？</h2><p>在 DDD 的分层架构中，事件订阅者（Subscriber/Listener）应该放在哪里？</p><p><strong>结论：用户接口层（User Interface / Adapters Layer）。</strong></p><ul><li><strong>理由</strong>：订阅 MQ 消息本质上和 Controller 接收 HTTP 请求是一样的。它们都是外部世界的输入（Input）。</li><li><strong>流程</strong>：<ol><li>Subscriber 接收 JSON 消息。</li><li>反序列化为 DTO。</li><li><strong>调用 Application Service</strong> 执行具体的业务命令。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 领域事件订阅者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DomainEventSubscriber</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> ApplicationService applicationService;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@KafkaListener(topics = &quot;domain_event_topic&quot;,groupId = &quot;local_consumer_group_id&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span> <span class="params">(String event)</span> &#123;</span><br><span class="line">            <span class="comment">// 解析得到领域事件</span></span><br><span class="line">            <span class="type">DomainEvent</span> <span class="variable">domainEvent</span> <span class="operator">=</span> JSON.parse(event,DomainEvent.class);</span><br><span class="line">            <span class="comment">// 拼装Command</span></span><br><span class="line">            <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="built_in">this</span>.toCommand(domainEvent);</span><br><span class="line">            <span class="comment">// 应用层执行领域模型状态变更</span></span><br><span class="line">            applicationService.handleCommand(command);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="幂等性（Idempotency）"><a href="#幂等性（Idempotency）" class="headerlink" title="幂等性（Idempotency）"></a>幂等性（Idempotency）</h3><p>由于网络抖动或重试机制，消费者必然会收到重复消息。<strong>必须</strong>利用 <code>event_id</code> 建立唯一索引或去重表，确保同一业务逻辑不执行两次。</p><hr><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>领域事件的设计不仅仅是技术实现，更是一种将<strong>业务流程显性化</strong>的手段。</p><ol><li><strong>设计上</strong>：优先选择 <strong>“聚合根暂存 + 基础设施抽取”</strong> 的生成模式，保持领域纯净。</li><li><strong>数据上</strong>：权衡消息大小，推荐使用 <strong>增强型事件</strong> 减少下游依赖。</li><li><strong>架构上</strong>：必须正视分布式一致性问题，<strong>本地消息表</strong> 是实现可靠投递的基石。</li></ol><p>DDD 的路途虽远，但只要处理好领域事件，系统的解耦与演进就会变得从容许多。</p><p>最后有关于领域事件跟事件回溯以及CQRS的结合可以看专门的文章。 CQRS与DDD: <a href="https://juejin.cn/post/7510057969265115146">https://juejin.cn/post/7510057969265115146</a> , 领域事件与事件回溯：<a href="https://juejin.cn/post/7510120678847184906">https://juejin.cn/post/7510120678847184906</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结（三) 链表</title>
      <link href="/posts/73873447.html"/>
      <url>/posts/73873447.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表相关的题目"><a href="#链表相关的题目" class="headerlink" title="链表相关的题目"></a>链表相关的题目</h1><p>这里用来记录链表相关的题目以及思路</p><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>思路：每k个翻转一次，可以单独进行反转，但注意上一组的尾节点和下一组的头节点要连接起来，所以需要记录上一组尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> teamEnd(start, k);</span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一组很特殊因为牵扯到换头的问题</span></span><br><span class="line">head = end;</span><br><span class="line">reverse(start, end);</span><br><span class="line"><span class="comment">// 翻转之后start变成了上一组的结尾节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">lastTeamEnd</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="keyword">while</span> (lastTeamEnd.next != <span class="literal">null</span>) &#123;</span><br><span class="line">start = lastTeamEnd.next;</span><br><span class="line">end = teamEnd(start, k);</span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">reverse(start, end);</span><br><span class="line">lastTeamEnd.next = end; <span class="comment">// 上一组结尾节点要连接下一组头节点</span></span><br><span class="line">lastTeamEnd = start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前组的开始节点是s，往下数k个找到当前组的结束节点返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">teamEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; s != <span class="literal">null</span>) &#123;</span><br><span class="line">s = s.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s -&gt; a -&gt; b -&gt; c -&gt; e -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment">// 上面的链表通过如下的reverse方法调整成 : e -&gt; c -&gt; b -&gt; a -&gt; s -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode s, ListNode e)</span> &#123;</span><br><span class="line">e = e.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = s, next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line">next = cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">s.next = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>思路：将每个节点复制一份，并把复制的节点放在原节点后面，比如1-&gt;2-&gt;3-&gt;4-&gt;5，复制之后变成1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;4-&gt;4’-&gt;5-&gt;5’，然后遍历链表，将复制的节点的random指针指向原节点的random指针指向的节点的下一个节点。最后将链表拆分，返回新链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span>head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将链表复制串联</span></span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">Node</span>(pre.val);</span><br><span class="line">        pre.next.next = next;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将random进行复制</span></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next.next;</span><br><span class="line">        pre.next.random = pre.random == <span class="literal">null</span> ? <span class="literal">null</span> : pre.random.next;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离两个链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newPre</span> <span class="operator">=</span> newHead;</span><br><span class="line">    pre =head;</span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next.next;</span><br><span class="line">        newPre.next = next == <span class="literal">null</span> ? <span class="literal">null</span> : next.next ;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        pre =next;</span><br><span class="line">        newPre = newPre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h2><p>思路：利用快慢指针，找到中点，然后翻转后半部分链表，比较前后两个链表是否相等。最后恢复链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//利用快慢指针找到中点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">man</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">kuai</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (kuai.next != <span class="literal">null</span> &amp;&amp; kuai.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        man = man.next;</span><br><span class="line">        kuai = kuai.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> reverseList(man);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isPal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reversePre</span> <span class="operator">=</span>reverseHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(reversePre!=<span class="literal">null</span> &amp;&amp; pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.val!=reversePre.val)&#123;</span><br><span class="line">            isPal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reversePre = reversePre.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表还原</span></span><br><span class="line">    reverseList(reverseHead);</span><br><span class="line">    <span class="keyword">return</span> isPal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next =head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre =head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表是否存在环-并求环的入口节点"><a href="#链表是否存在环-并求环的入口节点" class="headerlink" title="链表是否存在环 并求环的入口节点"></a>链表是否存在环 并求环的入口节点</h2><p>思路：利用快慢指针，快指针每次移动两步，慢指针每次移动一步，如果快慢指针相遇，则说明链表有环，否则没有环。相遇的时候，快指针回到头节点，慢指针继续移动，但是慢指针和快指针每次都移动一步，再次相遇的时候就是环的入口节点。 a+(nb+c) = 2(a+c)  a = nb - c  所以慢指针再走a步，就能到达入口节点。此时快指针也走a步，慢指针和快指针相遇的节点就是入口节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span>head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>要求：时间复杂度nlog(n),空间复杂度O(1)，且稳定<br>思路：利用非递归版本的归并排序，并且merge是合并两个有序链表。<br>代码很复杂，看看就好<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n*logn)，额外空间复杂度O(1)，有稳定性</span></span><br><span class="line"><span class="comment">// 注意为了额外空间复杂度O(1)，所以不能使用递归</span></span><br><span class="line"><span class="comment">// 因为mergeSort递归需要O(log n)的额外空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">n++;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l1...r1 每组的左部分</span></span><br><span class="line"><span class="comment">// l2...r2 每组的右部分</span></span><br><span class="line"><span class="comment">// next 下一组的开头</span></span><br><span class="line"><span class="comment">// lastTeamEnd 上一组的结尾</span></span><br><span class="line">ListNode l1, r1, l2, r2, next, lastTeamEnd;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 第一组很特殊，因为要决定整个链表的头，所以单独处理</span></span><br><span class="line">l1 = head;</span><br><span class="line">r1 = findEnd(l1, step);</span><br><span class="line">l2 = r1.next;</span><br><span class="line">r2 = findEnd(l2, step);</span><br><span class="line">next = r2.next;</span><br><span class="line">r1.next = <span class="literal">null</span>;</span><br><span class="line">r2.next = <span class="literal">null</span>;</span><br><span class="line">merge(l1, r1, l2, r2);</span><br><span class="line">head = start;</span><br><span class="line">lastTeamEnd = end;</span><br><span class="line"><span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">l1 = next;</span><br><span class="line">r1 = findEnd(l1, step);</span><br><span class="line">l2 = r1.next;</span><br><span class="line"><span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">lastTeamEnd.next = l1;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">r2 = findEnd(l2, step);</span><br><span class="line">next = r2.next;</span><br><span class="line">r1.next = <span class="literal">null</span>;</span><br><span class="line">r2.next = <span class="literal">null</span>;</span><br><span class="line">merge(l1, r1, l2, r2);</span><br><span class="line">lastTeamEnd.next = start;</span><br><span class="line">lastTeamEnd = end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括s在内，往下数k个节点返回</span></span><br><span class="line"><span class="comment">// 如果不够，返回最后一个数到的非空节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (s.next != <span class="literal">null</span> &amp;&amp; --k != <span class="number">0</span>) &#123;</span><br><span class="line">s = s.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l1...r1 -&gt; null : 有序的左部分</span></span><br><span class="line"><span class="comment">// l2...r2 -&gt; null : 有序的右部分</span></span><br><span class="line"><span class="comment">// 整体merge在一起，保证有序</span></span><br><span class="line"><span class="comment">// 并且把全局变量start设置为整体的头，全局变量end设置为整体的尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode r1, ListNode l2, ListNode r2)</span> &#123;</span><br><span class="line">ListNode pre;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">start = l1;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = l2;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">pre.next = l1;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre.next = l2;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">pre.next = l1;</span><br><span class="line">end = r1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre.next = l2;</span><br><span class="line">end = r2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h2><p>思路：利用双向链表和HashMap，双向链表负责维护最久未使用的顺序（最久未使用放到头节点，只要使用就放到尾节点）（实现三个功能 1.加入节点(直接放入尾部)，2.将已经有的节点放入尾部，3.删除头节点），HashMap实现快速查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Listnode</span>&#123;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            Listnode last;</span><br><span class="line">            Listnode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Listnode</span><span class="params">(<span class="type">int</span> val,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.val =val;</span><br><span class="line">                <span class="built_in">this</span>.key =key;</span><br><span class="line">                last =<span class="literal">null</span>;</span><br><span class="line">                next =<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">doubleList</span>&#123;</span><br><span class="line">            Listnode head;</span><br><span class="line">            Listnode tail;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">doubleList</span><span class="params">()</span>&#123;</span><br><span class="line">                head =<span class="literal">null</span>;</span><br><span class="line">                tail =<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Listnode node)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">                    head = node;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tail.next = node;</span><br><span class="line">                    node.last = tail;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNode2Tail</span><span class="params">(Listnode node)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (tail == node) &#123;  <span class="comment">/// 如果是最后一个节点，则不需要移动</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">                    head = node.next;</span><br><span class="line">                    head.last =<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    node.last.next = node.next;</span><br><span class="line">                    node.next.last = node.last;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tail.next = node;</span><br><span class="line">                node.last = tail;</span><br><span class="line">                node.next = <span class="literal">null</span>;</span><br><span class="line">                tail =node;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Listnode <span class="title function_">delHead</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">h</span> <span class="operator">=</span>head;</span><br><span class="line">                <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">                    head = <span class="literal">null</span>;</span><br><span class="line">                    tail =<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Listnode</span> <span class="variable">next</span> <span class="operator">=</span>head.next;</span><br><span class="line">                    head.next = <span class="literal">null</span>;</span><br><span class="line">                    head = next;</span><br><span class="line">                    head.last = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer,Listnode&gt; myMap;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">MaxCap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> doubleList myList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cap = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.MaxCap = capacity;</span><br><span class="line">            myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Listnode&gt;();</span><br><span class="line">            myList = <span class="keyword">new</span> <span class="title class_">doubleList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(key))&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> myMap.get(key);</span><br><span class="line">                myList.moveNode2Tail(node);</span><br><span class="line">                <span class="keyword">return</span> node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(key))&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> myMap.get(key);</span><br><span class="line">                node.val = value;</span><br><span class="line">                myList.moveNode2Tail(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cap == MaxCap)&#123;</span><br><span class="line">                    myMap.remove(myList.delHead().key);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    cap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Listnode</span>(value,key);</span><br><span class="line">                myMap.put(key,node);</span><br><span class="line">                myList.addNode(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务相关的总结</title>
      <link href="/posts/fee9ca7b.html"/>
      <url>/posts/fee9ca7b.html</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="TC-如何知道哪些RM属于同一个全局事务？"><a href="#TC-如何知道哪些RM属于同一个全局事务？" class="headerlink" title="TC 如何知道哪些RM属于同一个全局事务？"></a>TC 如何知道哪些RM属于同一个全局事务？</h3><p>以Seate框架为例，在TM向TC发送全局事务开始时，TC会生成对应的全局事务ID（XID），并发送给TM。TM 将 XID 放入当前线程的 ThreadLocal 中，后续的 RM (资源管理器) 分支事务通过解析该 XID 来注册分支。如果涉及RPC调用，每次调用时会在请求头部传递这个XID，让RM知道这个XID,RM向TC发送分支事务开始时,就会携带这个XID,从而告诉TC这个RM属于哪一个全局事务。</p><p>在多线程中，由于每个线程的XID是线程私有的，所以无法确定哪些RM属于同一个全局事务。这时全局事务会失效。解决方案可以是在开启新线程时，将XID传递给新线程，新线程的XID会继承父线程的XID。这样子线程的XID就会和父线程的XID一致，从而可以确定哪些RM属于同一个全局事务。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-15%20142842.png" alt="流程图片"/></div><span class="image-caption">流程图片</span></div>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD与MVC的统一</title>
      <link href="/posts/f4b47790.html"/>
      <url>/posts/f4b47790.html</url>
      
        <content type="html"><![CDATA[<h1 id="MVC到DDD：从架构分层到业务建模的思考"><a href="#MVC到DDD：从架构分层到业务建模的思考" class="headerlink" title="MVC到DDD：从架构分层到业务建模的思考"></a>MVC到DDD：从架构分层到业务建模的思考</h1><p>在后端开发学习和实践过程中，我们总会被各种架构模式和设计思想围绕——MVC、Service+DAO分层、DDD四层架构（DDD并非与四层架构绑定 DDD是思想，四层架构是代码落地的一个架构）……这些概念之间到底是替代关系还是互补关系？为什么简单业务用Service+DAO就够，复杂业务却要引入DDD？结合近期的学习思考，我想梳理清楚这些架构之间的核心关联，帮自己（也希望帮到同样困惑的同学）建立清晰的认知。</p><h2 id="一、起点：MVC的核心价值——解决“代码放哪”的基础问题"><a href="#一、起点：MVC的核心价值——解决“代码放哪”的基础问题" class="headerlink" title="一、起点：MVC的核心价值——解决“代码放哪”的基础问题"></a>一、起点：MVC的核心价值——解决“代码放哪”的基础问题</h2><p>最早接触后端开发时，MVC是绕不开的入门架构。它的核心思想非常简单：将软件分为三个核心层级，实现“展示与逻辑”的初步解耦。</p><ul><li><p><strong>Controller（控制器）</strong>：接收用户请求、协调后续处理、返回响应，相当于系统的“入口/出口”，不承载核心业务逻辑；</p></li><li><p><strong>Model（模型）</strong>：封装数据和核心业务逻辑，是系统的“大脑”，负责数据的增删改查和业务规则校验；</p></li><li><p><strong>View（视图）</strong>：展示数据，与用户直接交互（前后端分离场景下，前端页面即View层，后端不再关注）。</p></li></ul><p>MVC的价值在于给出了“代码该放哪”的明确答案，解决了早期开发中“业务逻辑与页面展示混在一起”的混乱问题。但它的局限性也很明显：Model层是一个“大黑盒”，没有明确的内部划分标准——当业务简单时，一个Service+Mapper就能撑起Model层；但当业务复杂（比如电商订单履约、金融风控）时，直接把所有逻辑堆在Service里，很快就会导致代码臃肿、逻辑混乱、难以维护。</p><h2 id="二、演进：Service-DAO分层——MVC-Model层的简易拆分"><a href="#二、演进：Service-DAO分层——MVC-Model层的简易拆分" class="headerlink" title="二、演进：Service+DAO分层——MVC Model层的简易拆分"></a>二、演进：Service+DAO分层——MVC Model层的简易拆分</h2><p>为了弥补MVC Model层的模糊性，在Spring生态实践中，我们自然演化出了“Controller+Service+DAO（Mapper）”的三层落地方案。这本质上是对MVC的Model层做了第一次“粗粒度拆分”，让职责更清晰：</p><ul><li><p><strong>Controller层</strong>：完全对应MVC的Controller层，负责请求接收、参数简单校验、调用Service层；</p></li><li><p><strong>Service层</strong>：对应MVC Model层的“业务逻辑核心”，实现订单支付、库存扣减等核心业务规则；</p></li><li><p><strong>DAO（Mapper）层</strong>：对应MVC Model层的“数据访问部分”，仅负责与数据库交互，不包含任何业务逻辑。</p></li></ul><p>这种拆分方案简单直观、开发效率高，非常适合简单CRUD场景（比如小型管理后台、个人工具）。但它的问题在复杂业务场景下会暴露无遗：Service层很容易变成“万能层”——既要处理跨实体的业务逻辑（比如支付需要协调订单、库存、支付三个模块），又要兼顾事务控制、数据组装等辅助逻辑，最终导致Service层代码臃肿、逻辑缠绕，后续迭代和维护成本极高。</p><h2 id="三、进阶：DDD四层架构——MVC-Model层的精细化升级"><a href="#三、进阶：DDD四层架构——MVC-Model层的精细化升级" class="headerlink" title="三、进阶：DDD四层架构——MVC Model层的精细化升级"></a>三、进阶：DDD四层架构——MVC Model层的精细化升级</h2><p>当业务复杂度上升到一定程度，DDD（领域驱动设计）就成了更优的选择。很多人会误以为DDD是“替代MVC”的架构，其实不然——DDD本质上是一套“业务建模方法论”，它在MVC的大框架下，对Model层做了更精细的拆分，让复杂业务逻辑更清晰、更贴合业务本身。</p><p>DDD提出的四层架构（用户层/接口层、应用层、领域层、基础设施层），与MVC、Service+DAO分层的对应关系非常清晰，核心结论先抛出来：<strong>DDD的用户层对应MVC的Controller层，后三层共同构成MVC的Model层；DDD与MVC完全兼容，只是对Model层的拆分更彻底</strong>。</p><h3 id="1-DDD四层架构的核心职责与对应关系"><a href="#1-DDD四层架构的核心职责与对应关系" class="headerlink" title="1. DDD四层架构的核心职责与对应关系"></a>1. DDD四层架构的核心职责与对应关系</h3><div class="table-container"><table><thead><tr><th>DDD四层架构</th><th>核心职责</th><th>对应MVC分层</th><th>对应Service+DAO分层</th><th>Spring实践落地</th></tr></thead><tbody><tr><td>用户层（接口层）</td><td>接收外部请求（HTTP/RPC/消息）、返回响应、参数非业务校验、权限拦截</td><td>Controller层</td><td>Controller层</td><td>@RestController、ControllerAdvice、RPC接口</td></tr><tr><td>应用层</td><td>协调领域层执行、处理事务、组装返回数据，无核心业务逻辑</td><td>Model层</td><td>Service层的“协调部分”</td><td>XXXApplicationService（应用服务）</td></tr><tr><td>领域层</td><td>封装核心业务规则、聚合根/实体/值对象、跨实体业务逻辑，系统核心</td><td>Model层（核心）</td><td>Service层的“核心业务部分”</td><td>聚合根（Entity）、XXXDomainService（领域服务）</td></tr><tr><td>基础设施层</td><td>封装技术细节（数据库、缓存、第三方接口），为上层提供技术支撑</td><td>Model层</td><td>DAO（Mapper）层</td><td>Repository、Mapper、RedisTemplate、Feign客户端</td></tr></tbody></table></div><h3 id="2-关键演进：从Service层到“应用服务-领域服务”"><a href="#2-关键演进：从Service层到“应用服务-领域服务”" class="headerlink" title="2. 关键演进：从Service层到“应用服务+领域服务”"></a>2. 关键演进：从Service层到“应用服务+领域服务”</h3><p>DDD对Service+DAO分层的核心优化，就是把传统“厚Service”拆成了“薄应用服务”和“厚领域服务”，让业务逻辑的归属更明确：</p><ul><li><p><strong>领域服务</strong>：只负责核心业务逻辑，比如“订单支付”需要校验订单状态、扣减库存、更新支付状态等跨实体逻辑，都放在领域服务；</p></li><li><p><strong>应用服务</strong>：不碰核心业务，只做“协调工作”——比如开启事务、调用领域服务、把领域层的结果组装成前端需要的格式。</p></li></ul><p>同时，DDD还强调“业务驱动建模”：先梳理业务领域的规则（比如“未支付订单24小时自动取消”），再把这些规则封装到实体类中（比如Order实体的canPay()、markAsPaid()方法），而不是像传统Service+DAO那样，把所有业务逻辑都写在Service的if-else里。这种方式让代码更贴合业务，后续迭代时也更容易理解和修改。</p><h2 id="四、核心认知：所有架构的本质都是“解耦”，只是粒度不同"><a href="#四、核心认知：所有架构的本质都是“解耦”，只是粒度不同" class="headerlink" title="四、核心认知：所有架构的本质都是“解耦”，只是粒度不同"></a>四、核心认知：所有架构的本质都是“解耦”，只是粒度不同</h2><p>梳理完从MVC到Service+DAO，再到DDD的演进脉络，会发现一个核心规律：<strong>所有架构分层的最终目标都是“解耦”，只是针对不同业务复杂度，选择了不同的拆分粒度</strong>。</p><ul><li><p>MVC：解决“展示与逻辑”的解耦，给出最基础的分层框架；</p></li><li><p>Service+DAO：解决MVC Model层的内部解耦，让数据访问和业务逻辑分离，适配简单业务；</p></li><li><p>DDD：解决复杂业务下Model层的深度解耦，让核心业务逻辑、协调逻辑、技术细节彻底分离，适配复杂业务。</p></li></ul><p>很多人会误以为“DDD比MVC高级”“用了DDD就不能用MVC”，这其实是误区。DDD和MVC不是对立关系，而是互补关系——MVC提供了整体的架构骨架，DDD则是对这个骨架中“Model层”的精细化设计指南。</p><h2 id="五、实践建议：根据业务复杂度选择合适的架构"><a href="#五、实践建议：根据业务复杂度选择合适的架构" class="headerlink" title="五、实践建议：根据业务复杂度选择合适的架构"></a>五、实践建议：根据业务复杂度选择合适的架构</h2><p>架构没有“最优解”，只有“最合适”。结合自己的实践经验，给出几点选择建议：</p><ol><li><p><strong>简单CRUD场景（小型管理后台、个人工具）</strong>：直接用“Controller+Service+DAO”，开发效率高、维护成本低，没必要过度设计；</p></li><li><p><strong>中等复杂度场景（常规业务系统）</strong>：可以借鉴DDD的思想，在Service层内部做简单拆分（比如把核心业务逻辑抽成单独的方法或类），避免Service层臃肿；</p></li><li><p><strong>高复杂度场景（电商、金融、供应链）</strong>：推荐使用DDD四层架构，通过领域建模让复杂业务逻辑更清晰，为长期迭代打下基础；</p></li><li><p><strong>渐进式改造</strong>：不用一开始就全盘重构为DDD，可以从“拆分Service层”开始，先把核心业务逻辑抽成领域服务，再逐步完善应用层和基础设施层，降低改造风险。</p></li></ol><h2 id="六、DDD跟四层架构什么关系？"><a href="#六、DDD跟四层架构什么关系？" class="headerlink" title="六、DDD跟四层架构什么关系？"></a>六、DDD跟四层架构什么关系？</h2><p>DDD（领域驱动设计）本身不强制规定 “四层架构”。DDD 的核心在于战略设计（限界上下文、领域模型）和战术设计（实体、值对象、聚合根、领域服务、仓储等），而 “四层架构” 确实是为了让这些战术设计模式在代码层面更好落地而总结出的一套经典工程实践。</p><p>在实际落地 DDD 时，代码架构的选择确实非常重要。虽然 DDD 是一种思想，不强求特定目录结构，但业界已经沉淀出两套最主流的架构模式：</p><ol><li><strong>经典的四层架构（Layered Architecture）</strong> —— 最容易理解，适合起步。</li><li><strong>整洁/六边形架构（Clean / Hexagonal Architecture）</strong> —— 依赖倒置更彻底，现代微服务主流。</li></ol><p>此外，国内 Java 圈（特别是阿里系）还常用 <strong>COLA 架构</strong>。</p><p>下面详细拆解这几种架构的代码目录结构和核心要点。</p><hr><h3 id="方案一：经典的四层架构-Standard-4-Layer"><a href="#方案一：经典的四层架构-Standard-4-Layer" class="headerlink" title="方案一：经典的四层架构 (Standard 4-Layer)"></a>方案一：经典的四层架构 (Standard 4-Layer)</h3><p>这是最符合上文所提出观点的理解的结构，结构清晰，适合从三层架构转型过来的团队。</p><h4 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h4><p><strong>依赖倒置（DIP）</strong>：虽然物理上是四层，但在逻辑上，<strong>领域层（Domain）必须是独立的</strong>。</p><ul><li><strong>错误的做法</strong>：Domain 层 <code>import</code> Infrastructure 层的代码。</li><li><strong>正确的做法</strong>：Domain 层定义接口（Repository Interface），Infrastructure 层去实现它。</li></ul><h4 id="目录结构示例"><a href="#目录结构示例" class="headerlink" title="目录结构示例"></a>目录结构示例</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.company.project</span><br><span class="line">├── interfaces (用户接口层 / Web)</span><br><span class="line">│   ├── controller       // 处理 HTTP 请求</span><br><span class="line">│   └── dto              // 数据传输对象 (Request/Response)</span><br><span class="line">├── application (应用层)</span><br><span class="line">│   ├── service          // 应用服务 (流程编排)</span><br><span class="line">│   └── assembler        // DTO 与 Entity 的转换器</span><br><span class="line">├── domain (领域层 - 核心)</span><br><span class="line">│   ├── model            // 聚合根、实体、值对象</span><br><span class="line">│   │   ├── aggregate    // 聚合</span><br><span class="line">│   │   └── entity       // 实体</span><br><span class="line">│   ├── service          // 领域服务 (跨实体逻辑)</span><br><span class="line">│   └── repository       // 仓储接口 (注意：这里只放接口！)</span><br><span class="line">└── infrastructure (基础设施层)</span><br><span class="line">    ├── repository       // 仓储实现 (Impl，这里依赖 JPA/MyBatis)</span><br><span class="line">    ├── entity           // PO (Persistent Object，对应数据库表)</span><br><span class="line">    └── util             // 通用工具</span><br></pre></td></tr></table></figure><hr><h3 id="方案二：整洁架构-六边形架构-Clean-Hexagonal"><a href="#方案二：整洁架构-六边形架构-Clean-Hexagonal" class="headerlink" title="方案二：整洁架构 / 六边形架构 (Clean / Hexagonal)"></a>方案二：整洁架构 / 六边形架构 (Clean / Hexagonal)</h3><p>这是目前 DDD 社区<strong>最推荐</strong>的架构，特别是在微服务场景下。它不再强调“上下层”，而是强调“<strong>内外</strong>”。</p><ul><li><strong>内核（Inner）</strong>：Domain + Application。这是雷打不动的业务核心。</li><li><strong>外壳（Outer）</strong>：Web、Database、Redis、MQ。这些都是“插件”。</li></ul><h4 id="核心原则-1"><a href="#核心原则-1" class="headerlink" title="核心原则"></a>核心原则</h4><p><strong>依赖只能由外向内</strong>。外壳（Web、DB）依赖内核（Domain），内核谁也不依赖。</p><h4 id="目录结构示例-1"><a href="#目录结构示例-1" class="headerlink" title="目录结构示例"></a>目录结构示例</h4><p>这种架构通常会把文件夹分为 <code>adapter</code>（适配器/外壳）和 <code>core</code>（内核）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com.company.project</span><br><span class="line">├── adapter (适配器层 - 对应“六边形”的端口)</span><br><span class="line">│   ├── inbound (输入端 / 驱动端)</span><br><span class="line">│   │   └── web          // RestController</span><br><span class="line">│   └── outbound (输出端 / 被驱动端)</span><br><span class="line">│       ├── persistence  // 数据库实现 (Repository Impl)</span><br><span class="line">│       └── thirdparty   // 第三方调用 (如调用支付接口)</span><br><span class="line">├── application (应用层 - 业务流程)</span><br><span class="line">│   ├── service          // 应用服务</span><br><span class="line">│   └── port             // 端口定义 (如果是严格六边形，接口定义在这里)</span><br><span class="line">└── domain (领域层 - 业务核心)</span><br><span class="line">    ├── model            // 实体、聚合根</span><br><span class="line">    ├── service          // 领域服务</span><br><span class="line">    └── repository       // 仓储接口 (定义数据该怎么存，但不关心存哪里)</span><br></pre></td></tr></table></figure><p><strong>区别点</strong>：<br>你会发现 <code>Controller</code> 和 <code>RepositoryImpl</code> 变成了兄弟关系，都属于 <code>Adapter</code>（外围设施），而 <code>Domain</code> 被层层保护在最里面。</p><hr><h3 id="方案三：COLA-架构-Clean-Object-Oriented-and-Layered-Architecture"><a href="#方案三：COLA-架构-Clean-Object-Oriented-and-Layered-Architecture" class="headerlink" title="方案三：COLA 架构 (Clean Object-Oriented and Layered Architecture)"></a>方案三：COLA 架构 (Clean Object-Oriented and Layered Architecture)</h3><p>如果你是 Java 开发者，特别是在国内大厂环境，阿里开源的 <strong>COLA 架构</strong> 是一个非常流行的 DDD 落地模板。它结合了四层架构和整洁架构的优点。</p><p>它的特点是把<strong>对外暴露的接口（API）</strong>单独抽离成一个模块，方便微服务之间调用。</p><h4 id="Maven-模块结构"><a href="#Maven-模块结构" class="headerlink" title="Maven 模块结构"></a>Maven 模块结构</h4><p>COLA 通常是多 Module 的 Maven 项目：</p><ol><li><strong><code>start</code> (启动层)</strong><ul><li>Spring Boot 启动类，各种配置。</li></ul></li><li><strong><code>adapter</code> (适配层)</strong><ul><li>Controller (Web), Consumer (MQ)。</li></ul></li><li><strong><code>client</code> (API 层 / SDK)</strong><ul><li><strong>重点</strong>：这里放 DTO 和 API 接口定义。外部系统只需要依赖这个 jar 包。</li></ul></li><li><strong><code>app</code> (应用层)</strong><ul><li>Application Service, Command Handler。</li></ul></li><li><strong><code>domain</code> (领域层)</strong><ul><li>Entity, ValueObject, DomainService, Repository Interface。</li><li><strong>最纯净的一层，不依赖 Spring，只依赖 JDK。</strong></li></ul></li><li><strong><code>infrastructure</code> (基础设施层)</strong><ul><li>MyBatis Mapper, Repository Impl, Redis Util。</li></ul></li></ol><hr><h3 id="总结：我该怎么选？"><a href="#总结：我该怎么选？" class="headerlink" title="总结：我该怎么选？"></a>总结：我该怎么选？</h3><ol><li><p><strong>如果你是初学者，或者项目规模不大</strong>：<br>推荐 <strong>方案一（经典的四层架构）</strong>。</p><ul><li>理由：最符合直觉，文件夹分层清晰，从 MVC 迁移过来认知负担最小。</li><li><em>注意点：一定要坚持“领域层定义接口，基础层实现接口”，不要让领域层依赖 MyBatis。</em></li></ul></li><li><p><strong>如果你在做微服务，或者业务逻辑极度复杂</strong>：<br>推荐 <strong>方案二（整洁/六边形架构）</strong>。</p><ul><li>理由：能够完美隔离技术实现的变动（比如从 MySQL 换到 MongoDB，核心业务代码一行都不用改）。</li></ul></li><li><p><strong>如果你的团队用 Java 且由于规范要求</strong>：<br>推荐 <strong>方案三（COLA）</strong>。</p><ul><li>理由：国内资料多，规范约束性强，适合团队协作。</li></ul></li></ol><h3 id="关键点（无论选哪个架构）"><a href="#关键点（无论选哪个架构）" class="headerlink" title="关键点（无论选哪个架构）"></a>关键点（无论选哪个架构）</h3><p>不管你选哪个文件结构，DDD 落地的<strong>生死线</strong>只有一条：</p><blockquote><p><strong>Domain 层（领域层）必须是“纯净”的。</strong></p></blockquote><ul><li>它可以引用 <code>java.util.List</code>。</li><li>它<strong>绝对不能</strong>引用 <code>javax.sql.DataSource</code>、<code>org.springframework.xxx</code>、<code>com.github.pagehelper</code>。</li><li>它只谈业务（账号、金额、冻结），不谈技术（表、JSON、HTTP）。</li></ul><p>只要守住了这条线，你的架构就是合格的 DDD 架构。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>从MVC到Service+DAO，再到DDD，不是架构的“替代”，而是架构的“演进”。它们的核心都是通过分层实现解耦，只是针对不同的业务复杂度，选择了不同的拆分粒度。</p><p>对于开发者而言，不用盲目追求“高大上”的架构，而应该理解每种架构的核心价值和适用场景：简单业务用简单架构，复杂业务用精细架构。同时，要抓住架构设计的本质——让代码结构清晰、职责明确，便于维护和迭代。这才是我们学习各种架构思想的最终目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络问题总结</title>
      <link href="/posts/a3a5550f.html"/>
      <url>/posts/a3a5550f.html</url>
      
        <content type="html"><![CDATA[<h2 id="学习过程中的疑惑"><a href="#学习过程中的疑惑" class="headerlink" title="学习过程中的疑惑"></a>学习过程中的疑惑</h2><h3 id="通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-那我应该得到谁的mac地址呢"><a href="#通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-那我应该得到谁的mac地址呢" class="headerlink" title="通过ARP协议我们可以知道目的ip的mac地址  那要是这个ip不在我的局域网里面 那我应该得到谁的mac地址呢"></a>通过ARP协议我们可以知道目的ip的mac地址  那要是这个ip不在我的局域网里面 那我应该得到谁的mac地址呢</h3><p>这是一个非常经典且关键的网络问题。</p><p>简单直接的回答是：<strong>你会得到你所在局域网的“网关”（Gateway）的 MAC 地址。</strong></p><h4 id="详细原理解析"><a href="#详细原理解析" class="headerlink" title="详细原理解析"></a>详细原理解析</h4><p>当你的电脑（主机 A）想要发送数据包给一个 IP 地址（主机 B）时，它会经历以下逻辑判断流程：</p><ol><li><p><strong>判断目标 IP 是否在同一个局域网（子网）内：</strong></p><ul><li>电脑会查看自己的子网掩码（Subnet Mask）。</li><li>如果 <code>目标IP</code> 和 <code>本机IP</code> 在同一个网段内，电脑认为它可以直接通信。</li><li><strong>如果不在同一个网段内</strong>，电脑认为“我够不着它”，必须找一个“中介”来帮忙转发。</li></ul></li><li><p><strong>寻找“中介”（网关）：</strong></p><ul><li>这个“中介”就是你配置的<strong>默认网关（Default Gateway）</strong>。通常这是你路由器（Router）的内网 IP 地址（例如 <code>192.168.1.1</code> 或 <code>192.168.0.1</code>）。</li><li>电脑会把数据包发给网关，由网关负责把数据包投递到外网。</li></ul></li><li><p><strong>ARP 解析的对象发生变化：</strong></p><ul><li>既然数据包要发给网关，那么在数据链路层（二层），目标 MAC 地址就必须是网关的 MAC 地址。</li><li>因此，你的电脑会发起一个 <strong>ARP 请求</strong>，但是请求的目标 IP 不再是“目的 IP”，而是 <strong>“网关的 IP”</strong>。</li></ul></li><li><p><strong>获取 MAC 地址：</strong></p><ul><li>网关（路由器）收到 ARP 请求后，回复它的 MAC 地址。</li><li>你的电脑将数据包封装，<strong>目标 IP 仍然是远方的 IP，但目标 MAC 地址变成了网关的 MAC 地址</strong>。</li></ul></li></ol><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假设你的网络环境如下：</p><ul><li><strong>你的电脑 IP：</strong> <code>192.168.1.100</code></li><li><strong>你的网关 IP：</strong> <code>192.168.1.1</code> （MAC: <code>AA:AA:AA:AA:AA:AA</code>）</li><li><strong>你想访问的百度服务器 IP：</strong> <code>110.242.68.4</code> （这显然不在你的局域网）</li></ul><p><strong>发生的过程：</strong></p><ol><li>你要 ping <code>110.242.68.4</code>。</li><li>你的电脑计算一下，发现 <code>110.242.68.4</code> 不在 <code>192.168.1.x</code> 这个圈子里。</li><li>你的电脑决定：“我要把这个包交给网关 <code>192.168.1.1</code> 处理。”</li><li>你的电脑发出 ARP 请求：“谁是 <code>192.168.1.1</code>？请告诉我你的 MAC 地址。”</li><li>路由器回复：“我是 <code>192.168.1.1</code>，我的 MAC 是 <code>AA:AA:AA:AA:AA:AA</code>。”</li><li>你的电脑发送数据包：<ul><li><strong>源 IP：</strong> <code>192.168.1.100</code></li><li><strong>目的 IP：</strong> <code>110.242.68.4</code> （IP 头不变）</li><li><strong>源 MAC：</strong> <code>你的电脑 MAC</code></li><li><strong>目的 MAC：</strong> <code>AA:AA:AA:AA:AA:AA</code> （变成了网关的 MAC）</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>同网段通信：</strong> ARP 解析 <strong>目标 IP</strong> 的 MAC。</li><li><strong>跨网段通信：</strong> ARP 解析 <strong>网关 IP</strong> 的 MAC。</li></ul><p>这就是为什么当你访问互联网上任何网站时，你电脑的 ARP 缓存表中，主要变动的其实是网关的记录，而不是互联网上无数服务器的 MAC 地址（你也无法直接获取互联网服务器的 MAC 地址，因为路由器会隔离广播域）。</p><h3 id="封装好网络包后如何送达目标IP？"><a href="#封装好网络包后如何送达目标IP？" class="headerlink" title="封装好网络包后如何送达目标IP？"></a>封装好网络包后如何送达目标IP？</h3><p>在网络通信中，“封装好网络包后如何送达目标IP”是最核心的基础问题之一。这个过程涉及链路层、网络层的协同工作，以及交换机、路由器等设备的核心机制。本文将结合此前的讨论，以技术思考的视角，完整梳理从网络包封装完成到最终送达目标IP的全流程，拆解其中的关键逻辑与设备分工。</p><h4 id="一、核心前提：网络包的“两层身份”与核心寻址要素"><a href="#一、核心前提：网络包的“两层身份”与核心寻址要素" class="headerlink" title="一、核心前提：网络包的“两层身份”与核心寻址要素"></a>一、核心前提：网络包的“两层身份”与核心寻址要素</h4><p>当我们在主机上完成网络包封装后（通常是TCP/UDP头部+IP头部+数据的封装），这个包要在物理网络中传输，必须具备“两层身份标识”，对应网络分层模型的不同职责：</p><ul><li><p><strong>网络层身份</strong>：即源IP地址（发送方主机IP）和目标IP地址（最终接收方IP），核心作用是“跨网段导航”，确定数据包的最终目的地，全程不变。</p></li><li><p><strong>链路层身份</strong>：即源MAC地址（当前发送设备网卡MAC）和目标MAC地址（当前链路下一跳设备MAC），核心作用是“局域网内定位”，每经过一跳链路都会更新，仅在当前链路有效。</p></li></ul><p>核心结论：IP地址负责“找最终目的地在哪”，MAC地址负责“找当前链路上下一跳是谁”，两者协同完成全路径传输。</p><h4 id="二、发送前的关键决策：目标IP是否在同一局域网？"><a href="#二、发送前的关键决策：目标IP是否在同一局域网？" class="headerlink" title="二、发送前的关键决策：目标IP是否在同一局域网？"></a>二、发送前的关键决策：目标IP是否在同一局域网？</h4><p>封装完成后，主机的TCP/IP协议栈首先会进行一个核心判断——目标IP是否与本机在同一局域网（通过子网掩码计算网段）。这个判断直接决定了后续的发送逻辑：是直接发送给目标主机，还是先发送给网关（路由器）。</p><h4 id="三、同一局域网场景：直接发送至目标主机"><a href="#三、同一局域网场景：直接发送至目标主机" class="headerlink" title="三、同一局域网场景：直接发送至目标主机"></a>三、同一局域网场景：直接发送至目标主机</h4><p>当目标IP在同一网段时，主机需要直接与目标主机通信，核心问题是“如何获取目标IP对应的MAC地址”，这就需要ARP协议的参与。</p><h5 id="3-1-步骤1：查询ARP缓存表"><a href="#3-1-步骤1：查询ARP缓存表" class="headerlink" title="3.1 步骤1：查询ARP缓存表"></a>3.1 步骤1：查询ARP缓存表</h5><p>主机本地会维护一个ARP缓存表，存储“IP地址-MAC地址”的映射关系。协议栈会先查询该表：</p><ul><li><p>若存在目标IP对应的MAC地址：直接进入链路层封装，将目标MAC填入以太网帧头，源MAC填入本机网卡MAC，然后将帧发送至交换机。</p></li><li><p>若不存在目标IP对应的MAC地址：触发ARP广播流程。</p></li></ul><h5 id="3-2-步骤2：ARP广播获取目标MAC"><a href="#3-2-步骤2：ARP广播获取目标MAC" class="headerlink" title="3.2 步骤2：ARP广播获取目标MAC"></a>3.2 步骤2：ARP广播获取目标MAC</h5><p>主机发送ARP请求包（链路层目标MAC为广播地址FF:FF:FF:FF:FF:FF），该广播包会被交换机泛洪至局域网内所有设备：</p><ul><li><p>非目标设备收到后，发现目标IP不是自己，直接丢弃；</p></li><li><p>目标设备收到后，识别出目标IP是自己，回复ARP响应包，包含自身MAC地址；</p></li><li><p>主机收到ARP响应后，将“目标IP-目标MAC”映射存入ARP缓存表，后续通信可直接使用。</p></li></ul><h5 id="3-3-步骤3：交换机的转发逻辑"><a href="#3-3-步骤3：交换机的转发逻辑" class="headerlink" title="3.3 步骤3：交换机的转发逻辑"></a>3.3 步骤3：交换机的转发逻辑</h5><p>主机将封装好的以太网帧发送至交换机后，交换机会通过自身的MAC地址表（记录“MAC地址-端口”映射）进行转发：</p><ul><li><p>若MAC地址表存在目标MAC对应的端口：直接将帧从该端口转发（单播），仅目标设备能接收；</p></li><li><p>若MAC地址表不存在目标MAC对应的端口：交换机执行“泛洪”，将帧从除接收端口外的所有端口转发，直到目标设备接收后，交换机通过源MAC学习，将目标MAC与对应端口的映射存入MAC地址表，后续通信直接单播。</p></li></ul><p>核心要点：交换机仅识别MAC地址，不关心IP地址；ARP广播仅在当前局域网内传播，不会跨网段。</p><h4 id="四、跨局域网场景：通过网关转发至目标IP"><a href="#四、跨局域网场景：通过网关转发至目标IP" class="headerlink" title="四、跨局域网场景：通过网关转发至目标IP"></a>四、跨局域网场景：通过网关转发至目标IP</h4><p>当目标IP不在同一网段时，主机无法直接与目标主机通信，必须通过网关（路由器）转发——网关是连接本地局域网与外部网络的“桥梁”，同时属于两个网络（本地局域网和外网），拥有两个IP和两个MAC（局域网侧IP/MAC、外网侧IP/MAC）。</p><h5 id="4-1-步骤1：获取网关的IP和MAC地址"><a href="#4-1-步骤1：获取网关的IP和MAC地址" class="headerlink" title="4.1 步骤1：获取网关的IP和MAC地址"></a>4.1 步骤1：获取网关的IP和MAC地址</h5><ul><li><p>网关IP的获取：主机通过DHCP自动获取（常见）或手动配置，存储在本地网络设置中；</p></li><li><p>网关MAC的获取：与同一局域网获取目标MAC逻辑一致，通过查询ARP缓存表或发送ARP广播获取网关IP对应的MAC地址。</p></li></ul><h5 id="4-2-步骤2：发送至网关"><a href="#4-2-步骤2：发送至网关" class="headerlink" title="4.2 步骤2：发送至网关"></a>4.2 步骤2：发送至网关</h5><p>主机将以太网帧的目标MAC填入网关的局域网侧MAC，源MAC填入本机MAC，发送至交换机，由交换机转发至网关。</p><h5 id="4-3-步骤3：网关的转发逻辑（跨网段核心）"><a href="#4-3-步骤3：网关的转发逻辑（跨网段核心）" class="headerlink" title="4.3 步骤3：网关的转发逻辑（跨网段核心）"></a>4.3 步骤3：网关的转发逻辑（跨网段核心）</h5><p>网关（路由器）收到帧后，会执行“剥帧-路由-重新封装”的核心流程：</p><ol><li><p>剥帧：路由器工作在网络层，会剥离链路层以太网帧头（MAC地址信息失效），查看IP头部的目标IP；</p></li><li><p>路由决策：查询自身路由表，确定目标IP对应的“下一跳网关”（可能是运营商路由器、骨干网路由器等）；</p></li><li><p>重新封装：通过ARP获取下一跳网关的MAC地址，将新的以太网帧头封装（源MAC为网关的外网侧MAC，目标MAC为下一跳网关的MAC），发送至下一跳；</p></li><li><p>重复转发：数据包在互联网中经过多个路由器接力转发，每一跳都重复“剥帧-路由-重新封装”，直到到达目标IP所在的局域网网关。</p></li></ol><h5 id="4-4-步骤4：NAT地址转换（家庭-企业网络必备）"><a href="#4-4-步骤4：NAT地址转换（家庭-企业网络必备）" class="headerlink" title="4.4 步骤4：NAT地址转换（家庭/企业网络必备）"></a>4.4 步骤4：NAT地址转换（家庭/企业网络必备）</h5><p>家庭/企业内网使用私有IP（如192.168.x.x），无法直接在互联网中路由。因此，网关在转发时会触发NAT（网络地址转换）：</p><ul><li><p>出口转换：将数据包的源IP从私有IP改为网关的公网IP，同时记录“私有IP:端口-公网IP:端口”的映射关系（NAT表）；</p></li><li><p>入口转换：当目标IP的响应包返回至网关时，网关通过NAT表反向查询，将目标IP改为对应的内网私有IP，目标MAC改为该主机的MAC，转发至目标主机。</p></li></ul><p>核心要点：NAT仅发生在本地网关的出口处，是私有IP访问互联网的必要条件；源IP在NAT转换后，在互联网传输过程中保持不变，直到到达目标局域网。</p><h5 id="4-5-步骤5：目标局域网内的最后一跳"><a href="#4-5-步骤5：目标局域网内的最后一跳" class="headerlink" title="4.5 步骤5：目标局域网内的最后一跳"></a>4.5 步骤5：目标局域网内的最后一跳</h5><p>当数据包到达目标IP所在的局域网网关后，网关会再次执行“剥帧-路由”，发现目标IP在当前局域网内，通过ARP获取目标主机的MAC地址，重新封装帧后发送至目标主机，完成全链路传输。</p><h4 id="五、关键设备分工总结"><a href="#五、关键设备分工总结" class="headerlink" title="五、关键设备分工总结"></a>五、关键设备分工总结</h4><div class="table-container"><table><thead><tr><th>设备</th><th>工作层级</th><th>核心职责</th><th>关键特性</th></tr></thead><tbody><tr><td>主机</td><td>网络层+链路层</td><td>封装网络包、ARP查询/广播、判断目标IP网段</td><td>维护ARP缓存表，不直接跨网段转发</td></tr><tr><td>交换机</td><td>链路层</td><td>根据MAC地址表转发帧、泛洪未知MAC帧、学习源MAC</td><td>不识别IP地址，不隔离广播域（二层交换机）</td></tr><tr><td>路由器（网关）</td><td>网络层+链路层</td><td>路由决策、跨网段转发、NAT转换、隔离广播域</td><td>丢弃广播包，同时属于多个网络，维护路由表</td></tr></tbody></table></div><h4 id="六、全流程核心总结（思维导图式）"><a href="#六、全流程核心总结（思维导图式）" class="headerlink" title="六、全流程核心总结（思维导图式）"></a>六、全流程核心总结（思维导图式）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">封装完成网络包</span><br><span class="line">├─ 决策：目标IP是否在同一局域网？</span><br><span class="line">│  ├─ 是：</span><br><span class="line">│  │  ├─ 查询ARP缓存表 → 有目标MAC？</span><br><span class="line">│  │  │  ├─ 是：封装帧（目标MAC=目标主机MAC）→ 交换机转发 → 目标主机</span><br><span class="line">│  │  │  └─ 否：ARP广播获取目标MAC → 存入缓存 → 封装转发</span><br><span class="line">│  └─ 否：</span><br><span class="line">│     ├─ 获取网关IP（DHCP/手动配置）</span><br><span class="line">│     ├─ 获取网关MAC（ARP查询/广播）</span><br><span class="line">│     ├─ 封装帧（目标MAC=网关MAC）→ 交换机转发 → 网关</span><br><span class="line">│     ├─ 网关NAT：源IP从私有IP改为公网IP</span><br><span class="line">│     ├─ 网关路由决策 → 转发至下一跳（互联网多路由器接力）</span><br><span class="line">│     ├─ 到达目标局域网网关 → 剥帧路由 → 获取目标主机MAC</span><br><span class="line">│     └─ 转发至目标主机</span><br><span class="line">└─ 核心不变量：目标IP全程不变；核心变量：MAC地址每跳更新</span><br></pre></td></tr></table></figure><h4 id="七、关键疑问解答（补充思考）"><a href="#七、关键疑问解答（补充思考）" class="headerlink" title="七、关键疑问解答（补充思考）"></a>七、关键疑问解答（补充思考）</h4><ul><li><p>Q：如果指定的MAC地址不在局域网内怎么办？<br>A：主机发送前会通过ARP验证，若ARP广播无响应，会判定“目标不可达”，直接报错，数据包不会发送。</p></li><li><p>Q：交换机有ARP吗？知道IP对应MAC吗？<br>A：二层交换机无ARP，不识别IP，仅通过MAC地址转发；三层交换机集成路由功能，才会有ARP表。</p></li><li><p>Q：ARP是广播，如何隔离广播域？<br>A：路由器会丢弃广播包，不跨网段转发，因此广播域被路由器隔离，仅在当前局域网内传播。</p></li></ul><h4 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h4><p>网络包从封装完成到送达目标IP的过程，本质是“IP地址导航+MAC地址定位”的协同过程，涉及ARP寻址、交换机泛洪/转发、路由器路由/NAT等核心机制。理解这一过程的关键，是分清网络层与链路层的职责边界，以及各设备的分工逻辑——IP负责“找终点”，MAC负责“找下一跳”，交换机管“局域网内搬运”，路由器管“跨网段导航+隔离广播”，最终实现数据包的精准传输。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结（二）</title>
      <link href="/posts/d323df1a.html"/>
      <url>/posts/d323df1a.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结（二）"><a href="#算法总结（二）" class="headerlink" title="算法总结（二）"></a>算法总结（二）</h1><h2 id="异或运算的骚操作"><a href="#异或运算的骚操作" class="headerlink" title="异或运算的骚操作"></a>异或运算的骚操作</h2><h3 id="异或解释"><a href="#异或解释" class="headerlink" title="异或解释"></a>异或解释</h3><ol><li>异或运算，相同的值异或为0，不同的值异或为1</li><li>也可以理解为无进位的加法</li><li>异或运算满足交换律，结合律</li><li>一个数组中所有数的异或和 跟 某些数异或的结果 相当于 减去某些数的异或和</li></ol><h3 id="使用异或进行交换两个数"><a href="#使用异或进行交换两个数" class="headerlink" title="使用异或进行交换两个数"></a>使用异或进行交换两个数</h3><ol><li>a = a^b</li><li>b = a^b (此时相当于a^b^b = a , 就让b等于a)</li><li>a = a^b (此时相当于a^b^a = b , 就让a等于b)</li></ol><p><em>局限性：注意这个交换不能对同一个地址的两个变量进行操作。因为第一步就会把他们都变为0</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">2323</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><h3 id="使用异或不用判断语句去判断两个数的大小"><a href="#使用异或不用判断语句去判断两个数的大小" class="headerlink" title="使用异或不用判断语句去判断两个数的大小"></a>使用异或不用判断语句去判断两个数的大小</h3><p>大体思路就是根据a-b的符号，来判断a和b的大小。<br>但是这样有溢出的风险（a-b会溢出）<br>优化思路：</p><ol><li>获取a和b的符号</li><li>获取c=a-b的符号</li><li>综合判断</li><li>如果a,b符号相同，则不可能溢出，直接根据c的符号来判断大小</li><li>如果a,b符号不同，则a-b可能会溢出，判断a的符号 如果a是非负的，就可以直接返回a更大</li><li>除了以上两种情况，其余情况都返回b</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 必须保证n一定是0或者1</span></span><br><span class="line"><span class="comment">// 0变1，1变0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非负数返回1</span></span><br><span class="line"><span class="comment">// 负数返回0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> flip(n &gt;&gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有溢出风险的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line"><span class="comment">// c非负，returnA -&gt; 1</span></span><br><span class="line"><span class="comment">// c非负，returnB -&gt; 0</span></span><br><span class="line"><span class="comment">// c负数，returnA -&gt; 0</span></span><br><span class="line"><span class="comment">// c负数，returnB -&gt; 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> sign(c);</span><br><span class="line"><span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line"><span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有任何问题的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="comment">// c可能是溢出的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line"><span class="comment">// a的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sa</span> <span class="operator">=</span> sign(a);</span><br><span class="line"><span class="comment">// b的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> sign(b);</span><br><span class="line"><span class="comment">// c的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sc</span> <span class="operator">=</span> sign(c);</span><br><span class="line"><span class="comment">// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">diffAB</span> <span class="operator">=</span> sa ^ sb;</span><br><span class="line"><span class="comment">// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sameAB</span> <span class="operator">=</span> flip(diffAB);</span><br><span class="line"><span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> diffAB * sa + sameAB * sc;</span><br><span class="line"><span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line"><span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异或去返回出现了奇数次的数（其余数都出现了偶数次）"><a href="#使用异或去返回出现了奇数次的数（其余数都出现了偶数次）" class="headerlink" title="使用异或去返回出现了奇数次的数（其余数都出现了偶数次）"></a>使用异或去返回出现了奇数次的数（其余数都出现了偶数次）</h3><p>思路很简单，就是把所有的数异或一遍，最后剩下的数就是出现了奇数次的数。<br>因为异或满足交换律。凡是出现偶数次的数，异或结果都为0，最后结果就是奇数次的数^0 = 奇数次的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">eor ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）"><a href="#使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）" class="headerlink" title="使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）"></a>使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）</h3><p>思路：(假设那两个数为a和b)</p><ol><li>先将数组中所有数异或一遍，得到一个数xor1=a^b</li><li>找到xor1最右边的1，即xor1 &amp; (-xor1) (解释：xor1 &amp; (-xor1)可以获取xor1最右边的1。并且这个1就是a跟b肯定不一样的数位（当然不只这一个，但是只需要这一个我们就可以区分它们了）)</li><li>将数组中所有数分为两组，一组是xor1最右边的1为1的数，一组是xor1最右边的1为0的数 （a,b肯定在不同的组中）</li><li>对其中一组数异或，得到XOR2  (XOR可能是a也有可能是b) （每组还是满足除了a,b之外所有数出现次数都是偶数）</li><li>讲XOR2与XOR1异或，得到另一个数 （XOR2^XOR1=a^b^b=a (假设XOR是b)）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="comment">// nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次</span></span><br><span class="line">eor1 ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eor1 : a ^ b</span></span><br><span class="line"><span class="comment">// Brian Kernighan算法</span></span><br><span class="line"><span class="comment">// 提取出二进制里最右侧的1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor1 &amp; (-eor1);</span><br><span class="line"><span class="type">int</span> <span class="variable">eor2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> ((num &amp; rightOne) == <span class="number">0</span>) &#123;</span><br><span class="line">eor2 ^= num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; eor2, eor1 ^ eor2 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他位运算的骚操作"><a href="#其他位运算的骚操作" class="headerlink" title="其他位运算的骚操作"></a>其他位运算的骚操作</h2><h3 id="判断一个数是不是2的幂"><a href="#判断一个数是不是2的幂" class="headerlink" title="判断一个数是不是2的幂"></a>判断一个数是不是2的幂</h3><p>原理： 如果是2的幂，那么二进制数只有一位为1，其他为0 。这时候我们用a&amp;-a 拿到到的数，就是a最右边的1。然后判断a是不是等于a&amp;-a 等于的话，那么a就是2的幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; <span class="number">0</span> &amp;&amp; a==(a&amp;-a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是不是三的幂"><a href="#判断一个数是不是三的幂" class="headerlink" title="判断一个数是不是三的幂"></a>判断一个数是不是三的幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子</span></span><br><span class="line"><span class="comment">// 1162261467是int型范围内，最大的3的幂，它是3的19次方</span></span><br><span class="line"><span class="comment">// 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么</span></span><br><span class="line"><span class="comment">// 1162261467 % n == 0</span></span><br><span class="line"><span class="comment">// 反之如果1162261467 % n != 0 说明n一定含有其他因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回大于等于n的最小的2某次方"><a href="#返回大于等于n的最小的2某次方" class="headerlink" title="返回大于等于n的最小的2某次方"></a>返回大于等于n的最小的2某次方</h3><p>先对n-1 然后把n最左边的1一直让右边全变为1.最后的答案就是n+1 (00111111 -&gt; 01000000)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">near2power</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="此区间内所有数字-amp-的结果-连续"><a href="#此区间内所有数字-amp-的结果-连续" class="headerlink" title="此区间内所有数字 &amp; 的结果(连续)"></a>此区间内所有数字 &amp; 的结果(连续)</h3><p>形如 0111001000 如果此时还存在一个比自己还小的数，那么我最右边的1肯定会被与运算变成0.直到最小的数都大于我，我的最右侧的1才能保留下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">right -= right &amp; -right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计一个数的二进制中1的个数"><a href="#统计一个数的二进制中1的个数" class="headerlink" title="统计一个数的二进制中1的个数"></a>统计一个数的二进制中1的个数</h3><p>具体思路参考 【算法讲解031【必备】位运算的骚操作】<a href="https://www.bilibili.com/video/BV1ch4y1Q7vd?vd_source=c6cdeb45f015e4ab4447a6c61482633a">https://www.bilibili.com/video/BV1ch4y1Q7vd?vd_source=c6cdeb45f015e4ab4447a6c61482633a</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cntOnes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算实现加减乘除操作"><a href="#位运算实现加减乘除操作" class="headerlink" title="位运算实现加减乘除操作"></a>位运算实现加减乘除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == MIN &amp;&amp; b == MIN) &#123;</span><br><span class="line"><span class="comment">// a和b都是整数最小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != MIN &amp;&amp; b != MIN) &#123;</span><br><span class="line"><span class="comment">// a和b都不是整数最小，那么正常去除</span></span><br><span class="line"><span class="keyword">return</span> div(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == MIN) &#123;</span><br><span class="line"><span class="comment">// a不是整数最小，b是整数最小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了</span></span><br><span class="line"><span class="keyword">if</span> (b == neg(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是整数最小，b不是整数最小，b也不是-1</span></span><br><span class="line">a = add(a, b &gt; <span class="number">0</span> ? b : neg(b));</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> div(a, b);</span><br><span class="line"><span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> b &gt; <span class="number">0</span> ? neg(<span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> add(ans, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须保证a和b都不是整数最小值，返回a除以b的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a &lt; <span class="number">0</span> ? neg(a) : a;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> b &lt; <span class="number">0</span> ? neg(b) : b;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &gt;= <span class="number">0</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">x = minus(x, y &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a &lt; <span class="number">0</span> ^ b &lt; <span class="number">0</span> ? neg(ans) : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ans : a和b无进位相加的结果</span></span><br><span class="line">ans = a ^ b;</span><br><span class="line"><span class="comment">// b : a和b相加时的进位信息</span></span><br><span class="line">b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">a = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(a, neg(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种乘法后面有大用处，尤其是求(a的b次方 % m)的结果，也叫龟速乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 考察b当前最右的状态！</span></span><br><span class="line">ans = add(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">b &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结（一）</title>
      <link href="/posts/e33533c2.html"/>
      <url>/posts/e33533c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结（一）"><a href="#算法总结（一）" class="headerlink" title="算法总结（一）"></a>算法总结（一）</h1><h2 id="归并分治"><a href="#归并分治" class="headerlink" title="归并分治"></a>归并分治</h2><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ol><li>左边结果+右边结果+跨越两边的结果是否等于最终结果</li><li>对于两边排序之后对于统计跨越两边的结果是否有帮助</li></ol><h3 id="注意与总结"><a href="#注意与总结" class="headerlink" title="注意与总结"></a>注意与总结</h3><ol><li>主要思想跟归并排序一样 只不过是在merge的时候进行一些额外统计操作（统计跨越两边的结果）</li><li>如果只是单纯的比大小（比如 小和，逆序对）可以直接在merge的时候进行比较<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小和 直接在合并的时候进行比较统计</span></span><br><span class="line">        <span class="keyword">while</span>(a &lt;=m &amp;&amp; b&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]&lt;nums[b])&#123;</span><br><span class="line">                help[i++] = nums[a];</span><br><span class="line">                sum+= (nums[a]*(r-b+<span class="number">1</span>));</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                help[i++] = nums[b++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>如果不只是比大小 而是比较乘以二倍的结果，那么就需要在merge的时候 添加额外的统计操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当左边的数大于右边的两倍时进行统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ll=l,rr=m+<span class="number">1</span>;ll&lt;=m;ll++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(rr&lt;=r &amp;&amp; (<span class="type">long</span>)nums[ll]&gt;((<span class="type">long</span>)nums[rr]&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                rr++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="两种partition-普通-荷兰国旗"><a href="#两种partition-普通-荷兰国旗" class="headerlink" title="两种partition (普通+荷兰国旗)"></a>两种partition (普通+荷兰国旗)</h3><ol><li>普通partition 一次只能确定一个数的位置</li></ol><p>核心思想：初始化索引i a xi<br>1.1 遍历数组，如果当前数小于等于x，则交换i和a数 i++ a++<br>1.2 如果大于x，则i++ a不动<br>1.3 如果遇到nums[a] == x,用xi记录他的位置<br>1.4 遍历结束后，交换xi和a-1的位置，让x放到对应的位置。<br>1.5 返回a-1（x应该在的位置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个区号 小于等于   大于</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= x)&#123;</span><br><span class="line">                swap(nums,a,i);</span><br><span class="line">                <span class="keyword">if</span>(nums[a] == x)&#123;</span><br><span class="line">                    xi = a;</span><br><span class="line">                &#125;</span><br><span class="line">                a++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,xi,a-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>荷兰国旗partition 一次可以确定多个相同的数的位置</li></ol><p>核心思路：初始化索引i a(小于区间) b（大于区间）<br>1.1 遍历数组，如果当前数小于x，则交换i和a数 i++ a++<br>1.2 如果大于x，则i不动 b—<br>1.3 如果等于x，则i++<br>1.4 遍历结束后，a-1（小于区间的末尾） b+1（大于区间的开头） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first,last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个区间 小于  大于   等于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=l;</span><br><span class="line">    <span class="type">int</span> b=r;</span><br><span class="line">    <span class="type">int</span> i=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; x)&#123;</span><br><span class="line">            swap(nums,a++,i++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x)&#123;</span><br><span class="line">            swap(nums,i,b--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first = a;</span><br><span class="line">    last = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-快速选择"><a href="#扩展-快速选择" class="headerlink" title="扩展 快速选择"></a>扩展 快速选择</h3><p>快速选择：给定一个数组，返回第k小的数</p><ol><li>快速排序的思想，partition之后，如果在当前区间内的排名大于指定的排名，则递归quickselect(l,left-1,k)</li><li>快速排序的思想，partition之后，如果在当前区间内的排名小于指定的排名，则递归quickselect(right+1,r,k-rightNow)  (rightNow指定的数在当前区间内的最靠右的排名)</li><li>快速排序的思想，partition之后，如果在当前区间内的排名等于指定的排名，则返回用于partition的数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">partitor</span> <span class="operator">=</span> nums[l+ (<span class="type">int</span>)(Math.random()*(r-l+<span class="number">1</span>))];</span><br><span class="line">    <span class="comment">//荷兰国旗</span></span><br><span class="line">    partition2(nums,l,r,partitor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftNow</span> <span class="operator">=</span> left -l +<span class="number">1</span>; <span class="comment">//当前区间内partitor靠左的排名（可能存在多个partitor）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightNow</span> <span class="operator">=</span> right -l+<span class="number">1</span>; <span class="comment">//当前区间内partitor靠右的排名</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;leftNow)&#123; <span class="comment">//要找的位置在左边 再去左边找</span></span><br><span class="line">        <span class="keyword">return</span> quick(nums,l,left-<span class="number">1</span>,pos);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;rightNow)&#123; <span class="comment">//要找的位置在右边 再去右边找</span></span><br><span class="line">        <span class="keyword">return</span> quick(nums,right+<span class="number">1</span>,r,pos-rightNow);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//要找的位置在中间 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nums[pos+l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序本身没什么好说的，就是利用堆这个数据结构进行排序。这里重点说一下heapify 跟 heapInsert</p><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>将节点下移到合适的位置，直接贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// i位置的数，变小了，又想维持大根堆结构</span></span><br><span class="line"><span class="comment">// 向下调整大根堆</span></span><br><span class="line"><span class="comment">// 当前堆的大小为size</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; size) &#123;</span><br><span class="line"><span class="comment">// 有左孩子，l</span></span><br><span class="line"><span class="comment">// 右孩子，l+1</span></span><br><span class="line"><span class="comment">// 评选，最强的孩子，是哪个下标的孩子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> l + <span class="number">1</span> &lt; size &amp;&amp; arr[l + <span class="number">1</span>] &gt; arr[l] ? l + <span class="number">1</span> : l;</span><br><span class="line"><span class="comment">// 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁</span></span><br><span class="line">best = arr[best] &gt; arr[i] ? best : i;</span><br><span class="line"><span class="keyword">if</span> (best == i) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, best, i);</span><br><span class="line">i = best;</span><br><span class="line">l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也有递归的版本也很简单，这里不详细说了。</p><p>此外使用heapify可以自底向上的构建堆 时间复杂度为O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapify(arr, i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="heapInsert"><a href="#heapInsert" class="headerlink" title="heapInsert"></a>heapInsert</h3><p>将节点上移到合适位置，直接贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// i位置的数，变大了，又想维持小根堆结构</span></span><br><span class="line"><span class="comment">// 向上调整小根堆</span></span><br><span class="line"><span class="comment">// 当前堆的大小为size</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">i = (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外使用heapInsert可以自上到下的构建堆 时间复杂度为O(n*logn) (不如上面的方法)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">heapInsert(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用堆结构去解决一些其他问题"><a href="#利用堆结构去解决一些其他问题" class="headerlink" title="利用堆结构去解决一些其他问题"></a>利用堆结构去解决一些其他问题</h3><h4 id="1-合并k个有序链表"><a href="#1-合并k个有序链表" class="headerlink" title="1. 合并k个有序链表"></a>1. 合并k个有序链表</h4><ol><li>创建一个最小堆，将k个链表的头节点加入堆中</li><li>弹出最小的节点，并加入到结果链表中</li><li>弹出的节点的next节点加入堆中</li><li>重复2-3，直到堆为空</li><li>返回结果链表</li></ol><p>复杂度 O(n*logk)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode listNode : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.add(listNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span>h;</span><br><span class="line">    <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        heap.add(pre.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">        pre.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            heap.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-线段最多重合问题"><a href="#2-线段最多重合问题" class="headerlink" title="2. 线段最多重合问题"></a>2. 线段最多重合问题</h4><p> 线段最多重合问题，就是给定很多线段，求线段最多重合的次数 </p><ol><li>将所有线段按开始的点进行排序</li><li>依次开始遍历线段</li><li>弹出堆中的最小点，如果最小点小于当前线段的开始点，则说明在当前线段开始时，这里面的线段已经结束不会重合。弹出堆中的最小点</li><li>循环3步直到堆里面的元素不小于当前线段的开始点。</li><li>将当前线段的结束点加入最小堆中</li><li>当前最小堆的size就是以这个线段开始为重合开始区间的重合的次数，用这个跟记录的最大次数进行比较，更新最大次数</li><li>循环2-6，直到所有线段都遍历结束</li><li>返回最大次数</li></ol><p>时间复杂度  O(n*logn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 堆的清空</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段一共有n条，line[0...n-1][2] : line[i][0] line[i][1], 左闭右闭</span></span><br><span class="line"><span class="comment">// 所有线段，根据开始位置排序，结束位置无所谓</span></span><br><span class="line"><span class="comment">// 比较器的用法</span></span><br><span class="line"><span class="comment">// line [0...n) 排序 : 所有小数组，开始位置谁小谁在前</span></span><br><span class="line">Arrays.sort(line, <span class="number">0</span>, n, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// i : line[i][0] line[i][1]</span></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; heap[<span class="number">0</span>] &lt;= line[i][<span class="number">0</span>]) &#123;</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line">add(line[i][<span class="number">1</span>]);</span><br><span class="line">ans = Math.max(ans, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-累加和减半最小操作次数"><a href="#3-累加和减半最小操作次数" class="headerlink" title="3.累加和减半最小操作次数"></a>3.累加和减半最小操作次数</h4><p>给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择任意一个数并将它减小到恰好一半。（注意，在后续操作中你可以对减半过的数继续执行操作）<br>请你返回将 nums 数组和至少减少一半的最少操作数。</p><p>思路： 其实就是贪心算法，每次把最大的数减到一半，直到和减少到一半。其中找最大的数就可以用大根堆来实现。</p><ol><li>创建一个大根堆，将数组中的数放入大根堆中。</li><li>取出最大的数，除以2 ，操作数++，并判断和是否减少到一半。如果和减少到一半，则返回当前操作数。</li><li>循环第二步。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">halveArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">PriorityQueue&lt;Double&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">heap.add((<span class="type">double</span>) num);</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum，整体累加和，-&gt; 要减少的目标！</span></span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">minus</span> <span class="operator">=</span> <span class="number">0</span>, cur; minus &lt; sum; ans++, minus += cur) &#123;</span><br><span class="line">cur = heap.poll() / <span class="number">2</span>;</span><br><span class="line">heap.add(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化思路：可以自己实现大根堆，并且不用Double类型，用long类型将所有数乘以2的20次方，相当于小数部分可以保留20位，可以精确到小数点后20位。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>原理很简单 不细说 主要说说感悟</p><p>为什么要逆序遍历 Array：</p><ol><li>排序的稳定性：<br>在基数排序的实现中，逆序访问原数组 arr 的目的是为了保证排序的稳定性。稳定性是指排序算法在处理相等元素时能够保持它们在原数组中的相对顺序不变。<br>在循环中，我们逆序遍历原数组 arr。这样做的好处是，当存在相等的元素时，先出现的元素会先放入对应的位置，而后出现的相等元素会放在它们之后的位置。这样可以保证相等元素的相对顺序不变，从而保证了排序的稳定性。<br>如果我们采用顺序访问 arr 的方式，那么在处理相等元素时，后出现的相等元素可能会先放入对应的位置，从而打破了它们在原数组中的相对顺序，导致排序不稳定。<br>因此，为了确保排序的稳定性，我们需要在逆序遍历原数组 arr 的情况下进行元素的放置操作。</li><li>自己的理解：<br>2.1 基数排序，是基于数字的每一位（从低位到高位）进行排序，每一位的排序 基于 上一位（较低位）排好的基础上<br>2.2 先将所有元素按照低位排序，再保持低位位序不变的情况下去排高位的位序（能让已经排好的低位的位序变化的原因只能受高位数值的影响）<br>2.3 如果是顺序排序，那么低位顺序的改变不仅仅受到高位数值的影响，也受到错位的影响<br>2.4 错位的影响：有数组：arr【 11 , 12 , 13 , 14 , 15】<br>低位序已经排好，如果按照高位顺序遍历，会导致数组变成 【15 , 14 , 13 , 12 , 11】<br>使得原先在 15 之前的 11 排在了 15 之后<br>这种错位的影响是 顺序遍历 和 使用词频统计方法往Help中放元素(逆序) 相互作用决定的</li></ol><h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/blog1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>feign的三种异常处理关系</title>
      <link href="/posts/20b8d2ff.html"/>
      <url>/posts/20b8d2ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"><a href="#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘" class="headerlink" title="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"></a>Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘</h1><p>在微服务架构中，Feign作为声明式HTTP客户端，是服务间调用的核心组件。而异常处理是保障微服务稳定性的关键环节——当Feign调用下游服务抛出异常时，我们常通过 <code>ErrorDecoder</code>、容错组件的 <code>Fallback</code>（如Sentinel/Hystrix）、Spring全局异常捕获器（<code>@RestControllerAdvice</code>）三种方式处理异常。但三者并存时，执行顺序如何？优先级背后的原理是什么？特殊场景下又会出现哪些变化？本文将结合实践拆解这一核心问题。</p><h2 id="一、核心结论：三者的优先执行顺序"><a href="#一、核心结论：三者的优先执行顺序" class="headerlink" title="一、核心结论：三者的优先执行顺序"></a>一、核心结论：三者的优先执行顺序</h2><p>当Feign调用发生异常（非2xx HTTP状态码、超时、网络异常等）时，三者的执行优先级从高到低依次为：</p><p><strong>ErrorDecoder（Feign原生） → Fallback（容错组件） → 全局异常捕获器（Spring MVC）</strong></p><p>完整执行链路可概括为：</p><blockquote><p>Feign调用触发异常 → ResponseInterceptor（OpenFeign 12.0+ 可选预处理） → ErrorDecoder（异常解码/转换） → 容错组件拦截异常 → Fallback（异常兜底，返回正常数据） → （Fallback失效时）全局异常捕获器 → （均未处理时）向上抛出原始异常</p></blockquote><p>其中，前两者属于Feign调用链路的“前置处理”，全局异常捕获器属于“后置兜底”，且Fallback默认会阻断异常向上传播，使全局异常捕获器无法触发。</p><h2 id="二、优先级原理：层级与职责边界决定执行顺序"><a href="#二、优先级原理：层级与职责边界决定执行顺序" class="headerlink" title="二、优先级原理：层级与职责边界决定执行顺序"></a>二、优先级原理：层级与职责边界决定执行顺序</h2><p>三者优先级的本质的是执行层级和职责边界的差异，不同层级对应不同的异常处理目标，形成了“层层拦截、各司其职”的链路。</p><h3 id="1-第一优先级：ErrorDecoder（Feign原生扩展点）"><a href="#1-第一优先级：ErrorDecoder（Feign原生扩展点）" class="headerlink" title="1. 第一优先级：ErrorDecoder（Feign原生扩展点）"></a>1. 第一优先级：ErrorDecoder（Feign原生扩展点）</h3><p><code>ErrorDecoder</code> 是Feign原生提供的异常解码扩展点，属于「Feign调用响应处理层级」，是异常进入业务链路前的“第一道关口”。</p><p>其核心职责是：拦截Feign调用返回的非2xx异常响应，将Feign默认抛出的 <code>FeignException</code>（包含杂乱的HTTP响应信息）转换为标准化的自定义业务异常，同时可解析异常响应体、提取下游服务异常详情，为后续处理提供统一的异常格式。</p><p>优先级最高的原因的是：它直接嵌入Feign的响应处理流程，在异常被传递给业务层或容错组件前，就完成了解码和转换。后续的Fallback和全局异常捕获器，处理的都是经过它转换后的异常（或未自定义时的默认异常）。</p><h3 id="2-第二优先级：Fallback（容错组件能力）"><a href="#2-第二优先级：Fallback（容错组件能力）" class="headerlink" title="2. 第二优先级：Fallback（容错组件能力）"></a>2. 第二优先级：Fallback（容错组件能力）</h3><p><code>Fallback</code> 是Sentinel、Hystrix、Resilience4j等容错组件提供的兜底能力，属于「微服务容错防护层级」，是异常传播的“第二道关口”。</p><p>其核心职责是：通过AOP或代理模式，拦截Feign调用/业务方法抛出的异常（已被ErrorDecoder处理），将“异常结果”转换为“合法的业务返回数据”，消化异常以防止服务雪崩，同时避免业务层手动try-catch。</p><p>优先级高于全局异常捕获器的原因的是：它在异常产生点附近直接拦截，且处理后返回正常数据——异常被完全“消化”，不再向上传播，导致全局异常捕获器失去触发前提（全局异常捕获器仅处理未被拦截的传播异常）。</p><h3 id="3-第三优先级：全局异常捕获器（Spring-MVC层级）"><a href="#3-第三优先级：全局异常捕获器（Spring-MVC层级）" class="headerlink" title="3. 第三优先级：全局异常捕获器（Spring MVC层级）"></a>3. 第三优先级：全局异常捕获器（Spring MVC层级）</h3><p>全局异常捕获器（基于 <code>@RestControllerAdvice</code> + <code>@ExceptionHandler</code>）是Spring MVC提供的全局能力，属于「应用层异常兜底层级」，是异常处理的“最后一道关口”。</p><p>其核心职责是：捕获所有向上传播到Controller层及以上的未处理异常，统一返回标准化错误响应，避免裸异常暴露给前端。</p><p>优先级最低的原因的是：它的执行依赖“异常未被前置逻辑处理且成功传播”，而Fallback通常会提前消化异常，只有在Fallback失效时，它才会补位生效。</p><h2 id="三、实战验证：直观感受执行顺序"><a href="#三、实战验证：直观感受执行顺序" class="headerlink" title="三、实战验证：直观感受执行顺序"></a>三、实战验证：直观感受执行顺序</h2><p>我们以「OpenFeign 12.0+ + Sentinel + Spring Boot」为例，通过代码验证三者的执行顺序，同时覆盖正常场景与特殊场景。</p><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>依赖核心组件：OpenFeign（12.0+）、Spring Cloud Alibaba Sentinel、Spring Web。</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><h4 id="（1）自定义ErrorDecoder（第一优先级）"><a href="#（1）自定义ErrorDecoder（第一优先级）" class="headerlink" title="（1）自定义ErrorDecoder（第一优先级）"></a>（1）自定义ErrorDecoder（第一优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【1. 执行 ErrorDecoder】：解码Feign异常，状态码=&quot;</span> + response.status());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorBody</span> <span class="operator">=</span> Util.toString(response.body().asReader(Util.UTF_8));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;服务调用异常（ErrorDecoder转换）：&quot;</span> + errorBody);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义业务异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）配置Fallback（第二优先级）"><a href="#（2）配置Fallback（第二优先级）" class="headerlink" title="（2）配置Fallback（第二优先级）"></a>（2）配置Fallback（第二优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Feign接口</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-service&quot;, fallback = ProviderFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/provider/getData&quot;)</span></span><br><span class="line">    String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback兜底类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id + <span class="string">&quot;（服务调用异常）&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）全局异常捕获器（第三优先级）"><a href="#（3）全局异常捕获器（第三优先级）" class="headerlink" title="（3）全局异常捕获器（第三优先级）"></a>（3）全局异常捕获器（第三优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleAllException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【3. 执行全局异常捕获器】：捕获异常：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;全局兜底：&quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）业务调用层"><a href="#（4）业务调用层" class="headerlink" title="（4）业务调用层"></a>（4）业务调用层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProviderClient providerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getData&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providerClient.getData(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-场景测试结果"><a href="#3-场景测试结果" class="headerlink" title="3. 场景测试结果"></a>3. 场景测试结果</h3><h4 id="（1）正常场景：三者并存，Fallback正常触发"><a href="#（1）正常场景：三者并存，Fallback正常触发" class="headerlink" title="（1）正常场景：三者并存，Fallback正常触发"></a>（1）正常场景：三者并存，Fallback正常触发</h4><p>当下游服务抛出异常时，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br></pre></td></tr></table></figure><p>接口返回：<code>兜底数据：id=123（服务调用异常）</code>，全局异常捕获器未触发（被Fallback阻断）。</p><h4 id="（2）特殊场景：Fallback自身抛出异常"><a href="#（2）特殊场景：Fallback自身抛出异常" class="headerlink" title="（2）特殊场景：Fallback自身抛出异常"></a>（2）特殊场景：Fallback自身抛出异常</h4><p>修改Fallback逻辑，故意抛出空指针异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nullStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        nullStr.length(); <span class="comment">// 空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：null</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：null</code>，Fallback异常向上传播，触发全局异常捕获器。</p><h4 id="（3）特殊场景：Fallback未触发（配置失效）"><a href="#（3）特殊场景：Fallback未触发（配置失效）" class="headerlink" title="（3）特殊场景：Fallback未触发（配置失效）"></a>（3）特殊场景：Fallback未触发（配置失效）</h4><p>若未开启Sentinel与Feign的整合（未配置 <code>feign.sentinel.enabled=true</code>），Fallback配置失效，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：服务调用异常（ErrorDecoder转换）：xxx</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：服务调用异常（ErrorDecoder转换）：xxx</code>，Fallback未触发，异常传播至全局捕获器。</p><h2 id="四、实践建议：三者协同的最佳姿势"><a href="#四、实践建议：三者协同的最佳姿势" class="headerlink" title="四、实践建议：三者协同的最佳姿势"></a>四、实践建议：三者协同的最佳姿势</h2><p>三者并非互斥关系，而是互补关系，合理搭配可实现“异常标准化+容错兜底+最终补位”的三层防护体系，提升微服务稳定性。</p><h3 id="1-分工明确，各司其职"><a href="#1-分工明确，各司其职" class="headerlink" title="1. 分工明确，各司其职"></a>1. 分工明确，各司其职</h3><ul><li><p><strong>ErrorDecoder</strong>：专注“异常标准化”，统一转换Feign原生异常为业务异常，解析异常详情，不做兜底逻辑；</p></li><li><p><strong>Fallback</strong>：专注“容错兜底”，针对核心服务调用，返回预设兜底数据（如缓存数据、默认值），防止服务雪崩；</p></li><li><p><strong>全局异常捕获器</strong>：专注“最终补位”，捕获所有漏网异常（Fallback异常、配置错误导致的异常），统一返回前端友好响应。</p></li></ul><h3 id="2-规避常见坑点"><a href="#2-规避常见坑点" class="headerlink" title="2. 规避常见坑点"></a>2. 规避常见坑点</h3><ul><li><p>Fallback方法签名必须与原方法一致（参数、返回值类型匹配），否则配置失效，异常直接传播；</p></li><li><p>Hystrix会忽略 <code>HystrixBadRequestException</code> 及 <code>ignoreExceptions</code> 配置的异常，这类异常不触发Fallback，需通过全局捕获器处理；</p></li><li><p>ErrorDecoder中避免抛出非业务异常，建议统一转换为自定义异常，便于Fallback和全局捕获器识别。</p></li></ul><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><ul><li>异常多层包装（含 Error 类型）会阻断 Spring 自动穿透。当异常链中存在 AssertionError 等 Error 类型异常时（如 Sentinel 整合 Feign 场景，在fallback函数中抛出RuntimeException异常会被Sentinel自动包装为AssertionError 继承 Error分支，然后又被Spring MVC DispatcherServlet自动抛出为NestedServletException异常），Spring 的 @ExceptionHandler 自动穿透功能仅支持 Exception 分支，无法穿透 Error 类型异常，导致自定义异常（CommonException）无法被精准捕获，最终被 Exception 兜底处理器捕获（或者被NestedServletException异常捕获器捕获）；</li><li><p>解决方案：手动解析完整的 Throwable 链（包含 Error 和 Exception），通过循环遍历 cause 链主动提取目标自定义异常，再手动分发到对应异常处理器；</p></li><li><p>下面是spring对于异常处理的源码。可以看见如果遇到非Exception的Throwable。它会自动抛出NestedServletException</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用处理器方法（Controller方法、Feign调用、Service方法等都在这一步执行）</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 捕获Exception类型异常，直接赋值给dispatchException，不包装</span></span><br><span class="line">    dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    <span class="comment">// 捕获Throwable类型（非Exception，如Error、AssertionError等），包装为NestedServletException</span></span><br><span class="line">    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-组件选择建议"><a href="#4-组件选择建议" class="headerlink" title="4. 组件选择建议"></a>4. 组件选择建议</h3><p>Hystrix已进入维护模式，推荐使用 <strong>Resilience4j</strong>（轻量、Spring官方推荐）或 <strong>Sentinel</strong>（阿里生态，支持流量控制、熔断降级等丰富特性）作为Fallback载体；OpenFeign 12.0+ 建议搭配 <code>ResponseInterceptor</code> 做响应日志预处理，与ErrorDecoder协同提升异常排查效率。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Feign异常处理的三重机制，本质是不同层级的“异常拦截-处理”链路：ErrorDecoder负责“入口标准化”，Fallback负责“中间容错”，全局异常捕获器负责“最终补位”。优先级的核心逻辑是“先处理异常、再消化异常、最后补位异常”。</p><p>在实际开发中，三者协同使用，既能保证异常处理的规范性和灵活性，又能提升微服务的高可用性，避免因单一异常处理机制失效导致的服务不稳定问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之间的全局异常捕获</title>
      <link href="/posts/df97f9d4.html"/>
      <url>/posts/df97f9d4.html</url>
      
        <content type="html"><![CDATA[<p>在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是500，错误信息固定为INTERNAL_SERVER_ERROR，全局异常捕获器形同虚设，尤其在微服务间通过OpenFeign调用API时，该问题更为突出。本文将围绕这一问题，从原因分析、解决方案到特殊场景适配，逐步拆解实战过程中的思考与踩坑。</p><h2 id="一、问题现象：单体架构异常捕获在微服务中失效"><a href="#一、问题现象：单体架构异常捕获在微服务中失效" class="headerlink" title="一、问题现象：单体架构异常捕获在微服务中失效"></a>一、问题现象：单体架构异常捕获在微服务中失效</h2><p>在单体应用中，我们通常会编写如下全局异常捕获器，针对不同业务异常返回自定义状态码和信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(e.getCode(), e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在微服务架构中，当服务A通过OpenFeign调用服务B，服务B抛出BusinessException并被自身全局异常捕获器处理，返回400状态码和自定义信息时，服务A接收到的响应却依然是500 INTERNAL_SERVER_ERROR，无法获取服务B返回的真实异常信息，导致异常排查困难，也无法根据真实异常类型做后续业务处理。</p><h2 id="二、根源分析：OpenFeign对非2XX响应的默认处理机制"><a href="#二、根源分析：OpenFeign对非2XX响应的默认处理机制" class="headerlink" title="二、根源分析：OpenFeign对非2XX响应的默认处理机制"></a>二、根源分析：OpenFeign对非2XX响应的默认处理机制</h2><p>问题的核心在于微服务间的调用方式——OpenFeign的异常处理逻辑。当被调用方（服务B）抛出异常后，其自身的全局异常捕获器会正常工作，返回自定义的非2XX状态码（如400、502）和错误信息。但调用方（服务A）通过OpenFeign调用时，OpenFeign有一个默认规则：<strong>对所有非2XX的HTTP响应，都会自动抛出FeignException异常</strong>。</p><p>这就导致服务A无法直接获取服务B返回的自定义异常信息，只能捕获到OpenFeign封装的FeignException，而该异常默认对应500 INTERNAL_SERVER_ERROR状态码，最终呈现出“所有异常都返回500”的现象。本质上是OpenFeign的默认异常转换，覆盖了被调用方的自定义异常响应。</p><h2 id="三、解决方案一：自定义ErrorDecoder处理状态码异常"><a href="#三、解决方案一：自定义ErrorDecoder处理状态码异常" class="headerlink" title="三、解决方案一：自定义ErrorDecoder处理状态码异常"></a>三、解决方案一：自定义ErrorDecoder处理状态码异常</h2><p>要解决上述问题，我们可以通过自定义ErrorDecoder接口实现，覆写decode方法，对不同状态码的响应进行差异化处理，还原被调用方的真实异常信息，甚至返回自定义异常类型。</p><h3 id="3-1-自定义ErrorDecoder实现"><a href="#3-1-自定义ErrorDecoder实现" class="headerlink" title="3.1 自定义ErrorDecoder实现"></a>3.1 自定义ErrorDecoder实现</h3><p>注意：decode方法的核心是<strong>返回FeignException，而非直接抛出异常</strong>，OpenFeign会对该返回值做进一步处理并传递给调用方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultErrorDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeignException</span>.InternalServerError(methodKey, response, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据响应状态码自定义异常</span></span><br><span class="line">        <span class="keyword">switch</span> (response.status()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                <span class="comment">// 解析响应体，封装自定义业务异常信息</span></span><br><span class="line">                <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">                <span class="keyword">return</span> FeignException.badRequest(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>)</span><br><span class="line">                        .reason(errorResponse.getMsg());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                <span class="keyword">return</span> FeignException.serviceUnavailable(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 其他状态码可按需扩展</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 默认使用OpenFeign原生解码器</span></span><br><span class="line">                <span class="keyword">return</span> defaultErrorDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-配置FeignConfig注册Bean"><a href="#3-2-配置FeignConfig注册Bean" class="headerlink" title="3.2 配置FeignConfig注册Bean"></a>3.2 配置FeignConfig注册Bean</h3><p>将自定义的CustomErrorDecoder配置为Spring Bean，纳入Feign的配置体系中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ErrorDecoder <span class="title function_">errorDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomErrorDecoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，当服务A通过OpenFeign调用服务B时，若服务B返回非2XX状态码，CustomErrorDecoder会解析响应体，返回对应状态码的FeignException，并携带真实错误信息，服务A即可通过捕获FeignException获取详细异常内容，再结合自身全局异常捕获器做进一步处理。</p><h2 id="四、特殊场景：基于业务状态码的响应处理"><a href="#四、特殊场景：基于业务状态码的响应处理" class="headerlink" title="四、特殊场景：基于业务状态码的响应处理"></a>四、特殊场景：基于业务状态码的响应处理</h2><p>上述方案适用于HTTP状态码区分异常的场景，但在实际项目开发中，很多团队会采用“统一HTTP状态码”的设计：所有接口均返回200 OK，异常信息通过响应体中的自定义业务状态码（如code字段）、msg字段区分，data字段存储业务数据，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">10001</span><span class="punctuation">,</span> <span class="comment">// 10001代表业务异常，200代表成功</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;参数校验失败&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种场景下，ErrorDecoder将完全失效——因为ErrorDecoder仅拦截HTTP状态码为4XX、5XX的响应，而当前所有请求的HTTP状态码都是200，无法触发自定义解码逻辑。此时需要寻找新的解决方案。</p><h2 id="五、解决方案二：CustomResponseInterceptor（版本限制）"><a href="#五、解决方案二：CustomResponseInterceptor（版本限制）" class="headerlink" title="五、解决方案二：CustomResponseInterceptor（版本限制）"></a>五、解决方案二：CustomResponseInterceptor（版本限制）</h2><p>针对HTTP 200响应中嵌入业务状态码的场景，可通过自定义ResponseInterceptor接口实现，覆写intercept方法，在响应返回后解析业务状态码，判断是否存在异常并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResponseInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ResponseInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intercept</span><span class="params">(Response response, Chain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析响应体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">            <span class="comment">// 根据业务状态码判断是否抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (errorResponse.getCode() != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorResponse.getCode(), errorResponse.getMsg());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(<span class="string">&quot;响应解析异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.proceed(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要在FeignConfig中配置该拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ResponseInterceptor <span class="title function_">responseInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomResponseInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该方案存在明显局限性：<strong>ResponseInterceptor接口仅在OpenFeign 12.0+版本中提供</strong>，对于一些基于低版本OpenFeign（如Spring Cloud Netflix早期版本）的老项目，无法使用该方案，兼容性较差。</p><h2 id="六、尝试方案：AOP拦截Feign调用（失效原因分析）"><a href="#六、尝试方案：AOP拦截Feign调用（失效原因分析）" class="headerlink" title="六、尝试方案：AOP拦截Feign调用（失效原因分析）"></a>六、尝试方案：AOP拦截Feign调用（失效原因分析）</h2><p>针对低版本OpenFeign无法使用ResponseInterceptor的问题，我尝试通过AOP切面，在Feign客户端调用API后，对响应结果进行解析，根据业务状态码抛出对应异常。但实际测试发现，AOP切面完全不生效，无法拦截Feign客户端的方法调用。</p><p>查阅资料后，明确了失效的核心原因：</p><ol><li><p><strong>Feign客户端的创建机制</strong>：Feign客户端是通过动态代理生成的，而非Spring容器管理的普通Bean，其代理逻辑由Feign自身控制。</p></li><li><p><strong>Spring AOP的拦截限制</strong>：Spring AOP默认采用JDK动态代理，仅能拦截Spring容器管理的Bean的方法调用，无法直接拦截Feign生成的动态代理对象。</p></li><li><p><strong>代理优先级问题</strong>：Feign动态代理的优先级高于Spring AOP代理，导致AOP切面无法切入Feign客户端的方法执行流程。</p></li></ol><p>即便尝试切换为CGLIB代理，也无法有效拦截Feign客户端的调用，该方案最终宣告失败。</p><h2 id="七、现状与思考：待解决的痛点"><a href="#七、现状与思考：待解决的痛点" class="headerlink" title="七、现状与思考：待解决的痛点"></a>七、现状与思考：待解决的痛点</h2><p>综合以上实践，目前针对微服务间异常捕获的解决方案存在明显的场景局限性：</p><ul><li><p>基于ErrorDecoder的方案：适用于HTTP状态码区分异常的场景，兼容性好，无版本限制，是目前最成熟的方案。</p></li><li><p>基于ResponseInterceptor的方案：适用于HTTP 200+业务状态码的场景，但仅支持OpenFeign 12.0+版本，老项目无法适配。</p></li><li><p>AOP方案：理论上可适配所有版本，但因Feign动态代理机制限制，无法生效，暂无可行的优化方向。</p></li></ul><p>对于“低版本OpenFeign + HTTP 200 + 业务状态码”的组合场景，目前仍没有优雅且兼容的解决方案。可以考虑在调用api的方法中，去接受api返回的响应结果，根据业务状态码判断是否抛出异常，但这种方案侵入性强，违背了面向切面编程的思想。</p><p>在此也欢迎各位同行分享实践经验，探讨更优的解决方案，共同完善微服务异常处理体系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>微服务间的异常捕获相比单体架构更复杂，核心难点在于OpenFeign的代理机制和响应处理逻辑。在实际开发中，建议优先采用“HTTP状态码+自定义响应体”的方式设计接口，通过CustomErrorDecoder实现异常透传，兼顾兼容性和优雅性；若因业务需求必须使用统一HTTP 200状态码，则需评估升级OpenFeign版本的可行性，或权衡侵入性方案的取舍。后续将持续关注OpenFeign的版本更新和社区实践，寻找更完善的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus的分页查询原理</title>
      <link href="/posts/3ecdcd9c.html"/>
      <url>/posts/3ecdcd9c.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-Plus分页查询底层原理"><a href="#MyBatis-Plus分页查询底层原理" class="headerlink" title="MyBatis-Plus分页查询底层原理"></a>MyBatis-Plus分页查询底层原理</h1><h3 id="一、分页查询的核心痛点与-MP-的解决方案"><a href="#一、分页查询的核心痛点与-MP-的解决方案" class="headerlink" title="一、分页查询的核心痛点与 MP 的解决方案"></a>一、分页查询的核心痛点与 MP 的解决方案</h3><p>在传统 MyBatis 开发中，分页实现往往需要手动拼接<code>LIMIT</code>语句（MySQL）或<code>ROWNUM</code>（Oracle），不仅繁琐且易出错，还存在两个核心问题：</p><ol><li><p><strong>SQL 侵入性强</strong>：业务 SQL 与分页语法耦合，切换数据库时需批量修改；</p></li><li><p><strong>总条数统计冗余</strong>：需手动编写 count 查询，且需处理复杂查询（如多表关联、分组统计）的 count 适配。</p></li></ol><p>MyBatis-Plus（以下简称 MP）的分页插件通过<strong>拦截器机制</strong>+<strong>数据库方言适配</strong>，实现了 “无侵入式分页”，其核心设计思路是：<strong>在 SQL 执行前动态改写 SQL，自动添加分页语法和 count 查询，同时封装分页结果</strong>。</p><h3 id="二、MP-分页的核心组件与依赖关系"><a href="#二、MP-分页的核心组件与依赖关系" class="headerlink" title="二、MP 分页的核心组件与依赖关系"></a>二、MP 分页的核心组件与依赖关系</h3><p>MP 分页功能的实现依赖 3 个核心组件，它们的协作流程决定了分页的底层逻辑：</p><div class="table-container"><table><thead><tr><th>组件名称</th><th>作用说明</th></tr></thead><tbody><tr><td><code>PaginationInnerInterceptor</code></td><td>核心拦截器，负责拦截 SQL 执行、改写 SQL、统计总条数（MP 3.4.0 + 推荐使用）</td></tr><tr><td><code>Page</code></td><td>分页参数载体，封装页码、每页条数、总条数、分页结果集等信息</td></tr><tr><td><code>Dialect</code></td><td>数据库方言接口，适配不同数据库的分页语法（如 MySQL 的 LIMIT、PostgreSQL 的 OFFSET）</td></tr></tbody></table></div><p><strong>依赖关系</strong>：<code>Page</code>传递分页参数 → <code>PaginationInnerInterceptor</code>拦截 SQL → 调用<code>Dialect</code>生成适配 SQL → 执行查询并封装结果。</p><h3 id="三、底层核心流程：从-SQL-拦截到结果返回"><a href="#三、底层核心流程：从-SQL-拦截到结果返回" class="headerlink" title="三、底层核心流程：从 SQL 拦截到结果返回"></a>三、底层核心流程：从 SQL 拦截到结果返回</h3><h4 id="1-拦截器触发条件"><a href="#1-拦截器触发条件" class="headerlink" title="1. 拦截器触发条件"></a>1. 拦截器触发条件</h4><p>MP 的分页插件本质是 MyBatis 的<code>Interceptor</code>接口实现类，通过<code>@Intercepts</code>注解指定拦截<code>StatementHandler</code>的<code>prepare</code>方法（SQL 预处理阶段）和<code>query</code>方法（结果查询阶段）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;),</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaginationInnerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InnerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 核心逻辑实现</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>mapper.selectPage(page, queryWrapper)</code>时，MyBatis 的插件链会触发该拦截器。</p><h4 id="2-SQL-动态改写原理"><a href="#2-SQL-动态改写原理" class="headerlink" title="2. SQL 动态改写原理"></a>2. SQL 动态改写原理</h4><p>这是分页功能的核心步骤，MP 会根据数据库方言，将原始查询 SQL 改写成 “分页查询 SQL” 和 “总条数查询 SQL”：</p><h5 id="（1）原始-SQL-示例（MySQL）"><a href="#（1）原始-SQL-示例（MySQL）" class="headerlink" title="（1）原始 SQL 示例（MySQL）"></a>（1）原始 SQL 示例（MySQL）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM user WHERE age &gt; 18</span><br></pre></td></tr></table></figure><h5 id="（2）分页-SQL-改写（添加-LIMIT）"><a href="#（2）分页-SQL-改写（添加-LIMIT）" class="headerlink" title="（2）分页 SQL 改写（添加 LIMIT）"></a>（2）分页 SQL 改写（添加 LIMIT）</h5><p>MP 通过<code>BoundSql</code>解析原始 SQL，拼接分页语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM user WHERE age &gt; 18 LIMIT 0, 10  -- 第1页，每页10条</span><br></pre></td></tr></table></figure><p><strong>关键逻辑</strong>：在<code>prepare</code>方法中，通过<code>Dialect.buildPaginationSql</code>生成适配 SQL，不同数据库的方言实现不同：</p><ul><li><p>MySQL：<code>LIMIT offset, size</code></p></li><li><p>Oracle：<code>SELECT * FROM (SELECT t.*, ROWNUM rn FROM (...) t WHERE ROWNUM  ?) WHERE rn &gt; ?</code></p></li><li><p>PostgreSQL：<code>OFFSET ? LIMIT ?</code></p></li></ul><h5 id="（3）总条数-SQL-自动生成"><a href="#（3）总条数-SQL-自动生成" class="headerlink" title="（3）总条数 SQL 自动生成"></a>（3）总条数 SQL 自动生成</h5><p>MP 会自动剥离原始 SQL 的<code>SELECT</code>字段和<code>ORDER BY</code>（避免 count 统计错误），生成 count 查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(1) FROM user WHERE age &gt; 18</span><br></pre></td></tr></table></figure><p><strong>优化点</strong>：</p><ul><li><p>若原始 SQL 含<code>GROUP BY</code>，count 会改为<code>COUNT(DISTINCT 分组字段)</code>；</p></li><li><p>可通过<code>page.setSearchCount(false)</code>关闭总条数统计（适用于无需总页数的场景）。</p></li></ul><h4 id="3-分页参数传递与结果封装"><a href="#3-分页参数传递与结果封装" class="headerlink" title="3. 分页参数传递与结果封装"></a>3. 分页参数传递与结果封装</h4><ul><li><p><strong>参数传递</strong>：<code>Page</code>对象中的<code>current</code>（当前页）和<code>size</code>（每页条数）会被转换为<code>offset = (current - 1) * size</code>，作为分页参数注入改写后的 SQL；</p></li><li><p><strong>结果封装</strong>：执行分页 SQL 后，查询结果会被设置到<code>page.getRecords()</code>；执行 countSQL 后，总条数会设置到<code>page.setTotal(total)</code>，并自动计算<code>pages = (total + size - 1) / size</code>（总页数）。</p></li></ul><h3 id="四、物理分页-vs-逻辑分页：MP-为何选择物理分页？"><a href="#四、物理分页-vs-逻辑分页：MP-为何选择物理分页？" class="headerlink" title="四、物理分页 vs 逻辑分页：MP 为何选择物理分页？"></a>四、物理分页 vs 逻辑分页：MP 为何选择物理分页？</h3><p>很多人会疑惑：MP 为何采用 “物理分页”（依赖数据库 SQL 语法）而非 “逻辑分页”（查询全量数据后内存截取）？</p><div class="table-container"><table><thead><tr><th>对比维度</th><th>物理分页（MP 实现）</th><th>逻辑分页（内存截取）</th></tr></thead><tbody><tr><td>性能</td><td>只查询当前页数据，数据库压力小</td><td>查询全量数据，大数据量下内存溢出</td></tr><tr><td>适用场景</td><td>大数据量、跨库兼容</td><td>小数据量、本地测试</td></tr><tr><td>依赖</td><td>数据库方言支持</td><td>无依赖，纯 Java 逻辑</td></tr></tbody></table></div><p>MP 选择物理分页的核心原因是<strong>性能优化</strong>—— 对于百万级数据，逻辑分页会导致全表扫描，而物理分页通过数据库的索引优化，仅返回当前页数据，大幅降低 IO 开销。</p><h3 id="五、源码关键片段解析（MP-3-5-3-版本）"><a href="#五、源码关键片段解析（MP-3-5-3-版本）" class="headerlink" title="五、源码关键片段解析（MP 3.5.3 版本）"></a>五、源码关键片段解析（MP 3.5.3 版本）</h3><h4 id="1-分页-SQL-改写核心代码"><a href="#1-分页-SQL-改写核心代码" class="headerlink" title="1. 分页 SQL 改写核心代码"></a>1. 分页 SQL 改写核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaginationInnerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrepare</span><span class="params">(StatementHandler sh, Connection conn, Integer transactionTimeout)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 获取原始BoundSql（封装SQL和参数）</span></span><br><span class="line"></span><br><span class="line">   <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> sh.getBoundSql();</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 判断是否需要分页（是否包含Page参数）</span></span><br><span class="line"></span><br><span class="line">   <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> getPage(sh);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; page.isNeedPagination()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 获取数据库方言（根据Connection自动识别）</span></span><br><span class="line"></span><br><span class="line">       <span class="type">Dialect</span> <span class="variable">dialect</span> <span class="operator">=</span> getDialect(conn);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 改写分页SQL</span></span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">paginationSql</span> <span class="operator">=</span> dialect.buildPaginationSql(sql, page.getOffset(), page.getSize());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 替换原始SQL</span></span><br><span class="line"></span><br><span class="line">      ReflectUtil.setFieldValue(boundSql, <span class="string">&quot;sql&quot;</span>, paginationSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-总条数统计核心代码"><a href="#2-总条数统计核心代码" class="headerlink" title="2. 总条数统计核心代码"></a>2. 总条数统计核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaginationInnerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(Connection conn, String sql, List Class</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   // <span class="number">1.</span> 生成count SQL</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   String countSql = DialectBuilder.buildCountSql(sql)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 执行count查询</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> SqlHelper.executeQuery(conn, countSql, paramList, rs -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> rs.getLong(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、常见问题与底层原理关联分析"><a href="#六、常见问题与底层原理关联分析" class="headerlink" title="六、常见问题与底层原理关联分析"></a>六、常见问题与底层原理关联分析</h3><h4 id="1-分页失效？——-拦截器未注册"><a href="#1-分页失效？——-拦截器未注册" class="headerlink" title="1. 分页失效？—— 拦截器未注册"></a>1. 分页失效？—— 拦截器未注册</h4><p>若分页 SQL 未添加 LIMIT，大概率是分页插件未注入 Spring 容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确配置（Spring Boot）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 添加分页拦截器，并指定数据库类型</span></span><br><span class="line"></span><br><span class="line">       interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：未注册拦截器时，SQL 不会被改写，自然无法实现分页。</p><h4 id="2-总条数统计错误？——-SQL-解析异常"><a href="#2-总条数统计错误？——-SQL-解析异常" class="headerlink" title="2. 总条数统计错误？—— SQL 解析异常"></a>2. 总条数统计错误？—— SQL 解析异常</h4><p>若 count 结果与实际不符，可能是原始 SQL 含复杂语法（如<code>UNION</code>、<code>子查询</code>），导致 MP 的 SQL 解析失败。此时可手动指定 countSQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.setCountSql(&quot;SELECT COUNT(1) FROM (原始复杂SQL) t&quot;);</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：MP 的自动 countSQL 生成依赖 SQL 解析器，复杂语法可能导致解析偏差，手动指定可绕过解析逻辑。</p><h4 id="3-跨库分页兼容问题？——-方言未适配"><a href="#3-跨库分页兼容问题？——-方言未适配" class="headerlink" title="3. 跨库分页兼容问题？—— 方言未适配"></a>3. 跨库分页兼容问题？—— 方言未适配</h4><p>切换数据库后分页失效，需确保<code>DbType</code>与实际数据库一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 适配PostgreSQL</span><br><span class="line"></span><br><span class="line">interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.POSTGRE\_SQL));</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：不同数据库的分页语法差异，方言是连接 SQL 改写与数据库的桥梁。</p><h3 id="七、总结与思考"><a href="#七、总结与思考" class="headerlink" title="七、总结与思考"></a>七、总结与思考</h3><p>MyBatis-Plus 的分页功能之所以强大，核心在于 **“无侵入式设计” 和 “数据库方言适配”**：</p><ol><li><p>基于 MyBatis 拦截器机制，无需修改业务 SQL，实现分页逻辑与业务逻辑解耦；</p></li><li><p>通过方言接口封装不同数据库的分页语法，解决跨库兼容问题；</p></li><li><p>自动生成 countSQL，减少重复编码，同时支持灵活配置（关闭统计、手动指定 countSQL）。</p></li></ol><p>从底层原理来看，MP 的分页插件本质是 “SQL 解析与改写的自动化工具”，其设计思路值得借鉴：<strong>将通用逻辑（分页）抽离为插件，通过拦截器嵌入框架流程，既不破坏原有架构，又能提升开发效率</strong>。</p><p>在实际开发中，需注意：</p><ul><li><p>复杂 SQL 场景下，建议手动验证分页 SQL 和 countSQL 的正确性；</p></li><li><p>大数据量分页（如千万级数据），可结合<code>PageHelper</code>的 “合理化分页” 或 MP 的<code>page.setReasonable(true)</code>避免页码越界；</p></li><li><p>无需总条数时，关闭<code>searchCount</code>可提升查询性能。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitMap实现签到功能</title>
      <link href="/posts/61e739c3.html"/>
      <url>/posts/61e739c3.html</url>
      
        <content type="html"><![CDATA[<p>在日常开发中，用户签到是一个非常常见的功能需求，比如APP的每日签到领积分、连续签到奖励等。面对海量用户的签到数据，如果使用传统的关系型数据库存储，不仅会占用大量的存储空间，而且在统计签到情况时效率也会比较低下。那么，有没有更高效、更节省空间的方案呢？答案是肯定的，那就是利用Redis中的Bitmap（位图）来实现用户签到功能。本文就来详细探讨一下如何使用Redis Bitmap结合Java实现用户签到，并分析其优势和注意事项。</p><h2 id="一、为什么选择Redis-Bitmap实现用户签到？"><a href="#一、为什么选择Redis-Bitmap实现用户签到？" class="headerlink" title="一、为什么选择Redis Bitmap实现用户签到？"></a>一、为什么选择Redis Bitmap实现用户签到？</h2><p>在介绍具体实现之前，我们先来思考一下为什么Redis Bitmap适合用来实现用户签到。首先，我们来回顾一下Bitmap的基本概念：Bitmap是一种基于位的数据结构，它使用一个位（bit）来表示一个元素的状态，0表示不存在或未发生，1表示存在或已发生。在用户签到场景中，我们可以用一个位来表示用户某一天是否签到，这样就能够极大地节省存储空间。</p><p>假设我们有1000万用户，每个用户每年签到数据需要365个 bit 来存储，那么一年的签到数据总存储空间为：1000万 <em> 365 bit = 10000000 </em> 365 / 8 / 1024 / 1024 ≈ 430MB。如果使用传统的数据库表，每个签到记录至少需要存储用户ID、签到日期等字段，假设每条记录占用20字节，那么1000万用户一年的签到数据存储空间为：1000万 <em> 365 </em> 20 byte = 10000000 <em> 365 </em> 20 / 1024 / 1024 / 1024 ≈ 6.8GB。通过对比可以明显看出，Bitmap在存储空间上具有巨大的优势。</p><p>除此之外，Redis Bitmap还提供了丰富的位操作命令，比如<code>SETBIT</code>（设置某一位的值）、<code>GETBIT</code>（获取某一位的值）、<code>BITCOUNT</code>（统计值为1的位的个数）、<code>BITOP</code>（位运算）等，这些命令能够高效地满足签到功能中的签到标记、签到查询、连续签到统计等需求，操作效率非常高。</p><h2 id="二、Redis-Bitmap实现用户签到的具体方案"><a href="#二、Redis-Bitmap实现用户签到的具体方案" class="headerlink" title="二、Redis Bitmap实现用户签到的具体方案"></a>二、Redis Bitmap实现用户签到的具体方案</h2><h3 id="2-1-键的设计"><a href="#2-1-键的设计" class="headerlink" title="2.1 键的设计"></a>2.1 键的设计</h3><p>要使用Bitmap实现用户签到，首先需要设计合理的键名。为了方便区分不同用户、不同年份和月份的签到数据，我们可以采用这样的键名格式：<code>user:checkin:uid:year:month</code>。其中，<code>uid</code>是用户的唯一标识，<code>year</code>是年份，<code>month</code>是月份。这样设计的好处是，每个用户每个月的签到数据都存储在一个独立的Bitmap中，既方便管理，又能避免单个Bitmap过大导致的性能问题。</p><h3 id="2-2-签到标记（SETBIT命令）"><a href="#2-2-签到标记（SETBIT命令）" class="headerlink" title="2.2 签到标记（SETBIT命令）"></a>2.2 签到标记（SETBIT命令）</h3><p>当用户进行签到操作时，我们需要将对应日期的位设置为1。具体步骤如下：</p><ol><li><p>获取当前日期，并计算出该日期在当月是第几天（假设为day，取值范围1-31）。</p></li><li><p>由于Bitmap的位是从0开始计数的，所以需要将day减1得到对应的位索引（index = day - 1）。</p></li><li><p>使用Redis的<code>SETBIT</code>命令，将键<code>user:checkin:uid:year:month</code>对应index位置的位设置为1。</p></li></ol><p><code>SETBIT</code>命令的语法为：<code>SETBIT key offset value</code>，其中offset是位索引，value是要设置的值（0或1）。该命令的返回值是该位在设置前的值。</p><h3 id="2-3-签到查询（GETBIT命令）"><a href="#2-3-签到查询（GETBIT命令）" class="headerlink" title="2.3 签到查询（GETBIT命令）"></a>2.3 签到查询（GETBIT命令）</h3><p>当需要查询用户某一天是否签到时，可以使用<code>GETBIT</code>命令。具体步骤如下：</p><ol><li><p>获取要查询的日期，并计算出该日期在当月是第几天（day）。</p></li><li><p>计算位索引index = day - 1。</p></li><li><p>使用<code>GETBIT</code>命令，获取键<code>user:checkin:uid:year:month</code>对应index位置的位值。如果返回1，表示用户当天已签到；如果返回0，表示用户当天未签到。</p></li></ol><p><code>GETBIT</code>命令的语法为：<code>GETBIT key offset</code>。</p><h3 id="2-4-签到统计（BITCOUNT命令）"><a href="#2-4-签到统计（BITCOUNT命令）" class="headerlink" title="2.4 签到统计（BITCOUNT命令）"></a>2.4 签到统计（BITCOUNT命令）</h3><p>在签到功能中，经常需要统计用户在某个时间段内的签到天数，比如当月签到天数、近7天签到天数等。这时候可以使用<code>BITCOUNT</code>命令，该命令用于统计Bitmap中值为1的位的个数。</p><p><code>BITCOUNT</code>命令的语法为：<code>BITCOUNT key [start end]</code>，其中start和end是字节的索引（注意不是位的索引），用于指定统计的范围。如果不指定start和end，则统计整个Bitmap。</p><p>例如，要统计用户当月的签到天数，直接使用<code>BITCOUNT user:checkin:uid:year:month</code>即可。如果要统计用户近7天的签到天数，需要先确定这7天对应的位索引范围，然后将位索引转换为字节索引（字节索引 = 位索引 / 8），再使用<code>BITCOUNT</code>命令进行统计。</p><h3 id="2-5-连续签到统计"><a href="#2-5-连续签到统计" class="headerlink" title="2.5 连续签到统计"></a>2.5 连续签到统计</h3><p>连续签到统计是签到功能中的一个难点，比如统计用户当前的连续签到天数。实现思路如下：</p><ol><li><p>从当前日期开始，依次向前查询每天的签到状态（使用<code>GETBIT</code>命令）。</p></li><li><p>如果查询到某一天未签到，则停止查询，连续签到天数为已查询到的签到天数。</p></li><li><p>如果查询到本月第一天都已签到，则继续查询上一个月的签到数据，直到查询到未签到的日期为止。</p></li></ol><p>在实现过程中，需要注意跨月份的情况，需要分别处理不同月份的Bitmap。</p><h2 id="三、Java代码实现"><a href="#三、Java代码实现" class="headerlink" title="三、Java代码实现"></a>三、Java代码实现</h2><p>接下来，我们通过Java代码来具体实现Redis Bitmap用户签到功能。首先，我们需要引入Redis的Java客户端依赖，这里以Jedis为例。</p><h3 id="3-1-依赖引入（Maven）"><a href="#3-1-依赖引入（Maven）" class="headerlink" title="3.1 依赖引入（Maven）"></a>3.1 依赖引入（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-签到工具类实现"><a href="#3-2-签到工具类实现" class="headerlink" title="3.2 签到工具类实现"></a>3.2 签到工具类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckinUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;user:checkin:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">YEAR_MONTH_FORMATTER</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckinUtil</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户签到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 签到日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签到前的状态（0：未签到，1：已签到）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">checkin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> dayOfMonth - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.setbit(key, offset, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户某一天是否签到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 查询日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：已签到，false：未签到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isCheckin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> dayOfMonth - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.getbit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计用户当月签到天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当月任意一天</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签到天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">countMonthCheckin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="keyword">return</span> jedis.bitcount(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计用户当前连续签到天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连续签到天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countContinuousCheckin</span><span class="params">(Long uid)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">currentDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">continuousDays</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">tempDate</span> <span class="operator">=</span> currentDate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">isCheckin</span> <span class="operator">=</span> isCheckin(uid, tempDate);</span><br><span class="line">            <span class="keyword">if</span> (isCheckin) &#123;</span><br><span class="line">                continuousDays++;</span><br><span class="line">                tempDate = tempDate.minusDays(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 避免无限循环，当查询到一年前仍未断签时，停止查询</span></span><br><span class="line">                <span class="keyword">if</span> (tempDate.isBefore(currentDate.minusYears(<span class="number">1</span>))) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> continuousDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取签到Redis键名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getCheckinKey</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">yearMonth</span> <span class="operator">=</span> date.format(YEAR_MONTH_FORMATTER);</span><br><span class="line">        <span class="keyword">return</span> REDIS_KEY_PREFIX + uid + <span class="string">&quot;:&quot;</span> + yearMonth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul><li><p><strong>Bitmap的大小限制</strong>：Redis中单个BitMap的偏移量最大为 2^32-1。在设计键名时，按用户每月拆分Bitmap，可以有效控制单个Bitmap的大小，避免因Bitmap过大导致报错。</p></li><li><p><strong>日期处理的准确性</strong>：在计算位索引时，一定要注意日期的准确性，特别是跨月份和闰年的情况。使用Java 8的<code>LocalDate</code>类可以方便、准确地处理日期相关操作。</p></li><li><p><strong>Redis连接管理</strong>：在实际项目中，不能每次操作都创建新的Jedis连接，应该使用连接池来管理Redis连接，以提高性能和避免资源泄露。（这个无需担心，实际开发大多采用spring-data-redis进行操作 会自行管理）</p></li><li><p><strong>数据持久化</strong>：Redis支持RDB和AOF两种持久化方式，为了防止签到数据丢失，需要合理配置Redis的持久化策略。</p></li><li><p><strong>过期策略</strong>：对于一些过期的签到数据（比如几年前的签到数据），如果业务上不再需要，可以设置键的过期时间，让Redis自动清理这些数据，节省存储空间。</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>使用Redis Bitmap实现用户签到功能，具有存储空间小、操作效率高、命令丰富等优点，非常适合处理海量用户的签到数据。通过合理的键名设计和Java代码实现，我们可以轻松地完成签到标记、签到查询、签到统计等功能。同时，在实际应用中，还需要注意Bitmap的大小限制、日期处理、Redis连接管理等问题，以确保系统的稳定性和性能。</p><p>总的来说，Redis Bitmap是实现用户签到功能的一种优秀方案，值得在项目中推广和应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Redis Sorted Set实现Java滚动分页查询</title>
      <link href="/posts/7be5306f.html"/>
      <url>/posts/7be5306f.html</url>
      
        <content type="html"><![CDATA[<p>在日常开发中，分页查询是一个非常常见的需求。传统的基于数据库的Limit Offset分页方式虽然简单，但在数据量较大或数据实时变动（如插入新数据）的场景下，会出现<strong>重复数据</strong>或<strong>数据遗漏</strong>的问题。本文将探讨如何利用Redis的Sorted Set（有序集合）数据结构来实现高效、准确的滚动分页查询，并结合具体Java代码进行详细解析。</p><h2 id="一、传统分页的痛点：为什么需要滚动分页？"><a href="#一、传统分页的痛点：为什么需要滚动分页？" class="headerlink" title="一、传统分页的痛点：为什么需要滚动分页？"></a>一、传统分页的痛点：为什么需要滚动分页？</h2><p>我们先回顾一下传统的Limit Offset分页。假设我们有一张博客表，要查询第2页数据（每页2条），SQL通常是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> blog <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> LIMIT <span class="number">2</span> <span class="keyword">OFFSET</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这种方式的问题在于：如果在查询第1页后、第2页前，有一条新的博客插入（create_time比第1页的部分数据更新），那么第2页的结果就会包含原本第1页的最后一条数据，导致重复查询。如下图所示：</p><ul><li><p>初始数据：[A(时间10), B(时间9), C(时间8), D(时间7)]</p></li><li><p>第1页（LIMIT 2 OFFSET 0）：[A, B]</p></li><li><p>插入新数据E(时间11)，数据变为：[E(11), A(10), B(9), C(8), D(7)]</p></li><li><p>第2页（LIMIT 2 OFFSET 2）：[B, C] → B重复出现</p></li></ul><p>滚动分页（也叫游标分页）则通过<strong>上一页的最后一个标记（如时间戳）</strong>来定位下一页的起始位置，避免了Offset带来的问题。而Redis的Sorted Set恰好能完美支持这种场景。</p><h2 id="二、Redis-Sorted-Set的特性：为什么适合滚动分页？"><a href="#二、Redis-Sorted-Set的特性：为什么适合滚动分页？" class="headerlink" title="二、Redis Sorted Set的特性：为什么适合滚动分页？"></a>二、Redis Sorted Set的特性：为什么适合滚动分页？</h2><p>Redis的Sorted Set（有序集合）是一种特殊的数据结构，它为每个元素分配一个<strong>分数（Score）</strong>，并按照分数对元素进行排序。其核心特性包括：</p><ol><li><p><strong>有序性</strong>：元素天然按照Score升序或降序排列，无需额外排序操作。</p></li><li><p><strong>范围查询</strong>：支持通过Score范围（如0到maxScore）查询元素，这是实现滚动分页的关键。</p></li><li><p><strong>高效性</strong>：无论是插入、查询还是删除操作，时间复杂度均为O(logN)，适合大数据量场景。</p></li></ol><p>在滚动分页场景中，我们可以将<strong>业务数据的唯一标识（如博客ID）</strong>作为Sorted Set的元素（Value），将<strong>排序字段（如创建时间戳）</strong>作为元素的分数（Score）。这样，通过Score范围就能快速定位下一页数据。</p><h2 id="三、滚动分页的实现思路与代码解析"><a href="#三、滚动分页的实现思路与代码解析" class="headerlink" title="三、滚动分页的实现思路与代码解析"></a>三、滚动分页的实现思路与代码解析</h2><p>下面结合提供的Java代码，详细拆解利用Redis Sorted Set实现滚动分页的完整流程。本文以“查询关注的博客动态”为例进行说明。</p><h3 id="3-1-核心流程概览"><a href="#3-1-核心流程概览" class="headerlink" title="3.1 核心流程概览"></a>3.1 核心流程概览</h3><p>滚动分页的核心是通过“上一页的最小时间戳（minTime）”和“偏移量（offset）”来定位下一页数据，具体流程如下：</p><ol><li><p>定义Redis的Sorted Set键：以用户ID为维度，存储该用户关注的博客ID集合（如<code>feed:1001</code>表示用户1001的关注动态）。</p></li><li><p>查询上一页数据：通过<code>reverseRangeByScoreWithScores</code>方法，查询Score在0到max（上一页的minTime）之间的元素，同时指定偏移量和每页数量。</p></li><li><p>处理查询结果：提取博客ID、计算当前页的最小时间戳和偏移量，用于下一页查询。</p></li><li><p>封装并返回结果：将博客详情、minTime、offset返回给前端，作为下一页请求的参数。</p></li></ol><h3 id="3-2-代码逐行解析"><a href="#3-2-代码逐行解析" class="headerlink" title="3.2 代码逐行解析"></a>3.2 代码逐行解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;feed:&quot;</span> + userId; <span class="comment">// Redis键：feed:用户ID</span></span><br><span class="line">    <span class="comment">// 2. 从Redis查询blogId列表</span></span><br><span class="line">    <span class="comment">// reverseRangeByScoreWithScores：倒序查询Score在[0, max]之间的元素</span></span><br><span class="line">    <span class="comment">// 参数说明：key, 最小Score, 最大Score, 偏移量, 每页数量</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; result = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3. 处理空结果</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;无新数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 提取博客ID、计算当前页的minTime和offset</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 初始化为当前时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 初始偏移量为1</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result.size());</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : result) &#123;</span><br><span class="line">        <span class="comment">// 提取博客ID</span></span><br><span class="line">        ids.add(Long.valueOf(Objects.requireNonNull(tuple.getValue())));</span><br><span class="line">        <span class="comment">// 提取Score（即博客创建时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> Objects.requireNonNull(tuple.getScore()).longValue();</span><br><span class="line">        <span class="comment">// 处理相同时间戳的情况：若时间等于当前minTime，偏移量+1；否则更新minTime和偏移量</span></span><br><span class="line">        <span class="keyword">if</span>(time == minTime) &#123;</span><br><span class="line">            offset1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            offset1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 查询博客详情（批量查询避免N+1问题，此处为简化示例）</span></span><br><span class="line">    List&lt;Blog&gt; blogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ids.size());</span><br><span class="line">    ids.forEach(id -&gt; &#123;</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id); <span class="comment">// 从数据库查询博客详情</span></span><br><span class="line">        setBlogIsLiked(blog); <span class="comment">// 处理博客点赞状态</span></span><br><span class="line">        queryUser(blog); <span class="comment">// 填充博客作者信息</span></span><br><span class="line">        blogs.add(blog);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 6. 封装滚动分页结果</span></span><br><span class="line">    ScrollResult&lt;Blog&gt; scrollResult = <span class="keyword">new</span> <span class="title class_">ScrollResult</span>&lt;&gt;();</span><br><span class="line">    scrollResult.setList(blogs); <span class="comment">// 当前页博客列表</span></span><br><span class="line">    scrollResult.setMinTime(minTime); <span class="comment">// 当前页最小时间戳（下一页的max参数）</span></span><br><span class="line">    scrollResult.setOffset(offset1); <span class="comment">// 当前页最小时间戳对应的偏移量</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-关键细节说明"><a href="#3-3-关键细节说明" class="headerlink" title="3.3 关键细节说明"></a>3.3 关键细节说明</h3><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**为什么用reverseRangeByScoreWithScores？**因为我们通常需要按时间倒序展示数据（最新的在前），该方法会按照Score从大到小返回元素，正好符合需求。</p></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**max和offset参数的作用？**- `max`：上一页返回的minTime，代表下一页数据的Score不能超过这个值（即时间不能晚于这个值）。- `offset`：当存在多个Score相同的元素时，用于跳过前N个元素，避免重复。</p></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**如何处理相同时间戳的数据？**如果多条博客的创建时间戳相同（Score相同），下一页查询时需要通过offset跳过这些重复的元素。例如，当前页有3条数据的Score都是1620000000，那么minTime=1620000000，offset=3，下一页查询时会从第4个Score=1620000000的元素开始。</p></div><h2 id="四、滚动分页的优势与注意事项"><a href="#四、滚动分页的优势与注意事项" class="headerlink" title="四、滚动分页的优势与注意事项"></a>四、滚动分页的优势与注意事项</h2><h3 id="4-1-优势"><a href="#4-1-优势" class="headerlink" title="4.1 优势"></a>4.1 优势</h3><ul><li><p><strong>无重复无遗漏</strong>：基于时间戳定位，即使中间插入新数据，也不会影响下一页的查询结果。</p></li><li><p><strong>高性能</strong>：Redis的Sorted Set查询效率高，尤其适合大数据量场景，避免了数据库Limit Offset的全表扫描问题。</p></li><li><p><strong>实时性好</strong>：数据插入Redis后可立即查询，无需等待数据库同步。</p></li></ul><h3 id="4-2-注意事项"><a href="#4-2-注意事项" class="headerlink" title="4.2 注意事项"></a>4.2 注意事项</h3><ul><li><p><strong>Score的唯一性问题</strong>：如果排序字段（如时间戳）存在大量重复，需要通过offset来处理，否则可能出现数据漏查。</p></li><li><p><strong>Redis数据一致性</strong>：需要保证业务数据（如博客）与Redis中的Sorted Set同步。例如，博客删除时，要及时从Redis中移除对应的元素。</p></li><li><p><strong>分页参数的传递</strong>：前端需要将上一页返回的minTime和offset作为下一页请求的参数，因此需要在接口设计中明确这两个参数。</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>相比传统的Limit Offset分页，基于Redis Sorted Set的滚动分页在实时性、准确性和高性能方面都有明显优势，尤其适合动态数据（如关注动态、消息流）的分页场景。其核心是利用Sorted Set的Score有序性和范围查询能力，通过“上一页的最小时间戳+偏移量”来定位下一页数据，从根本上解决了传统分页的重复和遗漏问题。</p><p>在实际开发中，我们还可以根据业务需求优化细节，例如结合Redis的过期策略清理历史数据、使用管道（Pipeline）减少Redis交互次数等，进一步提升系统性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Stream多消费者组模式：原理、ACK机制与在Java中的实践</title>
      <link href="/posts/da8941bc.html"/>
      <url>/posts/da8941bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Stream多消费者组模式：原理、ACK机制与Java实践"><a href="#Redis-Stream多消费者组模式：原理、ACK机制与Java实践" class="headerlink" title="Redis Stream多消费者组模式：原理、ACK机制与Java实践"></a>Redis Stream多消费者组模式：原理、ACK机制与Java实践</h1><p>在分布式系统中，消息队列是解耦服务、削峰填谷的核心组件。Redis作为高性能的内存数据库，从5.0版本开始引入Stream数据结构，原生支持消息队列功能。相较于Redis以往的Pub/Sub（无持久化）、List（简单队列），Stream提供了<strong>持久化、多消费者组、ACK确认、消息回溯</strong>等企业级特性，尤其在多消费者组场景下，能灵活实现消息的分发与处理。本文将深入剖析Stream多消费者组的实现原理，重点解读ACK确认机制与Pending List的作用，并结合Java代码演示实际运用场景。</p><h1 id="一、Redis-Stream核心概念与多消费者组模型"><a href="#一、Redis-Stream核心概念与多消费者组模型" class="headerlink" title="一、Redis Stream核心概念与多消费者组模型"></a>一、Redis Stream核心概念与多消费者组模型</h1><p>在理解多消费者组之前，我们先明确Stream的几个基础概念：</p><ul><li><p><strong>Stream</strong>：消息的载体，类似日志文件的结构，每条消息有唯一的ID（格式为“时间戳-序列号”，如1690000000000-0），消息内容以键值对存储。</p></li><li><p><strong>消费者组（Consumer Group）</strong>：一组消费者的集合，同一个Stream可以创建多个消费者组。<strong>不同消费者组之间是独立的</strong>，即同一条消息会被每个消费者组消费一次；而同一个消费者组内的消费者则竞争消费消息，确保一条消息只被组内一个消费者处理。</p></li><li><p><strong>消费者（Consumer）</strong>：隶属于某个消费者组，实际处理消息的个体。</p></li><li><p><strong>Pending List（PENDING列表）</strong>：消费者从组内获取消息后，若未发送ACK确认，消息会被放入该消费者的Pending List中，标记为“已读取但未确认”。</p></li></ul><p>多消费者组的核心模型如下图所示（概念示意）：</p><blockquote><p>Stream（消息队列） → 消费者组A（Consumer1、Consumer2） → 各自Pending List</p><pre><code>  └→ 消费者组B（Consumer3、Consumer4） → 各自Pending List</code></pre></blockquote><p>例如，一个订单Stream可以创建“支付组”和“物流组”，支付组处理订单支付状态，物流组处理订单发货，两者独立消费同一条订单消息，互不干扰。</p><h1 id="二、关键机制：ACK确认与Pending-List深度解析"><a href="#二、关键机制：ACK确认与Pending-List深度解析" class="headerlink" title="二、关键机制：ACK确认与Pending List深度解析"></a>二、关键机制：ACK确认与Pending List深度解析</h1><p>Stream的可靠性依赖于<strong>ACK确认机制</strong>，而Pending List则是ACK机制的核心载体。这两者共同确保消息“至少被消费一次”（At-Least-Once），避免消息丢失。</p><h2 id="2-1-ACK确认机制流程"><a href="#2-1-ACK确认机制流程" class="headerlink" title="2.1 ACK确认机制流程"></a>2.1 ACK确认机制流程</h2><p>当消费者从组内获取消息后，消息并不会立即从Stream中删除，而是需要消费者处理完成后主动发送ACK命令（<code>XACK</code>），Redis才会将消息从该消费者的Pending List中移除，标记为“已处理”。具体流程如下：</p><ol><li><p>消费者通过<code>XREADGROUP</code>命令从组内读取消息（如<code>XREADGROUP GROUP group1 consumer1 COUNT 1 STREAMS stream1 &gt;</code>，其中“&gt;”表示读取组内未被消费过的消息）。</p></li><li><p>Redis将消息标记为“已分配给consumer1”，并加入consumer1的Pending List。</p></li><li><p>消费者处理消息（如业务逻辑计算、数据库写入等）。</p></li><li><p>处理成功后，消费者发送<code>XACK stream1 group1 msgId</code>命令确认消息。</p></li><li><p>Redis收到ACK后，从consumer1的Pending List中删除该消息。</p></li></ol><h2 id="2-2-Pending-List的作用与核心操作"><a href="#2-2-Pending-List的作用与核心操作" class="headerlink" title="2.2 Pending List的作用与核心操作"></a>2.2 Pending List的作用与核心操作</h2><p>Pending List（简称PENDING）是每个消费者组内消费者独有的“未确认消息列表”，它解决了“消息已读取但处理失败”的问题。当消费者处理消息异常（如服务宕机、业务报错）时，消息会一直留在Pending List中，直到被重新处理并ACK。</p><div class="tip warning faa-horizontal animated-hover"><p><strong>核心特性</strong>：Pending List中的消息会记录三个关键信息——消息ID、消费者ID、未确认时长（idle time），方便后续进行消息重试或死信处理。</p></div><p>操作Pending List的常用命令：</p><ul><li><p><code>XPENDING</code>：查看消费者组或消费者的Pending消息统计，如<code>XPENDING stream1 group1</code>可查看group1的Pending总数、最小/最大idle time等。</p></li><li><p><code>XPENDING stream1 group1 - + 10 consumer1</code>：查看consumer1的前10条Pending消息（“-”表示最小ID，“+”表示最大ID）。</p></li><li><p><code>XCLAIM</code>：将Pending List中的消息“认领”给其他消费者处理，适用于消费者宕机后的消息转移，如<code>XCLAIM stream1 group1 consumer2 60000 1690000000000-0</code>（60000表示idle time超过60秒的消息）。</p></li></ul><h1 id="三、Java中的实践：从队列消费与Pending-List重试"><a href="#三、Java中的实践：从队列消费与Pending-List重试" class="headerlink" title="三、Java中的实践：从队列消费与Pending List重试"></a>三、Java中的实践：从队列消费与Pending List重试</h1><p>下面我们通过Java代码演示Stream的核心用法：<strong>先消费Stream中的新消息，若处理异常则将消息留在Pending List，下次消费前先处理Pending List中的消息</strong>。我们使用Spring Data Redis作为客户端（需引入依赖：<code>spring-boot-starter-data-redis</code>）。</p><h2 id="3-1-初始化Stream与消费者组"><a href="#3-1-初始化Stream与消费者组" class="headerlink" title="3.1 初始化Stream与消费者组"></a>3.1 初始化Stream与消费者组</h2><p>首先需要创建Stream并初始化消费者组（可在项目启动时执行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.Consumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ObjectRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ReadOffset;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.StreamInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_stream&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;order_group&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamInitializer</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initStreamAndGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.execute((RedisConnection connection) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 检查Stream是否存在，不存在则创建（可选，XADD会自动创建）</span></span><br><span class="line">            StreamInfo.<span class="type">XInfoStream</span> <span class="variable">info</span> <span class="operator">=</span> connection.streamCommands().xInfoStream(STREAM_KEY.getBytes());</span><br><span class="line">            <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Stream不存在，创建Stream：&quot;</span> + STREAM_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查消费者组是否存在，不存在则创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.streamCommands().xInfoGroup(STREAM_KEY.getBytes(), GROUP_NAME.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者组已存在：&quot;</span> + GROUP_NAME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// MKSTREAM选项：若Stream不存在则创建</span></span><br><span class="line">                connection.streamCommands().xGroupCreate(</span><br><span class="line">                        STREAM_KEY.getBytes(),</span><br><span class="line">                        GROUP_NAME.getBytes(),</span><br><span class="line">                        ReadOffset.latest(),</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                );</span><br><span class="line">                System.out.println(<span class="string">&quot;创建消费者组：&quot;</span> + GROUP_NAME);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-消息生产者"><a href="#3-2-消息生产者" class="headerlink" title="3.2 消息生产者"></a>3.2 消息生产者</h2><p>模拟发送订单消息到Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ObjectRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamProducer</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送订单消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOrderMessage</span><span class="params">(OrderMessage message)</span> &#123;</span><br><span class="line">        <span class="comment">// ObjectRecord会自动将对象序列化为Hash（需配置RedisTemplate的序列化方式）</span></span><br><span class="line">        ObjectRecord&lt;String, OrderMessage&gt; record = ObjectRecord.create(STREAM_KEY, message);</span><br><span class="line">        <span class="comment">// XADD命令：添加消息到Stream</span></span><br><span class="line">        redisTemplate.opsForStream().add(record);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单消息实体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderMessage</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String orderId;</span><br><span class="line">        <span class="keyword">private</span> String userId;</span><br><span class="line">        <span class="keyword">private</span> Double amount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getter、setter、toString</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-消息消费者：优先处理Pending-List"><a href="#3-3-消息消费者：优先处理Pending-List" class="headerlink" title="3.3 消息消费者：优先处理Pending List"></a>3.3 消息消费者：优先处理Pending List</h2><p>核心逻辑：消费者启动后，<strong>先处理Pending List中的消息</strong>，处理完后再持续消费Stream中的未被消费的消息；若处理消息异常，不发送ACK，消息留在Pending List下次重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SAVE_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动时执行 持续监听消息队列</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SAVE_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderTask</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从消息队列里面读取消息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order &gt;</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">if</span>(read == <span class="literal">null</span> || read.isEmpty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取消息 并且将消息转化为订单</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = read.getFirst();</span><br><span class="line">                    Map&lt;Object, Object&gt; orderMap = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(orderMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    voucherOrderSaveHandler(voucherOrder);</span><br><span class="line">                    <span class="comment">//确认消息 发送ack</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>);</span><br><span class="line">                    <span class="comment">//遇到异常应先处理pending list中的消息  确保每个消息都被处理一次</span></span><br><span class="line">                    handPendingMessagesList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handPendingMessagesList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从pending队列里面获取待处理的消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">if</span>(read == <span class="literal">null</span> || read.isEmpty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取消息 并且将消息转化为订单</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = read.getFirst();</span><br><span class="line">                Map&lt;Object, Object&gt; orderMap = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(orderMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                voucherOrderSaveHandler(voucherOrder);</span><br><span class="line">                <span class="comment">//确认消息 发送ack</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pending-list订单异常&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结与注意事项"><a href="#四、总结与注意事项" class="headerlink" title="四、总结与注意事项"></a>四、总结与注意事项</h1><p>Redis Stream的多消费者组模式通过ACK机制和Pending List，实现了消息的可靠消费，尤其适合中小型分布式系统的轻量级消息队列场景。但在使用时需注意以下几点：</p><ul><li><p><strong>消息持久化</strong>：Stream消息默认持久化到Redis的RDB/AOF中，需确保Redis的持久化配置合理，避免宕机丢失消息。</p></li><li><p><strong>Pending List积压</strong>：需定期监控Pending List的消息量，若积压过多，需排查消费者是否异常，并通过<code>XCLAIM</code>转移消息或设置死信机制（如超过重试次数后转移到其他Stream）。</p></li><li><p><strong>消费者弹性</strong>：同一个消费者组内可动态增减消费者，实现负载均衡，但需避免消费者ID重复。</p></li><li><p><strong>性能考量</strong>：Redis单线程处理命令，高并发场景下需评估Stream的消息生产速率，避免Redis成为瓶颈（可结合分片或集群扩展）。</p></li></ul><p>总之，Redis Stream以其轻量、高效、可靠的特性，为分布式系统提供了一种灵活的消息队列解决方案，尤其在多消费者组和消息重试场景下，展现了独特的优势。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中Redisson锁对于可重试的实现</title>
      <link href="/posts/3a74c7b3.html"/>
      <url>/posts/3a74c7b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java中Redisson锁对于可重试的实现方式"><a href="#Java中Redisson锁对于可重试的实现方式" class="headerlink" title="Java中Redisson锁对于可重试的实现方式"></a>Java中Redisson锁对于可重试的实现方式</h1><p>在分布式系统中，分布式锁是解决并发问题的关键工具，而Redisson作为基于Redis的Java客户端，其提供的分布式锁因其高效、可靠的特性被广泛应用。在实际业务场景中，由于网络抖动、Redis服务短暂不可用等原因，锁的获取可能会出现暂时性失败，此时<strong>可重试机制</strong>就显得尤为重要。本文将深入探讨Redisson锁可重试的实现方式，从核心思路到具体代码，再到注意事项，为大家梳理这一实用特性的来龙去脉。</p><h2 id="一、为什么需要Redisson锁的可重试机制？"><a href="#一、为什么需要Redisson锁的可重试机制？" class="headerlink" title="一、为什么需要Redisson锁的可重试机制？"></a>一、为什么需要Redisson锁的可重试机制？</h2><p>在分布式环境下，获取Redisson锁失败并不总是意味着“锁被占用”，还可能是由以下暂时性因素导致：</p><ul><li><p><strong>网络波动</strong>：客户端与Redis服务器之间的网络连接出现短暂不稳定，导致锁请求超时。</p></li><li><p><strong>Redis服务负载过高</strong>：Redis在高并发场景下处理请求的速度变慢，使得锁获取操作未能在预期时间内完成。</p></li><li><p><strong>锁竞争激烈</strong>：多个客户端同时竞争同一把锁，当前客户端第一次请求时锁正被占用，但短时间内锁就会被释放。</p></li></ul><p>如果此时直接返回失败，可能会导致业务流程中断，影响系统的可用性和用户体验。而可重试机制能够让客户端在一定条件下重复尝试获取锁，从而规避上述暂时性问题，提高锁获取的成功率。</p><h2 id="二、Redisson锁可重试实现的核心思路"><a href="#二、Redisson锁可重试实现的核心思路" class="headerlink" title="二、Redisson锁可重试实现的核心思路"></a>二、Redisson锁可重试实现的核心思路</h2><p>Redisson锁的可重试并非简单循环+固定等待，而是基于<strong>“Redis发布订阅的等待-唤醒机制”</strong>实现，核心是避免无意义的轮询，减少资源消耗。其本质是结合<code>tryLock</code>的阻塞等待逻辑与Redis的消息通知，具体拆解为以下步骤：</p><ol><li><p><strong>初始尝试获取锁</strong>：客户端通过<code>SET NX</code>命令尝试获取锁，若成功则返回锁实例，同时记录锁的租期(如果还需要实现可重入则需要用Hash结构去记录锁的持有者以及锁的数量，这里默认不支持可重入)。</p></li><li><p><strong>失败则订阅锁释放通知</strong>：若锁已被占用，客户端不会立即重试，而是通过Redis的<code>SUBSCRIBE</code>命令订阅该锁的释放通知频道（如<code>redisson_lock__channel:&#123;lockKey&#125;</code>）。</p></li><li><p><strong>阻塞等待通知或超时</strong>：客户端进入阻塞状态，等待两个触发条件之一：① 收到锁释放的<code>PUBLISH</code>通知；② 达到预设的最大等待时间（<code>waitTime</code>）。</p></li><li><p><strong>唤醒后重试或终止</strong>：若收到释放通知，客户端立即唤醒并重新尝试获取锁；若等待超时，则终止重试并返回失败。</p></li></ol><div class="tip warning faa-horizontal animated"><p>关键在于“精准唤醒”而非“盲目重试”：通过Redis的发布订阅机制，只有当锁真正释放时才触发重试，既减少了Redis的请求压力，又能保证重试的及时性。</p></div><h2 id="三、Redisson锁可重试的底层实现与手动封装"><a href="#三、Redisson锁可重试的底层实现与手动封装" class="headerlink" title="三、Redisson锁可重试的底层实现与手动封装"></a>三、Redisson锁可重试的底层实现与手动封装</h2><p>Redisson的原生<code>tryLock(waitTime, leaseTime, TimeUnit)</code>方法已内置“等待-唤醒”的可重试逻辑，其底层通过<code>RedissonLock#tryAcquireAsync</code>实现异步获取+通知订阅。我们无需重复开发核心机制，只需基于原生方法封装业务级的重试策略（如总超时控制、多轮等待等），以下是具体实现。</p><h3 id="方式一：基于原生tryLock的多轮等待封装"><a href="#方式一：基于原生tryLock的多轮等待封装" class="headerlink" title="方式一：基于原生tryLock的多轮等待封装"></a>方式一：基于原生tryLock的多轮等待封装</h3><p>Redisson原生<code>tryLock(waitTime, ...)</code>已实现“等待通知+单次重试”，若需支持多轮等待（如总等待时间较长时），可封装多轮<code>tryLock</code>调用，每轮利用原生的等待-唤醒机制，避免固定休眠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLockRetryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="comment">// 总最大等待时间（毫秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TOTAL_MAX_WAIT_MS</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">// 每轮等待时间（利用原生tryLock的等待-唤醒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PER_ROUND_WAIT_MS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedissonLockRetryDemo</span><span class="params">(RedissonClient redissonClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于原生tryLock等待-唤醒的多轮重试封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁租期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁实例，若获取失败则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RLock <span class="title function_">tryLockWithRetry</span><span class="params">(String lockKey, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(TOTAL_MAX_WAIT_MS);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (remainingWaitMs.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每轮调用原生tryLock，利用其等待-唤醒机制</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock(remainingWaitMs.get(), leaseTime, unit);</span><br><span class="line">                <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">usedWaitMs</span> <span class="operator">=</span> System.currentTimeMillis() - startTimestamp;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取锁成功，累计等待时间：&quot;</span> + usedWaitMs + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> lock;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新剩余等待时间（避免总等待超时）</span></span><br><span class="line">                remainingWaitMs.addAndGet(-PER_ROUND_WAIT_MS);</span><br><span class="line">                System.out.println(<span class="string">&quot;本轮等待超时，剩余等待时间：&quot;</span> + remainingWaitMs.get() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="string">&quot;获取锁过程被中断&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总等待时间已耗尽，获取锁失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<strong><code>tryLock</code></strong> <strong>核心是复用Redisson原生的等待逻辑</strong>：每轮调用<code>tryLock(remainingWaitMs, ...)</code>时，客户端会订阅锁释放通知并阻塞，直到收到通知（立即重试）或本轮等待超时。通过<code>remainingWaitMs</code>控制总等待时间，既保证了“精准唤醒”，又实现了业务级的多轮重试控制。</p><h3 id="方式二：理解Redisson原生等待-唤醒的底层逻辑"><a href="#方式二：理解Redisson原生等待-唤醒的底层逻辑" class="headerlink" title="方式二：理解Redisson原生等待-唤醒的底层逻辑"></a>方式二：理解Redisson原生等待-唤醒的底层逻辑</h3><p>为更深入理解“等待-唤醒”机制，以下简要分析RedissonLock的底层实现流程（基于Redisson 3.x版本），帮助我们更合理地使用可重试功能：</p><h4 id="1-锁获取失败后的订阅逻辑"><a href="#1-锁获取失败后的订阅逻辑" class="headerlink" title="1. 锁获取失败后的订阅逻辑"></a>1. 锁获取失败后的订阅逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RedissonLock#tryAcquireAsync简化逻辑</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 尝试获取锁</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; acquiredFuture = tryLockInnerAsync(waitTime, leaseTime, unit);</span><br><span class="line">    <span class="keyword">return</span> acquiredFuture.thenCompose(acquired -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 获取失败，订阅锁释放通知</span></span><br><span class="line">        <span class="keyword">return</span> subscribeToLockRelease(waitTime, unit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅锁释放频道</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">subscribeToLockRelease</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="type">RTopic</span> <span class="variable">topic</span> <span class="operator">=</span> redisson.getTopic(getChannelName()); <span class="comment">// 频道名：redisson_lock__channel:&#123;lockKey&#125;</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 订阅消息，收到通知后完成future</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">listenerId</span> <span class="operator">=</span> topic.addListener(String.class, (channel, message) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.equals(getLockName())) &#123; <span class="comment">// 验证是当前锁的释放通知</span></span><br><span class="line">            topic.removeListener(listenerId);</span><br><span class="line">            future.complete(<span class="literal">true</span>); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3. 同时设置超时任务，避免无限等待</span></span><br><span class="line">    scheduleTimeout(future, waitTime, unit, listenerId, topic);</span><br><span class="line">    <span class="keyword">return</span> future.thenCompose(ignored -&gt; &#123;</span><br><span class="line">        <span class="comment">// 4. 被唤醒后重新尝试获取锁</span></span><br><span class="line">        <span class="keyword">return</span> tryAcquireAsync(waitTime - usedTime, leaseTime, unit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-锁释放时的通知逻辑"><a href="#2-锁释放时的通知逻辑" class="headerlink" title="2. 锁释放时的通知逻辑"></a>2. 锁释放时的通知逻辑</h4><p>当持有锁的客户端释放锁时，会通过<code>PUBLISH</code>命令向对应频道发送通知，唤醒所有订阅的等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RedissonLock#unlockAsync简化逻辑</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 释放锁（删除Redis中的锁键）</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; releaseFuture = unlockInnerAsync();</span><br><span class="line">    <span class="keyword">return</span> releaseFuture.thenAccept(released -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (released) &#123;</span><br><span class="line">            <span class="comment">// 2. 发布锁释放通知</span></span><br><span class="line">            <span class="type">RTopic</span> <span class="variable">topic</span> <span class="operator">=</span> redisson.getTopic(getChannelName());</span><br><span class="line">            topic.publish(getLockName()); <span class="comment">// 发送当前锁的标识</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-核心优势总结"><a href="#3-核心优势总结" class="headerlink" title="3. 核心优势总结"></a>3. 核心优势总结</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// 原生tryLock的核心价值</span><br><span class="line">1. 无轮询：等待期间线程阻塞，不消耗CPU资源</span><br><span class="line">2. 精准唤醒：仅当锁释放时才触发重试，响应及时</span><br><span class="line">3. 自动超时：避免因通知丢失导致的无限等待</span><br><span class="line">4. 异步非阻塞：底层基于Netty实现异步操作，性能高效</span><br></pre></td></tr></table></figure><p>基于上述底层逻辑，我们在使用Redisson锁可重试功能时，需重点关注以下参数设计：</p><ul><li><p><code>waitTime</code>：单轮最大等待时间（非固定等待），建议设为业务可接受的单次阻塞时长，如1秒；</p></li><li><p><code>totalWaitTime</code>：业务级总等待时间，通过多轮<code>tryLock</code>累加控制，避免整体超时；</p></li><li><p><code>leaseTime</code>：锁租期，需大于业务执行时间，建议结合<code>lockWatchdogTimeout</code>（看门狗机制）自动续期，避免锁提前释放。</p></li></ul><h2 id="四、Redisson锁可重试实现的注意事项"><a href="#四、Redisson锁可重试实现的注意事项" class="headerlink" title="四、Redisson锁可重试实现的注意事项"></a>四、Redisson锁可重试实现的注意事项</h2><p>在实现Redisson锁的可重试机制时，需要注意以下几点，以确保系统的稳定性和正确性：</p><h3 id="1-合理设置重试参数"><a href="#1-合理设置重试参数" class="headerlink" title="1. 合理设置重试参数"></a>1. 合理设置重试参数</h3><p>重试次数和等待时间需要根据业务场景进行调整：</p><ul><li><p>若业务对响应时间敏感，应减少重试次数和等待时间；</p></li><li><p>若锁竞争激烈或网络不稳定，可适当增加重试次数，并采用指数退避等策略延长等待时间。</p></li></ul><h3 id="2-避免死锁风险"><a href="#2-避免死锁风险" class="headerlink" title="2. 避免死锁风险"></a>2. 避免死锁风险</h3><p>Redisson锁本身具有自动过期机制（<code>leaseTime</code>），可以避免死锁，但在重试过程中仍需注意：</p><ul><li><p>确保每次获取锁后都有对应的释放操作（建议使用<code>try-finally</code>块）；</p></li><li><p>不要在重试过程中持有其他资源，以免重试失败时导致资源泄漏。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 正确的锁释放方式</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> tryLockWithRetry(<span class="string">&quot;testLock&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-考虑Redis集群的一致性"><a href="#3-考虑Redis集群的一致性" class="headerlink" title="3. 考虑Redis集群的一致性"></a>3. 考虑Redis集群的一致性</h3><p>在Redis集群环境下，Redisson锁的实现基于Redis的<code>SET NX</code>命令，若采用主从复制架构，主节点宕机可能导致锁信息未同步到从节点，从而出现“锁丢失”问题。此时可考虑使用Redisson的<code>RedissonRedLock</code>（红锁），它通过在多个独立的Redis节点上获取锁，提高锁的可靠性，但会增加性能开销，需根据业务场景权衡。</p><h3 id="4-监控重试-metrics"><a href="#4-监控重试-metrics" class="headerlink" title="4. 监控重试 metrics"></a>4. 监控重试 metrics</h3><p>在生产环境中，建议对锁的重试情况进行监控，记录重试次数、成功率、失败原因等metrics，以便及时发现问题并调整重试策略。例如，使用Prometheus + Grafana监控重试相关指标。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Redisson锁的可重试机制是应对分布式环境中暂时性问题的有效手段，通过“循环尝试 + 条件判断 + 等待策略”的核心思路，结合手动实现或Spring Retry框架，能够灵活满足不同业务场景的需求。在实际应用中，需合理设置重试参数、避免死锁风险、考虑Redis集群一致性，并加强监控，以确保可重试机制的高效与可靠。</p><p>希望本文的思考能够为大家在使用Redisson锁时提供一些帮助，若有不同的见解或更好的实现方式，欢迎在评论区交流讨论！</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows11安装docker</title>
      <link href="/posts/fd5326b3.html"/>
      <url>/posts/fd5326b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-11下安装Docker并修改安装位置至非C盘教程"><a href="#Windows-11下安装Docker并修改安装位置至非C盘教程" class="headerlink" title="Windows 11下安装Docker并修改安装位置至非C盘教程"></a>Windows 11下安装Docker并修改安装位置至非C盘教程</h1><h1 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a>一、安装前准备</h1><h2 id="1-1-检查系统要求"><a href="#1-1-检查系统要求" class="headerlink" title="1.1 检查系统要求"></a>1.1 检查系统要求</h2><p>在安装Docker前，需确保Windows 11系统满足以下条件：</p><ul><li><p>系统版本：Windows 11 64位专业版、企业版或教育版（家庭版需通过WSL 2支持）。</p></li><li><p>硬件要求：支持硬件虚拟化技术（VT-x/AMD-V），并在BIOS/UEFI中启用。</p></li><li><p>WSL 2要求：已安装并启用Windows Subsystem for Linux 2，且内核版本更新至最新。</p></li><li><p>存储空间：非C盘预留至少20GB空闲空间（用于Docker安装及镜像存储）。</p></li></ul><h2 id="1-2-启用必要功能"><a href="#1-2-启用必要功能" class="headerlink" title="1.2 启用必要功能"></a>1.2 启用必要功能</h2><p>打开“控制面板”→“程序”→“程序和功能”→“启用或关闭Windows功能”，勾选以下选项并点击“确定”，等待系统配置完成后重启电脑：</p><ul><li><p>Hyper-V（全部组件）</p></li><li><p>容器</p></li><li><p>Windows虚拟机监控程序平台</p></li></ul><p>若为Windows 11家庭版，需先安装WSL 2：以管理员身份打开PowerShell，输入命令 <code>wsl --install</code>，重启电脑后完成WSL 2安装。</p><h1 id="二、下载Docker安装程序"><a href="#二、下载Docker安装程序" class="headerlink" title="二、下载Docker安装程序"></a>二、下载Docker安装程序</h1><p>访问Docker官方网站（<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>），点击“Download for Windows”下载最新版Docker Desktop安装包（.exe文件），保存至非C盘的临时文件夹（如D:\Temp）。</p><h1 id="三、修改安装位置（已有安装程序时）"><a href="#三、修改安装位置（已有安装程序时）" class="headerlink" title="三、修改安装位置（已有安装程序时）"></a>三、修改安装位置（已有安装程序时）</h1><h2 id="3-1-解压安装程序（可选）"><a href="#3-1-解压安装程序（可选）" class="headerlink" title="3.1 解压安装程序（可选）"></a>3.1 解压安装程序（可选）</h2><p>若已下载Docker安装包，可通过以下方式查看安装文件结构（非必需步骤）：</p><ol><li><p>以管理员身份打开PowerShell，切换至安装包所在目录，例如：<code>cd D:\Temp</code>。</p></li><li><p>输入命令解压安装包：<code>Docker Desktop Installer.exe extract --destination D:\DockerTemp</code>，将安装文件提取至D:\DockerTemp文件夹。</p></li></ol><h2 id="3-2-通过命令行指定安装路径"><a href="#3-2-通过命令行指定安装路径" class="headerlink" title="3.2 通过命令行指定安装路径"></a>3.2 通过命令行指定安装路径</h2><p>这是修改Docker安装位置的核心步骤，需通过命令行参数指定非C盘安装目录：</p><ol><li><p>以<strong>管理员身份</strong>打开PowerShell，切换至Docker安装包所在目录（如D:\Temp）。</p></li><li><p>输入以下命令，将安装位置指定为非C盘路径（以D:\Docker为例）：<br><code>.\Docker Desktop Installer.exe install --installation-dir=D:\Docker --windows-containers=false --wsl2=true</code></p></li><li><p>命令参数说明：</p><pre><code> `--installation-dir=D:\Docker`：指定Docker主程序安装目录（非C盘路径）。</code></pre></li><li><p><code>--windows-containers=false</code>：默认启用Linux容器（如需Windows容器可改为true）。</p></li><li><p><code>--wsl2=true</code>：强制使用WSL 2作为容器运行时（推荐）。</p></li><li><p>执行命令后，等待安装进度完成，期间可能会提示重启电脑，点击“确定”即可。</p></li></ol><div class="tip warning faa-horizontal animated-hover"><p>若之前已安装过Docker并默认在C盘，需先卸载旧版本：打开“设置”→“应用”→“应用和功能”，找到“Docker Desktop”，点击“卸载”，并删除残留文件后再执行上述命令。</p></div><h1 id="四、验证安装结果"><a href="#四、验证安装结果" class="headerlink" title="四、验证安装结果"></a>四、验证安装结果</h1><h2 id="4-1-启动Docker-Desktop"><a href="#4-1-启动Docker-Desktop" class="headerlink" title="4.1 启动Docker Desktop"></a>4.1 启动Docker Desktop</h2><p>安装完成后，在开始菜单中找到“Docker Desktop”并启动，首次启动可能需要几分钟时间（初始化WSL 2环境）。启动成功后，任务栏右下角会显示Docker图标（蓝色鲸鱼图标）。</p><h2 id="4-2-检查安装路径"><a href="#4-2-检查安装路径" class="headerlink" title="4.2 检查安装路径"></a>4.2 检查安装路径</h2><p>打开文件资源管理器，导航至之前指定的安装目录（如D:\Docker），可看到Docker的主程序文件及相关组件，确认安装位置正确。</p><h2 id="4-3-测试Docker功能"><a href="#4-3-测试Docker功能" class="headerlink" title="4.3 测试Docker功能"></a>4.3 测试Docker功能</h2><p>以管理员身份打开PowerShell，输入以下命令测试Docker是否正常工作：</p><ol><li><p>查看Docker版本：<code>docker --version</code>，若输出类似“Docker version 26.1.4, build 5650f9b”则说明版本查询正常。</p></li><li><p>运行Hello World镜像：<code>docker run hello-world</code>，若输出“Hello from Docker!”等信息，说明Docker已成功拉取并运行镜像，功能正常。</p></li></ol><h1 id="五、后续配置（可选）"><a href="#五、后续配置（可选）" class="headerlink" title="五、后续配置（可选）"></a>五、后续配置（可选）</h1><h2 id="5-1-修改镜像存储位置"><a href="#5-1-修改镜像存储位置" class="headerlink" title="5.1 修改镜像存储位置"></a>5.1 修改镜像存储位置</h2><p>默认情况下，Docker镜像存储在WSL 2分发版的虚拟磁盘中（通常位于C盘），可通过以下步骤迁移至非C盘：</p><ol><li><p>关闭Docker Desktop：右键任务栏Docker图标，点击“Quit Docker Desktop”。</p></li><li><p>导出WSL 2分发版：在PowerShell中输入<code>wsl --export docker-desktop-data D:\Docker\wsl\data\docker-desktop-data.tar</code>。</p></li><li><p>注销现有分发版：<code>wsl --unregister docker-desktop-data</code>。</p></li><li><p>重新导入分发版至非C盘：<code>wsl --import docker-desktop-data D:\Docker\wsl\data D:\Docker\wsl\data\docker-desktop-data.tar --version 2</code>。</p></li><li><p>重启Docker Desktop，镜像存储位置即迁移至D:\Docker\wsl\data。</p></li></ol><h2 id="5-2-配置国内镜像源"><a href="#5-2-配置国内镜像源" class="headerlink" title="5.2 配置国内镜像源"></a>5.2 配置国内镜像源</h2><p>为加快镜像拉取速度，可配置国内镜像源：打开Docker Desktop，点击“Settings”→“Docker Engine”，在JSON配置中添加镜像源，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.1ms.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker-0.unsee.tech&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>点击“Apply &amp; Restart”保存配置并重启Docker。</p><h1 id="六、常见问题解决"><a href="#六、常见问题解决" class="headerlink" title="六、常见问题解决"></a>六、常见问题解决</h1><ul><li><p><strong>问题1：安装时提示“Hyper-V未启用”</strong>：重新检查“启用或关闭Windows功能”中Hyper-V组件是否全部勾选，若已勾选仍报错，可能是BIOS中虚拟化未启用，需重启电脑进入BIOS开启VT-x/AMD-V。</p></li><li><p><strong>问题2：Docker启动卡在“Starting…”</strong>：关闭Docker后，在PowerShell中输入<code>wsl --shutdown</code>关闭WSL 2，再重新启动Docker。</p></li><li><p><strong>问题3：命令行输入docker命令提示“command not found”</strong>：检查系统环境变量PATH中是否包含Docker安装目录（如D:\Docker\resources\bin），若未包含需手动添加后重启PowerShell。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爬取贴吧的两种网页差异</title>
      <link href="/posts/cf38f81c.html"/>
      <url>/posts/cf38f81c.html</url>
      
        <content type="html"><![CDATA[<h1 id="百度贴吧爬取时两种网页结构的差异"><a href="#百度贴吧爬取时两种网页结构的差异" class="headerlink" title="百度贴吧爬取时两种网页结构的差异"></a>百度贴吧爬取时两种网页结构的差异</h1><p>百度贴吧作为国内极具影响力的中文社区，其海量的用户生成内容（UGC）是进行市场调研、情感分析、热点追踪的宝贵数据资源。但在实际爬取过程中，很多开发者会遇到“明明XPath规则正确却爬不到数据”的问题，其核心原因在于百度贴吧存在两种差异化的前端渲染结构。</p><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h3 id="1-1-贴吧URL结构分析"><a href="#1-1-贴吧URL结构分析" class="headerlink" title="1.1 贴吧URL结构分析"></a>1.1 贴吧URL结构分析</h3><p>贴吧的帖子URL遵循固定格式，掌握后可批量构造爬取链接：</p><ul><li><p><strong>单页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]</code>（默认显示第一页）</p></li><li><p><strong>分页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]?pn=[页码]</code>（pn参数指定页码，如pn=2表示第二页）</p></li></ul><p>例如：帖子<code>https://tieba.baidu.com/p/789012345?pn=3</code>表示ID为789012345的帖子的第三页内容。</p><h2 id="二、两种网页结构的深度对比"><a href="#二、两种网页结构的深度对比" class="headerlink" title="二、两种网页结构的深度对比"></a>二、两种网页结构的深度对比</h2><p>通过Chrome开发者工具（F12）查看网页源码，我们发现两种结构的核心差异集中在<strong>帖子内容容器</strong>和<strong>发布时间节点</strong>，以下是具体对比：</p><h3 id="2-1-结构一：传统版（无clearfix后缀）"><a href="#2-1-结构一：传统版（无clearfix后缀）" class="headerlink" title="2.1 结构一：传统版（无clearfix后缀）"></a>2.1 结构一：传统版（无clearfix后缀）</h3><p>通过“检查”功能定位到帖子内容和发布时间节点，其HTML结构如下：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/2.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code></p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#39;)</code><br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//span[@class=&quot;tail-info&quot;]/text()&#39;)[-1] for i in create_time]</code>（取最后一个tail-info的文本）</p></li></ul><h3 id="2-2-结构二：新版（含clearfix后缀）"><a href="#2-2-结构二：新版（含clearfix后缀）" class="headerlink" title="2.2 结构二：新版（含clearfix后缀）"></a>2.2 结构二：新版（含clearfix后缀）</h3><p>其HTML结构调整了class属性和节点层级：</p><p><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/3.png" alt="code"><br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/4.png" alt="code"></p><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code>（注意两个空格）</p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail &quot;]&#39;)</code>（<br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#39;)[-1] for i in create_time]</code>取p_tail最后一个li的span文本）</p></li></ul><p><strong>关键提醒</strong>：XPath中class属性的匹配是<strong>精确匹配</strong>，空格和后缀的差异会导致解析失败。在编写规则时，必须完全复制网页源码中的class值。</p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 提取帖子评论数据第一种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#x27;</span>)</span><br><span class="line">create_time = [i.xpath(<span class="string">&#x27;.//span[@class=&quot;tail-info&quot;]/text()&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> create_time]</span><br><span class="line"><span class="comment"># 提取帖子评论数据第二种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail &quot;]&#x27;</span>)</span><br><span class="line">create_time_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> create_time:</span><br><span class="line">    time_elements = i.xpath(<span class="string">&#x27;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> time_elements:</span><br><span class="line">        create_time_list.append(time_elements[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        create_time_list.append(<span class="string">&#x27;未知&#x27;</span>)</span><br><span class="line">create_time = create_time_list</span><br></pre></td></tr></table></figure><h2 id="四、关于爬取贴吧列表"><a href="#四、关于爬取贴吧列表" class="headerlink" title="四、关于爬取贴吧列表"></a>四、关于爬取贴吧列表</h2><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h3><p>贴吧列表页面如下所示<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/5.png" alt="code"><br>现在我们想要获取列表页的贴子名称，帖子作者，帖子链接，帖子时间<br>原来的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">        title_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@title&#x27;</span>)</span><br><span class="line">        link_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@href&#x27;</span>)</span><br><span class="line">        creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot;]/@title&#x27;</span>)</span><br><span class="line">        create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>看上去似乎没有什么问题 ，但是运行代码的时候，发现爬取的帖子有些标题跟时间对不上这会导致一些问题。<br>所以这到底是为什么呢？<br>我们可以打开f12查看网页源代码，查看列表页面的html结构，通过观察可以发现，一些帖子的标题，链接，发帖人的html结构跟大部分还不一样。<br>例如普通的标题页面结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/6.png" alt="code"><br>但是某些帖子标题的html结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/7.png" alt="code"><br>可以发现少部分贴子的标题比普通的多了member_thread_title_frs 这一段文字 导致获取不到一些帖子标题，所以也就造成了之后的时间不一致的问题。</p><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><p>解决方法很简单只需要在多匹配那少部分的内容即可。<br>可以把原来的正则表达式替换为<code>//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title</code>。<br>这样就能匹配只要有threadlist_title pull_left j_th_tit 的内容了。<br>但是注意这里的作者名称，一个帖子会有两个作者名称。第一个是帖子作者，第二个是最后评论的人的名称。这里我们只需要获取第一个作者名称即可。<br>于是关于作者名称的正则表达式用or即可。<br>修改的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">title_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title&#x27;</span>)</span><br><span class="line">link_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@href&#x27;</span>)</span><br><span class="line"><span class="comment"># 修改后的作者匹配规则，只匹配指定的两种形式</span></span><br><span class="line">creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot; or @class=&quot;tb_icon_author no_icon_author&quot;]/@title&#x27;</span>)</span><br><span class="line">create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>这样修改之后就可以匹配到正确的完整的数据了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬取微博移动端评论</title>
      <link href="/posts/eb47d163.html"/>
      <url>/posts/eb47d163.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬取微博移动端评论完整教程（基础-常见问题）"><a href="#Python爬取微博移动端评论完整教程（基础-常见问题）" class="headerlink" title="Python爬取微博移动端评论完整教程（基础+常见问题）"></a>Python爬取微博移动端评论完整教程（基础+常见问题）</h1><p>在数据采集领域，微博作为国内主流的社交媒体平台，其评论数据蕴含着丰富的用户观点和舆论倾向。相较于PC端，微博移动端接口更简洁、反爬措施相对宽松，是获取评论数据的优选方案。本文将以<strong>Python</strong>为工具，从环境搭建到代码实现，手把手教你爬取微博移动端评论，并解答过程中可能遇到的常见问题。</p><hr><h2 id="一、基础教程：从零实现微博评论爬取"><a href="#一、基础教程：从零实现微博评论爬取" class="headerlink" title="一、基础教程：从零实现微博评论爬取"></a>一、基础教程：从零实现微博评论爬取</h2><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><p>首先需要搭建Python爬虫环境，核心依赖库如下：</p><ul><li><p><strong>requests</strong>：发送HTTP请求，获取接口数据</p></li><li><p><strong>json</strong>：解析接口返回的JSON数据（Python内置，无需安装）</p></li><li><p><strong>pandas</strong>：数据存储与导出（可选，用于生成Excel文件）</p></li><li><p><strong>time</strong>：设置请求间隔，避免被反爬（Python内置）</p></li></ul><p>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install requests pandas</span><br></pre></td></tr></table></figure><h3 id="1-2-核心原理：找到评论接口"><a href="#1-2-核心原理：找到评论接口" class="headerlink" title="1.2 核心原理：找到评论接口"></a>1.2 核心原理：找到评论接口</h3><p>微博移动端评论通过AJAX异步加载，我们需要先找到真实的评论接口。步骤如下：</p><ol><li><p>打开手机浏览器（或电脑浏览器切换到<strong>移动端模式</strong>），登录微博账号，找到目标微博（例如：<a href="https://m.weibo.cn/detail/4900000000000000">https://m.weibo.cn/detail/4900000000000000</a>）</p></li><li><p>按F12打开开发者工具，切换到<strong>Network</strong>标签，勾选<strong>XHR</strong>（筛选AJAX请求）</p></li><li><p>下拉页面加载评论，此时会看到名为<strong>comment</strong>的请求，点击该请求查看详情</p></li><li><p>在<strong>Request URL</strong>中可以看到评论接口地址，在<strong>Response</strong>中可以看到JSON格式的评论数据</p></li></ol><div class="note primary modern"><p>典型的微博评论接口格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://m.weibo.cn/comments/hotflow?id=微博ID&amp;mid=微博ID&amp;max_id=下一页标识&amp;max_id_type=0</span><br></pre></td></tr></table></figure></div><p>参数说明：</p><ul><li><p><strong>id/mid</strong>：目标微博的ID（从微博详情页URL中获取，例如URL末尾的数字串）</p></li><li><p><strong>max_id</strong>：分页标识，初始为0，后续页面的max_id从当前响应中获取</p></li><li><p><strong>max_id_type</strong>：固定为0即可</p></li></ul><h3 id="1-3-代码实现步骤"><a href="#1-3-代码实现步骤" class="headerlink" title="1.3 代码实现步骤"></a>1.3 代码实现步骤</h3><h4 id="步骤1：获取请求头（Headers）"><a href="#步骤1：获取请求头（Headers）" class="headerlink" title="步骤1：获取请求头（Headers）"></a>步骤1：获取请求头（Headers）</h4><p>为了模拟真实用户请求，需要在请求中添加Headers，核心参数包括<strong>User-Agent</strong>和<strong>Cookie</strong>：</p><ul><li><p><strong>User-Agent</strong>：标识浏览器类型，移动端UA示例：<code>Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1</code></p></li><li><p><strong>Cookie</strong>：包含登录状态信息，从浏览器开发者工具的Request Headers中复制（登录后才能获取更多评论）</p></li></ul><h4 id="步骤2：发送请求并解析数据"><a href="#步骤2：发送请求并解析数据" class="headerlink" title="步骤2：发送请求并解析数据"></a>步骤2：发送请求并解析数据</h4><p>编写代码发送GET请求，解析JSON响应中的评论内容（用户名、评论时间、评论内容等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置信息</span></span><br><span class="line">weibo_id = <span class="string">&quot;4900000000000000&quot;</span>  <span class="comment"># 目标微博ID</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;你的Cookie信息&quot;</span>  <span class="comment"># 替换为自己的Cookie</span></span><br><span class="line">&#125;</span><br><span class="line">comments = []  <span class="comment"># 存储评论数据</span></span><br><span class="line">max_id = <span class="number">0</span>  <span class="comment"># 初始分页标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 构建请求URL</span></span><br><span class="line">    url = <span class="string">f&quot;https://m.weibo.cn/comments/hotflow?id=<span class="subst">&#123;weibo_id&#125;</span>&amp;mid=<span class="subst">&#123;weibo_id&#125;</span>&amp;max_id=<span class="subst">&#123;max_id&#125;</span>&amp;max_id_type=0&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">        response.raise_for_status()  <span class="comment"># 若状态码不是200，抛出异常</span></span><br><span class="line">        data = json.loads(response.text)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取评论列表</span></span><br><span class="line">        comment_list = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;data&quot;</span>, [])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> comment_list:  <span class="comment"># 没有更多评论时退出循环</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已获取所有评论&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解析每条评论</span></span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> comment_list:</span><br><span class="line">            item = &#123;</span><br><span class="line">                <span class="string">&quot;用户名&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;screen_name&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;用户ID&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论时间&quot;</span>: comment.get(<span class="string">&quot;created_at&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论内容&quot;</span>: comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;点赞数&quot;</span>: comment.get(<span class="string">&quot;like_count&quot;</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="string">&quot;回复数&quot;</span>: comment.get(<span class="string">&quot;reply_count&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            comments.append(item)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;已获取<span class="subst">&#123;<span class="built_in">len</span>(comments)&#125;</span>条评论&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新下一页的max_id</span></span><br><span class="line">        max_id = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;max_id&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> max_id == <span class="number">0</span>:  <span class="comment"># 没有下一页时退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置请求间隔，避免被封IP</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;请求出错：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="步骤3：数据存储"><a href="#步骤3：数据存储" class="headerlink" title="步骤3：数据存储"></a>步骤3：数据存储</h4><p>将爬取到的评论数据导出为Excel文件，方便后续分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 转换为DataFrame并导出</span></span><br><span class="line">df = pd.DataFrame(comments)</span><br><span class="line">df.to_excel(<span class="string">&quot;微博评论.xlsx&quot;</span>, index=<span class="literal">False</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;评论数据已保存到微博评论.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="二、常见问题及解决方案"><a href="#二、常见问题及解决方案" class="headerlink" title="二、常见问题及解决方案"></a>二、常见问题及解决方案</h2><h3 id="2-1-问题1：请求返回403-401错误"><a href="#2-1-问题1：请求返回403-401错误" class="headerlink" title="2.1 问题1：请求返回403/401错误"></a>2.1 问题1：请求返回403/401错误</h3><p><strong>原因</strong>：Headers参数不完整或Cookie失效，服务器识别为爬虫请求。</p><p><strong>解决方案</strong>：</p><ul><li><p>检查Cookie是否正确，重新登录微博后复制最新的Cookie</p></li><li><p>补充Headers中的其他参数（如<strong>Referer</strong>：设置为目标微博详情页URL）</p></li><li><p>确保User-Agent是移动端格式，避免使用PC端UA</p></li></ul><h3 id="2-2-问题2：只能爬取前20条评论"><a href="#2-2-问题2：只能爬取前20条评论" class="headerlink" title="2.2 问题2：只能爬取前20条评论"></a>2.2 问题2：只能爬取前20条评论</h3><p><strong>原因</strong>：未正确处理分页参数max_id，或未登录导致只能获取公开评论。</p><p><strong>解决方案</strong>：</p><ul><li><p>确保登录状态（Cookie有效），登录后可获取更多评论</p></li><li><p>检查max_id是否正确从响应中提取，避免手动设置固定值</p></li><li><p>部分微博可能限制评论查看权限，属于正常情况</p></li></ul><h3 id="2-3-问题3：IP被封禁，无法发送请求"><a href="#2-3-问题3：IP被封禁，无法发送请求" class="headerlink" title="2.3 问题3：IP被封禁，无法发送请求"></a>2.3 问题3：IP被封禁，无法发送请求</h3><p><strong>原因</strong>：请求频率过高，触发微博反爬机制。</p><p><strong>解决方案</strong>：</p><ul><li><p>增加请求间隔时间（如time.sleep(3-5秒)），避免高频请求</p></li><li><p>使用代理IP池，轮换IP地址发送请求（推荐使用高匿代理）</p></li><li><p>暂停爬取1-2小时，IP封禁通常是临时的</p></li></ul><h3 id="2-4-问题4：评论内容含HTML标签"><a href="#2-4-问题4：评论内容含HTML标签" class="headerlink" title="2.4 问题4：评论内容含HTML标签"></a>2.4 问题4：评论内容含HTML标签</h3><p><strong>原因</strong>：接口返回的text字段包含HTML格式（如表情、话题链接等）。</p><p><strong>解决方案</strong>：使用<strong>BeautifulSoup</strong>清理HTML标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理评论内容中的HTML标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_html</span>(<span class="params">text</span>):</span><br><span class="line">    soup = BeautifulSoup(text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> soup.get_text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在解析评论时调用</span></span><br><span class="line"><span class="string">&quot;评论内容&quot;</span>: clean_html(comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>)),</span><br></pre></td></tr></table></figure><h3 id="2-5-问题5：响应数据格式异常"><a href="#2-5-问题5：响应数据格式异常" class="headerlink" title="2.5 问题5：响应数据格式异常"></a>2.5 问题5：响应数据格式异常</h3><p><strong>原因</strong>：接口参数变化或微博更新反爬策略。</p><p><strong>解决方案</strong>：</p><ul><li><p>重新通过浏览器开发者工具抓取最新的评论接口，确认参数是否变化</p></li><li><p>打印response.text查看原始响应，分析数据格式是否与预期一致</p></li><li><p>关注微博接口的官方变化（若有），及时调整代码</p></li></ul><h3 id="2-6-问题6：请求第一页之后的数据响应ok-0"><a href="#2-6-问题6：请求第一页之后的数据响应ok-0" class="headerlink" title="2.6 问题6：请求第一页之后的数据响应ok{0}"></a>2.6 问题6：请求第一页之后的数据响应ok{0}</h3><p><strong>原因</strong>：请求的Cookie已失效，需要重新登录获取Cookie。(因为微博需要登录才能查看更多评论)</p><p><strong>解决方案</strong>：</p><ul><li>登录微博账号，打开浏览器开发者工具，选择Network选项卡，点击刷新按钮。</li><li>在Network选项卡中，找到对应的请求，查看响应头，找到Cookie字段，复制Cookie值。</li><li>将Cookie值替换为配置文件中的Cookie字段。</li><li>重新运行代码，即可获取最新数据。</li></ul><hr><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ul><li><p><strong>合规性</strong>：爬取微博数据需遵守《微博服务使用协议》，不得用于商业用途或恶意攻击，建议仅用于个人学习研究</p></li><li><p><strong>登录状态</strong>：尽量使用小号登录，避免主号因爬虫行为被限制</p></li><li><p><strong>请求频率</strong>：保持低调，避免短时间内发送大量请求，友好对待服务器</p></li><li><p><strong>数据备份</strong>：定期保存爬取到的数据，防止程序异常导致数据丢失</p></li></ul><p>通过以上步骤，你可以成功爬取微博移动端评论数据。如果遇到其他问题，欢迎在评论区留言交流！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于GitHub Pages加载静态文件失败</title>
      <link href="/posts/b1168866.html"/>
      <url>/posts/b1168866.html</url>
      
        <content type="html"><![CDATA[<h1 id="解决Github-Pages不加载Vue框架项目静态文件问题"><a href="#解决Github-Pages不加载Vue框架项目静态文件问题" class="headerlink" title="解决Github Pages不加载Vue框架项目静态文件问题"></a>解决Github Pages不加载Vue框架项目静态文件问题</h1><p>在使用Vue框架开发项目并部署到Github Pages时，很多开发者都会遇到一个头疼的问题：页面能够正常访问，但项目中的JS、CSS等静态文件却无法加载，导致页面样式错乱、功能失效。其实这个问题的核心在于静态文件的路径配置不当，本文将详细介绍如何通过配置打包工具的路径以及Github Pages设置来解决这一问题，并分别以Vite和Webpack两种常用打包工具进行演示。</p><h2 id="一、问题原因分析"><a href="#一、问题原因分析" class="headerlink" title="一、问题原因分析"></a>一、问题原因分析</h2><p>Github Pages部署的项目，其访问路径通常是 <code>https://[用户名].github.io/[项目名]/</code>，而Vue项目默认的静态文件路径是基于根目录（<code>/</code>）的。当项目部署到Github Pages后，静态文件会被请求从根目录获取，而实际静态文件却在<code>/[项目名]/</code>目录下，这就导致了路径不匹配，静态文件加载失败。</p><h2 id="二、不同打包工具的配置方法"><a href="#二、不同打包工具的配置方法" class="headerlink" title="二、不同打包工具的配置方法"></a>二、不同打包工具的配置方法</h2><div class="note primary modern"><p>解决该问题的关键是修改打包工具的静态文件公共路径（publicPath），使其指向Github Pages的项目地址。</p></div><div class="tip success"><p>如果你不想打包，直接在根目录下有一个index.html静态网页文件。那么将里面js,css等静态文件的引用路径前面加上<code>/[项目名]/</code>即可。例如：/static/js/app.js —&gt; /[项目名]/static/js/app.js 如果成功则无需打包</p></div><p>下面分别介绍Vite和Webpack的配置步骤。</p><h3 id="2-1-Vite打包工具配置"><a href="#2-1-Vite打包工具配置" class="headerlink" title="2.1 Vite打包工具配置"></a>2.1 Vite打包工具配置</h3><p>Vite是目前Vue项目常用的构建工具，配置方式较为简洁，只需修改项目根目录下的<code>vite.config.js</code>文件。</p><ol><li><p><strong>找到vite.config.js文件</strong>：该文件位于Vue项目的根目录下，如果没有则手动创建。</p></li><li><p><strong>配置publicPath</strong>：在<code>defineConfig</code>对象中添加<code>base</code>属性（Vite中publicPath对应的是base），其值设置为你的Github Pages项目地址。格式为 <code>&#39;https://[用户名].github.io/[项目名]/&#39;</code>，例如如果用户名为<code>testuser</code>，项目名为<code>vue-demo</code>，则配置为 <code>base: &#39;https://testuser.github.io/vue-demo/&#39;</code>。</p></li><li><p><strong>设置打包输出目录</strong>：默认情况下Vite打包输出到<code>dist</code>目录，我们需要将其改为<code>docs</code>目录，方便后续Github Pages配置。在<code>defineConfig</code>中添加<code>build</code>选项，设置<code>outDir: &#39;docs&#39;</code>。</p></li></ol><p>配置完成后的<code>vite.config.js</code>文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;https://testuser.github.io/vue-demo/&#x27;</span>, <span class="comment">// 替换为你的项目地址</span></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">outDir</span>: <span class="string">&#x27;docs&#x27;</span> <span class="comment">// 打包输出到docs目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>base路径不唯一 可自行在浏览器控制台中查看请求路径  将请求路径调整为 https://&lt;你的名称&gt;.github.io/&lt;项目名称&gt;/静态文件路径。即可<br>配置完成后，执行<code>npm run build</code>命令进行打包，此时项目根目录下会生成<code>docs</code>文件夹，里面包含了打包后的静态文件。</p><h3 id="2-2-Webpack打包工具配置（Vue-CLI项目）"><a href="#2-2-Webpack打包工具配置（Vue-CLI项目）" class="headerlink" title="2.2 Webpack打包工具配置（Vue CLI项目）"></a>2.2 Webpack打包工具配置（Vue CLI项目）</h3><p>如果你的Vue项目是使用Vue CLI创建的，那么使用的打包工具是Webpack，需要修改<code>vue.config.js</code>文件。</p><ol><li><p><strong>找到vue.config.js文件</strong>：该文件位于Vue项目的根目录下，若不存在则手动创建。</p></li><li><p><strong>配置publicPath</strong>：在配置对象中添加<code>publicPath</code>属性，值设置为你的Github Pages项目地址，格式与Vite相同，即 <code>&#39;https://[用户名].github.io/[项目名]/&#39;</code>。</p></li><li><p><strong>设置打包输出目录</strong>：同样将打包输出目录改为<code>docs</code>，在配置对象中添加<code>outputDir: &#39;docs&#39;</code>。</p></li></ol><p>配置完成后的<code>vue.config.js</code>文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;https://testuser.github.io/vue-demo/&#x27;</span>, <span class="comment">// 替换为你的项目地址</span></span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&#x27;docs&#x27;</span> <span class="comment">// 打包输出到docs目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npm run build</code>命令打包，项目根目录会生成<code>docs</code>文件夹，包含打包后的静态资源。</p><h2 id="三、Github-Pages配置步骤"><a href="#三、Github-Pages配置步骤" class="headerlink" title="三、Github Pages配置步骤"></a>三、Github Pages配置步骤</h2><p>完成打包工具配置并生成<code>docs</code>文件夹后，需要在Github仓库中设置Github Pages的部署源。</p><ol><li><p><strong>推送代码到Github仓库</strong>：将包含<code>docs</code>文件夹的项目代码推送到Github仓库的<code>main</code>分支（或你使用的主分支）。</p></li><li><p><strong>进入仓库设置</strong>：打开你的Github项目仓库，点击右上角的<code>Settings</code>选项。</p></li><li><p><strong>找到Github Pages设置</strong>：在左侧导航栏中找到<code>Pages</code>选项并点击进入。</p></li><li><p><strong>设置部署源</strong>：在<code>Build and deployment</code>下的<code>Source</code>选项中，选择<code>Deploy from a branch</code>。然后在<code>Branch</code>选项中，选择<code>main</code>分支，并在后面的文件夹选择框中选择<code>/docs</code>，点击<code>Save</code>保存设置。</p></li></ol><p>设置完成后，Github Pages会自动部署你的项目，通常几分钟后即可通过<code>https://[用户名].github.io/[项目名]/</code>访问，此时JS、CSS等静态文件就能正常加载了。</p><h2 id="四、常见问题排查"><a href="#四、常见问题排查" class="headerlink" title="四、常见问题排查"></a>四、常见问题排查</h2><ul><li><p><strong>publicPath配置错误</strong>：确保publicPath（Vite中为base）的路径正确，末尾必须加上<code>/</code>，否则可能导致部分静态文件路径拼接错误。</p></li><li><p><strong>docs文件夹未推送</strong>：检查是否将打包生成的<code>docs</code>文件夹推送到了Github仓库，若未推送则需要执行<code>git add docs</code>、<code>git commit -m &quot;add docs&quot;</code>、<code>git push</code>命令。</p></li><li><p><strong>分支或文件夹选择错误</strong>：确认Github Pages设置中选择的分支是<code>main</code>（或你的项目主分支），文件夹是<code>/docs</code>。</p></li></ul><h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、<wavy>额外注意</wavy></h2><div class="tip warning faa-horizontal animated-hover"><p>github pages 默认是使用jekyll作为静态文件处理引擎，这个会默认删除静态文件名的下划线_导致静态文件无法加载。</p></div><p>解决方法：即在跟目录下创建一个名为.nojekyll的文件即可取消jekyll<br>关于jekyll的详细介绍可以参考：<a href="https://jekyllcn.com/docs/home/">https://jekyllcn.com/docs/home/</a></p><p>通过以上步骤，就能顺利解决Github Pages不加载Vue项目静态文件的问题。核心在于正确配置打包工具的publicPath路径，并将打包文件输出到docs目录，再配合Github Pages的部署源设置，即可实现项目的正常访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机与数学的那些事</title>
      <link href="/posts/f8b7ba6f.html"/>
      <url>/posts/f8b7ba6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="学计算机一定要数学好吗？不同岗位需求大不同"><a href="#学计算机一定要数学好吗？不同岗位需求大不同" class="headerlink" title="学计算机一定要数学好吗？不同岗位需求大不同"></a>学计算机一定要数学好吗？不同岗位需求大不同</h1><p>“我数学不好，是不是学不了计算机？”这是很多想入行计算机领域的人都会问的问题。其实这个问题没有绝对的答案，核心在于你想从事计算机领域的哪个岗位。在我看来，<strong>普通开发岗对数学功底的要求并不高，而算法岗和人工智能岗则需要扎实且甚至高于计算机知识本身的数学基础</strong>。今天就来详细聊聊不同岗位对数学的真实需求，帮大家消除认知误区。</p><h2 id="一、普通开发岗：数学是“加分项”而非“必需品”"><a href="#一、普通开发岗：数学是“加分项”而非“必需品”" class="headerlink" title="一、普通开发岗：数学是“加分项”而非“必需品”"></a>一、普通开发岗：数学是“加分项”而非“必需品”</h2><p>普通开发岗涵盖的范围很广，比如前端开发、后端开发、移动端开发、全栈开发等，这些岗位的核心是“实现业务需求”，更看重的是编程能力、逻辑思维和业务理解能力，对数学的要求远没有大家想象中那么高。</p><p>以前端开发为例，日常工作主要是用HTML、CSS、JavaScript构建用户界面，实现页面交互效果。即使是用到React、Vue等框架，核心也是组件化思想和状态管理，涉及到的数学知识可能最多就是简单的布局计算（比如用Flex或Grid布局时的百分比、像素换算），连初中数学知识都能应对。后端开发虽然会接触到数据库、服务器等，但更多是掌握编程语言（如Java、Python、Go）、框架（如Spring、Django）和数据库优化技巧，数学知识的应用场景少之又少。</p><p>我身边有不少做普通开发的学长，大学时数学成绩并不突出，但凭借扎实的编程基础和不断积累的业务经验，照样能成为团队里的骨干。当然，这并不是说数学对普通开发岗毫无用处——如果懂一点离散数学，在理解数据结构（如树、图）时会更轻松；如果懂一点线性代数，在处理图形相关的开发任务时可能会更得心应手。但这些都属于“加分项”，而非“入门必备项”，不会成为阻碍你入行和发展的绊脚石。</p><h2 id="二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要"><a href="#二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要" class="headerlink" title="二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要"></a>二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要</h2><p>与普通开发岗不同，算法岗（如机器学习算法工程师、推荐算法工程师）和人工智能岗（如AI研究员、深度学习工程师）对数学的要求极高，数学知识是开展工作的核心基础，甚至在很多场景下比单纯的计算机知识更重要。</p><p>这些岗位的工作本质是“解决复杂问题”，需要通过数学模型来抽象现实问题，并设计高效的算法来求解。这就要求从业者必须掌握多门高等数学知识：</p><ul><li><p><strong>线性代数</strong>：是机器学习的基础，比如数据的表示（向量、矩阵）、特征变换（矩阵乘法、特征值分解）、降维算法（PCA）等，都离不开线性代数的知识。如果不懂矩阵运算，连最简单的神经网络前向传播都无法理解。</p></li><li><p><strong>概率论与数理统计</strong>：在处理不确定性问题时至关重要，比如贝叶斯分类器、概率模型（如隐马尔可夫模型）、模型评估指标（准确率、召回率、ROC曲线）等，都需要概率论和统计学的支撑。</p></li><li><p><strong>微积分</strong>：主要用于优化算法，比如机器学习中的梯度下降法，就是通过求导来找到函数的最小值点，从而更新模型参数。如果不懂导数、偏导数，就无法理解优化算法的原理，更谈不上调优模型。</p></li><li><p><strong>离散数学</strong>：在图算法、组合优化等领域应用广泛，比如最短路径算法（Dijkstra、Floyd）、图神经网络（GNN）等，都需要离散数学的知识作为铺垫。</p></li></ul><p>举个例子，如果你想做深度学习工程师，搭建一个神经网络模型可能用TensorFlow或PyTorch几行代码就能实现，但要想让模型达到更好的效果——比如调整网络结构、优化损失函数、解决过拟合问题，就必须深入理解模型背后的数学原理。如果数学基础薄弱，只能停留在“调参工程师”的层面，无法真正成为一名优秀的算法或AI工程师。很多顶尖的AI研究员，本身就是数学专业出身，可见数学在这个领域的重要性。</p><h2 id="三、总结：根据目标岗位，合理规划数学学习"><a href="#三、总结：根据目标岗位，合理规划数学学习" class="headerlink" title="三、总结：根据目标岗位，合理规划数学学习"></a>三、总结：根据目标岗位，合理规划数学学习</h2><p>回到最初的问题“学计算机一定要数学好吗？”，答案已经很清晰了：</p><div class="tip warning faa-horizontal animated"><p>如果你目标是普通开发岗，不用因为数学不好而焦虑，重点放在提升编程能力和逻辑思维上，数学可以作为后续提升的补充；如果你目标是算法岗或人工智能岗，那么一定要打好数学基础，把线性代数、概率论、微积分等核心知识学扎实，这比单纯掌握编程语言和框架更重要。</p></div><p>计算机领域博大精深，不同岗位的需求差异很大。关键是明确自己的职业方向，然后有针对性地学习。不要被“数学不好就不能学计算机”的误区吓住，也不要忽视算法和AI岗对数学的高要求。希望这篇文章能帮大家更清晰地认识计算机与数学的关系，祝大家在计算机的道路上走得更远！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdelivr不可用替代方案</title>
      <link href="/posts/6acc4ad2.html"/>
      <url>/posts/6acc4ad2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客提速实战：cdn-jsdelivr-net不可用"><a href="#Hexo博客提速实战：cdn-jsdelivr-net不可用" class="headerlink" title="Hexo博客提速实战：cdn.jsdelivr.net不可用"></a>Hexo博客提速实战：cdn.jsdelivr.net不可用</h1><p>对于使用Hexo搭建个人博客的开发者和博主而言，网站加载速度直接影响用户体验与内容传播效果。不少用户在运营过程中会发现，博客打开缓慢、样式加载延迟甚至部分资源失效，排查后往往能定位到核心问题——默认依赖的<code>cdn.jsdelivr.net</code>在国内网络环境下表现不佳。本文将从问题根源出发，提供一套完整的CDN替换方案，帮助你快速解决Hexo博客速度难题。</p><h2 id="一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？"><a href="#一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？" class="headerlink" title="一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？"></a>一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？</h2><p>在分析解决方案前，我们先明确<code>cdn.jsdelivr.net</code>导致Hexo博客速度慢的核心原因，避免盲目优化：</p><h3 id="1-网络环境的天然限制"><a href="#1-网络环境的天然限制" class="headerlink" title="1. 网络环境的天然限制"></a>1. 网络环境的天然限制</h3><p><code>jsDelivr</code>作为全球通用的开源CDN服务，其核心节点主要分布在北美、欧洲等海外地区。国内用户访问时，数据需经过跨境网络链路传输，受国际带宽、路由跳转等因素影响，延迟通常高达100-800ms，部分地区甚至出现数据包丢失。</p><h3 id="2-资源加载的连锁反应"><a href="#2-资源加载的连锁反应" class="headerlink" title="2. 资源加载的连锁反应"></a>2. 资源加载的连锁反应</h3><p>Hexo主题（如Next、Butterfly、Matery）默认依赖<code>jsDelivr</code>加载大量关键资源，包括：</p><ul><li>样式文件：CSS框架（Bootstrap）、图标库（Font Awesome）</li><li>脚本文件：交互插件（jQuery）、代码高亮（Prism.js）、评论系统（Valine）</li><li>静态资源：字体文件、主题图片、第三方组件</li></ul><p>这些资源若加载延迟，会导致页面“白屏时间”延长、样式错乱，甚至触发浏览器的“资源加载超时”错误。</p><h3 id="3-国内镜像的优势"><a href="#3-国内镜像的优势" class="headerlink" title="3. 国内镜像的优势"></a>3. 国内镜像的优势</h3><p><code>cdn.jsdmirror.com</code>是专为国内用户搭建的<code>jsDelivr</code>镜像服务，具备三大核心优势：</p><ul><li><strong>节点覆盖广</strong>：在国内30+城市部署节点，用户访问时自动匹配最近节点，延迟可降至50ms以内</li><li><strong>同步速度快</strong>：实时同步<code>jsDelivr</code>的GitHub仓库与npm包资源，资源更新无延迟</li><li><strong>访问稳定性高</strong>：规避跨境网络波动，支持HTTPS加密访问，兼容所有主流浏览器</li></ul><h2 id="二、替换前的准备工作"><a href="#二、替换前的准备工作" class="headerlink" title="二、替换前的准备工作"></a>二、替换前的准备工作</h2><p>为确保替换过程顺利，避免操作失误导致博客异常，需提前完成以下准备：</p><h3 id="1-核心文件备份"><a href="#1-核心文件备份" class="headerlink" title="1. 核心文件备份"></a>1. 核心文件备份</h3><ul><li>备份Hexo根目录下的<code>_config.yml</code>（全局配置文件）</li><li>备份主题目录（如<code>themes/next</code>、<code>themes/butterfly</code>），建议压缩为ZIP文件存储</li><li>若使用Git管理博客，可先提交当前版本，便于后续回滚</li></ul><h3 id="2-资源依赖排查"><a href="#2-资源依赖排查" class="headerlink" title="2. 资源依赖排查"></a>2. 资源依赖排查</h3><p>通过浏览器开发者工具（F12）定位所有<code>jsDelivr</code>资源：</p><ol><li>打开博客页面，按F12打开“开发者工具”</li><li>切换至“Network”标签，刷新页面</li><li>在搜索框输入<code>cdn.jsdelivr.net</code>，筛选出所有依赖该CDN的资源</li><li>记录资源类型（CSS/JS/Font）、链接地址及所在文件，避免替换遗漏</li></ol><h3 id="3-本地环境确认"><a href="#3-本地环境确认" class="headerlink" title="3. 本地环境确认"></a>3. 本地环境确认</h3><p>确保本地已搭建完整的Hexo运行环境：</p><ul><li>检查Node.js版本（建议v14+）：<code>node -v</code></li><li>检查Hexo CLI版本（建议v6+）：<code>hexo -v</code></li><li>测试本地服务可用性：在根目录执行<code>hexo s</code>，确认<code>http://localhost:4000</code>可正常访问</li></ul><h2 id="三、分主题替换教程（覆盖主流主题）"><a href="#三、分主题替换教程（覆盖主流主题）" class="headerlink" title="三、分主题替换教程（覆盖主流主题）"></a>三、分主题替换教程（覆盖主流主题）</h2><p>不同Hexo主题的资源配置位置存在差异，以下针对3个最常用主题，提供 step-by-step 替换指南：</p><u>为了方便可以直接在编辑器中进行全局替换，将所有`cdn.jsdelivr.net`替换为`cdn.jsdmirror.com`</u><emp>如果生效，则无需下面的步骤</emp><h3 id="1-Next主题（v8-x-v9-x）"><a href="#1-Next主题（v8-x-v9-x）" class="headerlink" title="1. Next主题（v8.x - v9.x）"></a>1. Next主题（v8.x - v9.x）</h3><p>Next主题的CDN配置分散在<strong>主题配置文件</strong>和<strong>布局模板文件</strong>中，需分两步替换：</p><h4 id="步骤1：修改主题配置文件（themes-next-config-yml）"><a href="#步骤1：修改主题配置文件（themes-next-config-yml）" class="headerlink" title="步骤1：修改主题配置文件（themes/next/_config.yml）"></a>步骤1：修改主题配置文件（themes/next/_config.yml）</h4><p>用文本编辑器打开该文件，按<code>Ctrl+F</code>搜索<code>cdn.jsdelivr.net</code>，逐一替换以下资源：</p><ul><li><strong>字体图标（Font Awesome）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdmirror.com/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>代码高亮（Prism.js）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdmirror.com/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>评论系统（Valine）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdmirror.com/npm/valine@1.4.18/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="步骤2：修改布局模板中的硬编码资源"><a href="#步骤2：修改布局模板中的硬编码资源" class="headerlink" title="步骤2：修改布局模板中的硬编码资源"></a>步骤2：修改布局模板中的硬编码资源</h4><p>进入<code>themes/next/layout</code>目录，搜索所有文件中的<code>cdn.jsdelivr.net</code>：</p><ol><li>打开<code>_partials/head.swig</code>，替换CSS资源引用</li><li>打开<code>_partials/footer.swig</code>，替换JS资源引用</li><li>打开<code>_third-party/comments/valine.swig</code>（若使用Valine），确认评论组件CDN已替换</li></ol><h3 id="2-Butterfly主题（v4-x-v5-x）"><a href="#2-Butterfly主题（v4-x-v5-x）" class="headerlink" title="2. Butterfly主题（v4.x - v5.x）"></a>2. Butterfly主题（v4.x - v5.x）</h3><p>Butterfly主题的CDN配置高度集中，主要在<strong>主题配置文件</strong>中：</p><h4 id="步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）"><a href="#步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）" class="headerlink" title="步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）"></a>步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）</h4><p>找到<code>CDN</code>相关配置段，替换以下关键资源：</p><ul><li><strong>基础框架（jQuery + Bootstrap）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdmirror.com/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br></pre></td></tr></table></figure></li><li><strong>图标与高亮</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdelivr.net/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdmirror.com/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdmirror.com/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>第三方插件（如阅读进度、目录）</strong><br>继续向下搜索，替换<code>tocbot</code>、<code>nprogress</code>等插件的CDN链接，确保无遗漏。</li></ul><h4 id="步骤2：检查自定义页面资源"><a href="#步骤2：检查自定义页面资源" class="headerlink" title="步骤2：检查自定义页面资源"></a>步骤2：检查自定义页面资源</h4><p>若在<code>source</code>目录下创建了自定义页面（如<code>about.md</code>、<code>links.md</code>），需打开文件检查是否有内嵌的<code>jsDelivr</code>链接，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原链接 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 替换后 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="3-Matery主题（v1-x）"><a href="#3-Matery主题（v1-x）" class="headerlink" title="3. Matery主题（v1.x）"></a>3. Matery主题（v1.x）</h3><p>Matery主题的资源配置在<strong>主题配置文件</strong>和<strong>HTML模板</strong>中：</p><h4 id="步骤1：修改主题配置（themes-matery-config-yml）"><a href="#步骤1：修改主题配置（themes-matery-config-yml）" class="headerlink" title="步骤1：修改主题配置（themes/matery/_config.yml）"></a>步骤1：修改主题配置（themes/matery/_config.yml）</h4><p>替换<code>CDN</code>部分的资源：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdelivr.net/npm/layer@3.5.1/dist/layer.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdmirror.com/npm/layer@3.5.1/dist/layer.min.js</span></span><br></pre></td></tr></table></figure></p><h4 id="步骤2：修改HTML模板（themes-matery-layout-partial）"><a href="#步骤2：修改HTML模板（themes-matery-layout-partial）" class="headerlink" title="步骤2：修改HTML模板（themes/matery/layout/_partial）"></a>步骤2：修改HTML模板（themes/matery/layout/_partial）</h4><p>打开<code>head.html</code>和<code>footer.html</code>，替换模板中硬编码的CDN链接，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 替换后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="四、替换后的验证与测试"><a href="#四、替换后的验证与测试" class="headerlink" title="四、替换后的验证与测试"></a>四、替换后的验证与测试</h2><p>完成替换后，需通过多维度测试确保博客正常运行且速度提升：</p><h3 id="1-本地环境验证"><a href="#1-本地环境验证" class="headerlink" title="1. 本地环境验证"></a>1. 本地环境验证</h3><p>在Hexo根目录执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存（关键步骤，避免旧资源干扰）</span></span><br><span class="line">hexo s      <span class="comment"># 启动本地服务器</span></span><br></pre></td></tr></table></figure><br>打开浏览器访问<code>http://localhost:4000</code>，进行以下检查：</p><ul><li><strong>视觉检查</strong>：页面样式是否完整（无错位、无缺失图标）</li><li><strong>控制台检查</strong>：按F12打开“Console”标签，确认无“404 Not Found”或“Failed to load”错误</li><li><strong>网络检查</strong>：在“Network”标签中搜索<code>jsdmirror</code>，确认所有资源均从该CDN加载</li></ul><h3 id="2-线上部署与速度测试"><a href="#2-线上部署与速度测试" class="headerlink" title="2. 线上部署与速度测试"></a>2. 线上部署与速度测试</h3><p>若本地验证无问题，部署到线上（如GitHub Pages、Gitee Pages、Vercel）后，使用以下工具测试速度提升效果：</p><h4 id="（1）基础速度检测"><a href="#（1）基础速度检测" class="headerlink" title="（1）基础速度检测"></a>（1）基础速度检测</h4><ul><li><strong>17CE</strong>：检测国内多地区节点的访问延迟，对比替换前后数据</li><li><strong>Ping.pe</strong>：测试全球节点响应速度，确保海外用户访问不受影响</li></ul><h4 id="（2）性能评分工具"><a href="#（2）性能评分工具" class="headerlink" title="（2）性能评分工具"></a>（2）性能评分工具</h4><ul><li><strong>Google PageSpeed Insights</strong>：重点关注“首次内容绘制（FCP）”和“最大内容绘制（LCP）”指标，替换后通常可提升10-30分</li><li><strong>WebPageTest</strong>：生成详细的资源加载瀑布图，查看<code>jsdmirror</code>资源的加载时间（目标：单个资源加载时间&lt;100ms）</li></ul><h2 id="五、进阶优化与风险规避"><a href="#五、进阶优化与风险规避" class="headerlink" title="五、进阶优化与风险规避"></a>五、进阶优化与风险规避</h2><h3 id="1-资源加载优化补充"><a href="#1-资源加载优化补充" class="headerlink" title="1. 资源加载优化补充"></a>1. 资源加载优化补充</h3><p>替换CDN后，可结合以下措施进一步提升速度：</p><ul><li><strong>开启Gzip压缩</strong>：在GitHub Pages中可通过配置<code>_config.yml</code>启用，或在Vercel中直接开启</li><li><strong>图片优化</strong>：使用<code>hexo-image-compressor</code>插件压缩图片，或迁移至国内图床（如阿里云OSS、腾讯云COS）</li><li><strong>减少第三方插件</strong>：卸载无用的评论、统计插件，降低资源请求数量</li></ul><h3 id="2-CDN服务风险规避"><a href="#2-CDN服务风险规避" class="headerlink" title="2. CDN服务风险规避"></a>2. CDN服务风险规避</h3><p><code>cdn.jsdmirror.com</code>作为第三方镜像，若后续出现服务不稳定，可切换至其他国内<code>jsDelivr</code>镜像，常用备选：</p><ul><li><code>https://cdn.jsdelivr.fusesearch.net/</code></li><li><code>https://jsd.onmicrosoft.cn/</code></li><li><code>https://jsdelivr.b-cdn.net/</code></li></ul><p>切换时仅需替换“域名”，保持资源路径完全一致，无需修改其他配置。</p><h3 id="3-定期检查与更新"><a href="#3-定期检查与更新" class="headerlink" title="3. 定期检查与更新"></a>3. 定期检查与更新</h3><p>建议每3-6个月检查一次CDN资源：</p><ul><li>确认使用的npm包/GitHub仓库资源是否有更新，避免使用过时版本导致安全风险</li><li>测试当前CDN的响应速度，若出现延迟升高，及时切换至其他镜像</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过将Hexo博客的<code>cdn.jsdelivr.net</code>替换为<code>cdn.jsdmirror.com</code>，可有效解决国内网络环境下的资源加载慢问题，通常能带来30%-70%的加载速度提升。整个过程核心在于“精准定位资源位置+完整替换域名”，配合本地测试与线上验证，即可确保博客稳定运行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Task定时任务的一些事</title>
      <link href="/posts/12ed125b.html"/>
      <url>/posts/12ed125b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-定时任务（Task）使用教程：从入门到精通"><a href="#Spring-Boot-定时任务（Task）使用教程：从入门到精通" class="headerlink" title="Spring Boot 定时任务（Task）使用教程：从入门到精通"></a>Spring Boot 定时任务（Task）使用教程：从入门到精通</h1><p>在日常开发中，定时任务是一个非常常见的需求，比如定时发送短信、定时生成报表、定时清理缓存等。Spring Boot 内置了 <code>spring-boot-starter</code> 模块，其中就包含了对定时任务的支持，无需额外引入复杂的第三方框架（如 Quartz），就能快速实现定时任务功能。本文将从基础到进阶，详细讲解 Spring Boot 定时任务的使用方法。</p><h2 id="一、Spring-Boot-定时任务基础"><a href="#一、Spring-Boot-定时任务基础" class="headerlink" title="一、Spring Boot 定时任务基础"></a>一、Spring Boot 定时任务基础</h2><h3 id="1-1-什么是定时任务？"><a href="#1-1-什么是定时任务？" class="headerlink" title="1.1 什么是定时任务？"></a>1.1 什么是定时任务？</h3><p>定时任务是指在预定的时间点或按照固定的时间间隔自动执行的任务。在 Java 生态中，常见的定时任务实现方式有 <code>Timer</code>、<code>ScheduledExecutorService</code>、Quartz 等，而 Spring Boot 提供的 <code>@Scheduled</code> 注解则是对这些底层实现的封装，简化了开发流程。</p><h3 id="1-2-启用定时任务"><a href="#1-2-启用定时任务" class="headerlink" title="1.2 启用定时任务"></a>1.2 启用定时任务</h3><p>Spring Boot 中启用定时任务非常简单，只需两步：</p><ol><li><strong>添加依赖</strong>：Spring Boot 的 <code>spring-boot-starter</code> 已经包含了定时任务相关的依赖，无需额外引入。如果是 Maven 项目，<code>pom.xml</code> 中默认的 <code>spring-boot-starter</code> 即可满足需求：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>开启定时任务注解</strong>：在 Spring Boot 启动类上添加 <code>@EnableScheduling</code> 注解，用于启用定时任务的自动配置：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TaskDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、简单定时任务实现"><a href="#二、简单定时任务实现" class="headerlink" title="二、简单定时任务实现"></a>二、简单定时任务实现</h2><p>启用定时任务后，只需在需要定时执行的方法上添加 <code>@Scheduled</code> 注解，并指定任务的执行时机即可。<code>@Scheduled</code> 注解支持多种定时方式，下面介绍最常用的几种。</p><h3 id="2-1-固定延迟执行（fixedDelay）"><a href="#2-1-固定延迟执行（fixedDelay）" class="headerlink" title="2.1 固定延迟执行（fixedDelay）"></a>2.1 固定延迟执行（fixedDelay）</h3><p><code>fixedDelay</code> 表示上一次任务执行完成后，间隔固定时间再执行下一次任务。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 交给 Spring 管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次任务执行完成后，间隔 3 秒执行下一次</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;固定延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间为 <code>3000ms + 任务执行耗时（1000ms）</code>，即约 4 秒。</p><h3 id="2-2-固定频率执行（fixedRate）"><a href="#2-2-固定频率执行（fixedRate）" class="headerlink" title="2.2 固定频率执行（fixedRate）"></a>2.2 固定频率执行（fixedRate）</h3><p><code>fixedRate</code> 表示按照固定的频率执行任务，无论上一次任务是否执行完成。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每隔 3 秒执行一次，不管上一次任务是否完成</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间约为 3 秒（因为任务耗时 1 秒，小于频率间隔）。如果任务耗时超过频率间隔（如任务耗时 4 秒），则上一次任务执行完成后会立即执行下一次任务。</p><h3 id="2-3-初始延迟执行（initialDelay）"><a href="#2-3-初始延迟执行（initialDelay）" class="headerlink" title="2.3 初始延迟执行（initialDelay）"></a>2.3 初始延迟执行（initialDelay）</h3><p><code>initialDelay</code> 表示任务启动后，延迟指定时间再开始执行第一次任务，之后按照 <code>fixedDelay</code> 或 <code>fixedRate</code> 执行。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 启动后延迟 5 秒执行第一次任务，之后每隔 3 秒执行一次</span></span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 5000, fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：应用启动 5 秒后，第一次执行任务，之后每 3 秒执行一次。</p><h2 id="三、Cron-表达式：灵活的定时配置"><a href="#三、Cron-表达式：灵活的定时配置" class="headerlink" title="三、Cron 表达式：灵活的定时配置"></a>三、Cron 表达式：灵活的定时配置</h2><p>如果需要更灵活的定时规则（如每天凌晨 2 点执行、每周一上午 10 点执行等），<code>fixedDelay</code> 和 <code>fixedRate</code> 就无法满足需求了，此时需要使用 <strong>Cron 表达式</strong>。</p><h3 id="3-1-Cron-表达式格式"><a href="#3-1-Cron-表达式格式" class="headerlink" title="3.1 Cron 表达式格式"></a>3.1 Cron 表达式格式</h3><p>Cron 表达式是一个字符串，由 6 或 7 个字段组成，字段之间用空格分隔。Spring Boot 中的 Cron 表达式支持 6 个字段（不支持年份），格式如下：</p><div class="callout">秒 分 时 日 月 星期</div><p>每个字段的取值范围和允许的特殊字符如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>取值范围</th><th>特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日</td><td>1-31</td><td>, - * / ? L W C</td></tr><tr><td>月</td><td>1-12 或 JAN-DEC</td><td>, - * /</td></tr><tr><td>星期</td><td>1-7 或 SUN-SAT（1 表示星期日）</td><td>, - * / ? L C #</td></tr></tbody></table></div><h3 id="3-2-常用特殊字符说明"><a href="#3-2-常用特殊字符说明" class="headerlink" title="3.2 常用特殊字符说明"></a>3.2 常用特殊字符说明</h3><ul><li><p><strong>*</strong>：表示所有可能的值，例如“秒”字段为 <code>*</code>，表示每秒执行。</p></li><li><p><strong>?</strong>：用于“日”和“星期”字段，表示不指定具体值，避免两者冲突。例如每月 10 日执行，不管是星期几，“星期”字段就填 <code>?</code>。</p></li><li><p><strong>/</strong>：表示增量，例如“分”字段为 <code>0/5</code>，表示从 0 分开始，每 5 分钟执行一次。</p></li><li><p><strong>-</strong>：表示范围，例如“时”字段为 <code>9-17</code>，表示 9 点到 17 点之间执行。</p></li><li><p><strong>,</strong>：表示多个值，例如“星期”字段为 <code>1,3,5</code>，表示星期日、星期二、星期四执行。</p></li><li><p><strong>L</strong>：表示“最后”，例如“日”字段为 <code>L</code>，表示每月最后一天；“星期”字段为 <code>L</code>，表示星期六。</p></li><li><p><strong>#</strong>：用于“星期”字段，表示每月的第几个星期几，例如 <code>6#3</code> 表示每月第三个星期五（6 表示星期五）。</p></li></ul><h3 id="3-3-Cron-表达式示例"><a href="#3-3-Cron-表达式示例" class="headerlink" title="3.3 Cron 表达式示例"></a>3.3 Cron 表达式示例</h3><ul><li><p>每秒执行：<code>* * * * * ?</code></p></li><li><p>每 5 分钟执行：<code>0 */5 * * * ?</code></p></li><li><p>每天凌晨 2 点执行：<code>0 0 2 * * ?</code></p></li><li><p>每月 10 日上午 10 点执行：<code>0 0 10 10 * ?</code></p></li><li><p>每周一到周五下午 5 点执行：<code>0 0 17 ? * 2-6</code>（2 表示星期一，6 表示星期五）</p></li><li><p>每月最后一天晚上 11 点执行：<code>0 0 23 L * ?</code></p></li></ul><h3 id="3-4-在-Scheduled-中使用-Cron-表达式"><a href="#3-4-在-Scheduled-中使用-Cron-表达式" class="headerlink" title="3.4 在 @Scheduled 中使用 Cron 表达式"></a>3.4 在 @Scheduled 中使用 Cron 表达式</h3><p>只需将 <code>@Scheduled</code> 注解的 <code>cron</code> 属性设置为对应的表达式即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每天凌晨 2 点执行</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、定时任务参数外部化配置"><a href="#四、定时任务参数外部化配置" class="headerlink" title="四、定时任务参数外部化配置"></a>四、定时任务参数外部化配置</h2><p>在实际开发中，定时任务的执行规则可能需要根据环境动态调整（如开发环境和生产环境的执行频率不同）。此时，不建议将参数硬编码在 <code>@Scheduled</code> 注解中，而是通过 <code>application.properties</code> 或 <code>application.yml</code> 进行外部化配置。</p><h3 id="4-1-使用-properties-文件配置"><a href="#4-1-使用-properties-文件配置" class="headerlink" title="4.1 使用 properties 文件配置"></a>4.1 使用 properties 文件配置</h3><p>在 <code>application.properties</code> 中添加定时任务参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 定时任务参数配置</span></span><br><span class="line"><span class="attr">task.fixedRate</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">task.cron</span>=<span class="string">0 0 2 * * ?</span></span><br></pre></td></tr></table></figure><p>在代码中通过 <code>$&#123;&#125;</code> 引用配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 fixedRate</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRateString = &quot;$&#123;task.fixedRate&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalFixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 cron 表达式</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalCronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置 Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于数值类型的参数（如 <code>fixedRate</code>、<code>fixedDelay</code>），需要使用 <code>fixedRateString</code>、<code>fixedDelayString</code> 属性来引用字符串类型的配置值。</p><h2 id="五、定时任务的高级特性"><a href="#五、定时任务的高级特性" class="headerlink" title="五、定时任务的高级特性"></a>五、定时任务的高级特性</h2><h3 id="5-1-定时任务线程池配置"><a href="#5-1-定时任务线程池配置" class="headerlink" title="5.1 定时任务线程池配置"></a>5.1 定时任务线程池配置</h3><p>Spring Boot 定时任务默认使用单线程执行，如果多个任务同时触发，会出现任务排队的情况。为了提高任务执行效率，可以配置定时任务线程池。</p><p>通过实现 <code>SchedulingConfigurer</code> 接口来配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为 5</span></span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        scheduler.setPoolSize(<span class="number">5</span>);</span><br><span class="line">        scheduler.setThreadNamePrefix(<span class="string">&quot;scheduled-task-&quot;</span>); <span class="comment">// 线程名前缀</span></span><br><span class="line">        scheduler.initialize();</span><br><span class="line">        </span><br><span class="line">        taskRegistrar.setTaskScheduler(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，定时任务会通过线程池中的线程并行执行，避免单线程瓶颈。</p><h3 id="5-2-动态调整定时任务"><a href="#5-2-动态调整定时任务" class="headerlink" title="5.2 动态调整定时任务"></a>5.2 动态调整定时任务</h3><p>如果需要在应用运行过程中动态修改定时任务的执行规则（如修改 Cron 表达式），可以通过 <code>ScheduledTaskRegistrar</code> 和 <code>Trigger</code> 接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTaskConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中读取 Cron 表达式，支持动态刷新</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;task.dynamic.cron&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String cronExpression;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态注册定时任务</span></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">            () -&gt; System.out.println(<span class="string">&quot;动态定时任务执行时间：&quot;</span> + LocalDateTime.now()),</span><br><span class="line">            triggerContext -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每次执行前重新读取 Cron 表达式，实现动态调整</span></span><br><span class="line">                <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cronExpression);</span><br><span class="line">                <span class="keyword">return</span> trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供方法修改 cronExpression</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCronExpression</span><span class="params">(String cronExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cronExpression = cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>setCronExpression</code> 方法，可以在应用运行时修改任务的执行规则。如果结合配置中心（如 Nacos、Apollo），还能实现配置的动态推送。</p><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><ul><li><p><strong>任务执行时长</strong>：如果任务执行时长超过了定时频率，会导致任务堆积。建议通过线程池配置或优化任务逻辑来避免。</p></li><li><p><strong>异常处理</strong>：定时任务方法中如果抛出未捕获的异常，会导致任务终止。建议在方法内部添加 try-catch 块，或通过全局异常处理器捕获异常。</p></li><li><p><strong>分布式环境</strong>：Spring Boot 内置的定时任务不支持分布式锁，在分布式环境下可能出现多个节点同时执行任务的情况。此时需要结合分布式锁（如 Redis 分布式锁）来保证任务的唯一性。</p></li><li><p><strong>幂等性</strong>：即使使用了分布式锁，也建议保证任务的幂等性，避免因网络抖动等问题导致任务重复执行。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Spring Boot 定时任务通过 <code>@EnableScheduling</code> 和 <code>@Scheduled</code> 注解，极大地简化了定时任务的开发。本文从基础的固定延迟、固定频率任务，到灵活的 Cron 表达式，再到参数外部化和线程池配置，最后介绍了动态任务和注意事项，覆盖了定时任务的大部分使用场景。</p><p>在实际开发中，需要根据业务需求选择合适的定时方式，并注意异常处理、分布式环境下的任务唯一性等问题。希望本文能帮助你快速掌握 Spring Boot 定时任务的使用😊</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring Security的一些事</title>
      <link href="/posts/3f6c5c0b.html"/>
      <url>/posts/3f6c5c0b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Security-使用教程：从入门到实战"><a href="#Spring-Security-使用教程：从入门到实战" class="headerlink" title="Spring Security 使用教程：从入门到实战"></a>Spring Security 使用教程：从入门到实战</h1><p>在Web应用开发中，安全永远是不可忽视的环节。Spring Security作为Spring生态中成熟的安全框架，提供了全面的认证（Authentication）和授权（Authorization）解决方案。本文将从基础到进阶，带你一步步掌握Spring Security的核心用法，构建安全可靠的Java Web应用。(对的，这是Spring Security的入门篇)</p><h2 id="一、Spring-Security-核心概念"><a href="#一、Spring-Security-核心概念" class="headerlink" title="一、Spring Security 核心概念"></a>一、Spring Security 核心概念</h2><p>在开始实战前，先理解几个核心概念，有助于后续学习：</p><ul><li><p><strong>认证（Authentication）</strong>：验证用户身份的过程，比如登录时校验用户名和密码是否正确。</p></li><li><p><strong>授权（Authorization）</strong>：在认证通过后，判断用户是否有权限执行某个操作（如访问特定接口、修改数据）。</p></li><li><p><strong>SecurityContext</strong>：存储当前认证用户的信息，通过<code>SecurityContextHolder</code>可以随时获取。</p></li><li><p><strong>UserDetails</strong>：封装用户信息的接口，包含用户名、密码、权限等核心字段。</p></li><li><p><strong>AuthenticationManager</strong>：认证的核心管理器，负责调度<code>AuthenticationProvider</code>完成认证。</p></li></ul><h2 id="二、环境搭建：快速集成Spring-Security"><a href="#二、环境搭建：快速集成Spring-Security" class="headerlink" title="二、环境搭建：快速集成Spring Security"></a>二、环境搭建：快速集成Spring Security</h2><p>本文基于<strong>Spring Boot 3.x</strong>进行演示，Spring Boot已为Spring Security提供了自动配置，集成过程非常简单。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><p>在<code>pom.xml</code>（Maven）或<code>build.gradle</code>（Gradle）中添加Spring Security依赖：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0-M2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="2-2-启动应用，体验默认安全配置"><a href="#2-2-启动应用，体验默认安全配置" class="headerlink" title="2.2 启动应用，体验默认安全配置"></a>2.2 启动应用，体验默认安全配置</h3><p>添加依赖后，直接启动Spring Boot应用，Spring Security会自动生效，默认做了以下安全配置：</p><ol><li><p>所有接口默认需要认证才能访问。</p></li><li><p>生成一个默认用户，用户名是<code>user</code>，密码会在控制台输出（格式如：<code>Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code>）。</p></li><li><p>提供一个默认的登录页面（访问任意接口会自动跳转）。</p></li></ol><p>测试：访问<code>http://localhost:8080/hello</code>（需先编写一个简单的Hello接口），会跳转至登录页，输入默认用户名和密码即可访问。</p><h2 id="三、自定义认证：从默认到数据库"><a href="#三、自定义认证：从默认到数据库" class="headerlink" title="三、自定义认证：从默认到数据库"></a>三、自定义认证：从默认到数据库</h2><p>默认配置仅用于测试，实际项目中需要对接数据库用户，下面实现自定义认证逻辑。</p><h3 id="3-1-编写配置类"><a href="#3-1-编写配置类" class="headerlink" title="3.1 编写配置类"></a>3.1 编写配置类</h3><p>创建<code>SecurityConfig</code>类，继承<code>WebSecurityConfigurerAdapter</code>（Spring Boot 3.x中已 deprecated，推荐使用函数式风格配置）：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入自定义的UserDetailsService（后续实现）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityConfig</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置密码加密器（Spring Security 5+要求必须指定密码加密方式）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置SecurityFilterChain（核心配置）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 关闭CSRF（测试环境可关闭，生产环境需开启）</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            <span class="comment">// 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                <span class="comment">// 放行登录接口、静态资源等</span></span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 其他所有接口需要认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置表单登录</span></span><br><span class="line">            .formLogin(form -&gt; form</span><br><span class="line">                <span class="comment">// 自定义登录页面路径（可选，默认是/spring-security-login）</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/custom-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录请求的接口路径（默认是/login）</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/do-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录成功后的跳转路径</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 登录失败后的跳转路径</span></span><br><span class="line">                .failureUrl(<span class="string">&quot;/custom-login?error=true&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置退出登录</span></span><br><span class="line">            .logout(logout -&gt; logout</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/custom-login?logout=true&quot;</span>)</span><br><span class="line">                .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 销毁session</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="3-2-实现UserDetailsService"><a href="#3-2-实现UserDetailsService" class="headerlink" title="3.2 实现UserDetailsService"></a>3.2 实现UserDetailsService</h3><p><code>UserDetailsService</code>负责从数据库加载用户信息，我们需要实现它来对接自己的用户表：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用户DAO（实际项目中替换为MyBatis或JPA的Repository）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomUserDetailsService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 从数据库查询用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据库用户转换为UserDetails对象（包含权限信息）</span></span><br><span class="line">        <span class="keyword">return</span> User.withUsername(user.getUsername())</span><br><span class="line">                .password(user.getPassword()) <span class="comment">// 数据库中存储的密码必须是加密后的</span></span><br><span class="line">                .roles(user.getRoles().split(<span class="string">&quot;,&quot;</span>)) <span class="comment">// 假设roles字段是逗号分隔的角色字符串</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="callout">注意：数据库中存储的密码必须是通过`BCryptPasswordEncoder`加密后的字符串，不能存储明文。可以通过`passwordEncoder.encode("123456")`生成加密密码。</div><h2 id="四、授权控制：基于角色和权限"><a href="#四、授权控制：基于角色和权限" class="headerlink" title="四、授权控制：基于角色和权限"></a>四、授权控制：基于角色和权限</h2><p>认证通过后，需要对不同用户授予不同权限，Spring Security支持多种授权方式。</p><h3 id="4-1-基于角色的URL授权"><a href="#4-1-基于角色的URL授权" class="headerlink" title="4.1 基于角色的URL授权"></a>4.1 基于角色的URL授权</h3><p>在<code>securityFilterChain</code>中通过<code>hasRole</code>或<code>hasAnyRole</code>配置URL的角色权限：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// 只有ADMIN角色可访问/admin下的接口</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>) <span class="comment">// ADMIN或USER角色可访问</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/public/**&quot;</span>).permitAll() <span class="comment">// 公开接口，无需认证</span></span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="4-2-基于注解的方法级授权"><a href="#4-2-基于注解的方法级授权" class="headerlink" title="4.2 基于注解的方法级授权"></a>4.2 基于注解的方法级授权</h3><p>在Controller方法上使用注解控制权限，需先开启全局方法安全：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span> <span class="comment">// 开启PreAuthorize注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在Controller方法上使用注解：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有ADMIN角色的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-manage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">manageUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户管理页面&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有DELETE权限的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;DELETE&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除用户：&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="五、进阶功能：记住我与JWT"><a href="#五、进阶功能：记住我与JWT" class="headerlink" title="五、进阶功能：记住我与JWT"></a>五、进阶功能：记住我与JWT</h2><p>除了基础的认证授权，Spring Security还支持“记住我”、JWT令牌等高级功能。</p><h3 id="5-1-实现“记住我”功能"><a href="#5-1-实现“记住我”功能" class="headerlink" title="5.1 实现“记住我”功能"></a>5.1 实现“记住我”功能</h3><p>只需在<code>securityFilterChain</code>中添加<code>rememberMe</code>配置：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.rememberMe(remember -&gt; remember</span><br><span class="line">    .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中的记住我参数名</span></span><br><span class="line">    .tokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>) <span class="comment">// 记住我有效期（7天）</span></span><br><span class="line">    .userDetailsService(userDetailsService) <span class="comment">// 加载用户信息</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在登录表单中添加一个名为<code>remember-me</code>的复选框即可。</p><h3 id="5-2-集成JWT实现无状态认证"><a href="#5-2-集成JWT实现无状态认证" class="headerlink" title="5.2 集成JWT实现无状态认证"></a>5.2 集成JWT实现无状态认证</h3><p>对于前后端分离项目，通常使用JWT（JSON Web Token）实现无状态认证，核心步骤如下：</p><ol><li><p><strong>引入JWT依赖</strong>：添加<code>jjwt-api</code>、<code>jjwt-impl</code>、<code>jjwt-jackson</code>依赖。</p></li><li><p><strong>编写JWT工具类</strong>：实现Token的生成、解析、验证逻辑。</p></li><li><p><strong>自定义JwtAuthenticationFilter</strong>：从请求头中获取Token，解析后完成认证。</p></li><li><p><strong>配置SecurityFilterChain</strong>：关闭session，添加JWT过滤器，放行登录接口等。</p></li></ol><p>由于JWT集成步骤较多，后续会单独写一篇实战文章，感兴趣的可以关注。</p><h2 id="六、常见问题与排查"><a href="#六、常见问题与排查" class="headerlink" title="六、常见问题与排查"></a>六、常见问题与排查</h2><ul><li><p><strong>密码加密失败</strong>：确保数据库中存储的是加密后的密码，且配置了正确的<code>PasswordEncoder</code>。</p></li><li><p><strong>接口授权不生效</strong>：检查URL匹配规则的顺序（具体规则要放在通用规则前面），以及角色/权限名称是否正确（<code>hasRole</code>会自动添加<code>ROLE_</code>前缀，<code>hasAuthority</code>需要完整名称）。</p></li><li><p><strong>CSRF问题</strong>：前后端分离项目中，若关闭CSRF，需确保请求头中没有携带CSRF Token；若开启，需在前端请求中添加Token。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本文介绍了Spring Security的核心概念、环境搭建、自定义认证、授权控制及进阶功能，涵盖了大部分实际项目中的常用场景。Spring Security功能强大且灵活，掌握它能有效提升应用的安全性。建议结合实际项目多动手实践，深入理解其核心原理（如过滤器链、认证流程等），以便应对更复杂的安全需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机技术</title>
      <link href="/posts/b67a9f87.html"/>
      <url>/posts/b67a9f87.html</url>
      
        <content type="html"><![CDATA[<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg><h1 id="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"><a href="#从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互" class="headerlink" title="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"></a>从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互</h1><p>在十年前，打开一个大型文档需要等待几十秒、视频通话时频繁出现“马赛克”、手机多开几个APP就会闪退，这些场景对大多数人来说都司空见惯。而如今，我们早已习惯了“即点即开”的文档编辑、4K画质的实时视频会议、手机后台同时运行十几个应用仍流畅切换——这些“丝滑”体验的背后，并非只是“硬件变好了”这么简单，而是计算机技术在<strong>存储架构、网络传输、系统优化</strong>等多个维度协同进化的结果。今天，我们就从日常场景切入，聊聊那些“看不见却离不开”的技术进步。</p><h2 id="一、存储技术：从“机械等待”到“电子秒达”"><a href="#一、存储技术：从“机械等待”到“电子秒达”" class="headerlink" title="一、存储技术：从“机械等待”到“电子秒达”"></a>一、存储技术：从“机械等待”到“电子秒达”</h2><p>打开电脑时，系统启动速度的快慢，很大程度上取决于存储设备的性能。十年前主流的机械硬盘（HDD），就像一个“带转盘的档案柜”：读写数据时，需要先让磁盘高速旋转（通常是5400转/分钟或7200转/分钟），再让磁头移动到指定位置“查找”数据——这个过程虽然比早期的软盘快，但仍有明显的“等待时间”（平均寻道时间约8-12毫秒）。</p><p>而现在主流的固态硬盘（SSD），彻底抛弃了“机械结构”，改用<strong>NAND闪存芯片</strong>存储数据，就像把“档案柜”换成了“电子货架”：数据通过电信号直接读写，无需等待磁盘旋转或磁头移动，平均响应时间可以做到0.1毫秒以内——这意味着，从“点击开机”到“进入桌面”，时间从原来的1-2分钟压缩到了10-20秒，甚至更短。</p><p>更关键的是，SSD的进步还在持续：</p><ul><li><strong>NVMe协议</strong>的普及：相比早期SSD使用的SATA接口，NVMe直接通过PCIe总线与CPU通信，带宽提升了10倍以上，读写速度从“几百MB/s”跃升到“几GB/s”，打开4K视频文件、大型设计软件时几乎没有延迟。</li><li><strong>QLC闪存的成本下降</strong>：早期SSD因成本高，容量普遍在128GB-256GB；而现在1TB容量的QLC SSD价格已非常亲民，既能满足日常文件存储，也能装下多个大型游戏或专业软件。</li></ul><p>对普通用户来说，存储技术的进步不是“参数的胜利”，而是“打开文件不用等、编辑视频不卡顿”的实在体验。</p><h2 id="二、网络传输：从“断断续续”到“实时互动”"><a href="#二、网络传输：从“断断续续”到“实时互动”" class="headerlink" title="二、网络传输：从“断断续续”到“实时互动”"></a>二、网络传输：从“断断续续”到“实时互动”</h2><p>疫情期间，远程办公和在线学习成为常态，很多人都经历过“视频会议卡成PPT”“在线课堂声音延迟”的尴尬。这背后的核心问题，是早期网络传输在<strong>带宽、延迟、稳定性</strong>上的不足。而现在，这些问题的缓解，离不开两项关键技术的成熟：</p><h3 id="1-5G与Wi-Fi-6：解决“带宽不够用”的问题"><a href="#1-5G与Wi-Fi-6：解决“带宽不够用”的问题" class="headerlink" title="1. 5G与Wi-Fi 6：解决“带宽不够用”的问题"></a>1. 5G与Wi-Fi 6：解决“带宽不够用”的问题</h3><ul><li>5G网络的峰值速率可达10Gbps，是4G的10-100倍，即使在户外用手机开热点参加视频会议，也能支持4K画质的实时传输；</li><li>Wi-Fi 6（802.11ax）的单设备速率提升到9.6Gbps，同时支持更多设备连接（最多可同时连接100+设备）——这意味着，家里的电视、手机、电脑、智能音箱同时联网，也不会出现“抢网速”导致的卡顿。</li></ul><h3 id="2-边缘计算：降低“数据跑太远”的延迟"><a href="#2-边缘计算：降低“数据跑太远”的延迟" class="headerlink" title="2. 边缘计算：降低“数据跑太远”的延迟"></a>2. 边缘计算：降低“数据跑太远”的延迟</h3><p>传统的网络架构中，我们的视频通话数据需要先传到远方的“中心服务器”，再转发给对方，这个过程会产生几十甚至上百毫秒的延迟（即“网络时延”）。而边缘计算则把“服务器”搬到了离用户更近的地方（比如城市的基站、区域数据中心），数据传输距离缩短，时延可以降低到10毫秒以内——这也是为什么现在的“实时连麦”“云游戏”能做到“操作无延迟”的关键。</p><p>举个例子：以前玩云游戏，按下“射击”按钮后，需要等1-2秒才能看到画面反应；现在有了边缘计算和高速网络，延迟几乎可以忽略，体验和在本地玩游戏没什么区别。</p><h2 id="三、系统优化：从“资源浪费”到“智能调度”"><a href="#三、系统优化：从“资源浪费”到“智能调度”" class="headerlink" title="三、系统优化：从“资源浪费”到“智能调度”"></a>三、系统优化：从“资源浪费”到“智能调度”</h2><p>除了硬件和网络，操作系统的优化同样重要。早期的系统（比如Windows XP、安卓4.0）对硬件资源的调度能力较弱，比如：</p><ul><li>打开多个APP后，后台应用不会“主动释放内存”，导致可用内存越来越少，手机或电脑越来越卡；</li><li>CPU资源分配“一刀切”，不管是微信聊天还是视频渲染，都用同样的性能模式，既浪费电量，又无法满足高负载需求。</li></ul><p>而现在的操作系统（如Windows 11、安卓14），通过<strong>智能资源调度</strong>技术，让硬件性能“用在刀刃上”：</p><h3 id="1-内存管理：“动态回收”与“压缩优化”"><a href="#1-内存管理：“动态回收”与“压缩优化”" class="headerlink" title="1. 内存管理：“动态回收”与“压缩优化”"></a>1. 内存管理：“动态回收”与“压缩优化”</h3><ul><li>安卓系统的“墓碑机制”（Android 12后优化）：当APP进入后台时，系统会“冻结”其占用的内存，不再让它消耗资源；如果内存不足，会自动回收优先级低的后台APP内存，保证前台应用流畅运行。</li><li>Windows的“内存压缩”：当物理内存不足时，系统会将不常用的内存数据压缩（压缩率可达50%以上），而不是直接写入硬盘（虚拟内存），避免了因硬盘速度慢导致的卡顿。</li></ul><h3 id="2-CPU调度：“按需分配”与“能效平衡”"><a href="#2-CPU调度：“按需分配”与“能效平衡”" class="headerlink" title="2. CPU调度：“按需分配”与“能效平衡”"></a>2. CPU调度：“按需分配”与“能效平衡”</h3><ul><li>手机的“异构计算”：现在的手机CPU大多是“多核心架构”（比如4个小核+4个大核），系统会根据任务轻重分配核心：聊微信时用低功耗小核，省电量；玩游戏时调用高性能大核，保证帧率稳定。</li><li>Windows的“性能模式”：用户可以根据需求切换“节能模式”“平衡模式”“高性能模式”，比如外出办公时用节能模式延长续航，做视频剪辑时开高性能模式提升效率。</li></ul><h2 id="四、技术的终极目标：让“复杂”隐于“无形”"><a href="#四、技术的终极目标：让“复杂”隐于“无形”" class="headerlink" title="四、技术的终极目标：让“复杂”隐于“无形”"></a>四、技术的终极目标：让“复杂”隐于“无形”</h2><p>回顾计算机技术的发展，我们会发现一个规律：真正优秀的技术，从来不是让用户去“理解它”，而是让用户“感受不到它的存在”——就像我们不会在意SSD的闪存芯片如何工作，也不会关心Wi-Fi 6的协议细节，我们只需要“打开文件很快”“视频通话很流畅”。</p><p>未来，随着AI与计算机技术的融合（比如AI驱动的智能内存调度、AI优化的网络传输路径），我们的交互体验还会进一步升级：可能电脑会“预判”你要打开的文件，提前加载到内存；可能网络会“自动避开”拥堵路段，保证视频会议不卡顿。</p><p>技术的进步，最终是为了“让工具回归工具的本质”——让我们不再被“卡顿”“等待”困扰，而是更专注于内容创作、沟通协作，或者单纯地享受数字生活的乐趣。这，或许就是计算机技术最动人的地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"纳斯卡可`Blog","short_name":"nskk","theme_color":"#13227a","background_color":"#13227a","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/256.png","sizes":"256x256","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我的</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/banner.css"/>
      <url>/bilibiliBanner/banner.css</url>
      
        <content type="html"><![CDATA[#app {  position: relative;  overflow: hidden;  margin: 0 auto;  min-width: 1000px;  min-height: 155px;  height: 10vw;  max-height: 240px;}.layer {  position: absolute;  left: 0;  top: 0;  height: 100%;  width: 100%;  display: flex;  align-items: center;  justify-content: center;}img {  user-select: none;  pointer-events: none;}#selectBox > button {  margin: 0 1em 1em 0;}/* 移动端适配 - 截取而不是缩放 */@media screen and (max-width: 1000px) {  #app {    min-width: 100%;    min-height: 120px;    height: 30vw;    max-height: 180px;  }    .layer {    justify-content: flex-start;  }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/banner.js"/>
      <url>/bilibiliBanner/banner.js</url>
      
        <content type="html"><![CDATA[const app = document.getElementById("app");//header是app的父元素//app是使用绝对定位的子元素，完全覆盖header//nav元素也是使用了绝对定位的header的子元素，且置顶压住了app//后续我们给header加上mousemove和mouseleave的事件监听,为什么？//即便我们鼠标是在nav或者app上移动，mousemove事件也会冒泡到父元素header//但如果我们只给app添加mousemove，当鼠标移动到nav上，就不会触发mousemove事件//为此时 nav 元素挡住了 app 元素，成为实际响应鼠标事件的元素//因为我们希望鼠标在nav或者app上移动时，banner都能动，所以我们将mousemove监听添加到父元素上//如果我们只给app添加mouseleave监听，当鼠标移动到nav（2个元素是同级关系），//就会触发app的mouseleave事件，播放回正动画，这样用户可交互的范围就变小了//但如果我们给header添加mouseleave的事件监听，只要鼠标不离开headr的范围，就不会触发mouseleave//所以我们给header添加mouseleave的事件监听const header = document.getElementById("page-header");(async function () {  // 随机取一个banner来展示  // 10表示当前有10个banner，如果爬取了更多banner，此处应该被修改  let index = Math.floor(Math.random() * 10 + 1)  if(index === 1)  {    index = 10  }  const response = await fetch(`https://cdn.jsdmirror.com/gh/rolay-nmcb/myblog@main/bilibiliBanner/images/${index}/data.json`)  const curBannerData = await response.json()  let layers = []; // 所有layer的DOM集合  let compensate = 0; // 视窗补偿值  // 添加图片元素(进行添加dom吗，修改dom的操作)  function init() {    //根据窗口宽度，计算补偿值compensate，用于动态调整元素尺寸和位置    compensate = window.innerWidth > 1650 ? window.innerWidth / 1650 : 1;    //进行离线操作，防止触发多次回流    app.style.display = "none";    for (let i = 0; i < curBannerData.length; i++) {      const layerChildConfig = curBannerData[i];      //创建layer      const layer = document.createElement("div");      layer.classList.add("layer");      // 创建子元素      const child = document.createElement(layerChildConfig.tagName);      // 如果子元素是video      if (layerChildConfig.tagName === 'video') {        // autoplay = true 尝试自动播放，但现代浏览器（如 Chrome 76+）会阻止有声自动播放。        // 通过 muted = true 静音绕过此限制        // loop = true 使视频播放结束后自动重播        child.loop = true; child.autoplay = true; child.muted = true;      }      child.src = layerChildConfig.src;      // 应用补偿值到元素的宽高      // 根据item中的信息设置img或者video的宽高      child.style.width = `${layerChildConfig.width * compensate}px`;      child.style.height = `${layerChildConfig.height * compensate}px`;      // 应用补偿值到变换矩阵的第4、5项（translateX/Y，偏移值）      let translateX = layerChildConfig.transform.translateX * compensate      let translateY = layerChildConfig.transform.translateY * compensate      let rotate = layerChildConfig.transform.rotate      let scale = layerChildConfig.transform.scale      // 添加偏移      child.style.transform = `translate(${translateX}px,${translateY}px) rotate(${rotate}deg) scale(${scale})`      // 将img或者video添加到div.layer      layer.appendChild(child);      // 将div.layer添加到div.app      app.appendChild(layer);    }    // 显示app，进行一次批量的回流    app.style.display = "";    // 所有layer都添加完毕后，重新捕获layer，给layers赋值    layers = document.querySelectorAll("#app .layer");  }  // 页面加载的时候，进行一次初始化操作，创建对应的layer结构，并初始化样式  init()  //鼠标在banner上的初始x坐标  let initX = 0;  //鼠标在banner上，在x轴方向移动的距离  let moveX = 0;  // 计算线性插值  lerp = (start, end, amt) => (1 - amt) * start + amt * end;  function mouseMove(e) {    moveX = e.pageX - initX;    requestAnimationFrame(() => {      animate(moveX);    })  }  // 动画执行  function animate(moveX) {    //如果不存在layers，直接返回    if (layers.length <= 0) return;    //每次鼠标在banner上移动，遍历所有layer,对每个layer中的子元素都应用变换    for (let i = 0; i < layers.length; i++) {      // 当前layer的子元素对应的配置信息      const layerChildConfig = curBannerData[i];      // 下面代码的核心就是利用moveX来计算新的样式并应用      // 当前translateX      let translateX = layerChildConfig.transform.translateX + moveX * (layerChildConfig.a || 0);      // 当前scale      let scale = layerChildConfig.transform.scale + (layerChildConfig.f || 0) * moveX      // 当前translateY      let translateY = layerChildConfig.transform.translateY + moveX * (layerChildConfig.g || 0);      // 当前rotate      let rotate = layerChildConfig.transform.rotate + moveX * (layerChildConfig.r || 0)      // 透明度变化      layers[i].firstChild.style.opacity = lerp(        layerChildConfig.opacity[0],        layerChildConfig.opacity[1],        (moveX / window.innerWidth) * 2      );      // 一次性应用所有变化      layers[i].firstChild.style.transform = `translate(${translateX}px,${translateY}px) rotate(${rotate}deg) scale(${scale})`    }  }  header.addEventListener('mouseenter',(e)=>{    initX = e.pageX;  })  header.addEventListener("mousemove", mouseMove);  // 鼠标已经离开了视窗，执行回正动画  function leave() {    //修改一些标记量    layers.forEach((layer, i) => {      const child = layer.firstChild      const layerChildConfig = curBannerData[i];      child.addEventListener('transitionend', () => {          child.style.transition = '';      }, { once: true });      requestAnimationFrame(() => {        //回正的时候给每个layer都添加过渡        child.style.transition = 'all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)'        // 应用补偿值到元素的宽高        // 根据item中的信息设置img或者video的宽高        child.style.width = `${layerChildConfig.width * compensate}px`;        child.style.height = `${layerChildConfig.height * compensate}px`;        // 应用补偿值到（translateX/Y，偏移值）        let translateX = layerChildConfig.transform.translateX * compensate        let translateY = layerChildConfig.transform.translateY * compensate        let rotate = layerChildConfig.transform.rotate        let scale = layerChildConfig.transform.scale        // 添加偏移        child.style.transform = `translate(${translateX}px,${translateY}px) rotate(${rotate}deg) scale(${scale})`      })    })  }  header.addEventListener("mouseleave", leave);})()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {  font-family: ZhuZiAYuanJWD;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);  font-display: swap;  font-weight: lighter;}div#menus {  font-family: "ZhuZiAYuanJWD";}h1#site-title {  font-family: ZhuZiAYuanJWD;  font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {  font-family: ZhuZiAYuanJWD;}.iconfont {  font-family: "iconfont" !important;  font-size: 3em;  /* 可以定义图标大小 */  font-style: normal;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {  /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */  width: 1em;  height: 1em;  /* width和height定义图标的默认宽度和高度*/  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}.icon-zhongbiao::before {  color: #f7c768;}/* bilibli番剧插件 */#article-container .bangumi-tab.bangumi-active {  background: var(--anzhiyu-theme);  color: var(--anzhiyu-ahoverbg);  border-radius: 10px;}a.bangumi-tab:hover {  text-decoration: none !important;}.bangumi-button:hover {  background: var(--anzhiyu-theme) !important;  border-radius: 10px !important;  color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {  text-decoration: none !important;}.bangumi-button {  padding: 5px 10px !important;}a.bangumi-tab {  padding: 5px 10px !important;}svg.icon.faa-tada {  font-size: 1.1em;}.bangumi-info-item {  border-right: 1px solid #f2b94b;}.bangumi-info-item span {  color: #f2b94b;}.bangumi-info-item em {  color: #f2b94b;}/* 解决artitalk的图标问题 */#uploadSource > svg {  width: 1.19em;  height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {  background-color: transparent !important;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {  background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {  background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {  background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {  background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {  background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts > .recent-post-item {  background: #121212;}[data-theme="dark"] .card-widget {  background: #121212 !important;}[data-theme="dark"] div#post {  background: #121212 !important;}[data-theme="dark"] div#tag {  background: #121212 !important;}[data-theme="dark"] div#archive {  background: #121212 !important;}[data-theme="dark"] div#page {  background: #121212 !important;}[data-theme="dark"] div#category {  background: #121212 !important;}[data-theme="dark"] div#category {  background: transparent !important;}/* 页脚透明 */#footer {  background: transparent !important;   display: flex;  flex-direction: column;  justify-content: center;  align-items: center;  text-align: center;  width: 100%;}/* 头图透明 */#page-header {  background: transparent !important;}/* 右侧边栏垂直居中 */#rightside {  bottom: 50% !important;  transform: translateY(50%) !important;}#rightside.rightside-show {  transform: translate(-58px, 50%) !important;}#rightside > div > button {  border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {  width: 10px;  height: 10px;}::-webkit-scrollbar-thumb {  background-color: #3b70fc;  border-radius: 2em;}::-webkit-scrollbar-corner {  background-color: transparent;}::-moz-selection {  color: #fff;  background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {  left: -66px !important;  transition: all 0.3s;  /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {  left: 0 !important;  transition: all 0.3s;  /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {  z-index: 999999 !important;}/* 评论框  */.vwrap {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {  text-decoration: none !important;}#article-container #hpp_talk p img {  display: inline;}/* 404页面 */#error-wrap {  position: absolute;  top: 40%;  right: 0;  left: 0;  margin: 0 auto;  padding: 0 1rem;  max-width: 1000px;  transform: translate(0, -50%);}#error-wrap .error-content {  display: flex;  flex-direction: row;  justify-content: center;  align-items: center;  margin: 0 1rem;  height: 18rem;  border-radius: 8px;  background: var(--card-bg);  box-shadow: var(--card-box-shadow);  transition: all 0.3s;}#error-wrap .error-content .error-img {  box-flex: 1;  flex: 1;  height: 100%;  border-top-left-radius: 8px;  border-bottom-left-radius: 8px;  background-color: #3b70fc;  background-position: center;  background-size: cover;}#error-wrap .error-content .error-info {  box-flex: 1;  flex: 1;  padding: 0.5rem;  text-align: center;  font-size: 14px;  font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {  margin-top: -4rem;  font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {  margin-top: -3.5rem;  word-break: break-word;  font-size: 1.6em;}#error-wrap .error-content .error-info a {  display: inline-block;  margin-top: 0.5rem;  padding: 0.3rem 1.5rem;  background: var(--btn-bg);  color: var(--btn-color);}#body-wrap.error .aside-list {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  bottom: 0px;  position: absolute;  padding: 1rem;  width: 100%;  overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  max-width: 1200px;  margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {  padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {  width: 100%;  object-fit: cover;  border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {  overflow: hidden;  width: 230px;  height: 143px;  background: var(--anzhiyu-card-bg);  display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {  -webkit-line-clamp: 2;  line-clamp: 2;  overflow: hidden;  display: -webkit-box;  -webkit-box-orient: vertical;  line-height: 1.5;  justify-content: center;  align-items: flex-end;  align-content: center;  padding-top: 0.5rem;  color: white;}#body-wrap.error .aside-list .aside-list-item .content time {  display: none;}/* 代码框主题 */#article-container figure.highlight {  border-radius: 10px;}svg.icon {  width: 1.28em;  height: 1.28em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgba(21, 5, 245, 0.3);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0;}#cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {  left: -125px;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 头像呼吸灯 */[data-theme="light"] .avatar-img {  animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {  animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {  0% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }  50% {    box-shadow: 0px 0px 5px 5px #e9f5fa;  }  100% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }}@keyframes huxi_dark {  0% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }  50% {    box-shadow: 0px 0px 5px 5px #39c5bb;  }  100% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }}#page-header.nav-fixed #nav {  background: transparent !important;  box-shadow: none !important;  backdrop-filter: none !important;}#page-header.nav-fixed:not(.fixed) #nav {  background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 夜间模式下背景宇宙星光 */#universe {      display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    z-index: 1;}/* 亮色模式下隐藏 */[data-theme='light'] #universe {    display: none;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[window._iconfont_svg_string_5021196='<svg><symbol id="icon-car" viewBox="0 0 1024 1024"><path d="M109.43488 539.96288L69.12 610.43968l28.16 102.90432h828.30848l28.89216-102.90176-54.0544-55.46496-207.81056-27.00032L605.79584 440.32h-257.6384l-127.82592 99.64288z" fill="#D31B1B" ></path><path d="M293.28128 542.62784l76.1728-67.24352h93.6704v67.24352zM638.16448 542.62784l-60.18048-67.24352h-93.6704v67.24352zM353.75104 561.11616h46.08v15.36h-46.08zM527.83104 561.11616h46.08v15.36h-46.08z" fill="#FFC9C9" ></path><path d="M292.31104 730.07616m-79.36 0a79.36 79.36 0 1 0 158.72 0 79.36 79.36 0 1 0-158.72 0Z" fill="#BA0303" ></path><path d="M768.47104 730.07616m-79.36 0a79.36 79.36 0 1 0 158.72 0 79.36 79.36 0 1 0-158.72 0Z" fill="#BA0303" ></path><path d="M768.47104 730.07616m-46.08 0a46.08 46.08 0 1 0 92.16 0 46.08 46.08 0 1 0-92.16 0Z" fill="#D31B1B" ></path><path d="M292.31104 730.07616m-46.08 0a46.08 46.08 0 1 0 92.16 0 46.08 46.08 0 1 0-92.16 0Z" fill="#D31B1B" ></path><path d="M814.7712 345.79712a33.8688 33.8688 0 0 1 0 48.1024c-32.47616 31.26528-52.1728 46.89664-59.08992 46.89664-7.36 0-27.06432-15.424-59.1104-46.272a33.8688 33.8688 0 0 1 0-48.1024c13.23264-13.15072 34.5984-13.28384 47.98976-0.39424l0.40192 0.39424 10.71872 10.3296 10.69824-10.95424c13.3632-13.28128 35.02848-13.28128 48.38912 0z" fill="#D31B1B" ></path><path d="M904.96512 222.31808a23.0784 23.0784 0 0 1 0 32.85248c-22.25152 21.3504-35.74784 32.0256-40.4864 32.0256-5.0432 0-18.54464-10.5344-40.4992-31.60064a23.0784 23.0784 0 0 1 0-32.84992c9.0624-8.98304 23.70304-9.07264 32.87808-0.27136l0.27648 0.27136 7.34464 7.05536 7.32928-7.48288c9.15712-9.07008 24-9.07008 33.15712 0z" fill="#FFC9C9" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M874.666667 181.333333H149.333333c-40.533333 0-74.666667 34.133333-74.666666 74.666667v512c0 40.533333 34.133333 74.666667 74.666666 74.666667h725.333334c40.533333 0 74.666667-34.133333 74.666666-74.666667V256c0-40.533333-34.133333-74.666667-74.666666-74.666667z m-725.333334 64h725.333334c6.4 0 10.666667 4.266667 10.666666 10.666667v25.6L512 516.266667l-373.333333-234.666667V256c0-6.4 4.266667-10.666667 10.666666-10.666667z m725.333334 533.333334H149.333333c-6.4 0-10.666667-4.266667-10.666666-10.666667V356.266667l356.266666 224c4.266667 4.266667 10.666667 4.266667 17.066667 4.266666s12.8-2.133333 17.066667-4.266666l356.266666-224V768c0 6.4-4.266667 10.666667-10.666666 10.666667z" fill="#666666" ></path></symbol><symbol id="icon-home" viewBox="0 0 1024 1024"><path d="M96 480c-9.6 0-19.2-3.2-25.6-12.8-12.8-12.8-9.6-35.2 3.2-44.8l377.6-310.4c35.2-25.6 86.4-25.6 118.4 0l377.6 307.2c12.8 9.6 16 32 3.2 44.8-12.8 12.8-32 16-44.8 3.2L531.2 166.4c-9.6-6.4-28.8-6.4-38.4 0L115.2 473.6c-6.4 6.4-12.8 6.4-19.2 6.4zM816 928H608c-19.2 0-32-12.8-32-32v-150.4c0-22.4-38.4-44.8-67.2-44.8-28.8 0-64 19.2-64 44.8V896c0 19.2-12.8 32-32 32H211.2C163.2 928 128 892.8 128 848V544c0-19.2 12.8-32 32-32s32 12.8 32 32v304c0 9.6 6.4 16 19.2 16H384v-118.4c0-64 67.2-108.8 128-108.8s131.2 44.8 131.2 108.8V864h176c9.6 0 16 0 16-19.2V544c0-19.2 12.8-32 32-32s32 12.8 32 32v304C896 896 864 928 816 928z" fill="#666666" ></path></symbol><symbol id="icon-archive" viewBox="0 0 1024 1024"><path d="M621.714286 475.428571q0-14.857143-10.857143-25.714286t-25.714286-10.857143l-146.285714 0q-14.857143 0-25.714286 10.857143t-10.857143 25.714286 10.857143 25.714286 25.714286 10.857143l146.285714 0q14.857143 0 25.714286-10.857143t10.857143-25.714286zm329.142857-109.714286l0 548.571429q0 14.857143-10.857143 25.714286t-25.714286 10.857143l-804.571429 0q-14.857143 0-25.714286-10.857143t-10.857143-25.714286l0-548.571429q0-14.857143 10.857143-25.714286t25.714286-10.857143l804.571429 0q14.857143 0 25.714286 10.857143t10.857143 25.714286zm36.571429-256l0 146.285714q0 14.857143-10.857143 25.714286t-25.714286 10.857143l-877.714286 0q-14.857143 0-25.714286-10.857143t-10.857143-25.714286l0-146.285714q0-14.857143 10.857143-25.714286t25.714286-10.857143l877.714286 0q14.857143 0 25.714286 10.857143t10.857143 25.714286z"  ></path></symbol><symbol id="icon-tags" viewBox="0 0 1086 1024"><path d="M256 256q0-30.285714-21.428571-51.714286t-51.714286-21.428571-51.714286 21.428571-21.428571 51.714286 21.428571 51.714286 51.714286 21.428571 51.714286-21.428571 21.428571-51.714286zm609.714286 329.142857q0 30.285714-21.142857 51.428571l-280.571429 281.142857q-22.285714 21.142857-52 21.142857-30.285714 0-51.428571-21.142857l-408.571429-409.142857q-21.714286-21.142857-36.857143-57.714286t-15.142857-66.857143l0-237.714286q0-29.714286 21.714286-51.428571t51.428571-21.714286l237.714286 0q30.285714 0 66.857143 15.142857t58.285714 36.857143l408.571429 408q21.142857 22.285714 21.142857 52zm219.428571 0q0 30.285714-21.142857 51.428571l-280.571429 281.142857q-22.285714 21.142857-52 21.142857-20.571429 0-33.714286-8t-30.285714-25.714286l268.571429-268.571429q21.142857-21.142857 21.142857-51.428571 0-29.714286-21.142857-52l-408.571429-408q-21.714286-21.714286-58.285714-36.857143t-66.857143-15.142857l128 0q30.285714 0 66.857143 15.142857t58.285714 36.857143l408.571429 408q21.142857 22.285714 21.142857 52z"  ></path></symbol><symbol id="icon-folder-open" viewBox="0 0 1024 1024"><path d="M86.592 153.6v716.8h853.376V288H472.64L365.696 153.6h-279.04zM1.28 64h404.288L512.64 198.4H1025.28V960H1.28V64z m85.312 281.6v535.616l853.376-1.28V480H472.64L365.696 345.6h-279.04zM33.28 256h372.352L512.64 390.4H993.28a32 32 0 0 1 32 32v458.496l-1025.216 16.192 1.152-609.152A32 32 0 0 1 33.28 256z" fill="#262626" ></path></symbol><symbol id="icon-xinfeng" viewBox="0 0 1024 1024"><path d="M858.485 277.242c0-78.249 0-155.963 0-234.182-234.766 0-468.999 0-703.764 0 0 77.808 0 155.527 0 234.023-39.534 0-78.545 0-117.553 0 0 234.615 0 469.233 0 703.85 2.919-0.113 5.841-0.323 8.765-0.323 306.93-0.017 613.86-0.017 920.794-0.017 2.691 0 5.381 0 8.409 0 0-234.656 0-468.738 0-703.355-38.88 0-77.498 0-116.651 0zM212.977 107.996c0-2.114 0-4.225 0-6.735 195.645 0 390.813 0 586.844 0 0 2.526 0 4.641 0 6.756 0 94.412-0.041 188.823 0.112 283.237 0.005 4.813-1.589 7.786-5.154 10.834-94.62 80.916-189.163 161.918-283.595 243.050-3.791 3.258-5.81 3.223-9.578-0.017-94.433-81.13-188.979-162.134-283.597-243.050-3.569-3.053-5.147-6.037-5.139-10.844 0.148-94.411 0.112-188.822 0.112-283.233zM916.815 921.972c-273.675 0-547.028 0-820.766 0 0-182.334 0-364.432 0-547.913 137.018 117.426 273.403 234.315 410.351 351.681 136.572-117.047 273.022-233.989 410.416-351.743 0 183.445 0 365.532 0 547.97z"  ></path><path d="M740.498 160.106c-156.121 0-311.873 0-468.189 0 0 19.487 0 38.522 0 57.708 156.255 0 312.142 0 468.189 0 0-19.395 0-38.435 0-57.708z"  ></path><path d="M623.23 277.67c-117.247 0-234.149 0-350.958 0 0 19.381 0 38.262 0 57.43 117.102 0 233.866 0 350.958 0 0-19.183 0-38.068 0-57.43z"  ></path><path d=""  ></path></symbol><symbol id="icon-V" viewBox="0 0 1024 1024"><path d="M91.24412 525.851473c-7.443529 0-14.869662-2.988054-20.322861-8.887414-10.371208-11.221576-9.6815-28.726252 1.540076-39.098483L499.002988 83.60207c10.708899-9.893324 27.2619-9.782807 37.835723 0.258896l415.014108 394.263505c11.078313 10.523681 11.523451 28.036543 0.99977 39.114856-10.519588 11.082406-28.036543 11.525498-39.114856 1.003863L517.520737 141.837402 110.017696 518.502088C104.699574 523.420097 97.962126 525.851473 91.24412 525.851473z" fill="#29739A" ></path><path d="M801.37462 945.479669 614.618169 945.479669c-15.278985 0-27.66713-12.388145-27.66713-27.66713l0-214.423581L444.001303 703.388958l0 214.423581c0 15.278985-12.388145 27.66713-27.66713 27.66713L229.577722 945.479669c-15.278985 0-27.66713-12.388145-27.66713-27.66713L201.910593 498.18332c0-15.278985 12.388145-27.66713 27.66713-27.66713 15.278985 0 27.66713 12.388145 27.66713 27.66713l0 391.960043L388.66602 890.143363l0-214.423581c0-15.278985 12.388145-27.66713 27.66713-27.66713l198.285019 0c15.278985 0 27.66713 12.388145 27.66713 27.66713l0 214.423581 131.421168 0L773.706467 498.18332c0-15.278985 12.388145-27.66713 27.66713-27.66713s27.66713 12.388145 27.66713 27.66713l0 419.628196C829.042773 933.090501 816.653605 945.479669 801.37462 945.479669z" fill="#29739A" ></path><path d="M932.795788 253.786077c-15.278985 0-27.66713-12.388145-27.66713-27.66713l0-94.53098L789.847076 131.587967c-15.278985 0-27.66713-12.388145-27.66713-27.66713s12.388145-27.66713 27.66713-27.66713l142.949736 0c15.278985 0 27.66713 12.388145 27.66713 27.66713l0 122.199133C960.463941 241.397932 948.074773 253.786077 932.795788 253.786077z" fill="#29739A" ></path></symbol><symbol id="icon-zhifeiji" viewBox="0 0 1024 1024"><path d="M226.67264 834.59584l-25.05728-274.51392L25.6 409.19552l972.8-219.79136-476.3392 622.91968-139.62752-104.7296-155.76064 127.0016zM81.88928 423.15776l144.69632 124.03712 21.57056 236.30336 133.61152-108.92288 135.28064 101.44256 417.07008-545.408L81.88928 423.15776z" fill="" ></path><path d="M242.36032 820.58752L199.7312 545.8944l761.13408-347.72992 12.44672 22.78912-649.6256 417.90464-81.32608 181.72928z m-13.88032-259.20512l26.09664 168.18688 48.50176-108.42624 3.26656-2.07872 500.16256-321.75104-578.02752 264.06912z" fill="" ></path><path d="M373.45792 700.80512l-68.71552-61.0816 17.3056-19.46624 68.71552 61.0816z" fill="" ></path></symbol><symbol id="icon-QQ1" viewBox="0 0 1024 1024"><path d="M512 62C263.273 62 62 263.273 62 512s201.273 450 450 450 450-201.273 450-450S760.727 62 512 62z m184.91 563.727c-6.546 8.182-23.728-1.636-36.82-28.636-3.272 12.273-11.454 31.909-30.272 56.454 31.091 7.364 39.273 37.637 29.455 54-7.364 11.455-23.728 21.273-52.364 21.273-51.545 0-73.636-13.909-84.273-23.727-1.636-2.455-4.909-3.273-9-3.273-4.09 0-6.545 0.818-9 3.273-9.818 9.818-32.727 23.727-84.272 23.727-28.637 0-45.819-9.818-52.364-21.273-10.636-16.363-1.636-46.636 29.455-54-18-24.545-26.182-44.181-30.273-56.454-12.273 27-30.273 37.636-36.818 28.636-4.91-7.363-7.364-22.909-6.546-33.545 3.273-40.91 30.273-75.273 46.637-93.273-2.455-4.909-7.364-35.182 13.09-55.636v-1.637c0-81 57.273-139.09 130.091-139.09 72 0 130.091 58.09 130.091 139.09v1.637c20.455 20.454 15.546 50.727 13.091 55.636 15.546 18 43.364 52.364 46.637 93.273 0.818 10.636-0.819 26.182-6.546 33.545z" fill="#30A5DD" ></path></symbol><symbol id="icon-time" viewBox="0 0 1024 1024"><path d="M217.634 164.24h588.73c21.4 0 38.74-17.34 38.74-38.74-0.03-21.39-17.37-38.71-38.76-38.71h-588.71c-21.4 0-38.74 17.34-38.74 38.74 0.01 21.38 17.35 38.71 38.74 38.71z" fill="#EF7E20" ></path><path d="M806.364 187.02h-588.73c-33.91 0-61.5-27.58-61.52-61.47 0-33.95 27.6-61.55 61.52-61.55h588.72c33.89 0 61.49 27.57 61.54 61.47-0.01 33.95-27.61 61.55-61.53 61.55z m-588.73-77.46c-8.8 0-15.96 7.16-15.96 15.97 0 8.78 7.16 15.93 15.96 15.93h588.73c8.8 0 15.97-7.16 15.97-15.96-0.01-8.78-7.18-15.94-15.98-15.94h-588.72z" fill="#363432" ></path><path d="M217.634 937.23h588.73c21.4 0 38.74-17.34 38.74-38.74-0.02-21.38-17.36-38.71-38.74-38.71h-588.73c-21.4 0-38.74 17.34-38.74 38.74 0.01 21.38 17.35 38.71 38.74 38.71z" fill="#EF7E20" ></path><path d="M217.604 960c-16.41 0-31.84-6.39-43.46-17.99-11.62-11.61-18.02-27.07-18.03-43.48 0-33.93 27.6-61.53 61.52-61.53h588.73c33.89 0 61.49 27.57 61.52 61.46 0 33.95-27.6 61.55-61.52 61.55h-588.73 0.01c-0.01-0.01-0.03-0.01-0.04-0.01z m0.03-77.44c-8.8 0-15.96 7.16-15.96 15.96 0 4.26 1.66 8.26 4.67 11.27 3.01 3 7.01 4.66 11.26 4.66h588.76c8.8 0 15.97-7.16 15.97-15.96-0.01-8.76-7.17-15.93-15.97-15.93h-588.73z" fill="#363432" ></path><path d="M265.194 859.78c0-192.08 110.5-347.77 246.79-347.77s246.8 155.69 246.8 347.77h-493.59z" fill="#E9E7DF" ></path><path d="M758.784 882.56h-493.56c-12.58 0-22.81-10.2-22.81-22.78 0-204.32 120.93-370.56 269.57-370.56s269.57 166.24 269.57 370.56c0.01 12.57-10.18 22.78-22.77 22.78zM288.524 837h446.95c-8.09-168.62-105.23-302.22-223.47-302.22S296.614 668.37 288.524 837z" fill="#363432" ></path><path d="M758.784 164.24c0 192.08-110.5 347.77-246.79 347.77s-246.8-155.7-246.8-347.77h493.59z" fill="#E9E7DF" ></path><path d="M511.994 534.78c-148.65 0-269.57-166.22-269.57-370.54 0-12.58 10.2-22.78 22.78-22.78h493.59c12.58 0 22.78 10.2 22.78 22.78-0.01 204.32-120.94 370.54-269.58 370.54z m-223.47-347.76c8.09 168.61 105.23 302.2 223.47 302.2s215.38-133.59 223.47-302.2h-446.94z" fill="#363432" ></path><path d="M356.074 250.48h-86.76c-12.58 0-22.78-10.2-22.78-22.78 0-12.58 10.2-22.78 22.78-22.78h86.76c12.58 0 22.78 10.2 22.78 22.78 0 12.58-10.2 22.78-22.78 22.78z" fill="#363432" ></path><path d="M290.604 317.98C330.874 432.91 414.794 512 511.994 512c87.28 0 163.92-63.89 207.8-160.23l-429.19-33.79z" fill="#FFFBF1" ></path><path d="M511.994 527.19c-101.26 0-191.59-78.23-235.72-204.17-1.7-4.85-0.83-10.22 2.3-14.3 3.14-4.06 8.01-6.27 13.23-5.87l429.18 33.78c4.94 0.39 9.37 3.16 11.89 7.43 2.52 4.27 2.8 9.49 0.74 14-48.23 105.9-131.07 169.13-221.62 169.13z m-198.61-192.18c41.88 100.4 116.49 161.8 198.61 161.8 72.72 0 140.45-48.79 184.3-131.67l-382.91-30.13z" fill="#363432" ></path><path d="M611.874 705.33a767.174 767.174 0 0 0-93.26-20.2c-49.86-4.77-98.8 18.5-146.7 29.33l-90.24 20.41a474.673 474.673 0 0 0-16.48 124.91h493.56c0.08-42.19-5.46-84.2-16.48-124.92l-130.4-29.53z" fill="#FFFBF1" ></path><path d="M758.754 874.96h-493.56c-8.37 0-15.17-6.78-15.19-15.16a489.88 489.88 0 0 1 17-128.91c1.47-5.43 5.82-9.6 11.31-10.84l90.24-20.42c13.84-3.13 27.67-7.3 42.32-11.72 35.05-10.6 71.28-21.56 109.18-17.9 32.68 4.94 64.54 11.83 95.55 20.58l130.02 29.44c5.49 1.25 9.84 5.41 11.31 10.86 11.37 42 17.08 85.38 17 128.91-0.01 8.38-6.8 15.16-15.18 15.16z m-478.15-30.37h462.75c-1.02-32.7-5.52-65.21-13.44-96.96l-121.4-27.48c-0.26-0.06-0.52-0.13-0.78-0.21a758.846 758.846 0 0 0-91.41-19.8c-31.11-3.01-62.95 6.66-96.67 16.85-14.51 4.38-29.51 8.91-44.4 12.28l-81.22 18.38a459.674 459.674 0 0 0-13.43 96.94z" fill="#363432" ></path><path d="M511.994 590.08m-21.78 0a21.78 21.78 0 1 0 43.56 0 21.78 21.78 0 1 0-43.56 0Z" fill="#363432" ></path><path d="M511.994 665.01m-21.78 0a21.78 21.78 0 1 0 43.56 0 21.78 21.78 0 1 0-43.56 0Z" fill="#363432" ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1059 1024"><path d="M366.309517 147.950345l-97.456551-94.455173S253.598897 34.745379 279.375448 13.523862c25.882483-21.080276 27.188966-11.687724 35.910621-5.861517 8.721655 5.861517 144.948966 140.288 144.948965 140.288h-93.925517z m323.725242 3.531034l97.456551-94.490482s15.254069-18.714483-10.522482-39.936c-25.776552-21.080276-27.188966-11.723034-35.910621-5.861518-8.721655 5.861517-144.948966 140.288-144.948966 140.288h93.925518z" fill="#FB759C" ></path><path d="M1055.814621 326.338207a178.105379 178.105379 0 0 0-132.06069-176.057379s-658.679172-5.296552-796.107034 0C-9.745655 189.086897 0.776828 326.338207 0.776828 326.338207s1.836138 294.099862-0.141242 442.968276c14.830345 148.833103 129.588966 172.526345 129.588966 172.526345s45.832828 0.918069 79.271724 0.918069c3.531034 9.639724 6.10869 56.35531 58.156138 56.35531 51.906207 0 58.191448-56.35531 58.191448-56.35531s380.468966-1.836138 412.071724-1.836138c1.836138 15.889655 9.639724 58.968276 61.687173 58.191448 51.906207-0.918069 55.437241-61.687172 55.437241-61.687173s17.584552-1.836138 70.408828 0c123.233103-22.916414 130.365793-167.371034 130.365793-167.371034s-1.694897-295.759448 0-443.709793zM949.777655 797.307586c0 23.304828-18.46731 42.301793-41.242483 42.301793H158.614069c-22.775172 0-41.242483-18.891034-41.242483-42.301793V300.596966c0-23.304828 18.46731-42.301793 41.242483-42.301794H908.535172c22.775172 0 41.242483 18.855724 41.242483 42.301794v496.67531z" fill="#FB759C" ></path><path d="M196.325517 440.849655l220.195311-42.266483 16.666482 82.732138-218.359172 42.301793-18.46731-82.767448z m685.126621 0l-220.16-42.266483-16.772414 82.732138 218.465104 42.301793 18.46731-82.767448z m-448.264828 205.223724s48.375172 87.181241 102.152828-28.248276c51.906207 112.67531 109.179586 29.943172 109.179586 29.943173l32.485517 21.186207s-60.733793 97.739034-140.888275 23.834483c-67.795862 73.904552-139.122759-23.552-139.122759-23.552l36.193103-23.163587z" fill="#FB759C" ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M256 153.6a51.2 51.2 0 0 0 0 102.4c282.7776 0 512 229.2224 512 512a51.2 51.2 0 1 0 102.4 0C870.4 428.6976 595.3024 153.6 256 153.6z" fill="#374151" ></path><path d="M204.8 460.8a51.2 51.2 0 0 1 51.2-51.2 358.4 358.4 0 0 1 358.4 358.4 51.2 51.2 0 1 1-102.4 0 256 256 0 0 0-256-256 51.2 51.2 0 0 1-51.2-51.2zM153.6 768a102.4 102.4 0 1 1 204.8 0 102.4 102.4 0 0 1-204.8 0z" fill="#374151" ></path></symbol><symbol id="icon-icon_yinyue" viewBox="0 0 1024 1024"><path d="M208 794.5c19.5 50.5 88.7 70.8 154.7 45.3 65.9-25.5 103.6-87 84.1-137.5-12.6-32.6-47-54-90.3-56.1-43.3-2.1-88.8 15.5-119.4 46.1-30.6 30.6-41.7 69.6-29.1 102.2z m0 0M576.6 717.7c12.6 32.7 47 54 90.3 56.1 43.3 2.1 88.8-15.5 119.4-46.1 30.6-30.6 41.8-69.5 29.1-102.2-12.6-32.7-47-54-90.3-56.1-43.3-2.1-88.8 15.5-119.4 46.1-30.6 30.6-41.7 69.6-29.1 102.2z m0 0" fill="#A63EFF" ></path><path d="M730.8 177.3l-284.3 90.5c-29.2 8.8-49.2 35.7-49.2 66.2v396.6h54.6V409.1c0-6.5 4.1-12.3 10.6-14l284.7-90.8c1.4-0.3 2.7-0.7 4.1-0.7 7.2 0 14.7 5.8 14.7 14.7v334.5h54.6V243.2c0-46.4-45.1-79.5-89.8-65.9z m0 0" fill="#A63EFF" ></path></symbol><symbol id="icon-gitHub" viewBox="0 0 1024 1024"><path d="M419.632443 756.688877c-18.237168 18.909063-26.875826 41.369575-31.035179 65.909763-0.735886 4.255339-4.223344 5.951076-7.774793 7.422847-57.527065 23.964278-110.446846 10.142425-142.345892-43.641222-11.518211-19.388989-25.724005-36.154385-46.200824-46.584764-12.222102-6.239031-24.956124-10.462375-38.969948-8.958609-2.591597 0.25596-5.27918 0.543916-7.710802 1.375786-7.390852 2.559602-8.638658 6.399006-3.967384 12.734022 3.583443 4.89524 8.126738 8.958609 13.277938 12.094122 29.115478 17.693252 46.232819 44.857033 58.102976 75.476278 18.909063 48.824417 54.839483 73.524581 105.999537 77.715929 19.197018 1.567757 38.298052 0.415935 57.271105-3.263493 9.246564-1.791722 10.398385-0.863866 10.462375 8.862624 0.223965 27.067796 0.479925 54.135592 0.12798 81.235383-0.223965 17.533277-14.685719 29.115478-31.995031 26.235925a74.132486 74.132486 0 0 1-14.077813-4.031374c-119.82139-45.144988-210.847253-123.884759-273.717489-235.291456a516.719747 516.719747 0 0 1-60.150657-173.701022 534.253024 534.253024 0 0 1-5.727111-119.021515C5.808715 419.685218 22.894062 351.535802 55.465003 287.961676 130.877291 140.752539 248.714989 46.783134 410.76982 10.404784c48.344491-10.846315 97.456864-12.638037 146.857191-7.998758 120.397301 11.358236 223.325315 60.278638 309.135988 144.713524 78.611791 77.363984 127.276232 171.173415 147.945022 279.572579 8.222723 43.097306 11.102276 86.610548 8.094743 130.219776-9.598509 138.538483-63.606121 256.856107-164.038523 353.353119-50.552149 48.632447-109.19904 84.466881-174.916833 108.8151a79.891592 79.891592 0 0 1-15.13365 4.383319c-15.293625 2.367632-27.259766-6.111051-31.03518-21.18071a62.77425 62.77425 0 0 1-1.279801-15.677565c0.19197-42.489401 0.479925-85.010797 0.543915-127.500198 0.06399-18.045197-0.415935-36.0584-5.53514-53.655666-4.70327-16.061505-11.294246-31.03518-22.844452-43.513242-1.695737-1.791722-4.70327-3.455463-3.391473-6.431001 1.183816-2.687583 4.415314-2.559602 6.974917-2.879553 20.92475-2.335637 41.59354-6.175041 61.878389-11.902152 35.194534-9.91846 67.509515-25.180089 94.545316-50.392173 29.275453-27.323756 46.456785-61.590434 56.439234-99.760506 10.3024-39.289898 12.606042-79.539646 8.958609-119.725405a186.019109 186.019109 0 0 0-42.937331-103.6639c-5.759106-6.910927-6.846937-12.798012-4.351325-21.37268 11.262251-38.809972 7.966763-77.299994-4.479304-115.278096-3.423468-10.55836-7.038907-12.478062-18.493128-11.294246-21.980586 2.271647-42.489401 9.342549-62.32632 18.685098-18.717093 8.830628-36.57032 19.293004-53.623671 31.003185a18.525123 18.525123 0 0 1-16.765396 2.911547 473.782416 473.782416 0 0 0-149.736744-14.429758c-29.275453 1.695737-58.262951 6.239031-86.610549 13.981828a21.852606 21.852606 0 0 1-19.900909-3.423468c-25.276074-17.085346-51.83195-31.899046-80.883437-41.753515a168.389847 168.389847 0 0 0-34.138698-7.102897c-11.294246-1.375786-14.909684 1.055836-18.237168 11.678186-12.478062 39.609848-15.4536 79.507651-2.911548 119.661415 1.695737 5.503145 0.51192 9.086589-2.943542 13.245943A197.505325 197.505325 0 0 0 191.731839 457.535339a247.065628 247.065628 0 0 0-3.327483 55.031453c1.343791 28.955503 4.511299 57.591055 12.606042 85.618702 20.86076 72.052809 68.309391 117.581738 139.114394 139.818285 21.532656 6.782947 43.481247 11.838161 65.941758 14.333774 4.063369 0.44793 8.222723 0.895861 13.565893 4.351324" fill="#4F4F4F" ></path></symbol><symbol id="icon-lianjie" viewBox="0 0 1024 1024"><path d="M221.098667 706.474667c-42.88-45.226667-42.88-118.528 0-163.754667l213.333333-225.194667a105.685333 105.685333 0 0 1 155.136 0c42.837333 45.226667 42.837333 118.528 0 163.754667l-106.666667 112.64a45.141333 45.141333 0 0 0 0 61.397333 39.637333 39.637333 0 0 0 58.197334 0l106.666666-112.64c74.965333-79.104 74.965333-207.445333 0-286.592-74.965333-79.146667-196.565333-79.146667-271.530666 0l-213.333334 225.194667c-74.965333 79.146667-74.965333 207.488 0 286.634667a187.008 187.008 0 0 0 123.733334 58.965333c22.698667 1.493333 42.24-16.725333 43.648-40.661333 1.408-23.936-15.829333-44.544-38.528-46.08a106.624 106.624 0 0 1-70.656-33.664z" fill="#666666" ></path><path d="M376.234667 481.28c-74.965333 79.146667-74.965333 207.488 0 286.634667 74.965333 79.146667 196.565333 79.146667 271.530666 0l213.333334-225.194667c74.965333-79.146667 74.965333-207.488 0-286.634667a187.008 187.008 0 0 0-123.733334-58.965333c-22.698667-1.493333-42.24 16.725333-43.648 40.661333-1.408 23.936 15.829333 44.544 38.485334 46.08 25.813333 1.664 51.029333 12.885333 70.698666 33.664 42.88 45.226667 42.88 118.528 0 163.754667l-213.333333 225.194667a105.685333 105.685333 0 0 1-155.136 0c-42.837333-45.226667-42.837333-118.528 0-163.754667l106.666667-112.64a45.141333 45.141333 0 0 0 0-61.397333 39.637333 39.637333 0 0 0-58.197334 0l-106.666666 112.64z" fill="#666666" ></path></symbol><symbol id="icon-liaotian" viewBox="0 0 1024 1024"><path d="M532.533333 1024H243.466667c-33.2 0-64.533333-31.333333-64.533334-64.533333v-57.866667C65.066667 805.066667 0 663.6 0 512c0-68.933333 13.466667-135.733333 40.133333-198.8 25.733333-60.933333 62.533333-115.733333 109.466667-162.8C246.266667 53.466667 374.933333 0 512 0c137.066667 0 265.733333 53.466667 362.533333 150.4 46.933333 47.066667 83.733333 101.866667 109.466667 162.8 26.533333 63.066667 40 129.866667 40 198.8 0 132.533333-50.933333 258.533333-143.466667 354.666667-92.266667 95.866667-215.6 151.733333-347.6 157.333333h-0.4zM512 39.466667c-260.533333 0-472.533333 212-472.533333 472.533333 0 142.933333 62.666667 276 171.733333 365.066667l7.2 5.866666v76.533334c0 11.466667 13.6 25.066667 25.066667 25.066666h288.266666c254-11.066667 452.8-218.533333 452.8-472.533333 0-260.533333-212-472.533333-472.533333-472.533333z"  ></path><path d="M291.466667 512m-88.4 0a88.4 88.4 0 1 0 176.8 0 88.4 88.4 0 1 0-176.8 0Z"  ></path><path d="M512 512m-88.4 0a88.4 88.4 0 1 0 176.8 0 88.4 88.4 0 1 0-176.8 0Z"  ></path><path d="M732.533333 512m-88.4 0a88.4 88.4 0 1 0 176.8 0 88.4 88.4 0 1 0-176.8 0Z"  ></path></symbol><symbol id="icon-bilibili1" viewBox="0 0 1024 1024"><path d="M300.5 501.2s47.1-9.6 53.8-3.8l23.2 171.2-38.5 4.8-38.5-172.2z m18.3-94.1h26.9l7.7 66.3h-25.1l-9.5-66.3z m-30.7 6.7l25.1-2.2 7.7 64.9-21.9 3.6-10.9-66.3z m65.4-80.9s54.9-5.8 56.7 0l26.9 323.2h-41.9l-41.7-323.2z m96.1 170.3h52.9v174.1H464l-14.4-174.1z m26.5-88.5h26.4v65.4h-26.4v-65.4z m-32.3 0h23.1v65.4h-23.1v-65.4zM125.5 546.5L111 282.1c-8.6 7.7-73.1 28.9-73.1 28.9 22 76 52 392.3 52 392.3 151.5 4.9 214.4-61.5 218.3-76.9 2.3-9.2 2.3-18.8 0-27.9-36.5-60.7-182.7-52-182.7-52z m45.8 114.4l-9.5-75.3 69.9 29.5-60.4 45.8z m618.8-62.5c-36.5-60.5-182.8-52-182.8-52L592.8 282c-8.6 7.7-72.9 28.9-72.9 28.9 22 76 52 392.3 52 392.3 151.5 4.9 214.4-61.5 218.3-76.9 2.2-9.2 2.2-18.7-0.1-27.9zM653 660.9l-9.5-75.3 69.9 29.5-60.4 45.8z m129.4-159.7s47.1-9.6 53.8-3.8l23.1 171.2-38.5 4.8-38.4-172.2z m18.3-94.1h26.9l7.7 66.3h-25.1l-9.5-66.3z m-30.9 6.7l25.1-2.2 7.7 64.9-21.9 3.6-10.9-66.3z m65.4-80.9s54.9-5.8 56.7 0l27 323.1H877l-41.8-323.1z m96.3 170.3h52.9v174.1h-38.5l-14.4-174.1z m26.4-88.5h26.4v65.4h-26.4v-65.4z m-32.2 0h23.1v65.4h-23.1v-65.4z" fill="#FF6B86" ></path></symbol><symbol id="icon-dragon_chen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-498.122105 265.620211L431.157895 754.526316V485.052632h-66.074948c-14.470737 110.645895-44.355368 197.066105-102.696421 260.742736l-39.747368-36.432842C306.526316 617.876211 323.368421 462.901895 323.368421 242.526316V215.578947h377.263158v53.894737H377.182316c-0.404211 58.260211-2.209684 112.128-6.359579 161.684211H700.631579v53.894737h-122.152421a481.172211 481.172211 0 0 0 76.826947 119.70021l66.479158-39.855158 27.728842 46.214737-54.460631 32.687158c29.507368 24.953263 63.757474 45.675789 102.80421 58.098526l-16.303158 51.361684c-134.224842-42.711579-222.773895-167.073684-261.551158-268.207157H485.052632v221.857684l68.985263-41.391158 27.728842 46.214737-109.783579 65.886316zM646.736842 377.263158h-215.578947v-53.894737h215.578947v53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-dog_xu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-375.592421 150.393263c33.684211 44.544 75.210105 74.698105 124.739369 90.812632l11.425684 3.718737 10.401684-6.009264C781.204211 727.740632 808.421053 622.565053 808.421053 592.842105h-53.894737c0 22.069895-19.132632 80.869053-33.711158 103.504842-34.816-14.605474-64.538947-39.262316-89.249684-74.13221 48.316632-55.269053 92.079158-117.328842 120.535579-179.900632l-49.044211-22.285473c-23.767579 52.250947-59.742316 104.717474-100.055579 152.656842-24.010105-50.930526-41.148632-115.927579-51.658105-195.395369H700.631579v-53.894737h-155.189895A1848.050526 1848.050526 0 0 1 538.947368 161.684211h-53.894736c0 58.206316 2.155789 112.074105 6.494315 161.68421H323.368421v26.947368c0 216.549053-13.177263 263.545263-100.702316 359.046737l39.747369 36.432842c63.326316-69.093053 92.806737-118.272 105.714526-206.848H485.052632v-53.894736h-111.319579a1742.147368 1742.147368 0 0 0 3.449263-107.789474h120.158316c12.611368 98.250105 35.031579 177.475368 67.395368 238.187789-61.978947 65.536-128.053895 117.975579-173.298526 142.282106l25.519158 47.481263c47.589053-25.573053 114.095158-77.446737 177.55621-142.821053z m125.170526-411.971368l-80.842105-80.842106-38.103579 38.103579 80.842105 80.842106 38.103579-38.103579z" fill="#231F20" ></path></symbol><symbol id="icon-dog" viewBox="0 0 1024 1024"><path d="M894.814316 904.434526l83.240421-183.134315-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939369-185.263158-0.134737-7.922526-0.134737-33.953684-0.134736-55.996631-30.693053 15.306105-70.090105 19.887158-106.09179 19.887157-92.752842 0-163.624421-23.983158-210.647579-71.275789a192.512 192.512 0 0 1-27.944421-36.513684H377.263158v377.263158c342.662737 0 403.105684 51.092211 494.592 128.377263 7.922526 6.682947 15.521684 13.312 22.959158 19.86021z" fill="#85C3DE" ></path><path d="M326.063158 282.947368c0 34.250105-13.231158 44.463158-29.642105 44.463158s-29.642105-10.213053-29.642106-44.463158c0-34.223158 13.231158-44.463158 29.642106-44.463157s29.642105 10.24 29.642105 44.463157zM269.473684 430.295579v311.646316L190.275368 916.210526h59.203369L323.368421 753.637053V377.263158h-26.947368c-119.403789 0-172.732632-53.382737-185.505685-107.789474h35.624421c51.092211 0 68.581053-15.764211 120.535579-62.544842 12.773053-11.506526 28.079158-25.276632 47.023158-41.741474l18.351158-15.952842-69.658947-99.139368-44.085895 30.989474 41.768421 59.472842c-11.183158 9.862737-20.884211 18.593684-29.480421 26.327579C180.736 212.156632 176.235789 215.578947 146.539789 215.578947H53.894737v26.947369c0 88.710737 66.910316 178.149053 215.578947 187.769263z m216.710737-161.414737c2.290526 71.733895 28.698947 136.326737 75.048421 182.918737C618.711579 509.628632 702.437053 538.947368 810.091789 538.947368c18.593684 0 36.190316-1.158737 52.628211-3.449263 3.745684 111.265684 33.630316 170.334316 51.496421 196.015158l-38.507789 84.722526C782.174316 742.049684 688.774737 700.631579 377.263158 700.631579v53.894737c34.277053 0 65.697684 0.512 94.639158 1.509052L374.595368 970.105263h59.203369l96.013474-211.240421c66.182737 4.338526 117.005474 11.829895 157.911578 22.016L626.229895 916.210526h59.176421l54.16421-119.134315c47.616 18.405053 79.737263 42.091789 113.125053 69.739789L805.753263 970.105263h59.203369l113.071157-248.778105-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939368-185.263158C985.168842 498.553263 1024 447.811368 1024 377.263158c0-95.205053-66.506105-161.684211-161.684211-161.684211v53.894737c65.482105 0 107.789474 42.307368 107.789474 107.789474 0 89.088-87.013053 107.789474-160.013474 107.789474-92.752842 0-163.624421-23.983158-210.647578-71.27579-30.315789-30.504421-45.891368-65.832421-53.35579-98.735158 11.210105 6.952421 22.932211 13.338947 35.274105 19.186527l23.04-48.720843c-92.106105-43.654737-148.992-128.646737-219.243789-243.981473l-46.026105 28.05221c49.448421 81.246316 92.968421 148.506947 147.051789 199.302737z" fill="#231F20" ></path></symbol><symbol id="icon-goat" viewBox="0 0 1024 1024"><path d="M548.378947 646.736842a952.32 952.32 0 0 1 140.90779-161.68421H107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L66.721684 754.526316h417.172211c20.345263-41.472 43.654737-77.446737 64.485052-107.789474z" fill="#F7C768" ></path><path d="M608.256 144.734316C555.762526 115.577263 506.098526 107.789474 485.052632 107.789474V53.894737c32.579368 0 91.270737 11.452632 149.369263 43.735579 75.290947 41.822316 130.694737 94.531368 171.385263 150.878316C755.873684 288.013474 697.101474 323.368421 646.736842 323.368421h-107.789474v-53.894737h107.789474c20.506947 0 48.424421-11.210105 80.437895-31.285895a471.04 471.04 0 0 0-118.918737-93.453473zM832.673684 342.231579c-16.384 0-29.642105 10.24-29.642105 44.463158 0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642105-44.463158c0-34.223158-13.231158-44.463158-29.642105-44.463158zM1024 619.789474C1024 347.109053 901.066105 122.448842 686.753684 3.395368l-26.165895 47.104C914.324211 191.461053 964.688842 440.400842 969.647158 592.842105h-84.506947c-17.92-35.624421-45.352421-69.12-87.013053-101.995789l-16.788211-13.285053-16.734315 13.392842c-66.128842 52.897684-134.629053 127.083789-187.311158 209.677474H102.965895l-8.272842-20.318316C159.043368 617.013895 161.684211 603.109053 161.684211 485.052632v-53.894737h485.052631v-53.894737H161.684211c0-80.384 14.309053-110.026105 66.586947-137.916632l-25.384421-47.535158C123.365053 234.226526 107.789474 291.920842 107.789474 377.263158v107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L110.618947 862.315789h58.206316l-43.897263-107.789473h103.477895l43.897263 107.789473h58.206316l-43.897263-107.789473h259.47621C508.981895 824.939789 485.052632 899.152842 485.052632 970.105263h53.894736c0-68.688842 27.270737-144.060632 68.958316-215.578947H687.157895c7.410526 0 13.473684 6.063158 13.473684 13.473684V862.315789h53.894737v-94.315789c0-37.160421-30.208-67.368421-67.368421-67.368421h-44.65179c40.771368-58.017684 89.438316-111.427368 138.913684-153.626947C841.512421 600.037053 862.315789 655.225263 862.315789 754.526316h53.894737c0-38.912-2.748632-74.482526-11.102315-107.789474H1024v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-goat_wei" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 50.202947c52.304842 70.925474 136.973474 152.144842 232.528843 190.383158l19.994947-50.041263c-109.271579-43.708632-202.805895-152.629895-238.780632-217.49221H808.421053v-53.894737H538.947368v-53.894737h215.578948v-53.894737h-215.578948V161.684211h-53.894736v161.68421h-215.578948v53.894737h215.578948v53.894737H215.578947v53.894737h255.757474c-35.974737 64.862316-129.536 173.783579-238.807579 217.49221l20.021895 50.041263c95.528421-38.238316 180.197053-119.484632 232.501895-190.383158V808.421053h53.894736v-246.218106z" fill="#231F20" ></path></symbol><symbol id="icon-dragon" viewBox="0 0 1024 1024"><path d="M366.376421 344.441263l152.980211-152.98021c43.142737-43.142737 141.204211-9.216 270.201263 115.738947-15.225263 9.835789-25.114947 15.818105-44.13979 32.256s-38.076632 35.489684-59.418947 56.832c-4.203789 4.203789-51.173053 53.221053-78.740211 82.027789-10.805895-12.126316-22.743579-24.171789-34.654315-36.082526L493.136842 362.792421l-54.218105 54.218105-72.542316-72.569263zM862.315789 512c0 46.834526-45.352421 80.842105-107.789473 80.842105-108.948211 0-189.359158-28.806737-267.129263-56.697263C414.100211 509.871158 344.872421 485.052632 258.182737 485.052632 80.788211 485.052632 0 588.126316 0 683.897263h53.894737C73.216 659.779368 135.302737 646.736842 177.340632 646.736842c77.338947 0 223.124211 23.282526 291.893894 47.912421C547.462737 722.701474 615.989895 754.526316 734.315789 754.526316 862.315789 754.526316 916.210526 670.315789 916.210526 512h-53.894737z" fill="#FF8787" ></path><path d="M552.421053 1024c-69.766737 0-113.825684-13.958737-156.402527-27.459368-54.487579-17.273263-110.807579-35.004632-232.421052-26.516211l-3.826527-53.733053c131.718737-9.458526 195.934316 10.967579 252.52379 28.887579 42.226526 13.365895 78.686316 24.926316 140.126316 24.926316 92.752842 0 148.210526-57.936842 148.210526-113.960421 0-16.949895-5.524211-101.618526-114.634105-101.618526-64.970105 0-112.747789 23.336421-163.328 48.02021C365.325474 830.571789 300.301474 862.315789 204.288 862.315789 85.908211 862.315789 0 787.294316 0 683.897263 0 588.126316 80.788211 485.052632 258.182737 485.052632c86.689684 0 155.917474 24.818526 229.214316 51.09221 45.810526 16.410947 92.564211 33.172211 145.488842 44.166737 9.000421-7.033263 13.850947-16.276211 13.850947-26.758737 0-37.187368-37.672421-74.859789-74.13221-111.265684l-3.287579-3.287579 38.103579-38.103579 3.260631 3.287579C652.853895 446.275368 700.631579 494.026105 700.631579 553.552842c0 12.719158-2.802526 24.926316-7.976421 36.109474A594.997895 594.997895 0 0 0 754.526316 592.842105c62.437053 0 107.789474-34.007579 107.789473-80.842105 0-58.853053-52.870737-110.268632-108.840421-164.702316l-8.057263-7.841684c-19.024842 16.437895-38.076632 35.489684-59.418947 56.832l-38.103579-38.103579c74.805895-74.832842 134.898526-134.898526 268.314947-141.931789V55.619368c-63.407158 7.787789-120.993684 39.424-121.667368 39.801264l-15.818105 8.811789-14.120421-11.344842C731.701895 66.452211 709.712842 53.894737 673.684211 53.894737c-41.418105 0-74.347789 25.869474-109.190737 53.301895-26.624 20.911158-54.137263 42.549895-86.851369 53.194105L469.342316 161.684211h-69.093053l-105.525895 105.525894-38.103579-38.130526L324.015158 161.684211H161.684211V107.789474h303.104c22.231579-8.272842 43.708632-25.168842 66.398315-42.981053C569.829053 34.438737 613.618526 0 673.684211 0c48.909474 0 81.408 17.946947 110.888421 40.097684C813.702737 26.300632 877.729684 0 943.157895 0h26.947368v323.368421h-53.894737v-53.167158c-54.164211 3.098947-92.914526 15.845053-127.002947 36.675369l1.832421 1.778526C852.587789 368.505263 916.210526 430.376421 916.210526 512c0 60.928-43.708632 109.945263-107.789473 127.622737V700.631579h53.894736v-53.894737h53.894737v53.894737h53.894737v53.894737h-53.894737v53.894737h-53.894737v-53.894737h-53.894736c-29.722947 0-53.894737-24.171789-53.894737-53.894737v-53.894737c-118.325895 0-207.063579-31.797895-285.318737-59.877053C400.437895 562.229895 335.494737 538.947368 258.182737 538.947368 117.059368 538.947368 53.894737 611.732211 53.894737 683.897263 53.894737 757.221053 115.738947 808.421053 204.288 808.421053c11.910737 0 23.228632-0.538947 34.034526-1.536C248.454737 796.321684 269.473684 770.640842 269.473684 739.166316c0-33.118316-43.088842-70.979368-58.152421-81.596632l30.935579-44.139789c8.299789 5.793684 81.111579 58.664421 81.111579 125.736421 0 19.429053-4.527158 37.052632-10.994526 52.304842 30.773895-10.051368 58.314105-23.498105 86.662737-37.349053C452.877474 727.848421 508.577684 700.631579 585.997474 700.631579 702.410105 700.631579 754.526316 778.725053 754.526316 856.144842 754.526316 938.657684 678.912 1024 552.421053 1024z m-21.180632-623.104L493.136842 362.792421l137.889684-137.889684 38.103579 38.103579-137.889684 137.889684z m-126.760421-18.351158l-38.103579-38.103579 152.980211-152.98021 38.103579 38.103579-152.980211 152.98021z m282.004211-218.624c15.494737-9.754947 43.331368-31.447579 43.331368-31.447579-25.734737-27.809684-49.556211-33.333895-67.368421-29.07621-19.240421 4.608-37.753263 24.602947-37.753263 24.602947s42.253474 22.447158 61.790316 35.920842z" fill="#231F20" ></path></symbol><symbol id="icon-horse" viewBox="0 0 1024 1024"><path d="M776.003368 646.736842c16.599579-99.947789 43.439158-181.086316 83.213474-256.538947l6.817684-12.934737H269.473684c-36.756211 0-53.894737 54.945684-53.894737 92.05221 0 46.753684 6.656 77.527579 70.278737 176.074106l84.533895 128.269473L498.876632 646.736842h277.126736z" fill="#FFAF6E" ></path><path d="M1024 0v404.210526c0 33.333895 0 134.736842-92.079158 134.736842h-13.824l-78.362947-109.056c-22.743579 49.906526-40.340211 103.046737-53.490527 162.950737h115.092211C937.310316 592.842105 970.105263 625.637053 970.105263 661.638737c0 60.631579-69.389474 154.300632-77.312 164.75621l-43.008-32.471579C875.466105 759.861895 916.210526 693.813895 916.210526 661.638737c0-5.982316-8.919579-14.901895-14.901894-14.901895h-125.332211C761.128421 736.121263 754.526316 840.569263 754.526316 970.105263h-53.894737c0-283.971368 31.097263-453.605053 110.888421-605.049263l20.318316-38.534737 112.801684 156.995369c14.443789-4.419368 25.465263-20.938105 25.465263-79.306106V0h53.894737z m-161.684211 161.684211h53.894737V0h-53.894737v80.842105c-17.381053-14.955789-38.184421-26.947368-80.842105-26.947368h-134.736842v53.894737h134.736842c37.672421 0 80.842105 40.906105 80.842105 53.894737z m-107.789473 0h-215.578948v53.894736h161.684211l53.894737-53.894736zM300.894316 766.544842L400.680421 916.210526h64.754526l-95.043368-142.551579L498.876632 646.736842h167.855157a1212.631579 1212.631579 0 0 1 9.431579-53.894737h-199.383579l-175.885473 173.702737z m109.97221-184.400842l-37.861052-38.319158-132.419369 130.802526C173.729684 571.095579 161.684211 529.812211 161.684211 469.315368 161.684211 398.578526 199.464421 323.368421 269.473684 323.368421h323.368421l53.894737-53.894737H269.473684c-6.709895 0-13.258105 0.565895-19.698526 1.482105C234.927158 249.451789 204.638316 215.578947 160.633263 215.578947 65.967158 215.578947 0 349.291789 0 469.315368c0 70.170947 16.141474 136.650105 49.232842 202.671158L6.197895 723.833263l41.472 34.41179 66.128842-79.737264-8.704-16.033684C83.105684 622.133895 53.894737 558.214737 53.894737 469.315368 53.894737 368.451368 106.765474 269.473684 160.633263 269.473684c13.231158 0 25.815579 9.889684 35.43579 20.533895C142.874947 321.967158 107.789474 388.500211 107.789474 469.315368c0 78.201263 19.698526 130.937263 93.642105 243.981474l-55.296 54.622316L280.899368 970.105263h64.754527l-130.048-195.072 195.260631-192.889263z" fill="#231F20" ></path></symbol><symbol id="icon-monkey_shen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 134.736842h161.684211v53.894737h53.894737V269.473684h-215.578948V161.684211h-53.894736v107.789473h-215.578948v431.157895h53.894737v-53.894737h161.684211v215.578947h53.894736v-215.578947z m0-161.68421h161.684211v107.789473h-161.684211v-107.789473z m-215.578947 0h161.684211v107.789473h-161.684211v-107.789473z m215.578947-161.684211h161.684211v107.789474h-161.684211v-107.789474z m-215.578947 0h161.684211v107.789474h-161.684211v-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-ox_chou" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-161.68421 188.631579h-159.555369c13.985684-172.813474 43.115789-357.429895 70.817684-385.158737L700.631579 269.473684H323.368421v53.894737h107.169684c-1.940211 45.756632-8.192 103.962947-15.76421 161.684211H323.368421v53.894736h83.968c-9.862737 68.446316-20.264421 130.128842-25.734737 161.684211H215.578947v53.894737h592.842106v-53.894737z m-346.543158-161.684211h149.800421a3313.717895 3313.717895 0 0 0-16.842105 161.684211h-158.477474c6.036211-35.247158 16.114526-95.636211 25.519158-161.684211z m22.608842-215.578947h171.735579c-15.198316 41.121684-27.405474 100.594526-36.890948 161.684211h-150.123789c7.383579-57.505684 13.419789-115.361684 15.279158-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-monkey" viewBox="0 0 1024 1024"><path d="M757.733053 485.052632H565.894737a80.842105 80.842105 0 0 0-80.842105 80.842105v215.578947c0 40.96 43.546947 99.678316 77.446736 139.210105C596.426105 960.215579 603.055158 970.105263 603.055158 970.105263H754.526316s15.144421-18.674526 45.891368-58.071579S862.315789 809.984 862.315789 717.608421c0-89.573053-47.993263-166.346105-104.582736-232.555789z" fill="#C3D686" ></path><path d="M538.947368 1024h-53.894736c0-32.794947 25.869474-87.417263 77.446736-103.316211C528.599579 881.152 485.052632 822.433684 485.052632 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h80.842105v53.894737h-80.842105a26.947368 26.947368 0 0 0-26.947369 26.947368c0 19.725474 36.675368 77.473684 92.133053 134.736842h88.602947c20.210526-14.147368 88.737684-71.464421 88.737685-198.602105 0-108.382316-93.237895-202.967579-168.151579-278.986105-49.502316-50.202947-88.576-89.842526-98.735158-128.61979-11.749053-44.732632-21.584842-112.586105-26.327579-148.318315H377.263158c-45.136842 0-89.519158 8.434526-121.802105 53.894736H431.157895v53.894737c-97.28 0-107.789474 113.071158-107.789474 161.684211v53.894737h53.894737v161.68421h-53.894737v-107.789474h-26.947368c-170.253474 0-188.631579-94.234947-188.631579-134.736842 0-31.043368 35.220211-72.326737 55.727158-93.722947 2.694737-14.686316 5.847579-28.348632 9.431579-41.013895H161.684211V215.578947h31.528421C239.642947 120.993684 317.224421 107.789474 377.263158 107.789474h185.640421l2.802526 23.794526c0.134737 1.050947 12.719158 106.657684 27.944421 164.756211 6.494316 24.872421 44.624842 63.514947 84.965053 104.448C760.481684 483.813053 862.315789 587.129263 862.315789 717.608421c0 92.375579-31.124211 155.028211-61.898105 194.425263C904.919579 892.146526 970.105263 803.004632 970.105263 673.684211c0-91.405474-42.819368-154.381474-84.237474-215.255579C847.791158 402.458947 808.421053 344.576 808.421053 269.473684c0-119.349895 87.093895-161.684211 161.68421-161.68421v53.894737c-32.417684 0-107.789474 10.509474-107.789474 107.789473 0 58.502737 31.555368 104.933053 68.096 158.639158C974.282105 492.597895 1024 565.679158 1024 673.684211c0 177.286737-108.301474 296.421053-269.473684 296.421052h-161.684211c-37.672421 0-53.894737 40.906105-53.894737 53.894737zM229.214316 269.473684a384.808421 384.808421 0 0 0-14.012632 58.341053l-1.401263 8.488421-6.090105 6.117053c-22.878316 22.932211-44.813474 52.601263-46.026105 62.275368 0 56.805053 53.76 75.264 107.789473 79.386947V431.157895c0-58.691368 13.473684-119.619368 46.511158-161.684211h-86.770526zM323.368421 1024h-53.894737c0-32.794947 25.869474-87.417263 77.446737-103.316211C313.020632 881.152 269.473684 822.433684 269.473684 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h45.16379A188.847158 188.847158 0 0 1 565.894737 592.842105h134.736842v53.894737h-134.736842c-74.293895 0-134.736842 60.442947-134.736842 134.736842v26.516211l-53.894737 0.377263V781.473684c0-9.162105 0.646737-18.135579 1.913263-26.947368H350.315789c-14.848 0-26.947368 12.072421-26.947368 26.947368 0 19.725474 36.675368 77.473684 92.133053 134.736842H431.157895v53.894737h-53.894737c-37.672421 0-53.894737 40.906105-53.894737 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-horse_wu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 26.947368h269.473685v-53.894736H538.947368v-161.684211h161.684211v-53.894737H411.001263c12.045474-33.28 20.156632-69.793684 20.156632-107.789473h-53.894737c0 121.963789-105.364211 233.391158-106.415158 234.496l38.858105 37.349052c2.883368-3.018105 43.816421-46.133895 77.392842-110.160842H485.052632v161.684211H215.578947v53.894736h269.473685v323.368421h53.894736V538.947368z" fill="#231F20" ></path></symbol><symbol id="icon-ox" viewBox="0 0 1025 1024"><path d="M540.294737 754.526316h215.578947c20.210526 0 35.112421 1.374316 53.894737 4.581052 91.863579 15.656421 145.354105 67.691789 161.684211 86.069895V916.210526h53.894736V635.580632l-7.895579-7.895579c-9.269895-9.269895-36.513684-49.232842-44.032-196.527158H540.294737a161.684211 161.684211 0 0 0-161.684211 161.68421v131.098948c43.304421 20.210526 97.28 30.585263 161.684211 30.585263z" fill="#FFAF6E" ></path><path d="M1025.347368 635.580632V916.210526h-53.894736v-71.033263c-16.330105-18.405053-69.820632-70.413474-161.684211-86.069895V916.210526h-53.894737v-161.68421h-107.789473v215.578947h-53.894737V700.631579h161.68421c100.998737 0 172.570947 38.669474 215.578948 71.868632v-115.738948c-33.684211-43.627789-51.712-137.458526-53.706106-279.498105H701.978947c-76.934737 0-127.218526-26.219789-175.804631-51.550316a1556.048842 1556.048842 0 0 0-26.839579-13.743158c-26.839579 26.004211-66.209684 44.921263-115.738948 55.511579 24.441263 22.986105 60.874105 52.116211 106.469053 72.838737l-22.312421 49.044211c-76.584421-34.816-129.589895-88.926316-150.824421-113.125053-10.644211 0.619789-21.477053 1.024-32.687158 1.024a473.734737 473.734737 0 0 1-123.365053-15.952842l-93.022315 186.314105 68.581052 53.86779C167.882105 579.557053 237.891368 538.947368 324.715789 538.947368v53.894737c-95.986526 0-170.361263 62.490947-171.088842 63.137684l-16.78821 14.282106-136.838737-107.358316 109.729684-219.809684C46.430316 314.448842 1.347368 267.371789 1.347368 199.868632 1.347368 89.815579 121.586526 53.894737 163.031579 53.894737v53.894737c-14.120421 0-107.789474 17.165474-107.789474 92.079158C55.242105 290.465684 192.188632 323.368421 284.240842 323.368421c67.907368 0 122.421895-12.988632 157.696-35.624421-42.711579-14.336-95.097263-23.120842-169.337263-18.324211l-3.503158-53.786947c95.878737-6.117053 160.148211 8.515368 211.429053 28.833684C484.244211 235.439158 486.4 225.818947 486.4 215.578947c0-48.855579-57.829053-76.288-58.394947-76.557473l22.393263-49.017263C454.063158 91.648 540.294737 131.826526 540.294737 215.578947c0 18.566737-3.422316 35.84-9.997474 51.631158 7.060211 3.584 13.985684 7.168 20.776421 10.698106C597.854316 302.322526 638.248421 323.368421 701.978947 323.368421h269.473685v26.947368c0 214.689684 35.220211 266.590316 45.999157 277.369264l7.895579 7.895579z m-729.384421 25.141894l-98.789052 118.541474 86.797473 137.835789 45.594948-28.725894-65.913263-104.690527 37.052631-44.43621C358.642526 785.192421 439.080421 808.421053 540.294737 808.421053v-53.894737c-99.893895 0-175.077053-24.549053-223.474526-72.946527l-20.857264-20.857263z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit_mao" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-377.263158-188.631579h107.789474v323.368421c-20.48 0-39.936-11.264-40.016842-11.317895l-27.728842 46.214737c3.206737 1.940211 32.660211 18.997895 67.745684 18.997895 30.746947 0 53.894737-23.147789 53.894737-53.894737V269.473684h-215.578948v538.947369h53.894737V323.368421z m-107.789473 242.526316v-242.526316h-53.894737v196.904421l-107.789474 40.421053v-243.927579l169.094737-48.316632-14.821053-51.819789L269.473684 276.102737v304.801684l-36.405895 13.662316 18.917053 50.472421 178.741895-67.018105c-5.039158 69.928421-55.269053 106.981053-165.133474 122.933894l7.733895 53.328842C325.712842 746.657684 485.052632 723.536842 485.052632 565.894737z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit" viewBox="0 0 1024 1024"><path d="M680.96 488.744421a1666.667789 1666.667789 0 0 0-54.433684-23.95621c-16.006737 12.234105-33.899789 20.264421-60.631579 20.264421h-80.842105c-36.810105 0-83.644632 30.396632-104.394106 67.772631-42.819368 77.123368-53.409684 117.813895-11.021473 201.701053C397.096421 808.879158 431.157895 876.409263 431.157895 970.105263h338.539789l68.338527-138.859789c20.129684-40.96 24.252632-73.701053 24.252631-110.349474 0.026947-57.397895-25.061053-159.717053-181.328842-232.151579z" fill="#FFBDD8" ></path><path d="M862.315789 720.896c0 36.621474-4.122947 69.389474-24.252631 110.349474L769.697684 970.105263H485.052632v-53.894737h48.370526C507.877053 880.074105 485.052632 833.509053 485.052632 781.473684c0-59.418947 24.171789-113.313684 63.218526-152.360421l38.103579 38.103579A161.091368 161.091368 0 0 0 538.947368 781.473684c0 54.784 35.381895 104.043789 63.514948 134.736842h133.712842l53.490526-108.759579c15.710316-31.851789 18.755368-55.834947 18.755369-86.554947 0-80.976842-63.434105-150.096842-178.607158-195.503158-17.542737 8.138105-38.292211 13.554526-63.919158 13.554526h-80.842105c-13.958737 0-43.924211 15.979789-57.290106 40.016843l-47.104-26.165895C401.408 515.449263 448.242526 485.052632 485.052632 485.052632h80.842105c37.268211 0 57.478737-15.440842 79.090526-36.45979C625.367579 336.195368 549.753263 269.473684 485.052632 269.473684h-107.789474a21.288421 21.288421 0 0 0-5.955369 2.021053A683.762526 683.762526 0 0 0 302.187789 194.021053c-35.84-34.223158-61.763368-58.933895-94.908631-79.440842A42.442105 42.442105 0 0 0 185.478737 107.789474a22.824421 22.824421 0 0 0-17.381053 7.194947c-10.913684 11.425684-6.063158 28.240842 1.428211 39.181474 21.989053 32.121263 47.912421 56.858947 83.752421 91.109052 20.614737 19.671579 49.259789 43.169684 77.392842 63.08379C281.007158 367.400421 215.578947 484.432842 215.578947 592.842105c0 74.482526 24.791579 124.065684 51.065264 176.586106C294.534737 825.209263 323.368421 882.903579 323.368421 970.105263h-53.894737c0-74.482526-24.791579-124.065684-51.065263-176.586105C190.517895 737.738105 161.684211 680.043789 161.684211 592.842105c0-90.866526 42.226526-197.685895 93.453473-274.485894a803.759158 803.759158 0 0 1-39.046737-34.115369C177.852632 247.754105 150.231579 221.399579 125.035789 184.616421c-24.441263-35.759158-22.797474-78.686316 4.069053-106.819368 26.300632-27.567158 70.898526-31.043368 106.522947-9.000421 37.941895 23.444211 65.562947 49.798737 103.774316 86.258526 9.970526 9.512421 33.037474 32.309895 56.93979 60.550737h68.634947c-27.621053-37.780211-60.416-72.730947-88.522105-99.543579-28.833684-27.540211-54.730105-52.116211-84.533895-74.024421L326.305684 0.296421c31.232 23.228632 57.802105 48.532211 87.309474 76.719158 53.840842 51.388632 94.450526 100.594526 121.74821 146.83621 82.836211 26.650947 150.042947 116.870737 165.025685 230.750316l1.724631 13.177263-9.404631 9.404632c-3.772632 3.772632-7.706947 7.653053-11.802948 11.587368C837.227789 561.178947 862.315789 663.498105 862.315789 720.896zM309.463579 754.526316c3.934316 8.057263 7.895579 16.087579 11.991579 24.144842C348.887579 832.970105 377.263158 889.128421 377.263158 970.105263h53.894737c0-93.696-34.061474-161.226105-61.520842-215.578947h-60.173474z m597.90821 53.894737c-3.422316 9.404632-7.814737 19.806316-13.770105 31.959579L829.790316 970.105263h60.065684l52.143158-105.957052c10.778947-21.935158 17.515789-40.016842 21.90821-55.727158h-56.535579zM514.694737 390.736842c0-34.223158-13.231158-44.463158-29.642105-44.463158s-29.642105 10.24-29.642106 44.463158c0 34.250105 13.231158 44.463158 29.642106 44.463158s29.642105-10.213053 29.642105-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rat_zi" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 188.631579v-215.578947h269.473685v-53.894737H538.947368v-39.585684c26.543158-18.081684 94.585263-65.050947 177.852632-127.488L700.631579 215.578947H323.368421v53.894737h295.316211a4221.008842 4221.008842 0 0 1-121.640421 85.369263l-11.991579 8.003369V431.157895H242.526316v53.894737h242.526316v215.578947c0 48.343579-13.850947 53.894737-134.736843 53.894737v53.894737c105.391158 0 188.631579 0 188.631579-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-rat" viewBox="0 0 1024 1024"><path d="M727.659789 431.157895c-132.581053 0-220.348632 47.454316-285.803789 154.354526-19.779368 32.309895-15.845053 76.503579-9.404632 96.579368 3.260632 10.159158 7.760842 18.647579 12.422737 25.546106C464.761263 737.010526 499.927579 754.526316 538.947368 754.526316h66.829474c1.158737 17.893053-1.967158 34.762105-15.144421 53.975579-12.692211 18.539789-37.807158 40.151579-56.32 54.810947 25.249684-0.673684 52.709053-0.997053 83.240421-0.997053C877.487158 862.315789 970.105263 711.922526 970.105263 571.176421 936.421053 512 882.364632 431.157895 727.659789 431.157895z" fill="#85C3DE" ></path><path d="M210.432 1012.897684l-43.573895-31.690105c106.954105-147.051789 185.317053-171.196632 423.828211-172.705684 21.396211-31.258947 16.249263-56.266105 9.377684-89.70779-3.557053-17.138526-7.221895-34.842947-7.221895-54.433684 0-68.958316 25.330526-104.636632 63.407158-136.973474l34.896842 41.040842c-29.453474 25.061053-44.409263 46.780632-44.409263 95.932632 0 14.093474 2.937263 28.402526 6.063158 43.546947 5.901474 28.510316 12.8 62.032842-1.131789 99.462737 166.373053-10.24 264.542316-96.902737 264.542315-236.193684C916.210526 418.330947 827.580632 323.368421 684.921263 323.368421c-83.644632 0-153.303579 29.696-174.187789 39.612632a224.875789 224.875789 0 0 1-20.533895 31.339789l-41.741474-34.115368 20.884211 17.057684-20.911158-16.976842C448.781474 359.828211 485.052632 314.287158 485.052632 262.736842c0-34.816-8.946526-60.766316-26.570106-77.069474-17.515789-16.249263-44.786526-24.602947-81.219368-24.953263V323.368421h-53.894737V109.783579l24.872421-1.913263c64.700632-4.931368 114.095158 7.895579 146.863158 38.238316C524.207158 173.056 538.947368 212.291368 538.947368 262.736842c0 11.102316-1.131789 21.908211-3.072 32.202105 37.268211-12.584421 89.842526-25.465263 149.045895-25.465263C858.165895 269.473684 970.105263 387.907368 970.105263 571.176421 970.105263 711.922526 877.487158 862.315789 617.552842 862.315789c-258.667789 0-311.942737 19.698526-407.120842 150.581895z m19.105684-256.835368c-12.045474 0-24.387368-0.565895-37.025684-1.64379l-22.096842-1.859368-2.425263-22.016C167.747368 728.144842 161.684211 672.444632 161.684211 631.026526c0-103.585684 21.450105-178.903579 53.894736-259.045052V107.789474h53.894737v274.782315l-2.021052 4.904422C235.439158 465.758316 215.578947 533.800421 215.578947 631.026526c0 22.878316 2.101895 51.442526 3.826527 70.979369 99.678316 2.802526 172.813474-35.408842 222.450526-116.493474l48.020211 24.090947c-11.237053 28.133053-11.371789 51.577263-0.377264 67.853474 9.701053 14.282105 28.645053 23.174737 49.448421 23.174737v53.894737c-39.019789 0-74.186105-17.515789-94.073263-46.888421a100.244211 100.244211 0 0 1-12.422737-25.546106c-53.221053 49.178947-121.128421 73.943579-202.913684 73.970527zM379.957895 525.473684c0-34.223158-13.231158-44.463158-29.642106-44.463158s-29.642105 10.24-29.642105 44.463158c0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642106-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rooster_you" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-215.578947-188.631579h-161.684211v-26.947368h161.684211V242.526316H269.473684v53.894737h161.684211v26.947368h-161.684211v485.052632h53.894737v-53.894737h377.263158v53.894737h53.894737V323.368421zM323.368421 646.736842h377.263158v53.894737H323.368421v-53.894737z m0-269.473684h107.789474c0 103.316211-72.784842 107.654737-81.084632 107.789474L350.315789 538.947368c46.592 0 134.736842-33.792 134.736843-161.68421h53.894736v107.789474c0 29.722947 24.171789 53.894737 53.894737 53.894736h107.789474v53.894737H323.368421v-215.578947z m377.263158 0v107.789474h-107.789474v-107.789474h107.789474z m-215.578947-80.842105h53.894736v26.947368h-53.894736v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-rooster" viewBox="0 0 1024 1024"><path d="M891.688421 506.421895C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V116.224l-323.368421 195.745684V323.368421c0 78.524632 14.928842 131.664842 29.372632 183.053474 12.611368 44.894316 24.522105 87.282526 24.522105 140.314947 0 101.618526-77.931789 176.693895-168.286316 203.991579l5.416422 11.587368h215.578947c24.333474 0 43.385263-0.242526 58.556631-2.128842C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947z" fill="#FF8787" ></path><path d="M673.684211 354.357895c-16.384 0-29.642105-10.213053-29.642106-44.463158 0-34.223158 13.231158-44.463158 29.642106-44.463158s29.642105 10.24 29.642105 44.463158c0 34.250105-13.258105 44.463158-29.642105 44.463158zM540.106105 970.105263l-50.58021-107.789474h156.05221l50.607158 107.789474h59.553684l-51.60421-109.918316C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V107.789474c0-59.445895-48.343579-107.789474-107.789473-107.789474a107.924211 107.924211 0 0 0-107.789474 106.172632 100.890947 100.890947 0 0 0-24.117895-3.314527 88.710737 88.710737 0 0 0-88.602947 88.602948c0 20.668632 5.227789 39.720421 10.671158 53.921684l-99.489684 59.688421 93.749894 14.470737V377.263158c0 14.416842-5.901474 21.692632-33.360842 49.152l-11.129263 11.129263C398.228211 326.521263 324.985263 269.473684 215.740632 269.473684 96.768 269.473684 0 366.241684 0 485.214316V646.736842h53.894737v-161.522526A162.007579 162.007579 0 0 1 215.740632 323.368421c82.081684 0 140.422737 36.244211 240.64 152.252632l-38.615579 38.615579C367.804632 461.285053 323.098947 431.157895 259.584 431.157895A151.983158 151.983158 0 0 0 107.789474 582.952421V754.526316h53.894737v-171.573895A98.007579 98.007579 0 0 1 259.584 485.052632c46.322526 0 79.629474 20.911158 137.027368 86.016l18.970948 21.530947 128.080842-128.080842C572.200421 435.981474 592.842105 415.366737 592.842105 377.263158v-97.926737l23.309474-14.120421-13.662316-23.04c-0.161684-0.242526-14.578526-24.899368-14.578526-50.688 0-19.132632 15.575579-34.708211 34.70821-34.708211 5.093053 0 26.785684 3.179789 39.558737 18.647579l26.327579 46.026106 39.774316-24.090948-20.372211-49.367579C704.754526 140.449684 700.631579 117.517474 700.631579 107.789474c0-29.722947 24.171789-53.894737 53.894737-53.894737s53.894737 24.171789 53.894737 53.894737v215.578947c0 85.935158 16.680421 145.300211 31.366736 197.632C851.887158 564.008421 862.315789 601.141895 862.315789 646.736842c0 95.285895-99.408842 161.684211-188.631578 161.684211h-209.461895l-68.419369-145.704421C375.242105 618.954105 338.108632 592.842105 296.448 592.842105A80.976842 80.976842 0 0 0 215.578947 673.711158V862.315789h53.894737v-188.604631c0-14.874947 12.099368-26.974316 26.974316-26.974316 20.533895 0 38.965895 14.147368 50.553263 38.858105L480.579368 970.105263h59.526737z" fill="#231F20" ></path></symbol><symbol id="icon-snake_si" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-242.041263 180.762947l-52.116211-13.797052C657.219368 749.864421 651.425684 754.526316 619.789474 754.526316h-242.526316V485.052632h269.473684v53.894736h53.894737V215.578947H323.368421v538.947369c0 29.722947 24.171789 53.894737 53.894737 53.894737h242.526316c77.689263 0 91.189895-51.065263 108.274526-115.658106zM377.263158 269.473684h269.473684v161.684211H377.263158v-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-tiger_yin" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-257.42821 299.250526l-107.789474-53.894737-24.117895 48.208843 107.789474 53.894736 24.117895-48.208842z m-269.473685-5.658947l-24.117894-48.208842-107.789474 53.894737 24.117895 48.208842 107.789473-53.894737zM700.631579 431.157895h-161.684211v-53.894737h107.789474v-53.894737H377.263158v53.894737h107.789474v53.894737h-161.684211v323.368421h53.894737v-53.894737h269.473684v53.894737h53.894737V431.157895z m-161.684211 161.68421h107.789474v53.894737h-107.789474v-53.894737z m-161.68421 0h107.789474v53.894737h-107.789474v-53.894737z m161.68421-107.789473h107.789474v53.894736h-107.789474v-53.894736z m-161.68421 0h107.789474v53.894736h-107.789474v-53.894736zM754.526316 215.578947h-223.097263l-20.803369-62.410105-51.119158 17.057684L474.624 215.578947H269.473684v107.789474h53.894737v-53.894737h377.263158v53.894737h53.894737V215.578947z" fill="#231F20" ></path></symbol><symbol id="icon-snake" viewBox="0 0 1024 1024"><path d="M107.789474 790.474105c0-72.434526 67.880421-91.513263 121.451789-91.513263 74.401684 0 153.815579 34.438737 237.891369 70.925474 50.580211 21.935158 104.609684 45.325474 162.250105 63.083789-52.412632 44.786526-118.784 74.347789-195.152842 83.078737-143.171368 16.357053-326.440421 7.006316-326.440421-125.574737zM377.263158 215.578947c-15.575579 0-30.288842 3.449263-43.654737 9.377685A250.691368 250.691368 0 0 0 323.368421 296.421053c0 115.550316 76.422737 169.391158 137.83579 212.614736 8.138105 5.712842 16.141474 11.371789 23.848421 17.057685V323.368421a107.789474 107.789474 0 0 0-107.789474-107.789474z" fill="#C3D686" ></path><path d="M671.528421 788.857263c44.328421 11.964632 89.626947 19.563789 136.892632 19.56379 89.168842 0 161.684211-60.442947 161.68421-134.736842s-72.515368-134.736842-161.68421-134.736843c-19.078737 0-37.025684 1.509053-54.218106 4.015158-0.754526-101.402947-38.211368-172.355368-79.413894-219.648L673.684211 323.368421a1749.962105 1749.962105 0 0 1-79.036632-1.751579c45.702737 35.866947 108.705684 107.870316 105.984 232.367158 0 0.431158-0.080842 0.808421-0.10779 1.239579-34.923789 10.994526-66.155789 26.731789-95.097263 45.190737a163.085474 163.085474 0 0 0-15.845052-42.388211c-21.557895-39.639579-60.065684-66.775579-97.360842-93.022316C433.098105 423.343158 377.263158 384 377.263158 296.421053c0-130.290526 108.274526-188.631579 215.578947-188.631579 64.134737 0 132.715789 12.045474 214.366316 37.807158C802.330947 180.250947 780.099368 209.381053 700.631579 214.635789V161.684211h-53.894737v53.679157c-63.272421-1.024-104.528842-5.200842-104.986947-5.254736l-5.578106 53.598315C538.408421 263.949474 592.357053 269.473684 673.684211 269.473684c125.170526 0 188.631579-48.128 188.631578-143.063579V106.981053l-18.432-6.144C747.789474 68.823579 668.025263 53.894737 592.842105 53.894737c-158.666105 0-269.473684 99.732211-269.473684 242.526316 0 115.550316 76.422737 169.391158 137.83579 212.614736 33.684211 23.713684 65.509053 46.106947 81.003789 74.698106 9.539368 17.542737 13.285053 33.414737 12.341895 47.750737 21.153684 9.108211 42.118737 17.839158 62.949052 25.977263C671.151158 620.193684 729.977263 592.842105 808.421053 592.842105c59.445895 0 107.789474 36.271158 107.789473 80.842106s-48.343579 80.842105-107.789473 80.842105c-105.472 0-203.237053-42.388211-297.768421-83.429053-94.800842-41.094737-184.346947-79.952842-281.411369-79.952842C122.718316 591.171368 53.894737 644.715789 53.894737 727.578947c0 79.063579 67.098947 136.434526 159.555368 136.434527 142.174316 0 230.426947-66.883368 306.79579-129.886316 31.420632 13.419789 62.787368 26.058105 94.450526 37.133474-47.077053 49.637053-110.969263 82.566737-186.610526 91.270736l5.066105 53.625264c93.453474-7.006316 143.144421 9.350737 195.718737 26.543157 46.457263 15.225263 94.127158 30.854737 169.822316 30.854737 19.994947 0 41.957053-1.077895 66.344421-3.557052l-5.416421-53.625263c-105.283368 10.778947-158.100211-6.548211-213.935158-24.872422-22.150737-7.275789-44.624842-14.632421-70.305684-20.345263a334.848 334.848 0 0 0 96.14821-82.297263z m-458.078316 21.261474C162.573474 810.118737 107.789474 784.276211 107.789474 727.578947c0-60.847158 62.733474-82.539789 121.451789-82.539789 77.850947 0 154.731789 30.288842 235.250526 64.943158-66.263579 52.924632-139.722105 100.136421-251.041684 100.136421z" fill="#231F20" ></path></symbol><symbol id="icon-tiger" viewBox="0 0 1024 1024"><path d="M431.157895 162.250105V134.736842c0-41.552842-39.289263-80.842105-80.842106-80.842105-28.833684 0-57.128421 4.661895-58.314105 4.850526L269.473684 62.490947v83.887158C144.788211 223.824842 89.222737 346.839579 66.991158 431.157895h266.051368c240.747789 0 415.851789 107.789474 415.85179 269.473684-14.848-25.114947-43.924211-53.894737-88.68379-53.894737-67.988211 0-121.263158 71.033263-121.263158 161.684211 0 66.802526 30.477474 119.888842 60.712421 156.16 12.638316 15.171368 36.055579 37.726316 59.014737 58.88 5.066105 0.107789 9.781895 0.538947 15.009685 0.538947 219.297684 0 350.315789-191.811368 350.315789-377.263158C1024 327.545263 679.855158 172.813474 431.157895 162.250105z" fill="#F7C768" ></path><path d="M673.684211 1024c-114.768842 0-188.820211-33.333895-254.167579-62.787368-53.625263-24.144842-99.974737-45.002105-161.28-45.002106-40.448 0-83.590737 23.255579-103.639579 45.16379l-39.747369-36.432842C142.497684 894.787368 199.168 862.315789 258.236632 862.315789c68.392421 0 119.861895 21.288421 172.921263 45.056V673.684211c0-35.166316-17.542737-64.107789-30.639158-80.815158-15.198316 9.835789-32.067368 18.890105-50.741895 26.947368l-21.342316-49.475368C469.800421 509.413053 485.052632 377.317053 485.052632 323.368421V221.642105A597.827368 597.827368 0 0 0 404.210526 215.578947h-26.947368V134.736842c0-12.099368-14.848-26.947368-26.947369-26.947368-9.377684 0-18.836211 0.592842-26.947368 1.347368V269.473684h-53.894737V211.671579c-136.030316 102.912-158.450526 266.886737-161.306947 295.882105 9.135158 9.108211 38.992842 25.061053 71.976421 38.669474l38.103579-59.365053 12.449684-1.589894C321.212632 473.653895 377.263158 392.192 377.263158 323.368421h53.894737c0 88.333474-68.796632 192.242526-180.870737 213.342316l-48.397474 75.398737-20.291368-7.437474C53.894737 557.756632 53.894737 523.317895 53.894737 512c0-50.041263 37.025684-254.733474 215.578947-365.621895V62.490947l22.528-3.745684C293.187368 58.556632 321.482105 53.894737 350.315789 53.894737c41.552842 0 80.842105 39.289263 80.842106 80.842105v27.513263c248.697263 10.563368 592.842105 165.295158 592.842105 484.486737 0 185.451789-131.018105 377.263158-350.315789 377.263158z m-13.473685-323.368421c-36.513684 0-67.368421 49.367579-67.368421 107.789474 0 85.746526 68.096 145.084632 89.465263 161.549473 91.540211-2.533053 164.378947-45.487158 213.827369-107.654737H700.631579v-53.894736h230.238316c8.919579-17.273263 16.357053-35.354947 22.285473-53.894737h-239.885473l-6.467369-17.650527C706.290526 735.582316 692.439579 700.631579 660.210526 700.631579zM485.052632 931.112421c33.926737 14.066526 70.521263 26.597053 114.607157 33.468632C569.424842 928.309895 538.947368 875.223579 538.947368 808.421053c0-90.650947 53.274947-161.684211 121.263158-161.684211 44.759579 0 73.835789 28.779789 88.68379 53.894737h217.007158c2.775579-17.866105 4.203789-35.920842 4.203789-53.894737 0-38.938947-5.658947-74.752-15.925895-107.627789l-126.706526 126.679579-38.103579-38.103579L932.001684 485.052632a367.939368 367.939368 0 0 0-57.775158-81.596632l-154.543158 154.543158-38.103579-38.103579 153.573053-153.573053a537.869474 537.869474 0 0 0-82.593684-56.751158l-140.665263 140.638316-38.103579-38.103579 128.134737-128.134737A794.731789 794.731789 0 0 0 538.947368 231.046737V323.368421c0 50.149053-11.102316 156.698947-95.932631 236.328421 18.378105 23.417263 42.037895 63.407158 42.037895 113.987369v257.42821zM215.578947 431.157895v-53.894737c39.774316 0 53.894737-29.022316 53.894737-53.894737h53.894737c0 53.571368-37.025684 107.789474-107.789474 107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-boar" viewBox="0 0 1024 1024"><path d="M732.079158 377.263158c-107.789474 0-186.421895 31.393684-281.869474 126.841263L180.331789 773.982316C257.724632 807.909053 348.725895 808.421053 485.052632 808.421053h96.013473c55.834947-34.411789 133.551158-53.894737 227.354948-53.894737h121.344L970.105263 680.555789V572.631579c0-94.315789-130.236632-195.368421-238.026105-195.368421z" fill="#FFBDD8" ></path><path d="M808.421053 700.631579v53.894737c-196.446316 0-323.368421 84.641684-323.368421 215.578947h-53.894737c0-163.705263 148.075789-269.473684 377.263158-269.473684z m-323.368421 107.789474v-53.894737c-158.342737 0-245.598316 0-319.649685-49.367579L158.612211 700.631579H80.842105c-21.692632 0-26.624-14.821053-26.947368-26.947368v-82.620632c84.156632-11.183158 161.684211-74.913684 161.68421-186.853053V215.578947H161.684211v161.684211H134.736842c-66.964211 0-134.736842 37.025684-134.736842 107.789474h53.894737c0-42.630737 52.870737-53.894737 80.842105-53.894737h24.629895C147.132632 504.912842 85.153684 538.947368 26.947368 538.947368H0v134.736843c0 32.498526 21.530947 80.842105 80.842105 80.842105h61.682527c32.687158 20.506947 67.125895 33.145263 105.957052 41.013895A232.879158 232.879158 0 0 0 215.578947 916.210526h53.894737c0-41.930105 14.012632-80.303158 39.424-112.505263C358.885053 808.151579 415.959579 808.421053 485.052632 808.421053z m-72.946527-342.420211L323.368421 554.738526V431.157895h-53.894737v253.682526l180.736-180.736-38.103579-38.103579zM323.368421 161.684211h-53.894737v190.032842a769.536 769.536 0 0 1 53.894737-49.098106V161.684211z m323.368421-53.894737c-72.623158 0-146.809263 23.336421-215.578947 58.637473V107.789474h-53.894737v154.138947C458.832842 205.392842 555.331368 161.684211 646.736842 161.684211c148.587789 0 269.473684 120.885895 269.473684 269.473684v235.654737L809.579789 862.315789h61.359158L970.105263 680.555789V431.157895c0-178.310737-145.057684-323.368421-323.368421-323.368421z" fill="#231F20" ></path></symbol><symbol id="icon-boar_hai" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M309.975579 804.756211l-27.136-46.592c103.073684-60.011789 183.026526-132.473263 241.475368-219.24379H350.315789l-13.473684-50.283789c58.88-33.980632 99.435789-117.571368 118.703158-165.295158H242.526316v-53.894737h538.947368v53.894737h-268.18021c-12.395789 34.088421-42.469053 106.603789-90.435369 161.68421h134.009263a680.555789 680.555789 0 0 0 46.349474-107.708631l51.092211 17.057684c-58.421895 175.265684-171.034947 309.490526-344.333474 410.381474z m192.350316-2.937264L467.806316 760.454737c88.414316-73.728 154.516211-158.773895 202.105263-259.907369l48.801684 22.959158a797.372632 797.372632 0 0 1-82.351158 137.781895c32.741053 15.009684 83.456 44.867368 137.647158 101.591579l-38.938947 37.268211c-57.236211-59.877053-109.325474-85.557895-133.766737-95.178106a850.997895 850.997895 0 0 1-98.977684 96.848842z m48.613052-536.872421l-80.842105-53.894737 29.884632-44.840421 80.842105 53.894737-29.884632 44.840421zM512 53.894737C259.395368 53.894737 53.894737 259.395368 53.894737 512s205.500632 458.105263 458.105263 458.105263c9.081263 0 17.973895-0.835368 26.947368-1.374316v-53.894736c-8.946526 0.619789-17.866105 1.374316-26.947368 1.374315-222.881684 0-404.210526-181.328842-404.210526-404.210526S289.118316 107.789474 512 107.789474s404.210526 181.328842 404.210526 404.210526c0 195.206737-139.075368 358.507789-323.368421 396.045474v54.460631c214.096842-38.346105 377.263158-225.549474 377.263158-450.533052C970.105263 259.395368 764.604632 53.894737 512 53.894737z" fill="#231F20" ></path></symbol></svg>',(h=>{var c=(l=(l=document.getElementsByTagName("script"))[l.length-1]).getAttribute("data-injectcss"),l=l.getAttribute("data-disable-injectsvg");if(!l){var a,t,i,v,o,m=function(c,l){l.parentNode.insertBefore(c,l)};if(c&&!h.__iconfont__svg__cssinject__){h.__iconfont__svg__cssinject__=!0;try{document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>")}catch(c){console&&console.log(c)}}a=function(){var c,l=document.createElement("div");l.innerHTML=h._iconfont_svg_string_5021196,(l=l.getElementsByTagName("svg")[0])&&(l.setAttribute("aria-hidden","true"),l.style.position="absolute",l.style.width=0,l.style.height=0,l.style.overflow="hidden",l=l,(c=document.body).firstChild?m(l,c.firstChild):c.appendChild(l))},document.addEventListener?~["complete","loaded","interactive"].indexOf(document.readyState)?setTimeout(a,0):(t=function(){document.removeEventListener("DOMContentLoaded",t,!1),a()},document.addEventListener("DOMContentLoaded",t,!1)):document.attachEvent&&(i=a,v=h.document,o=!1,s(),v.onreadystatechange=function(){"complete"==v.readyState&&(v.onreadystatechange=null,p())})}function p(){o||(o=!0,i())}function s(){try{v.documentElement.doScroll("left")}catch(c){return void setTimeout(s,50)}p()}})(window);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='.5'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener("visibilitychange", function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = "w(ﾟДﾟ)w 再不来我都要睡着了 ";    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = "♪(^∇^*)等你半天了 " + OriginTitile;    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/10/data.json"/>
      <url>/bilibiliBanner/images/10/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1670,"height":157,"src":"/bilibiliBanner/images/10/5598c26a3d090ba7cdf1d99de1e7d76561d56e78.png@1c.webp","a":0,"g":0,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1670,"height":157,"src":"/bilibiliBanner/images/10/556c868c5b003f3f167cf1e63e6e3aa27b74bdc7.png@1c.webp","a":0.00158182,"g":0,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":5,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/10/b1b6ebe5d3def015132105fe7a8253eced9b563c.png@1c.webp","a":0.0121212,"g":0.006060600000000001,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1670,"height":157,"src":"/bilibiliBanner/images/10/59a63bc51e049fd01d7e567b9759727888d0de43.png@1c.webp","a":0.00263636,"g":0,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-234.9,"translateY":-17.4,"rotate":0,"scale":1},"width":1670,"height":157,"src":"/bilibiliBanner/images/10/2e5a5407987125451f4401e1f80da8aa6c9ec74e.png@1c.webp","a":0.010545000000000016,"g":0,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-47.5,"translateY":0,"rotate":0,"scale":1},"width":1824,"height":171,"src":"/bilibiliBanner/images/10/96151dfbace0750a4a590e9fac92211ce7c28b82.png@1c.webp","a":0.008636400000000002,"g":-0.00287879,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-250,"translateY":-20,"rotate":0,"scale":1},"width":75,"height":60,"src":"/bilibiliBanner/images/10/f272c9c3125afec158fe4c4e0540a271cd75dfb4.png@1c.webp","a":0.018181999999999986,"g":0,"r":0.006060609999999999,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/10/598389b103a4c89592706b9a426c1dd5c9fbdb96.png@1c.webp","a":0.018181799999999998,"g":0.0030303,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1670,"height":157,"src":"/bilibiliBanner/images/10/3dd93e33d7e9bb6b74b7e2c577cb4a61cd7876bf.png@1c.webp","a":0.0263636,"g":0.00527273,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1824,"height":171,"src":"/bilibiliBanner/images/10/2ec5703e20135d578a4d31a9d40dd9deb23c326e.png@1c.webp","a":0.0115152,"g":0.00287879,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/10/48d675bee7f2b20af495ddcfa2051d1e42eeb526.png@1c.webp","a":0.0242424,"g":0.006060609999999999,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2112,"height":198,"src":"/bilibiliBanner/images/10/e35035fb17abb07d80c1749988bc938c9a5919dc.png@1c.webp","a":0.0466667,"g":0.01,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2112,"height":198,"src":"/bilibiliBanner/images/10/5cbcbeb21c079264f78e63c411f09334126a11d3.png@1c.webp","a":0.0533333,"g":0.01,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2112,"height":198,"src":"/bilibiliBanner/images/10/c9ef0b13e5ec27cc6e9fa1516e79a8ab8f5c5b38.png@1c.webp","a":0.06,"g":0.01,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1670,"height":157,"src":"/bilibiliBanner/images/10/5a97b3d3f84e4ce0e77988a8a0d5744a2a2fd8b9.png@1c.webp","a":0,"g":0,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/10/679c3bb077504de3379100c688770d94d97778cf.png@1c.webp","a":0.0424242,"g":0.0048484800000000005,"r":0,"f":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/10/add3317b33f371b4ce4391b5169dbd6455065ed4.png@1c.webp","a":0.036363599999999996,"g":0.006060609999999999,"r":0,"f":0},{"tagName":"video","opacity":["0.5","0.5"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/10/b7b1a495-92d2-4b8f-b41b-1162af6f00e4","a":0.036363599999999996,"g":0,"r":0,"f":0}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/2/data.json"/>
      <url>/bilibiliBanner/images/2/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2100,"height":197,"src":"/bilibiliBanner/images/2/0876da4f3ec73ff180fc87b46b6d1bcf4d52030a.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1711,"height":197,"src":"/bilibiliBanner/images/2/4adc24834b64143296d77bc81ccd952a59301b08.png@1c.webp","a":0.0101597},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":21,"translateY":0,"rotate":0,"scale":1},"width":2100,"height":197,"src":"/bilibiliBanner/images/2/e33992d2d75647af38c50792c199fb9db006786c.png@1c.webp","a":0.025399099999999997},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-30,"translateY":0,"rotate":0,"scale":1},"width":1649,"height":169,"src":"/bilibiliBanner/images/2/57102cf6e2e2845f2773581928c1d0f0c1985a3e.png@1c.webp","a":0.043541399999999994},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":360,"translateY":0,"rotate":0,"scale":1},"width":90,"height":81,"src":"/bilibiliBanner/images/2/0f79aa287163a3271c6cb22a73a6dc0fc210ab7c.png@1c.webp","a":0.043540999999999996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-240,"translateY":-36,"rotate":0,"scale":1},"width":84,"height":29,"src":"/bilibiliBanner/images/2/639de634f90688e86b7bd32924cfb029a316cde4.png@1c.webp","a":0.43541399999999997},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":140,"translateY":0,"rotate":0,"scale":1},"width":544,"height":197,"src":"/bilibiliBanner/images/2/852c3bd9d9608ceccb7265de8cea7cf3a4b039eb.png@1c.webp","a":-0.1523948},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":227,"height":197,"src":"/bilibiliBanner/images/2/9556f65510f73c44aa6756ee9b8cf7fc2562b906.png@1c.webp","a":0.253991},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-90,"translateY":12,"rotate":0,"scale":1},"width":97,"height":108,"src":"/bilibiliBanner/images/2/530a4624fe408881101885c6f24c72e8c2a14fb6.png@1c.webp","a":0.08708273},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-350,"translateY":56,"rotate":0,"scale":1},"width":1713,"height":74,"src":"/bilibiliBanner/images/2/bf896616dec163402ec79a81f936af67932eca2f.png@1c.webp","a":0.126996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-165,"translateY":0,"rotate":0,"scale":1},"width":180,"height":147,"src":"/bilibiliBanner/images/2/32aa867cd3e8fba371a2be90d7d844a68c67f7a5.png@1c.webp","a":0.11973879999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-360,"translateY":12,"rotate":0,"scale":1},"width":207,"height":161,"src":"/bilibiliBanner/images/2/c6263485a0218c887848c47a0fe4f515006e1567.png@1c.webp","a":0.152395},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-132,"translateY":54,"rotate":0,"scale":1},"width":1650,"height":63,"src":"/bilibiliBanner/images/2/cd4fda9478b06a8d81cd04f69d7a2ad475d1db40.png@1c.webp","a":0.1741655},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":180,"translateY":12,"rotate":0,"scale":1},"width":257,"height":161,"src":"/bilibiliBanner/images/2/0479542df6a7c5deddf60fbbf63b6e1f1f770c08.png@1c.webp","a":0.21770699999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-85,"translateY":-4.25,"rotate":0,"scale":1},"width":2550,"height":239,"src":"/bilibiliBanner/images/2/b6f4359409b4550fb38594d8c227902db29c720a.png@1c.webp","a":0.370102},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-1440,"translateY":0,"rotate":0,"scale":1},"width":501,"height":225,"src":"/bilibiliBanner/images/2/8a6899088fc9dcd37a0039884fb77f69dc3b1c30.png@1c.webp","a":0.5805520000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":1500,"translateY":0,"rotate":0,"scale":1},"width":409,"height":169,"src":"/bilibiliBanner/images/2/96704a6197153e1717a910e6c227937f34743cee.png@1c.webp","a":0.6531199999999999}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/3/data.json"/>
      <url>/bilibiliBanner/images/3/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/3/b51d0d75b1b27b669e456aa36bdf3b46f658a531.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":-20,"rotate":0,"scale":1},"width":464,"height":48,"src":"/bilibiliBanner/images/3/8f976964bf99b64dcf844b698642caa01449623b.png@1c.webp","a":0.121212},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1410,"height":49,"src":"/bilibiliBanner/images/3/a1d3587a7230b68e78b724558697ae6a1739e1cc.png@1c.webp","a":0.000969697},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":-5,"rotate":0,"scale":1},"width":1920,"height":80,"src":"/bilibiliBanner/images/3/454a3f4bd1f8bd23d89d8e3a676a826e144ab13a.png@1c.webp","a":0.006060609999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":360,"translateY":-36,"rotate":0,"scale":1},"width":56,"height":34,"src":"/bilibiliBanner/images/3/a89c6c61109d1f58b83bc76fa3cf939df82d2ff4.png@1c.webp","a":0.72727},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":30,"rotate":0,"scale":1},"width":1611,"height":118,"src":"/bilibiliBanner/images/3/1c4b40f96bac2479f7a67541171170f79429158c.png@1c.webp","a":0.0242424},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-55,"translateY":22,"rotate":0,"scale":1},"width":2039,"height":149,"src":"/bilibiliBanner/images/3/a9a0eb9ce2e611290e86961a61c3b0942de3515b.png@1c.webp","a":0.04666666999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-300,"translateY":5,"rotate":0,"scale":1},"width":95,"height":152,"src":"/bilibiliBanner/images/3/2422523efbc7d3486555c66a9a8f20c3e3f6fdb5.png@1c.webp","a":0.05454499999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-165,"translateY":0,"rotate":0,"scale":1},"width":184,"height":180,"src":"/bilibiliBanner/images/3/16dc88de1e536a9b11dbe4acec40d44acbf30e4d.png@1c.webp","a":0.12121209999999999,"deg":0.00015707963267948965},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-200,"translateY":20,"rotate":0,"scale":1},"width":140,"height":123,"src":"/bilibiliBanner/images/3/85d3ee641e1af27233ce0571bfdc650bb6bac668.png@1c.webp","a":0.1212121},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":200,"translateY":20,"rotate":0,"scale":1},"width":200,"height":131,"src":"/bilibiliBanner/images/3/d86630ee943035f95c0e318bc386764196ab08b6.png@1c.webp","a":0.09090899999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":660,"translateY":0,"rotate":0,"scale":1},"width":798,"height":188,"src":"/bilibiliBanner/images/3/e3a1d1ea8c4360518fa9bbef665795056ca1d50f.png@1c.webp","a":0.14545500000000003},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":521.3,"translateY":-45.5,"rotate":0,"scale":1},"width":46,"height":43,"src":"/bilibiliBanner/images/3/459b9e641fc8be0466084ec0fff89e28ca2229ea.png@1c.webp","a":0.14890899999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":750,"translateY":45,"rotate":0,"scale":1},"width":132,"height":98,"src":"/bilibiliBanner/images/3/392e080a19e6618774a15c235ab0873180e4010d.png@1c.webp","a":0.21818200000000001,"g":0.14},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-600,"translateY":0,"rotate":0,"scale":1},"width":414,"height":216,"src":"/bilibiliBanner/images/3/d9ff91200e453584beb49626c2ddbd78e4dd60ed.png@1c.webp","a":0.10909100000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-500,"translateY":50,"rotate":0,"scale":1},"width":347,"height":80,"src":"/bilibiliBanner/images/3/d29049442060427102881e002285ae50686052e2.png@1c.webp","a":0.12121199999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-1170,"translateY":13,"rotate":0,"scale":1},"width":542,"height":143,"src":"/bilibiliBanner/images/3/a2f14a60908565b6a4b85caee82bd0457127f9f3.png@1c.webp","a":0.31515200000000004},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-660,"translateY":60,"rotate":0,"scale":1},"width":656,"height":116,"src":"/bilibiliBanner/images/3/f3bbed911be68b540c12fb7cbe602ae71ec9a8c7.png@1c.webp","a":0.254545},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":990,"translateY":33,"rotate":0,"scale":1},"width":602,"height":107,"src":"/bilibiliBanner/images/3/f3bbed911be68b540c12fb7cbe602ae71ec9a8c7.png@1c.webp","a":0.2666700000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":600,"translateY":35,"rotate":0,"scale":1},"width":417,"height":110,"src":"/bilibiliBanner/images/3/a2f14a60908565b6a4b85caee82bd0457127f9f3.png@1c.webp","a":0.24242399999999997}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/4/data.json"/>
      <url>/bilibiliBanner/images/4/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2304,"height":216,"src":"/bilibiliBanner/images/4/cb5b4ca963e3a1a6d3917182561844b24a05fc20.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1283,"height":211,"src":"/bilibiliBanner/images/4/bad95b1085650b58108b3491c9c13e1ef4e6b41f.png@1c.webp","a":0.00145455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1687,"height":173,"src":"/bilibiliBanner/images/4/b28b35a71a658e8bc449cd570337d7d9662d07d7.png@1c.webp","a":0.00727273},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":10,"rotate":0,"scale":1},"width":1920,"height":160,"src":"/bilibiliBanner/images/4/596c782fe6636269c65a50a9188fd4d16d12a83e.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":55,"rotate":0,"scale":1},"width":1920,"height":83,"src":"/bilibiliBanner/images/4/4cbfd5b2c00e1abb157e9ca3e79380bfa40d2b26.png@1c.webp","a":0.060606099999999996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":40,"rotate":0,"scale":1},"width":1920,"height":111,"src":"/bilibiliBanner/images/4/6b8bf544dec0088423136771f01696c68112a145.png@1c.webp","a":0.0121212},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-250,"translateY":-10,"rotate":0,"scale":1},"width":713,"height":106,"src":"/bilibiliBanner/images/4/cd6dadba219330bf44d3f8bcb584aede77d37f79.png@1c.webp","a":0.03636400000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":300,"translateY":25,"rotate":0,"scale":1},"width":53,"height":47,"src":"/bilibiliBanner/images/4/31ff321fe1c2b003ab5c42beebb07f6c1652f66e.png@1c.webp","a":-0.04545500000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":130,"translateY":20,"rotate":0,"scale":1},"width":260,"height":80,"src":"/bilibiliBanner/images/4/cfb54458ad3e2101d245f3434222e33453825f4e.png@1c.webp","a":0.042424},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-320,"translateY":20,"rotate":0,"scale":1},"width":70,"height":61,"src":"/bilibiliBanner/images/4/5103762686dc9627619b028354c15ba2a72b0886.png@1c.webp","a":0.06060599999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-180,"translateY":18,"rotate":0,"scale":1},"width":83,"height":94,"src":"/bilibiliBanner/images/4/09fa68c0c716596cebf6b1f81ed69a2a7a0a8c89.png@1c.webp","a":0.065455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":75,"translateY":19,"rotate":0,"scale":1},"width":341,"height":127,"src":"/bilibiliBanner/images/4/c2914ea86a54203e59b9b9fb1b8ab3461a5976ed.png@1c.webp","a":0.09090899999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-720,"translateY":48,"rotate":0,"scale":1},"width":833,"height":118,"src":"/bilibiliBanner/images/4/0cea6143cb8fce3ac55c0e1888a889c906a976aa.png@1c.webp","a":0.14545500000000003},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-600,"translateY":-5,"rotate":0,"scale":1},"width":340,"height":174,"src":"/bilibiliBanner/images/4/c7cb3d67462676f79b3e702db60f4d4b038f3f28.png@1c.webp","a":0.24242399999999997},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-850,"translateY":0,"rotate":0,"scale":1},"width":454,"height":180,"src":"/bilibiliBanner/images/4/459fbeaaff1fbeced05ac36f1cb0c0c70df3ff01.png@1c.webp","a":0.30302999999999997},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-1200,"translateY":55,"rotate":0,"scale":1},"width":422,"height":74,"src":"/bilibiliBanner/images/4/bba2f3520bedef31ef33a816f11a9d22487b80aa.png@1c.webp","a":0.42424199999999995},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":450,"translateY":20,"rotate":0,"scale":1},"width":214,"height":118,"src":"/bilibiliBanner/images/4/7c2d36bba37320de03c417ed7d86111f7b05347e.png@1c.webp","a":0.30302999999999997},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":350,"translateY":50,"rotate":0,"scale":1},"width":126,"height":75,"src":"/bilibiliBanner/images/4/aa01bb2357ea84d7cc6cf3030769f2581a3ac98f.png@1c.webp","a":0.36363599999999996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":700,"translateY":0,"rotate":0,"scale":1},"width":367,"height":180,"src":"/bilibiliBanner/images/4/89d1c8fb55797a064a4d4aca51be2ebb8d86643a.png@1c.webp","a":0.4848499999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":1200,"translateY":55,"rotate":0,"scale":1},"width":422,"height":74,"src":"/bilibiliBanner/images/4/bba2f3520bedef31ef33a816f11a9d22487b80aa.png@1c.webp","a":0.5151500000000001},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2112,"height":154,"src":"/bilibiliBanner/images/4/55e90a11-9e7a-494a-93d6-ced3f0d352ed","a":0.0333333}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/5/data.json"/>
      <url>/bilibiliBanner/images/5/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/5/01b79b5b5b38d7305a0ca1780c24662cc5a59f18.png@1c.webp","a":0.00272727},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":-9,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/5/fe903820ca0f604ef24f16ff7ad51192ead3d0c8.png@1c.webp","a":0.0109091},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1728,"height":148,"src":"/bilibiliBanner/images/5/73fcb8a56776307147c140f68bf9c5793696ae88.png@1c.webp","a":0.0218182},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":-40,"rotate":0,"scale":1},"width":826,"height":76,"src":"/bilibiliBanner/images/5/b8a5bcf77a07793ce50294a8cb14a9fb8f2cea83.png@1c.webp","a":0.018181799999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":100,"translateY":0,"rotate":0,"scale":1},"width":1523,"height":180,"src":"/bilibiliBanner/images/5/1fd3d44b8f890b88cf52f6bcc041326b30e7cb62.png@1c.webp","a":0.03636400000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-126,"translateY":-45,"rotate":0,"scale":1},"width":382,"height":67,"src":"/bilibiliBanner/images/5/085bc5e7f70b625b62c1f5d374f55acbd828ab65.png@1c.webp","a":0.0272727},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":10,"rotate":0,"scale":1},"width":1920,"height":156,"src":"/bilibiliBanner/images/5/3e16264878dd88c1b8ead37aab07a9363186b18c.png@1c.webp","a":0.0424242},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":276,"translateY":-48,"rotate":0,"scale":1},"width":125,"height":131,"src":"/bilibiliBanner/images/5/8902051ab71c8093a85ce2a71882054ee91ea631.png@1c.webp","a":0.05818200000000002,"deg":-0.00065},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":660,"translateY":0,"rotate":0,"scale":1},"width":589,"height":180,"src":"/bilibiliBanner/images/5/c9231e763120806f3e918d06ad3f415e920c2b73.png@1c.webp","a":0.048485000000000014},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":750,"translateY":0,"rotate":0,"scale":1},"width":420,"height":157,"src":"/bilibiliBanner/images/5/67a3c27832d63060d88fbd7bdb2fc543e3fb9ddf.png@1c.webp","a":0.06060599999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":503.5,"translateY":14.25,"rotate":0,"scale":1},"width":370,"height":142,"src":"/bilibiliBanner/images/5/c651a0183b81857191c86b133c5a777059b13571.png@1c.webp","a":0.06909100000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":504,"translateY":13.5,"rotate":0,"scale":1},"width":172,"height":133,"src":"/bilibiliBanner/images/5/6afc90f36610318b4785a52c1a51ef6f1de9d25b.png@1c.webp","a":0.14727300000000002},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-171,"translateY":-4.5,"rotate":0,"scale":1},"width":203,"height":149,"src":"/bilibiliBanner/images/5/476679726643b3b6cc5599b882d85953ef34f3d9.png@1c.webp","a":0.054545},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-540,"translateY":0,"rotate":0,"scale":1},"width":732,"height":162,"src":"/bilibiliBanner/images/5/121335f79c78bb6f47e4fc7dae4b0af0eac804bb.png@1c.webp","a":0.09818200000000002},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-332.5,"translateY":23.75,"rotate":0,"scale":1},"width":292,"height":112,"src":"/bilibiliBanner/images/5/590a6dd64ff00d5d0e63e230188939c405253452.png@1c.webp","a":0.08636400000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-551,"translateY":23.75,"rotate":0,"scale":1},"width":191,"height":116,"src":"/bilibiliBanner/images/5/e00c60ae700774655af2e2516a13a5b1fa2fcfe7.png@1c.webp","a":0.14451499999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-880,"translateY":16,"rotate":0,"scale":1},"width":379,"height":144,"src":"/bilibiliBanner/images/5/357dd346995f678c43eb6bf51fe02f47bbe7db7d.png@1c.webp","a":0.17454499999999995},{"tagName":"img","opacity":["0.3","0.3"],"transform":{"translateX":20,"translateY":10,"rotate":0,"scale":1},"width":288,"height":145,"src":"/bilibiliBanner/images/5/bae427c01d895b63e6aaf6b0c239b86027527e6a.png@1c.webp","a":0.04848480000000001},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2112,"height":154,"src":"/bilibiliBanner/images/5/a98a8707-3a16-4700-949b-57a2f9693deb","a":0.02},{"tagName":"video","opacity":["0.3","0.3"],"transform":{"translateX":42,"translateY":-84,"rotate":0,"scale":1},"width":420,"height":630,"src":"/bilibiliBanner/images/5/83d47d6f-2598-454f-9ffa-495ee5f3d270","a":0.0458182}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/6/data.json"/>
      <url>/bilibiliBanner/images/6/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/17a1bcfacfc51f000cad0611dca32020b18db6f5.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/f0ba9b7f8d4ec1745a08cabdf3951ceb4aa266d1.png@1c.webp","a":0.0012121200000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":300,"translateY":24,"rotate":0,"scale":1},"width":2400,"height":224,"src":"/bilibiliBanner/images/6/be5632d3f86228a81979b8a85ce9cf0d5df541e0.png@1c.webp","a":0.003636000000000024},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":330,"translateY":33,"rotate":0,"scale":1},"width":2200,"height":206,"src":"/bilibiliBanner/images/6/f63cf9726b73c78ececc43ff16f3336fdfc76748.png@1c.webp","a":0.02},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/2c32dd208cb8f317ac78e03c78da5cd04b9a1410.png@1c.webp","a":0.00727273},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/e04d0fbaaf67bdb0de7c40dca04180a9c1defa0a.png@1c.webp","a":0.0109091},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/d5113ee4aaca71d7e7570a45b1e541efc0deca71.png@1c.webp","a":0.018181799999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/ae0543610dd9b3d0903cec7a6982200691dce1b5.png@1c.webp","a":0.00930706},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/6d9f792b3458e0b6f8647f7ad3958b1c1438d50e.png@1c.webp","a":0.018181799999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/f3945f0ed928e45fb58c8a1edb07358ec719c8df.png@1c.webp","a":0.0242424},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/ba22577d90164e589f87f9073d56953ff3e30088.png@1c.webp","a":0.0333333},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":100,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/d6ef89533fed72dfde53009ac2aab66009ab545a.png@1c.webp","a":0.018182000000000004},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/8cacfce7b1f44f707836fa4fb68444a9c7202d63.png@1c.webp","a":0.036363599999999996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":10,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/ff63f10698f5f0a9e9083d90c6f32de5269801d4.png@1c.webp","a":0.0484848},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/5630bebd1068fa6c46eaea4ffa9b004f882d7d33.png@1c.webp","a":0.0484848},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/a7ead379e7a6653cd70f24e8556ce336702abb3a.png@1c.webp","a":0.0484848},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/06336184ba84f89890f50e867012c05914219947.png@1c.webp","a":0.0727273},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-100,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/ddc58cd92df71ada0be9bad00b2139a34872ef94.png@1c.webp","a":0.10909091},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-90,"translateY":0,"rotate":0,"scale":1},"width":1800,"height":168,"src":"/bilibiliBanner/images/6/996a5656d3a31738f79b67d94ea0b654fba169ac.png@1c.webp","a":0.1636364},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/905fbc85df462f16c3fe0b83f0e5814696818a56.png@1c.webp","a":0.0727273},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/4d37acea06841ace858f27cab3a5596d9fdd8354.png@1c.webp","a":0.09090909999999999},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":-245,"translateY":15,"rotate":0,"scale":1},"width":180,"height":100,"src":"/bilibiliBanner/images/6/9c1a6b86-0480-43b6-86e5-3faa3ba4de7b","a":0.04424600000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":2200,"height":206,"src":"/bilibiliBanner/images/6/d4d4569741806055f36c4d9140bdd7069a50ec09.png@1c.webp","a":0.133333},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":15,"rotate":0,"scale":1},"width":2000,"height":187,"src":"/bilibiliBanner/images/6/2dd4a5f8aee1829bcdae687052853b8947a5d2f6.png@1c.webp","a":0.121212}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/7/data.json"/>
      <url>/bilibiliBanner/images/7/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/7/75ec2d45ce8c942a1f7379d4641171da4d90ab0d.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1696,"height":159,"src":"/bilibiliBanner/images/7/286eb259a60a0eabfcde96d7ea92d239fe68b3fe.png@1c.webp","a":0.00321212},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1760,"height":165,"src":"/bilibiliBanner/images/7/782d55aeca6cc75f51d2d630005f514a61a0ddfa.png@1c.webp","a":0.0033333300000000002},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/d6c941cf2d5fc6c717173f7e3f166dbc444aa15b.png@1c.webp","a":0.009454549999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1760,"height":165,"src":"/bilibiliBanner/images/7/27e411d92729604aa594858beb5130ed60aad76d.png@1c.webp","a":0.01},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/09d0855b6b6d6965e8f02404777986237848c6c9.png@1c.webp","a":0.0945455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/40878bbef514e2d4bf5d660fe1145c869567bec2.png@1c.webp","a":0.006303029999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/7/42485baddbca05d2c4c7710a0b76b74d303e06d7.png@1c.webp","a":0.026181799999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/8ea0e95a8e5fc85ae227810925dba1ace1e9fcba.png@1c.webp","a":0.037818199999999996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/c13ca9c6405c71bf864ed2bc421680cb437f45ef.png@1c.webp","a":0.0252121},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/a43c6833d262301373234ffbd6934559d2ce7fb2.png@1c.webp","a":0.0315152},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/7/ce8c5e45230a6d3805baf60f5916f1cd441aac8e.png@1c.webp","a":0.0425455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/cbf19f3682dfb02e62557d07fefaf241a80296a1.png@1c.webp","a":0.0630303},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":500,"translateY":0,"rotate":0,"scale":1},"width":100,"height":250,"src":"/bilibiliBanner/images/7/0fb2e121-b816-4df0-a70f-cf288d61a9ba","a":0.006060999999999979},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/7998ca9f0bc267375fb7b45f75626d96806f94d7.png@1c.webp","a":0.0945455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/198efffbc58493300854c04ab0ea8d979a6f9223.png@1c.webp","a":0.0882424},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/142a486b8dd500a626a60b68ad993af8dabc8b55.png@1c.webp","a":0.0945455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":104,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/bb6266e1525a51f7920fc8881e47cadeee271b0c.png@1c.webp","a":0.110303},{"tagName":"img","opacity":["0.5","0.5"],"transform":{"translateX":-104,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/7/cd68251cde11936871237ca94360acb451bf7ed2.png@1c.webp","a":0.15757580000000002},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":216,"translateY":0,"rotate":0,"scale":1},"width":108,"height":270,"src":"/bilibiliBanner/images/7/9aa57b05-9373-4b56-8edb-bca259791d6d","a":0.016364000000000004},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":-700,"translateY":0,"rotate":0,"scale":1},"width":200,"height":500,"src":"/bilibiliBanner/images/7/fff83dd5-c49c-48d0-b5a4-96d9f79d2e10","a":0.018182000000000018}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/8/data.json"/>
      <url>/bilibiliBanner/images/8/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/18e14b236c8c0478b9f126b53dc149718c8277d6.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/2c048730ce3449400cd657650f5f2e68e2fa5ef5.png@1c.webp","a":0.00315152},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/582b9609daf669327c460af63776f5f0c14b5c26.png@1c.webp","a":0.006303029999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1696,"height":159,"src":"/bilibiliBanner/images/8/f5fcc108b811577571e3f54d6d46df58a9f553ed.png@1c.webp","a":0.012848499999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/4367bada261c826302101afa18fe41e86f545099.png@1c.webp","a":0.0126061},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/0ebcccd16a9fe9bb551e213de4eaf3cd5a24c8ff.png@1c.webp","a":0.014181800000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":104,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/21a613a7457891ed7daa559b03191df7bf551362.png@1c.webp","a":0.15757600000000002},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/83b58af34fc683e529962449078a3ded7f1d2e80.png@1c.webp","a":0.0157576},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/6683112849dadee65749c4f7f72b83c9a9f8f537.png@1c.webp","a":0.018909099999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":10.4,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/93ab310ca3e2a24489aa1873865501adb3f81393.png@1c.webp","a":0.014181800000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/064a75156c568aa6a9982e2c983d2a30cb86ea94.png@1c.webp","a":0.0220606},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1696,"height":159,"src":"/bilibiliBanner/images/8/7bb79a88a5c61724c7fd2ab009f462b744ba5b29.png@1c.webp","a":0.0160606},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":1.08,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/8/1b6718fe3996574889da7ef1b9c29a566fe963f4.png@1c.webp","a":0.0245455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/c31995a7a80e459e165ae4ef60e323e27f497420.png@1c.webp","a":0.0315152},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/4a66f79212d4c6182a8e10a1eb0424f3d7c79120.png@1c.webp","a":0.0252121},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":-10.4,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/30ccbdfe561bcd18a7ee457bd151b55da7a3dd3c.png@1c.webp","a":0.126061},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":260,"translateY":10.4,"rotate":0,"scale":1},"width":104,"height":67,"deg":0.0002,"g":-0.001,"src":"/bilibiliBanner/images/8/20ccfde3e5606d223ab230a78234e4f9ac140371.png@1c.webp","a":0.12606099999999998},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":104,"translateY":10.4,"rotate":0,"scale":1},"width":133,"height":85,"src":"/bilibiliBanner/images/8/d562864113a6e6cce54b41745132a974b4576c3c.png@1c.webp","a":0.09454499999999999},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/ab4fbaed481d880a618e52f97e7e1f6e5c8b7f7c.png@1c.webp","a":0.189091},{"tagName":"video","opacity":["1","1"],"transform":{"translateX":0,"translateY":10.4,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/64ec820b-8857-4965-a7ab-ffc3d29ceebd","a":0.0630303},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/57f20e919517fc784f1e03900140274cfea2cb85.png@1c.webp","a":0.0945455},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1664,"height":156,"src":"/bilibiliBanner/images/8/670d70b0351582e5b53855ddbf50600c03425062.png@1c.webp","a":0.157576}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/bilibiliBanner/images/9/data.json"/>
      <url>/bilibiliBanner/images/9/data.json</url>
      
        <content type="html"><![CDATA[[{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/9/477fb7a2f5e2cc1b2aa00c679c8ab168b47ff1b9.png@1c.webp","a":0.0016363600000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-42.5,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/dd4aa5af4898a15dde074fe6b833bdfbc045dd47.png@1c.webp","a":0.005151499999999999,"deg":0.00008},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/ae64c474ba2748b4fea1a1433b9b373598d3e686.png@1c.webp","a":0},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":-63,"translateY":-18,"rotate":0,"scale":1},"width":1728,"height":162,"src":"/bilibiliBanner/images/9/d41b0292d9d1b0fce37a35f6efacac579093cdb3.png@1c.webp","a":0.008181800000000003,"deg":0.00007},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/a12cbab877db2b6d3b96ec012735cfe3998de399.png@1c.webp","a":-0.00515152},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":9.5,"translateY":0,"rotate":0,"scale":1},"width":1824,"height":171,"src":"/bilibiliBanner/images/9/6f27fe80f495e83546921c2c58b2107c2ee89706.png@1c.webp","a":0.0143939},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/ac580ac636595e27b5d5c8b1f9d802751823f02f.png@1c.webp","a":-0.020606100000000002},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":8.5,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/987a407da2e02a12be549ad7f011dc11f73216e9.png@1c.webp","a":-0.00772727},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":8.5,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/843ee84b16bab6274b98b317b3adaf1351b4be76.png@1c.webp","a":0.0154545},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":8.5,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/a5607001ac06b4780106e2a10aa835657e553f07.png@1c.webp","a":-0.01030303,"g":0.02},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":17,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/b14cad3c76e957705810c26f4c6acc236f280721.png@1c.webp","a":0.0077272999999999994},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":8.5,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/f569be6834a5968c038bcc0fb0403f8f77e24c18.png@1c.webp","a":0.010303000000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":21,"translateY":21,"rotate":0,"scale":1},"width":1344,"height":126,"src":"/bilibiliBanner/images/9/eb98a42561de7d45f8856407c4531d2724ac6fc6.png@1c.webp","a":0.0424242},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/480a5c02dbcd3afd5f790cf621efbd1b2d39efcb.png@1c.webp","a":0.0257576},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":17,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/cc1405d4d805baf9c459f67c03f095f70ec864c6.png@1c.webp","a":0.00772727},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/1696ffeacb26bcce7ad50037952620ee43614a4a.png@1c.webp","a":0.010303000000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":34.4,"translateY":0,"rotate":0,"scale":1},"width":1651,"height":155,"src":"/bilibiliBanner/images/9/b0747b7f64e0e07e379a4bd416a0891b3e52c7d9.png@1c.webp","a":0.03127270000000001},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/ec9f99bf71be9408a359d7cd48dfb47e48ebce2c.png@1c.webp","a":0.0128788,"deg":0.00015,"f":-0.0004},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":17,"translateY":0,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/c4cef2b063a853521c7f413d8e7782ff653e4126.png@1c.webp","a":0.0412121},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":30,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/9/567e0221b3bd89e34d85c604549d915c95ca17d1.png@1c.webp","a":-0.060606099999999996},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":15.3,"translateY":17,"rotate":0,"scale":1},"width":1632,"height":153,"src":"/bilibiliBanner/images/9/23c05e4d9e0ffbc16671e14c406fbe785b06ff9f.png@1c.webp","a":0.046363600000000005},{"tagName":"img","opacity":["1","1"],"transform":{"translateX":0,"translateY":0,"rotate":0,"scale":1},"width":1920,"height":180,"src":"/bilibiliBanner/images/9/fbfeb5de7e41fd1e888fca7ac76cbf2f8a42f3d3.png@1c.webp","a":0.060606099999999996}]]]></content>
      
    </entry>
    
    
  
</search>
