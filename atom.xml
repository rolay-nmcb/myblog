<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2026-02-22T12:13:28.639Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发与串行下的接口幂等</title>
    <link href="https://nmcb666.vip/posts/34e1e2ae.html"/>
    <id>https://nmcb666.vip/posts/34e1e2ae.html</id>
    <published>2026-02-21T12:41:31.000Z</published>
    <updated>2026-02-22T12:13:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践"><a href="#架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践" class="headerlink" title="架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践"></a>架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践</h1><p>在分布式系统的开发中，<strong>“接口幂等性（Idempotency）”</strong>是一个老生常谈却又极易踩坑的话题。尤其是涉及资金交易、订单状态流转的业务（如提现、转账、支付回调），一旦防重逻辑出现漏洞，轻则客诉，重则产生直接资损。</p><p>面对“重复请求防并发”，很多开发者的第一反应往往是：“<strong>加个 Redis 分布式锁不就行了吗？</strong>” </p><p>然而，在经历过几次血淋淋的生产事故，或者深入剖析过数据库底层原理后，你会发现：<strong>用分布式锁来保证业务幂等，不仅大材小用、徒增系统复杂度，而且一旦用错，根本拦不住真正的重复执行。</strong></p><p>今天，我们就来深度剖析一下，为什么在绝大多数场景下，<strong>数据库本身就是最好的幂等防线</strong>；以及在企业级架构中，究竟该如何优雅地构建这套防御体系。</p><hr><h2 id="1-灾难现场：被击穿的“加锁”逻辑"><a href="#1-灾难现场：被击穿的“加锁”逻辑" class="headerlink" title="1. 灾难现场：被击穿的“加锁”逻辑"></a>1. 灾难现场：被击穿的“加锁”逻辑</h2><p>假设有一个“异步出款”的消费者，由于网络抖动，同一笔订单的出款消息被消费了两次。</p><p>重度依赖中间件的开发者，防重代码往往是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反面教材：单纯依赖分布式锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayout</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (redisLock.tryLock(<span class="string">&quot;lock:payout:&quot;</span> + orderId)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 调用银行接口打款</span></span><br><span class="line">            bankService.pay(orderId, amount);</span><br><span class="line">            <span class="comment">// 2. 更新订单状态为成功</span></span><br><span class="line">            orderService.updateStatus(orderId, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>漏洞在哪里？</strong><br>当第一条消息正常执行完毕，<strong>锁被释放了</strong>。此时，重发的第二条消息姗姗来迟。它兴冲冲地去 Redis 拿锁，发现锁是空闲的！于是它顺利拿到锁，<strong>再次调用了银行接口，导致同一笔订单被打了两次钱。</strong></p><p>这里暴露了一个核心认知误区：<strong>分布式锁只能解决“并发拥挤”问题，根本无法解决“状态记忆”问题。</strong> 真正的幂等，必须依赖持久化的状态。</p><hr><h2 id="2-核心洞察：数据库才是最完美的“并发-状态”守卫者"><a href="#2-核心洞察：数据库才是最完美的“并发-状态”守卫者" class="headerlink" title="2. 核心洞察：数据库才是最完美的“并发+状态”守卫者"></a>2. 核心洞察：数据库才是最完美的“并发+状态”守卫者</h2><p>其实，我们完全没必要在应用层用 Redis 绕这么大一个圈子。现代关系型数据库（如 MySQL InnoDB）底层自带的<strong>事务（ACID）和锁机制</strong>，天生就是解决这类问题的终极武器。</p><p>我们可以将业务场景分为两类：<strong>更新操作（UPDATE）</strong> 和 <strong>插入操作（INSERT）</strong>。只要用好数据库的特性，连分布式锁的影子都不需要有。</p><h3 id="场景一：状态流转类（UPDATE）——-状态机-数据库行锁"><a href="#场景一：状态流转类（UPDATE）——-状态机-数据库行锁" class="headerlink" title="场景一：状态流转类（UPDATE）—— 状态机 + 数据库行锁"></a>场景一：状态流转类（UPDATE）—— 状态机 + 数据库行锁</h3><p>对于订单支付、状态变更等业务，最优雅的解法是利用<strong>带有状态流转条件的 UPDATE 语句</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 黄金示范：利用数据库行锁 + 状态机实现幂等</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processPayout</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 直接执行状态机更新 SQL</span></span><br><span class="line">    <span class="comment">// 对应的 SQL: UPDATE order SET status = &#x27;SUCCESS&#x27; WHERE id = ? AND status = &#x27;PENDING&#x27;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">updateCount</span> <span class="operator">=</span> orderMapper.updateStatusToSuccess(orderId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断是否抢到了执行权</span></span><br><span class="line">    <span class="keyword">if</span> (updateCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 真正防并发成功，且是第一次执行</span></span><br><span class="line">        bankService.pay(orderId, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;打款成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. updateCount == 0，说明被并发拦截，或者之前已经处理过了！</span></span><br><span class="line">    <span class="comment">// 此时需要查一次最新状态，来决定返回什么（这才是真正的幂等响应）</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.getById(orderId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;SUCCESS&quot;</span>.equals(order.getStatus())) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;订单 &#123;&#125; 已处理，幂等返回&quot;</span>, orderId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;打款成功&quot;</span>; <span class="comment">// 结果符合预期，直接告诉调用方成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;订单状态异常，无法打款&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层原理解析（为什么它不怕高并发？）：</strong><br>当两个请求同时打到数据库执行这条 <code>UPDATE</code> 语句时，MySQL 的 InnoDB 引擎会利用主键（id）瞬间给这行数据加上<strong>排他锁（X锁 / 记录锁）</strong>。</p><ul><li><strong>请求 A</strong> 抢到了记录锁，核对 <code>status = &#39;PENDING&#39;</code> 成功，完成更新并释放锁。</li><li><strong>请求 B</strong> 在门外阻塞等待。等 A 释放锁后，B 进门重新读取数据（当前读），发现 <code>status</code> 已经是 <code>SUCCESS</code> 了，<code>WHERE</code> 条件不成立，直接返回 <code>affected_rows = 0</code>。<br><strong>结论：全程无需 Redis，数据库自己就把并发冲突防得死死的。</strong></li></ul><h3 id="场景二：资源创建类（INSERT）——-唯一约束（Unique-Key）"><a href="#场景二：资源创建类（INSERT）——-唯一约束（Unique-Key）" class="headerlink" title="场景二：资源创建类（INSERT）—— 唯一约束（Unique Key）"></a>场景二：资源创建类（INSERT）—— 唯一约束（Unique Key）</h3><p>如果业务是没有前置状态的“凭空创建”（比如创建退款单、记录出款流水），状态机就不适用了。此时，最强的物理防御是：<strong>数据库唯一约束</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 黄金示范：唯一索引防重表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createRefund</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 插入流水表（利用唯一约束：unique_key(order_id)）</span></span><br><span class="line">        refundMapper.insert(<span class="keyword">new</span> <span class="title class_">RefundRecord</span>(orderId, <span class="string">&quot;REFUNDING&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DuplicateKeyException e) &#123;</span><br><span class="line">        <span class="comment">// 2. 捕获唯一键冲突，说明已经有人处理过了，直接幂等返回</span></span><br><span class="line">        log.warn(<span class="string">&quot;订单 &#123;&#125; 已存在退款流水，幂等拦截&quot;</span>, orderId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行后续退款逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一索引天然具备双重能力：高并发下，底层行锁会阻塞并报错；串行重试下，磁盘上的记录会永远挡住重复的插入。</p><hr><h2 id="3-架构师的抉择：那分布式锁还要不要用？"><a href="#3-架构师的抉择：那分布式锁还要不要用？" class="headerlink" title="3. 架构师的抉择：那分布式锁还要不要用？"></a>3. 架构师的抉择：那分布式锁还要不要用？</h2><p>既然数据库这么牛，是不是就可以把 Redis 扔了？<strong>当然不是。</strong></p><p>我们要重新定义分布式锁在架构中的角色：<strong>它不是保证“业务正确性”的必需品，而是保护数据库的“性能防弹衣”。</strong></p><p>在极端超高并发场景下（例如秒杀大促，或者黑客用脚本一秒钟对同一个订单发起 1 万次重试请求）：</p><ul><li>如果你只用数据库兜底，这 1 万个请求都会去 MySQL 里抢夺同一行数据的行锁。虽然最后 9999 个请求都会返回 <code>updateCount = 0</code>（数据绝对安全），但这会<strong>白白消耗大量 MySQL 的 CPU 资源和宝贵的连接池</strong>，甚至引发系统雪崩。</li><li><strong>此时，分布式锁才应该登场。</strong></li></ul><p><strong>高并发终极架构：前置 Redis 挡流量 + 后置 DB 保底</strong></p><ol><li><strong>第一道防线（Redis 分布式锁 - 挡并发/抗压）：</strong><br>作为前锋，利用 Redis 的极高性能，将 99% 的恶并发意重试拦截在应用层，直接返回“处理中”。</li><li><strong>第二道防线（DB 状态机/唯一索引 - 保正确/兜底）：</strong><br>作为守门员，处理那些突破了 Redis（比如 Redis 宕机、主从切换丢失锁）的漏网之鱼。只要 SQL 写得对，资金绝对不会多发一毛钱。</li></ol><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>当你下次再面对接口幂等需求时，请跳出“只会加锁”的惯性思维，默念这三条军规：</p><ol><li><strong>防重与幂等的绝对核心在数据库</strong>：利用“状态机 + 行锁（UPDATE）”或“唯一约束（INSERT）”，这是系统最坚固的底线。</li><li><strong>正确处理 <code>updateCount == 0</code></strong>：拦截重复并不是抛出异常，而是结合当前最新状态，返回给客户端一个“符合预期的成功响应”，这才是幂等性的精髓。</li><li><strong>按需引入分布式锁</strong>：不要迷信中间件，只有当评估<strong>数据库压力过大、锁竞争过于激烈</strong>时，才引入分布式锁作为“削峰/挡流量”的性能优化手段。</li></ol><p>大道至简。看透并发与底层锁的本质，用最简单的组件组合解决最复杂的问题，才是高级架构师的必修课。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践&quot;&gt;&lt;a href=&quot;#架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践&quot; class=&quot;headerlink&quot; title=&quot;架构漫谈：别盲信分布式锁——大道至简的接口幂等性深度实践&quot;&gt;&lt;/a&gt;架构</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Kafka的多副本同步机制</title>
    <link href="https://nmcb666.vip/posts/10b4eaf1.html"/>
    <id>https://nmcb666.vip/posts/10b4eaf1.html</id>
    <published>2026-02-16T17:22:19.000Z</published>
    <updated>2026-02-22T12:13:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度解析-Kafka-多副本同步机制：从-HW-到-Leader-Epoch"><a href="#深度解析-Kafka-多副本同步机制：从-HW-到-Leader-Epoch" class="headerlink" title="深度解析 Kafka 多副本同步机制：从 HW 到 Leader Epoch"></a>深度解析 Kafka 多副本同步机制：从 HW 到 Leader Epoch</h1><p>在分布式系统中，数据的一致性和高可用性永远是核心课题。Kafka 作为顶级消息流平台，其高可靠性主要依赖于<strong>多副本（Replication）机制</strong>。本文将带你深入底层，剖析 Kafka 副本之间是如何协同工作、确保数据不丢不重的。</p><hr><h2 id="一、-核心角色与概念"><a href="#一、-核心角色与概念" class="headerlink" title="一、 核心角色与概念"></a>一、 核心角色与概念</h2><p>在深入同步流程之前，我们先统一几个关键术语：</p><ol><li><strong>Leader 副本</strong>：每个分区（Partition）在创建时，由 <strong>Controller</strong> 负责指派 Leader。Controller 会从 <strong>AR（Assigned Replicas，所有副本）</strong> 列表中找到第一个在 <strong>ISR</strong> 中的副本作为优先 Leader。所有的读写请求都由 Leader 处理。</li><li><strong>Follower 副本</strong>：不处理客户端请求，只负责从 Leader 拉取（Pull）数据。</li><li><strong>ISR (In-Sync Replicas)</strong>：与 Leader 保持同步的副本集合。判断标准是 <code>replica.lag.time.max.ms</code>（默认 30s），只要 Follower 在这个时间内向 Leader 发起过同步请求且进度没落后太多，就留在 ISR 中。</li><li><strong>LEO (Log End Offset)</strong>：下一条待写入消息的位移。每个副本都有自己的 LEO。</li><li><strong>HW (High Watermark)</strong>：高水位。这是消费者能看到的最高位移。<strong>HW 之前的消息被认为是“已提交”的。</strong></li></ol><hr><h2 id="二、-数据同步全过程：HW-的动态演进"><a href="#二、-数据同步全过程：HW-的动态演进" class="headerlink" title="二、 数据同步全过程：HW 的动态演进"></a>二、 数据同步全过程：HW 的动态演进</h2><p>Kafka 的同步机制是一个“两步走”的拉取模型。</p><h3 id="1-第一步：Follower-拉取数据"><a href="#1-第一步：Follower-拉取数据" class="headerlink" title="1. 第一步：Follower 拉取数据"></a>1. 第一步：Follower 拉取数据</h3><p>Follower 会周期性地向 Leader 发送 <code>FetchRequest</code>。请求中包含 Follower 自己当前的 <strong>LEO</strong>。</p><h3 id="2-第二步：Leader-更新-LEO-与-HW"><a href="#2-第二步：Leader-更新-LEO-与-HW" class="headerlink" title="2. 第二步：Leader 更新 LEO 与 HW"></a>2. 第二步：Leader 更新 LEO 与 HW</h3><p>当 Leader 收到 Fetch 请求后：</p><ul><li><strong>更新 LEO 记录</strong>：Leader 会在内存中记录这个 Follower 的 LEO。</li><li><strong>计算 HW</strong>：Leader 会取 <strong>ISR 集合中所有副本 LEO 的最小值</strong>，作为该分区新的 HW。</li></ul><h3 id="3-第三步：Follower-更新-HW"><a href="#3-第三步：Follower-更新-HW" class="headerlink" title="3. 第三步：Follower 更新 HW"></a>3. 第三步：Follower 更新 HW</h3><p>Leader 在处理完 Fetch 请求后，会将<strong>当前分区的 HW</strong> 随数据一起返回给 Follower。<br>Follower 收到响应后：</p><ul><li>将数据写入本地日志，更新自己的 <strong>LEO</strong>。</li><li>比较“自己的 LEO”和“Leader 传回的 HW”，<strong>取最小值</strong>作为自己本地的 HW。</li></ul><blockquote><p><strong>注意：HW 更新的“滞后性”</strong><br>由于 HW 是在 Fetch Response 中带回的，这意味着 Follower 自身的 HW 总是比 Leader 慢一轮拉取。</p></blockquote><hr><h2 id="三、-HW-机制的局限性：为什么需要-Leader-Epoch？"><a href="#三、-HW-机制的局限性：为什么需要-Leader-Epoch？" class="headerlink" title="三、 HW 机制的局限性：为什么需要 Leader Epoch？"></a>三、 HW 机制的局限性：为什么需要 Leader Epoch？</h2><p>在 Kafka 0.11 版本之前，仅仅依靠 HW 存在两个严重问题：<strong>数据丢失</strong>和<strong>数据不一致</strong>。</p><p><strong>场景模拟：</strong><br>假设 A 是 Leader，B 是 Follower。</p><ol><li>A 收到消息并写入，A 的 LEO=1, HW=1。B 同步了消息，但还没来得及收到 A 的 HW 更新回传，此时 B 的 LEO=1, HW=0。</li><li>B 重启。根据 HW 机制，B 重启后会将日志<strong>截断</strong>到自己的 HW（即位移 0），位移 1 的数据丢失了。</li><li>B 截断后尝试拉取 A。此时 A 突然宕机，B 被选为新 Leader。</li><li>A 恢复后成为 Follower，发现自己的 HW 也是 1，与 B 似乎一致，但实际上 B 已经丢了数据。</li></ol><p>为了解决这个问题，Kafka 引入了 <strong>Leader Epoch</strong>。</p><h3 id="Leader-Epoch-机制"><a href="#Leader-Epoch-机制" class="headerlink" title="Leader Epoch 机制"></a>Leader Epoch 机制</h3><p>Leader Epoch 相当于一个“版本号”+“起始位移”。</p><ul><li>当 Follower 重启后，<strong>不再直接根据 HW 截断日志</strong>。</li><li>它会先向 Leader 发送一个 <code>OffsetForLeaderEpochRequest</code>，询问当前 Epoch 的最后一个位移。</li><li>通过 Leader 返回的确认信息，Follower 能够判断该位移的数据是否真的失效，从而避免了盲目截断导致的数据丢失。</li></ul><hr><h2 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h2><p>Kafka 的副本同步机制可以概括为：</p><ol><li><strong>由 Controller 指派优先副本作为 Leader</strong>，确保负载均衡。</li><li><strong>ISR 机制保证可靠性</strong>，动态剔除掉队副本，确保只有同步的副本能竞选 Leader。</li><li><strong>HW 机制定义可见性边界</strong>，通过拉取模型（Pull）异步更新各副本水位。</li><li><strong>Leader Epoch 修复了 HW 的物理缺陷</strong>，在极端的宕机重启场景下保障了数据的绝对一致性。</li></ol><p><strong>一句话总结：</strong><br>HW 决定了你能消费到哪，而 ISR 和 Leader Epoch 决定了你的数据有多安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度解析-Kafka-多副本同步机制：从-HW-到-Leader-Epoch&quot;&gt;&lt;a href=&quot;#深度解析-Kafka-多副本同步机制：从-HW-到-Leader-Epoch&quot; class=&quot;headerlink&quot; title=&quot;深度解析 Kafka 多副本同步</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>在DDD下怎么高效实现一人一单+库存超卖</title>
    <link href="https://nmcb666.vip/posts/ae7d08b8.html"/>
    <id>https://nmcb666.vip/posts/ae7d08b8.html</id>
    <published>2026-02-11T14:22:55.000Z</published>
    <updated>2026-02-22T12:13:28.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD实战-高并发下的“一人一单”与库存扣减"><a href="#DDD实战-高并发下的“一人一单”与库存扣减" class="headerlink" title="[DDD实战] 高并发下的“一人一单”与库存扣减"></a>[DDD实战] 高并发下的“一人一单”与库存扣减</h1><p>在电商系统的“秒杀”或“限购”场景中，<strong>创建订单</strong>看似简单，实则暗流涌动。特别是在面临以下两个核心约束时，传统的CRUD思维往往会陷入性能瓶颈或逻辑混乱：</p><ol><li><strong>购买资格校验</strong>：例如“一人一单”、“一人一天限购5单”。</li><li><strong>高并发库存扣减</strong>：如何防止超卖，同时保证高性能。</li></ol><p>本文将复盘我在项目中遇到的领域建模难点，探讨如何通过引入<strong>新的聚合根</strong>、<strong>Redis+Lua原子操作</strong>以及<strong>最终一致性</strong>策略来优雅解决这些问题。</p><hr><h2 id="一、-领域建模的困局：限购逻辑该放哪？"><a href="#一、-领域建模的困局：限购逻辑该放哪？" class="headerlink" title="一、 领域建模的困局：限购逻辑该放哪？"></a>一、 领域建模的困局：限购逻辑该放哪？</h2><p>限购逻辑的核心在于：“判断一个用户在特定时间窗口内，对某个商品的购买历史是否满足条件。”</p><p>在设计初期，我们面临着模型归属的抉择：</p><h3 id="❌-方案一：放在“订单（Order）”聚合根中"><a href="#❌-方案一：放在“订单（Order）”聚合根中" class="headerlink" title="❌ 方案一：放在“订单（Order）”聚合根中"></a>❌ 方案一：放在“订单（Order）”聚合根中</h3><p><strong>思路</strong>：在创建新订单时，查询该用户所有的历史订单，统计购买数量。<br><strong>问题</strong>：</p><ul><li><strong>性能极差</strong>：随着时间推移，历史订单表数据量巨大，实时统计（Count/Sum）是数据库杀手。</li><li><strong>职责不清</strong>：订单聚合根应该关注“本次交易”的状态流转，而不是背负“历史审计”的责任。</li></ul><h3 id="❌-方案二：放在“用户（User）”聚合根中"><a href="#❌-方案二：放在“用户（User）”聚合根中" class="headerlink" title="❌ 方案二：放在“用户（User）”聚合根中"></a>❌ 方案二：放在“用户（User）”聚合根中</h3><p><strong>思路</strong>：在用户模型中增加一个<code>List&lt;PurchaseHistory&gt;</code>。<br><strong>问题</strong>：</p><ul><li><strong>大对象问题</strong>：如果是高频购买用户，加载用户聚合根会将大量无关的历史订单载入内存，造成资源浪费。</li><li><strong>违背单一职责（SRP）</strong>：用户领域应关注账号、画像等信息，不应包含具体的交易规则逻辑。</li></ul><hr><h2 id="二、-破局：引入“用户商品（UserProduct）”聚合根"><a href="#二、-破局：引入“用户商品（UserProduct）”聚合根" class="headerlink" title="二、 破局：引入“用户商品（UserProduct）”聚合根"></a>二、 破局：引入“用户商品（UserProduct）”聚合根</h2><p>为了解决上述问题，我们决定从业务场景出发，剥离出一个独立的领域模型——<strong>UserProduct（用户购买记录）</strong>。</p><h3 id="1-为什么不是直接查数据库？"><a href="#1-为什么不是直接查数据库？" class="headerlink" title="1. 为什么不是直接查数据库？"></a>1. 为什么不是直接查数据库？</h3><p>有人可能会问：<em>“如果只是判断买没买过，直接写一个 SQL <code>select count(1) from order where ...</code> 不行吗？”</em></p><ul><li><strong>简单的场景</strong>：如果规则仅仅是“一人终身一单”，数据库唯一索引确实够用。</li><li><strong>复杂的场景</strong>：业务需求往往是多变的，比如“一人一天最多买一单，但活动期间总共可以买五单”。</li></ul><p>这时候，我们需要一个<strong>聚合根（Aggregate Root）</strong>来封装这些变化的业务规则。<code>UserProduct</code> 聚合根不仅仅是一张表，它包含了校验逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPurchaseHistory</span> <span class="keyword">extends</span> <span class="title class_">AggregateRoot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String skuId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> todayCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> totalCount;</span><br><span class="line">    <span class="keyword">private</span> Date lastPurchaseTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 领域行为：校验并预占额度</span></span><br><span class="line">    <span class="comment">// 注意：这里只修改内存状态，后续由Application Service负责持久化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordPurchase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todayCount &gt;= <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DomainException</span>(<span class="string">&quot;今日限购已达上限&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (totalCount &gt;= <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DomainException</span>(<span class="string">&quot;活动限购已达上限&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.todayCount++;</span><br><span class="line">        <span class="built_in">this</span>.totalCount++;</span><br><span class="line">        <span class="built_in">this</span>.lastPurchaseTime = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 领域行为：回滚额度（用于补偿）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollbackPurchase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todayCount &gt; <span class="number">0</span>) <span class="built_in">this</span>.todayCount--;</span><br><span class="line">        <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span>) <span class="built_in">this</span>.totalCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们将复杂的限购规则<strong>内聚</strong>在了一个轻量级的聚合根中，查询快、逻辑清晰。</p><hr><h2 id="三、-架构设计：Redis预扣减与异步下单"><a href="#三、-架构设计：Redis预扣减与异步下单" class="headerlink" title="三、 架构设计：Redis预扣减与异步下单"></a>三、 架构设计：Redis预扣减与异步下单</h2><p>解决了“能不能买”的逻辑模型，接下来是“怎么买”的性能问题。在高并发下，直接操作数据库扣减库存是最大的瓶颈。</p><p>我们采用了 <strong>Check-Lock-Act</strong> 模式结合 <strong>Redis Lua</strong> 脚本来实现高效吞吐。</p><h3 id="核心流程设计"><a href="#核心流程设计" class="headerlink" title="核心流程设计"></a>核心流程设计</h3><h4 id="第一阶段：同步校验与预占资源（HTTP接口响应）"><a href="#第一阶段：同步校验与预占资源（HTTP接口响应）" class="headerlink" title="第一阶段：同步校验与预占资源（HTTP接口响应）"></a>第一阶段：同步校验与预占资源（HTTP接口响应）</h4><p>这一步的目标是抗住高并发，确保<strong>“进来的流量一定有库存，且用户有资格买”</strong>，并快速返回。</p><ol><li><p><strong>缓存前置校验（快速失败）</strong>：</p><ul><li>订单域维护一份<strong>Redis库存缓存</strong>（Key: <code>sku_stock:&#123;skuId&#125;</code>）。</li><li>请求进来先 <code>get(key)</code>，如果库存 &lt;= 0，直接抛出“商品已售罄”异常，拦截绝大部分无效流量。</li><li><em>缓存更新机制</em>：监听<strong>库存服务</strong>发布的 <code>StockChangedEvent</code>，或者通过Canal同步库存DB变化到Redis。</li></ul></li><li><p><strong>用户维度加锁（防刷单）</strong>：</p><ul><li>为了保证 <code>UserPurchaseHistory</code> 聚合根在并发场景下的数据一致性（防止同一个用户同时发10个请求绕过限购校验），需要加分布式锁。</li><li><strong>Lock Key</strong>: <code>lock:purchase:&#123;userId&#125;</code>。</li><li><em>注意</em>：锁的粒度是用户，不是全局锁，所以不影响不同用户的并发购买。（考虑到一个用户不会在同一个时间进行多个秒杀所以直接锁用户即可）</li></ul></li><li><p><strong>加载并校验用户资格</strong>：</p><ul><li>在锁内，从数据库加载 <code>UserPurchaseHistory</code> 聚合根。</li><li>执行 <code>userPurchaseHistory.recordPurchase()</code>。如果此时抛出异常（如限购），释放锁并返回错误。</li></ul></li><li><p><strong>Redis Lua 原子扣减库存</strong>：</p><ul><li>用户资格校验通过后，执行 <strong>Redis Lua 脚本</strong> 进行库存扣减。</li><li>Lua脚本逻辑：再次检查 Redis 库存是否足够，如果够则 <code>decr</code>，否则返回失败。</li><li><em>为什么还要查Redis？</em> 因为第1步的检查和第4步之间存在时间差，且Lua能保证扣减的原子性。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- simple_deduct.lua</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> qty = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> current = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, key))</span><br><span class="line"><span class="keyword">if</span> current <span class="keyword">and</span> current &gt;= qty <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, key, qty)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">-- 库存不足</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><strong>持久化与发布事件</strong>：</p><ul><li>如果Lua返回成功：<ul><li>保存更新后的 <code>UserPurchaseHistory</code> 到数据库（记录了用户买过）。</li><li>发布 <strong><code>PreOrderSuccessEvent</code>（预下单成功事件）</strong>。</li></ul></li><li><strong>事务性</strong>：保存聚合根和发布事件应在同一个本地事务中（或使用事务性发件箱模式）。</li></ul></li></ol><h4 id="第二阶段：异步落库与真实扣减（MQ消费者）"><a href="#第二阶段：异步落库与真实扣减（MQ消费者）" class="headerlink" title="第二阶段：异步落库与真实扣减（MQ消费者）"></a>第二阶段：异步落库与真实扣减（MQ消费者）</h4><p>订单服务作为消费者监听 <code>PreOrderSuccessEvent</code>，负责重资源的落地。</p><ol><li><p><strong>创建订单（Order Aggregate）</strong>：</p><ul><li>根据事件携带的数据，构建并保存 <code>Order</code> 聚合根到数据库。</li></ul></li><li><p><strong>数据库库存扣减</strong>：</p><ul><li>调用库存服务（或在订单服务内部）执行数据库层面的 <code>update stock set num = num - 1 where sku_id = ?</code>。</li><li><em>注意</em>：由于第一阶段Redis已经保证了库存足够，这里的数据库扣减理论上<strong>一定成功</strong>（除非数据不一致）。</li></ul></li><li><p><strong>清理操作</strong>：</p><ul><li>清空用户购物车对应商品。</li><li>发送“下单成功”通知给用户。</li></ul></li></ol><hr><h2 id="四、-异常处理与Saga补偿"><a href="#四、-异常处理与Saga补偿" class="headerlink" title="四、 异常处理与Saga补偿"></a>四、 异常处理与Saga补偿</h2><p>虽然Redis和DB通常能保持最终一致，但在极端情况下（如Redis扣了，但保存用户记录失败；或者第一阶段全成功，第二阶段DB挂了），系统会出现数据不一致。</p><p>我们需要设计<strong>补偿策略（Compensating Transaction）</strong>：</p><h3 id="场景-A：第一阶段中，Lua扣减成功，但保存-UserPurchaseHistory-失败"><a href="#场景-A：第一阶段中，Lua扣减成功，但保存-UserPurchaseHistory-失败" class="headerlink" title="场景 A：第一阶段中，Lua扣减成功，但保存 UserPurchaseHistory 失败"></a>场景 A：第一阶段中，Lua扣减成功，但保存 UserPurchaseHistory 失败</h3><ul><li><strong>现象</strong>：Redis库存少了，但用户没买成。</li><li><strong>处理</strong>：在 <code>catch</code> 块中，捕获数据库异常，立即异步执行 <strong>Redis库存回补</strong>（incr）。</li></ul><h3 id="场景-B：第二阶段中，订单创建或DB库存扣减失败"><a href="#场景-B：第二阶段中，订单创建或DB库存扣减失败" class="headerlink" title="场景 B：第二阶段中，订单创建或DB库存扣减失败"></a>场景 B：第二阶段中，订单创建或DB库存扣减失败</h3><ul><li><strong>现象</strong>：用户额度占了，Redis库存扣了，但没有生成订单。</li><li><strong>处理</strong>：<ol><li>消费端重试（Retry）。</li><li>如果重试达到上限仍失败，发布 <strong><code>OrderCreateFailedEvent</code></strong>。</li><li><strong>补偿监听器</strong>收到失败事件：<ul><li>调用 <code>UserPurchaseHistory.rollbackPurchase()</code> 并落库（恢复用户限购额度）。</li><li>对 Redis 库存进行 <code>incr</code> 操作（恢复缓存库存）。</li><li>通知用户下单失败。</li></ul></li></ol></li></ul><hr><h2 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h2><p>通过本次重构，我们明确了DDD在高性能场景下的落地方式：</p><ol><li><strong>模型分离</strong>：<code>UserProduct</code> 聚合根专门承载复杂的限购规则，与 <code>Order</code> 解耦。</li><li><strong>分层风控</strong>：<ul><li><strong>L1 缓存层</strong>：Redis Lua 脚本作为抗并发的“看门人”，精准拦截超卖流量。</li><li><strong>L2 逻辑层</strong>：用户粒度锁 + 聚合根逻辑，精准拦截违规购买。</li><li><strong>L3 数据层</strong>：异步落库，削峰填谷。</li></ul></li><li><strong>读写策略</strong>：<ul><li><strong>读</strong>：优先读缓存（Redis Stock）。</li><li><strong>写</strong>：先写缓存（Redis Decr），后异步写库（DB Insert/Update）。</li></ul></li></ol><p>这种“Redis预扣减 + 异步最终一致性”的方案，既保留了DDD的业务清晰度，又完美适配了互联网高并发的性能要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DDD实战-高并发下的“一人一单”与库存扣减&quot;&gt;&lt;a href=&quot;#DDD实战-高并发下的“一人一单”与库存扣减&quot; class=&quot;headerlink&quot; title=&quot;[DDD实战] 高并发下的“一人一单”与库存扣减&quot;&gt;&lt;/a&gt;[DDD实战] 高并发下的“一人一单</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>算法（十六） 区间DP</title>
    <link href="https://nmcb666.vip/posts/95975943.html"/>
    <id>https://nmcb666.vip/posts/95975943.html</id>
    <published>2026-02-07T13:37:09.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a>让字符串成为回文串的最少插入次数</h2><p>leetcode 1312</p><p>思路： 跟求最长回文子序列一样。dp[i][j] 表示 让s[i:j] 变成回文串的最少插入数。 如果 s[i] == s[j]，则 dp[i][j] = dp[i + 1][j - 1]  否则 dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1。 边界值dp[i][i] = 0 以及 dp[i][i + 1] = 1 if s[i] != s[i + 1] else 0 。最后还可以空间压缩，一个格子依赖它的左下，下面，左边3个格子。顺序为从下到上，从左到右。用leftDown记录左下的值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s1)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[n-<span class="number">1</span>] = s[n-<span class="number">2</span>] == s[n-<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftDown</span> <span class="operator">=</span> dp[i+<span class="number">1</span>],backUp;</span><br><span class="line">            <span class="comment">// dp[i] = 0</span></span><br><span class="line">            dp[i+<span class="number">1</span>] = s[i] == s[i+<span class="number">1</span>] ? <span class="number">0</span> :<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">2</span>;j&lt;n;j++)&#123;</span><br><span class="line">                backUp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                    dp[j] = leftDown;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j],dp[j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                leftDown = backUp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a>预测赢家</h2><p>leetcode 486</p><p>思路：dp[i][j]表示玩家1在i到j的区间内，能赢的最多分数。如果玩家1拿了i位置的数，那么玩家2只能拿i+1或者j位置的数，而玩家二应该选择能让玩家1拿更少的拿法。所以 <strong>p1 = nums[i] + Math.min(dp[i+2][j],dp[i+1][j-1]);</strong> 同理如果玩家1拿了j位置的数，那么玩家2只能拿i位置的数或者j-1位置的数，而玩家二应该选择能让玩家1拿更少的拿法。所以 <strong>p2 = nums[j] + Math.min(dp[i][j-2],dp[i+1][j-1]);</strong>  。 最后状态转移方程为 dp[i][j] = Math.max(p1,p2)；  初始化只有一个数的情况 dp[i][i] = nums[i]; 只有两个数的情况就拿最大的 dp[i][i+1] = Math.max(nums[i],nums[i+1]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">predictTheWinner</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) ==<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i][i] = nums[i];</span><br><span class="line">        sum +=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>] = Math.max(nums[i],nums[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">2</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[i] + Math.min(dp[i+<span class="number">2</span>][j],dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> nums[j] + Math.min(dp[i+<span class="number">1</span>][j-<span class="number">1</span>],dp[i][j-<span class="number">2</span>]);</span><br><span class="line">            dp[i][j] = Math.max(p1,p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>] &gt;= (sum - dp[<span class="number">0</span>][n-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边三角形剖分的最低得分"><a href="#多边三角形剖分的最低得分" class="headerlink" title="多边三角形剖分的最低得分"></a>多边三角形剖分的最低得分</h2><p>leetcode 1039</p><p>思路： dp[i][j] 表示 i到j的区间内，多边形能得到的最低得分。 dp[i][j] = Math.min(dp[i][k] + dp[k][j] + s[i]<em>s[j]</em>s[k]); k为i到j的区间内任意一个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minScoreTriangulation</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">2</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i+<span class="number">1</span>;m&lt;j;m++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][m]+dp[m][j]+ values[i]*values[j]*values[m],dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><p>套路：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-02-07%20183124.png" alt="套路"/></div><span class="image-caption">套路</span></div><h2 id="最大BST子树"><a href="#最大BST子树" class="headerlink" title="最大BST子树"></a>最大BST子树</h2><p>leetcode 333</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestBSTSubtree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(root).maxBstSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> max;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> min;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> isBst;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> maxBstSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">boolean</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">max = a;</span><br><span class="line">min = b;</span><br><span class="line">isBst = c;</span><br><span class="line">maxBstSize = d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">f</span><span class="params">(TreeNode x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(Long.MIN_VALUE, Long.MAX_VALUE, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Info</span> <span class="variable">infol</span> <span class="operator">=</span> f(x.left);</span><br><span class="line"><span class="type">Info</span> <span class="variable">infor</span> <span class="operator">=</span> f(x.right);</span><br><span class="line"><span class="comment">// 左 4信息</span></span><br><span class="line"><span class="comment">// 右 4信息</span></span><br><span class="line"><span class="comment">// x 整合出4信息返回</span></span><br><span class="line"><span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(x.val, Math.max(infol.max, infor.max));</span><br><span class="line"><span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(x.val, Math.min(infol.min, infor.min));</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isBst</span> <span class="operator">=</span> infol.isBst &amp;&amp; infor.isBst &amp;&amp; infol.max &lt; x.val &amp;&amp; x.val &lt; infor.min;</span><br><span class="line"><span class="type">int</span> maxBSTSize;</span><br><span class="line"><span class="keyword">if</span> (isBst) &#123;</span><br><span class="line">maxBSTSize = infol.maxBstSize + infor.maxBstSize + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxBSTSize = Math.max(infol.maxBstSize, infor.maxBstSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(max, min, isBst, maxBSTSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大BST子树和"><a href="#最大BST子树和" class="headerlink" title="最大BST子树和"></a>最大BST子树和</h2><p>leetcode 1317</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交如下的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(root).maxBstSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="comment">// 为什么这里的max和min是int类型？</span></span><br><span class="line"><span class="comment">// 因为题目的数据量规定，</span></span><br><span class="line"><span class="comment">// 节点值在[-4 * 10^4，4 * 10^4]范围</span></span><br><span class="line"><span class="comment">// 所以int类型的最小值和最大值就够用了</span></span><br><span class="line"><span class="comment">// 不需要用long类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> max;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> min;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> sum;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> isBst;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> maxBstSum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">boolean</span> d, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">max = a;</span><br><span class="line">min = b;</span><br><span class="line">sum = c;</span><br><span class="line">isBst = d;</span><br><span class="line">maxBstSum = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">f</span><span class="params">(TreeNode x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(Integer.MIN_VALUE, Integer.MAX_VALUE, <span class="number">0</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Info</span> <span class="variable">infol</span> <span class="operator">=</span> f(x.left);</span><br><span class="line"><span class="type">Info</span> <span class="variable">infor</span> <span class="operator">=</span> f(x.right);</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(x.val, Math.max(infol.max, infor.max));</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(x.val, Math.min(infol.min, infor.min));</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> infol.sum + infor.sum + x.val;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isBst</span> <span class="operator">=</span> infol.isBst &amp;&amp; infor.isBst &amp;&amp; infol.max &lt; x.val &amp;&amp; x.val &lt; infor.min;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxBstSum</span> <span class="operator">=</span> Math.max(infol.maxBstSum, infor.maxBstSum);</span><br><span class="line"><span class="keyword">if</span> (isBst) &#123;</span><br><span class="line">maxBstSum = Math.max(maxBstSum, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(max, min, sum, isBst, maxBstSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在二叉树中分配硬币"><a href="#在二叉树中分配硬币" class="headerlink" title="在二叉树中分配硬币"></a>在二叉树中分配硬币</h2><p>leetcode 979</p><p>思路：每棵树需要的信息是总节点数，总硬币数，移动次数。 那么对于父节点只需要把左树多的硬币移动到右树去，加上左右的次数返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">int</span> nodeSum;</span><br><span class="line">    <span class="type">int</span> moSum;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> nodeSum,<span class="type">int</span> moSum,<span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nodeSum = nodeSum;</span><br><span class="line">        <span class="built_in">this</span>.moSum = moSum;</span><br><span class="line">        <span class="built_in">this</span>.cnt = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCoins</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findDBC(root).cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Info <span class="title function_">findDBC</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> findDBC(root.left);</span><br><span class="line">    <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> findDBC(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeSum</span> <span class="operator">=</span> left.nodeSum + right.nodeSum + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">moSum</span> <span class="operator">=</span> left.moSum + right.moSum + root.val;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> Math.abs(left.nodeSum - left.moSum) + Math.abs(right.nodeSum - right.moSum) + left.cnt + right.cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(nodeSum,moSum,cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h2><p>思路：跟leetcode上的打家劫舍3一样。每个节点选择偷跟不偷。如果偷那么子节点只能不偷。不偷那么子节点可以偷也可以不偷求最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">6001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">6000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] boss = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        Arrays.fill(head,<span class="number">0</span>,n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        Arrays.fill(boss,<span class="number">0</span>,n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        boss[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="type">int</span> no;</span><br><span class="line">        <span class="type">int</span> yes;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">            no = a;</span><br><span class="line">            yes = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span>(in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>)in.nval;</span><br><span class="line">            build(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                in.nextToken(); weight[i] = (<span class="type">int</span>)in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)&#123;</span><br><span class="line">                in.nextToken(); u = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); v = (<span class="type">int</span>) in.nval;</span><br><span class="line">                add(v,u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">Boss</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//找到头节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(boss[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    Boss = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Info</span> <span class="variable">ans</span> <span class="operator">=</span> compute(Boss);</span><br><span class="line">            out.println(Math.max(ans.no,ans.yes));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">compute</span><span class="params">(<span class="type">int</span> node)</span>&#123;</span><br><span class="line">        <span class="comment">//没有出边</span></span><br><span class="line">        <span class="keyword">if</span>(head[node] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>,weight[node]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yes</span> <span class="operator">=</span> weight[node];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[node];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">            <span class="type">Info</span> <span class="variable">p</span> <span class="operator">=</span> compute(to[ie]);</span><br><span class="line">            no+=Math.max(p.yes,p.no);</span><br><span class="line">            yes+=p.no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(no,yes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>leetcode 968</p><p>思路：其实这道题代码并不难，难的是思路。我们给每个节点赋予三种状态： 0，1，2。 0表示当前节点没有被监控，1表示当前节点被监控，但是没有摄像头，2表示当前节点被监控且安装了摄像头。</p><ol><li>如果一个节点的左右两个节点有一个状态为0，那么这个节点必须安装摄像头，返回2状态，不然他的孩子就永远无法被监控。</li><li>如果两个孩子有一个有摄像头，那自己就返回1状态，因为自己被监控了</li><li>如果两个孩子都被监控了但是没有摄像头（都是1状态）。那么自己就以0状态返回。那这时候为什么不给自己装个摄像头呢？因为自己就只会让父节点跟自己两个节点被新监控到，但是如果把装摄像头的机会让给父节点，那么这个摄像头就有可能覆盖更多的节点。</li></ol><p>综上一个节点的状态返回依赖两个孩子的状态，这就是典型的树形dp。 初始化空节点为1状态即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> findMCC(root) == <span class="number">0</span> ? ans+<span class="number">1</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMCC</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> findMCC(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> findMCC(node.right);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">2</span> || right == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h1><p>状态dp就是在带记忆化搜索的时候，把路径信息用二进制表示。一般路径信息不会很大，小于20个可以考虑状态dp。有点像用位运算的n皇后。</p><h2 id="我能赢吗"><a href="#我能赢吗" class="headerlink" title="我能赢吗"></a>我能赢吗</h2><p>leetcode 464</p><p>思路：用一个status表示当前拿数的状态。 比如 0011011 表示第1，2，4，5的数字还没拿其他已经拿了。然后dfs(int status,int res ,int[] dp) 表示在当前状态下，还剩余res的和的情况下，先手能不能赢。那么只用枚举剩下的数字，如果拿了这个数字之后让对方先手不能赢，那么自己就可以赢。然后dp[]表示，在当前这个状态下，先手能不能赢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canIWin</span><span class="params">(<span class="type">int</span> maxChoosableInteger, <span class="type">int</span> desiredTotal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (desiredTotal == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 来自题目规定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxChoosableInteger * (maxChoosableInteger + <span class="number">1</span>) / <span class="number">2</span> &lt; desiredTotal) &#123;</span><br><span class="line">            <span class="comment">// 如果1~n数字全加起来</span></span><br><span class="line">            <span class="comment">// 累加和和是n * (n+1) / 2，都小于m</span></span><br><span class="line">            <span class="comment">// 那么不会有赢家，也就意味着先手不会获胜</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> (<span class="number">1</span>&lt;&lt;maxChoosableInteger) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>&lt;&lt;(maxChoosableInteger)];</span><br><span class="line">        <span class="keyword">return</span> findCIW(status,desiredTotal,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findCIW</span><span class="params">(<span class="type">int</span> status,<span class="type">int</span> res,<span class="type">int</span>[] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[status] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[status] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> status;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> temp &amp; (-temp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>,m=pos;</span><br><span class="line">            <span class="keyword">while</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">                m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp ^= pos;</span><br><span class="line">            <span class="keyword">if</span>(!findCIW(status ^ pos,res - n,dp))&#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[status] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="火柴拼接正方形"><a href="#火柴拼接正方形" class="headerlink" title="火柴拼接正方形"></a>火柴拼接正方形</h2><p>Leetcode 473</p><p>思路: 就是按dfs的思路。staus表示当前剩余的火柴，len表示当前拼接的边长,res表示还需要几条边。依次枚举每个剩下的火柴，如果火柴加上当前边长，那么下次递归就len = 0,res = res-1。如果小于那下次递归就 len = len + 火柴长度 ，res = res。 如果大于那就不会要这个火柴。当火柴用完的时候看边品完没有即可。dp[]表示在当前状态下能不能拼出剩余的正方形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : m) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">4</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> (<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>&lt;&lt;n];</span><br><span class="line">        <span class="keyword">return</span> findMQ(m,status,<span class="number">0</span>,sum/<span class="number">4</span>,<span class="number">4</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findMQ</span><span class="params">(<span class="type">int</span>[] m,<span class="type">int</span> status,<span class="type">int</span> len,<span class="type">int</span> limit,<span class="type">int</span> res,<span class="type">int</span>[] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[status] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[status] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次枚举还能拿的火柴</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> status;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> temp &amp; (-temp);</span><br><span class="line">            <span class="type">int</span> n=-<span class="number">1</span>,k=pos;</span><br><span class="line">            <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">                k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//n就是能拿的火柴</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> m[n];</span><br><span class="line">            temp ^= pos;</span><br><span class="line">            <span class="keyword">if</span>(slen + len == limit)&#123;</span><br><span class="line">                ans = findMQ(m,status ^ pos,<span class="number">0</span>,limit,res-<span class="number">1</span>,dp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(slen + len &lt; limit)&#123;</span><br><span class="line">                ans = findMQ(m,status^pos,slen+len,limit,res,dp);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[status] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区间DP&quot;&gt;&lt;a href=&quot;#区间DP&quot; class=&quot;headerlink&quot; title=&quot;区间DP&quot;&gt;&lt;/a&gt;区间DP&lt;/h1&gt;&lt;h2 id=&quot;让字符串成为回文串的最少插入次数&quot;&gt;&lt;a href=&quot;#让字符串成为回文串的最少插入次数&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka为什么这么快</title>
    <link href="https://nmcb666.vip/posts/4b1bdc5.html"/>
    <id>https://nmcb666.vip/posts/4b1bdc5.html</id>
    <published>2026-02-07T13:32:58.000Z</published>
    <updated>2026-02-22T12:13:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计"><a href="#深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计" class="headerlink" title="深度解析：为什么 Kafka 能快到“突破天际”？—— 论 Kafka 的机械共鸣设计"></a>深度解析：为什么 Kafka 能快到“突破天际”？—— 论 Kafka 的机械共鸣设计</h1><p>在分布式系统领域，Apache Kafka 几乎是高性能消息队列的代名词。令人惊叹的是，作为一个<strong>基于磁盘存储</strong>的系统，Kafka 的吞吐量竟然能超越许多基于内存的数据库。</p><p>很多人将其归结为“快”，但这种快并不是某种单一的黑科技，而是一场<strong>对硬件特性的极致压榨</strong>。这种设计思想在计算机科学中被称为 <strong>“机械共鸣”</strong> —— 即了解底层硬件的工作原理，并让软件设计顺应这些原理。</p><p>本文将从五个核心维度，拆解 Kafka 性能神话背后的技术思考。</p><hr><h3 id="一、-颠覆认知：磁盘并不慢，随机读写才慢"><a href="#一、-颠覆认知：磁盘并不慢，随机读写才慢" class="headerlink" title="一、 颠覆认知：磁盘并不慢，随机读写才慢"></a>一、 颠覆认知：磁盘并不慢，随机读写才慢</h3><p>很多人对 Kafka 的第一个疑问是：“数据存磁盘上，怎么可能快？”</p><p>事实上，磁盘的<strong>顺序写（Sequential Writing）</strong>性能极高。在某些场景下，磁盘顺序写的速度甚至可以媲美随机内存读写。</p><ul><li><strong>Kafka 的做法</strong>：Kafka 将所有消息以 <strong>Append-only（仅追加）</strong> 的方式写入日志文件（Log）。它不执行任何随机位置的更新，也不删除单条数据。</li><li><strong>技术思考</strong>：通过将“逻辑上的随机写”转换为“物理上的顺序写”，Kafka 绕过了磁盘磁头寻道的最大延迟。这种简单到极致的追加设计，是其写入性能的基础。</li></ul><h3 id="二、-零拷贝（Zero-Copy）：减少-CPU-的“搬运工”工作"><a href="#二、-零拷贝（Zero-Copy）：减少-CPU-的“搬运工”工作" class="headerlink" title="二、 零拷贝（Zero-Copy）：减少 CPU 的“搬运工”工作"></a>二、 零拷贝（Zero-Copy）：减少 CPU 的“搬运工”工作</h3><p>在传统的网络传输中，数据从磁盘到网卡需要经历 <strong>4 次拷贝</strong>和 <strong>4 次上下文切换</strong>。</p><ol><li>磁盘 -&gt; 内核缓冲区</li><li>内核缓冲区 -&gt; 用户空间应用缓冲区（CPU 参与）</li><li>用户空间应用缓冲区 -&gt; 内核 Socket 缓冲区（CPU 参与）</li><li>Socket 缓冲区 -&gt; 网卡</li></ol><ul><li><strong>Kafka 的优化</strong>：Kafka 利用了 Linux 内核的 <code>sendfile</code> 系统调用。数据直接从<strong>内核页缓存（Page Cache）</strong>传输到<strong>网卡</strong>，跳过了用户空间。</li><li><strong>技术思考</strong>：这意味着数据在传输过程中不需要经过 Java 堆内存，不仅减少了 CPU 消耗，更重要的是<strong>彻底消除了 JVM 的垃圾回收（GC）压力</strong>。对于海量数据流，不进 JVM 才是最快的。</li></ul><h3 id="三、-页缓存（Page-Cache）-vs-JVM-缓存"><a href="#三、-页缓存（Page-Cache）-vs-JVM-缓存" class="headerlink" title="三、 页缓存（Page Cache） vs JVM 缓存"></a>三、 页缓存（Page Cache） vs JVM 缓存</h3><p>传统的 Java 应用喜欢在内存中维护各种 Cache。但 Kafka 反其道而行之：它几乎不自己管理缓存，而是完全交由操作系统的 <strong>Page Cache</strong> 处理。</p><ul><li><strong>带来的红利</strong>：<ul><li><strong>内存利用率更高</strong>：Page Cache 由内核管理，避免了对象存储在 JVM 堆中带来的额外内存开销（Header, Padding 等）。</li><li><strong>热数据直达</strong>：如果消费者紧跟生产者的脚步，消息直接从内存中读取，根本不会产生真实的磁盘 I/O。</li><li><strong>容错性</strong>：即使 Kafka 进程崩溃，数据依然在系统缓存中，重启后依然可以立即通过缓存提供服务。</li></ul></li></ul><h3 id="四、-网络通信的艺术：多级-Reactor-模型"><a href="#四、-网络通信的艺术：多级-Reactor-模型" class="headerlink" title="四、 网络通信的艺术：多级 Reactor 模型"></a>四、 网络通信的艺术：多级 Reactor 模型</h3><p>Kafka 的网络层是高性能并发处理的典范。它采用了<strong>基于 Java NIO 的多级 Reactor 模型</strong>：</p><ol><li><strong>Acceptor</strong>：只负责接收连接。</li><li><strong>Processor 线程池</strong>：负责处理 I/O 读写。每个线程维护一个 Selector，并发管理成千上万个连接。</li><li><strong>RequestHandler 线程池</strong>：解耦网络 I/O 与业务逻辑。</li></ol><ul><li><strong>技术思考</strong>：这种设计实现了<strong>读写分离</strong>。即便某个请求因为磁盘压力变慢，Processor 线程依然可以继续接收其他连接的数据，不会导致整个系统的网络阻塞。</li></ul><h3 id="五、-批量化与压缩：压榨每一比特带宽"><a href="#五、-批量化与压缩：压榨每一比特带宽" class="headerlink" title="五、 批量化与压缩：压榨每一比特带宽"></a>五、 批量化与压缩：压榨每一比特带宽</h3><p>在高性能系统中，网络往返（RTT）和系统调用的开销往往比数据处理本身更贵。</p><ul><li><strong>批量（Batching）</strong>：Kafka 允许生产者将多条消息打包成一个 Batch 发送。对 Broker 来说，一次 I/O 操作写入的是一批消息，大大减少了系统调用次数。</li><li><strong>压缩（Compression）</strong>：Kafka 支持端到端的压缩（Producer 压缩 -&gt; Broker 存储 -&gt; Consumer 解压）。</li><li><strong>技术思考</strong>：在现代系统中，带宽往往比 CPU 更珍贵。通过在 Producer 端消耗少量 CPU 进行压缩，换取更小的网络延迟和存储空间，是一笔极其划算的买卖。</li></ul><hr><h3 id="总结：Kafka-给我们的架构启示"><a href="#总结：Kafka-给我们的架构启示" class="headerlink" title="总结：Kafka 给我们的架构启示"></a>总结：Kafka 给我们的架构启示</h3><p>Kafka 的成功并非源于它发明了什么深奥的算法，而在于它对<strong>操作系统基础原语</strong>的深刻理解：</p><ol><li><strong>顺应硬件</strong>：既然随机 I/O 慢，就只用顺序 I/O。</li><li><strong>相信系统</strong>：既然内核管缓存管得好，就不要在 JVM 里重复造轮子。</li><li><strong>减少损耗</strong>：既然搬运数据浪费 CPU，就用零拷贝绕过去。</li><li><strong>分而治之</strong>：既然单机有上限，就通过分区（Partitioning）实现横向扩展。</li></ol><p><strong>“快”的本质，其实是消除浪费。</strong> Kafka 的架构告诉我们：有时候，为了获得极致的性能，你不需要做得更多，而是要学会“少做”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计&quot;&gt;&lt;a href=&quot;#深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计&quot; class=&quot;headerlink&quot; title=&quot;深度解析：为</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java中的NIO就是操作系统的同步非阻塞IO吗？</title>
    <link href="https://nmcb666.vip/posts/9edb0695.html"/>
    <id>https://nmcb666.vip/posts/9edb0695.html</id>
    <published>2026-02-07T02:26:33.000Z</published>
    <updated>2026-02-22T12:13:28.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”"><a href="#Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”" class="headerlink" title="Java NIO：不仅仅是“非阻塞”，更是 IO 模型的“Pro Max”"></a>Java NIO：不仅仅是“非阻塞”，更是 IO 模型的“Pro Max”</h1><p>在 Java 后端面试或高并发系统设计的讨论中，<strong>NIO (New I/O)</strong> 永远是一个绕不开的话题。</p><p>很多同学在初学时，往往会被教科书上的定义绕晕：</p><ul><li>“NIO 是同步非阻塞的。”</li><li>“NIO 有三大组件：Channel、Buffer、Selector。”</li><li>“NIO 性能比 BIO 好。”</li></ul><p>但如果继续追问：“为什么非阻塞就快？Selector 到底是个什么东西？它和操作系统的 epoll 有什么关系？”很多人可能就卡壳了。</p><p>今天我们就从<strong>操作系统的底层模型</strong>出发，来聊聊 Java NIO 的前世今生，以及为什么我说它是 IO 模型的“Pro Max”版。</p><h2 id="1-痛点：BIO-时代的“贵族服务”"><a href="#1-痛点：BIO-时代的“贵族服务”" class="headerlink" title="1. 痛点：BIO 时代的“贵族服务”"></a>1. 痛点：BIO 时代的“贵族服务”</h2><p>在 JDK 1.4 之前，我们使用的是 BIO（Blocking I/O，阻塞 IO）。<br>BIO 的编程模型非常简单符合直觉：<strong>建立连接 -&gt; 读数据 -&gt; 写数据</strong>。</p><p>但是它有一个致命的弱点：<strong>阻塞</strong>。<br>就像一个传统的餐厅，<strong>每一桌客人（Socket 连接）必须配备一名专属服务员（Thread）</strong>。</p><ul><li>客人看菜单（数据未就绪），服务员就得傻站在旁边等着，什么都不能干。</li><li>客人吃饭（数据传输中），服务员还是得等着。</li></ul><p><strong>后果是显而易见的：</strong><br>如果餐厅来了 1 万桌客人，老板就需要雇佣 1 万个服务员。在计算机世界里，线程是昂贵的资源，内存占用高、上下文切换开销大。这种“一对一”的贵族服务模式，注定了 BIO 无法支撑高并发。</p><h2 id="2-误区：NIO-就是“非阻塞”吗？"><a href="#2-误区：NIO-就是“非阻塞”吗？" class="headerlink" title="2. 误区：NIO 就是“非阻塞”吗？"></a>2. 误区：NIO 就是“非阻塞”吗？</h2><p>为了解决阻塞问题，操作系统引入了 <strong>Non-blocking I/O（非阻塞 IO）</strong> 的概念。很多人认为 Java NIO 指的就是这个。</p><p><strong>并不完全是。</strong></p><p>如果仅仅把 Socket 设置为非阻塞（Non-blocking），模型是这样的：</p><ul><li>用户线程发起读取请求。</li><li>内核看了一眼：没数据。立刻返回一个错误（EWOULDBLOCK）。</li><li>用户线程不死心，过一会儿再来问，还没有，再返回错误。</li></ul><p>这在技术上叫<strong>“轮询”（Polling）</strong>。<br>这就好比服务员不傻站着了，他在餐厅里跑来跑去，不停地问每一桌：“你要点菜吗？你要点菜吗？”</p><p>虽然线程没被卡死，但 CPU 却在空转（Busy Waiting）。每一次询问都是一次用户态到内核态的切换，这种<strong>“用户态轮询”</strong>效率极低，甚至比 BIO 还糟糕。</p><h2 id="3-破局：IO-多路复用"><a href="#3-破局：IO-多路复用" class="headerlink" title="3. 破局：IO 多路复用"></a>3. 破局：IO 多路复用</h2><p>Java NIO 的真正威力，不仅仅在于“非阻塞”，而在于它引入了 <strong>Selector（选择器）</strong>。</p><p>Selector 的本质，是利用了操作系统的 <strong>I/O 多路复用（I/O Multiplexing）</strong> 技术。<br>这才是真正的 <strong>Pro Max</strong> 进化。</p><h3 id="什么是多路复用？"><a href="#什么是多路复用？" class="headerlink" title="什么是多路复用？"></a>什么是多路复用？</h3><p>复用，是指<strong>多个连接复用同一个线程</strong>。<br>在这个模型下，餐厅不再需要几千个服务员，也不需要一个服务员像没头苍蝇一样轮询。我们引入了一个<strong>“智能管家”（Selector）</strong>。</p><ol><li><strong>注册：</strong> 所有的桌子（Channel）都在管家那里登记：“我有事会按铃，没按铃别烦我。”</li><li><strong>监听：</strong> 管家在吧台坐着，只听铃声（事件）。</li><li><strong>处理：</strong> 只有当某一桌按铃了（数据就绪），管家才通知服务员过去处理。</li></ol><h3 id="这里的关键点在于：谁在轮询？"><a href="#这里的关键点在于：谁在轮询？" class="headerlink" title="这里的关键点在于：谁在轮询？"></a>这里的关键点在于：谁在轮询？</h3><ul><li><strong>普通非阻塞 IO：</strong> 是<strong>用户程序</strong>在轮询（低效）。</li><li><strong>IO 多路复用（Java NIO）：</strong> 是<strong>操作系统内核</strong>在帮你轮询（高效）。</li></ul><h2 id="4-底层黑科技：从-select-到-epoll"><a href="#4-底层黑科技：从-select-到-epoll" class="headerlink" title="4. 底层黑科技：从 select 到 epoll"></a>4. 底层黑科技：从 select 到 epoll</h2><p>Java NIO 的 Selector 只是一个 Java API，它的性能取决于底层的操作系统实现。</p><ul><li><strong>JDK 1.4 / 早期 Linux：</strong> 使用 <code>select</code> 或 <code>poll</code> 模型。<ul><li>这就像管家虽然不跑了，但他手里拿个长长的单子（1万个连接）。每次有人按铃，他都要从头到尾检查一遍单子：“是谁按的铃？”（时间复杂度 O(N)）。</li></ul></li><li><strong>JDK 1.5+ / 现代 Linux：</strong> 使用 <strong>epoll</strong> 模型。<ul><li>Epoll 是<strong>事件驱动</strong>的。它在内核里维护了一个“就绪列表”。</li><li>谁按铃，硬件中断直接把谁的名字扔进“就绪列表”。</li><li>管家只需要看一眼“就绪列表”里有没有人就行了，根本不需要遍历那 1 万个连接。（时间复杂度 O(1)）。</li></ul></li></ul><p><strong>所以，当我们说 Java NIO 高性能时，默认是在 Linux 环境下，因为其底层依托于 epoll 强大的事件驱动能力。</strong></p><h2 id="5-总结与思考"><a href="#5-总结与思考" class="headerlink" title="5. 总结与思考"></a>5. 总结与思考</h2><p>回答标题的问题：<br><strong>Java NIO 是什么？</strong><br>它是一套工具包，它引入了 Buffer（内存管理）、Channel（双向通道），但其灵魂是 <strong>Selector</strong>。</p><p><strong>它是 IO 多路复用吗？</strong><br>Java NIO 的 Selector 是 <strong>IO 多路复用</strong> 在 JVM 层面的封装。而在 Linux 上，它最终进化为 <strong>epoll</strong>，解决了传统轮询的性能瓶颈。</p><p><strong>技术思考图谱：</strong></p><ol><li><strong>BIO</strong> = 阻塞 + 多线程（资源耗尽）</li><li><strong>OS NIO</strong> = 非阻塞 + 用户态轮询（CPU 空转）</li><li><strong>Java NIO (Selector)</strong> = 非阻塞 + <strong>IO 多路复用</strong> (内核态轮询/事件驱动) = <strong>高并发的基石</strong></li></ol><p>理解了这一点，你再去看 Netty 这种框架，就会明白它为什么这么快：因为它不仅把 Java NIO 难用的 API 封装好了，还通过 Reactor 模型将这种“多路复用”的优势发挥到了极致。</p><h2 id="补充说明，操作系统的NIO跟多路复用的区别"><a href="#补充说明，操作系统的NIO跟多路复用的区别" class="headerlink" title="补充说明，操作系统的NIO跟多路复用的区别"></a>补充说明，操作系统的NIO跟多路复用的区别</h2><p>NIO就是用户进程轮询，多路复用是内核里面的选择器去轮询。这正是区分 <strong>“单纯的非阻塞 IO（OS NIO）”</strong> 和 <strong>“IO 多路复用”</strong> 最核心的界限：<strong>苦力活（轮询）到底是谁在干？</strong></p><h3 id="1-单纯的-OS-NIO-用户进程在轮询"><a href="#1-单纯的-OS-NIO-用户进程在轮询" class="headerlink" title="1. 单纯的 OS NIO = 用户进程在轮询"></a>1. 单纯的 OS NIO = 用户进程在轮询</h3><p><strong>“用户进程自己去轮询”</strong>。</p><ul><li><strong>场景：</strong> 你写了一个 <code>while(true)</code> 循环。</li><li><strong>动作：</strong> 你的代码里遍历 1000 个 Socket，挨个调用系统函数 <code>read()</code>。</li><li><strong>对话：</strong><ul><li>用户：“Socket A 有数据吗？” -&gt; 内核：“没。”（上下文切换 1 次）</li><li>用户：“Socket B 有数据吗？” -&gt; 内核：“没。”（上下文切换 1 次）</li><li>…</li><li>用户：“Socket Z 有数据吗？” -&gt; 内核：“没。”（上下文切换 1 次）</li></ul></li><li><strong>代价：</strong><ul><li><strong>CPU 瞎忙：</strong> 你的进程跑得飞快，CPU 占用率 100%，但全是空转。</li><li><strong>系统开销巨大：</strong> 每一次 <code>read()</code> 都是一次 <strong>用户态 &lt;-&gt; 内核态</strong> 的切换。1000 次循环就是 1000 次切换，这简直是性能杀手。</li></ul></li></ul><h3 id="2-IO-多路复用-内核在轮询-监控"><a href="#2-IO-多路复用-内核在轮询-监控" class="headerlink" title="2. IO 多路复用 = 内核在轮询/监控"></a>2. IO 多路复用 = 内核在轮询/监控</h3><p><strong>“内核里面的选择器去轮询”</strong>。</p><ul><li><strong>场景：</strong> 你把 1000 个 Socket 打包，调用一次 <code>select()</code> 或 <code>epoll_wait()</code>。</li><li><strong>动作：</strong> 你的进程此时<strong>休息了</strong>（阻塞在这一行），把监控的任务甩锅给内核。</li><li><strong>对话：</strong><ul><li>用户：“内核，这 1000 个兄弟你帮我盯着，谁有数据了叫醒我。” -&gt; <strong>（只有 1 次上下文切换）</strong></li><li>… （用户睡觉，内核在干活） …</li><li>内核：“醒醒！Socket C 和 Socket F 有数据了！” -&gt; <strong>（再切换 1 次回来）</strong></li></ul></li><li><strong>收益：</strong><ul><li><strong>用户态不忙了：</strong> 用户进程不需要写死循环，不需要做无意义的系统调用。</li><li><strong>切换次数极少：</strong> 从 N 次切换变成了 1 次切换。</li></ul></li></ul><hr><h3 id="还有一个深层次的细节（关于-epoll）"><a href="#还有一个深层次的细节（关于-epoll）" class="headerlink" title="还有一个深层次的细节（关于 epoll）"></a>还有一个深层次的细节（关于 epoll）</h3><p>“内核选择器去轮询”，这对于 <code>select</code> 和 <code>poll</code> 是完全正确的。</p><p>但对于 <strong>epoll</strong>，内核甚至<strong>都不用轮询</strong>，它更高级：</p><ul><li><strong>select/poll（内核轮询）：</strong> 内核在一个死循环里检查这 1000 个 Socket 的状态。（虽然比用户态轮询快，但内核也很累）。</li><li><strong>epoll（内核回调）：</strong> 内核根本不轮询。它在网卡驱动上注册了<strong>回调函数</strong>。<ul><li>网卡收到数据 -&gt; 触发硬件中断 -&gt; 触发回调 -&gt; <strong>直接把有数据的那个 Socket 扔进“就绪列表”</strong>。</li><li>内核只需要看一眼那个列表是不是空的就行了。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><strong>NIO（指 OS 原始非阻塞）是用户态自己在死循环检查；</strong><br><strong>多路复用是把这个检查的动作挪到了内核态（由 select 轮询或 epoll 事件驱动），从而解放了用户进程。</strong></p></blockquote><p>这也是为什么 Java NIO（使用多路复用）比单纯使用非阻塞 Socket 性能高出几个数量级的原因。</p><hr><blockquote><p><strong>写在最后</strong><br>技术名词层出不穷，但底层的原理往往是通用的。从 BIO 到 NIO 的演进，本质上是<strong>为了压榨 CPU 性能，减少无效等待和上下文切换</strong>。理解了“谁在等”和“谁在问”，就理解了高并发 IO 的核心。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”&quot;&gt;&lt;a href=&quot;#Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”&quot; class=&quot;headerlink&quot; title=&quot;Java NIO：不仅仅是“非阻塞”</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法（十五） 背包dp</title>
    <link href="https://nmcb666.vip/posts/2707a2f4.html"/>
    <id>https://nmcb666.vip/posts/2707a2f4.html</id>
    <published>2026-02-05T16:34:22.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="基础背包"><a href="#基础背包" class="headerlink" title="基础背包"></a>基础背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[weight+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=weight;j&gt;=nums[i-<span class="number">1</span>];j--)&#123;</span><br><span class="line">        dp[j] = Math.max(dp[j-nums[i-<span class="number">1</span>]]+nums[i-<span class="number">1</span>],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[weight];</span><br></pre></td></tr></table></figure><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>leetcode 494</p><p>思路：见代码注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新思路，转化为01背包问题</span></span><br><span class="line"><span class="comment">// 思考1:</span></span><br><span class="line"><span class="comment">// 虽然题目说nums是非负数组，但即使nums中有负数比如[3,-4,2]</span></span><br><span class="line"><span class="comment">// 因为能在每个数前面用+或者-号</span></span><br><span class="line"><span class="comment">// 所以[3,-4,2]其实和[3,4,2]会达成一样的结果</span></span><br><span class="line"><span class="comment">// 所以即使nums中有负数，也可以把负数直接变成正数，也不会影响结果</span></span><br><span class="line"><span class="comment">// 思考2:</span></span><br><span class="line"><span class="comment">// 如果nums都是非负数，并且所有数的累加和是sum</span></span><br><span class="line"><span class="comment">// 那么如果target&gt;sum，很明显没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line"><span class="comment">// 思考3:</span></span><br><span class="line"><span class="comment">// nums内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性</span></span><br><span class="line"><span class="comment">// 所以，如果所有数的累加和是sum，并且与target的奇偶性不一样</span></span><br><span class="line"><span class="comment">// 那么没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line"><span class="comment">// 思考4(最重要):</span></span><br><span class="line"><span class="comment">// 比如说给定一个数组, nums = [1, 2, 3, 4, 5] 并且 target = 3</span></span><br><span class="line"><span class="comment">// 其中一个方案是 : +1 -2 +3 -4 +5 = 3</span></span><br><span class="line"><span class="comment">// 该方案中取了正的集合为A = &#123;1，3，5&#125;</span></span><br><span class="line"><span class="comment">// 该方案中取了负的集合为B = &#123;2，4&#125;</span></span><br><span class="line"><span class="comment">// 所以任何一种方案，都一定有 sum(A) - sum(B) = target</span></span><br><span class="line"><span class="comment">// 现在我们来处理一下这个等式，把左右两边都加上sum(A) + sum(B)，那么就会变成如下：</span></span><br><span class="line"><span class="comment">// sum(A) - sum(B) + sum(A) + sum(B) = target + sum(A) + sum(B)</span></span><br><span class="line"><span class="comment">// 2 * sum(A) = target + 数组所有数的累加和</span></span><br><span class="line"><span class="comment">// sum(A) = (target + 数组所有数的累加和) / 2</span></span><br><span class="line"><span class="comment">// 也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2</span></span><br><span class="line"><span class="comment">// 那么就一定对应一种target的方式</span></span><br><span class="line"><span class="comment">// 比如非负数组nums，target = 1, nums所有数累加和是11</span></span><br><span class="line"><span class="comment">// 求有多少方法组成1，其实就是求，有多少种子集累加和达到6的方法，(1+11)/2=6</span></span><br><span class="line"><span class="comment">// 因为，子集累加和6 - 另一半的子集累加和5 = 1(target)</span></span><br><span class="line"><span class="comment">// 所以有多少个累加和为6的不同集合，就代表有多少个target==1的表达式数量</span></span><br><span class="line"><span class="comment">// 至此已经转化为01背包问题了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">sum += n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> subsets(nums, (target + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求非负数组nums有多少个子序列累加和是t</span></span><br><span class="line"><span class="comment">// 01背包问题(子集累加和严格是t) + 空间压缩</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123; <span class="comment">// i省略了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= num; j--) &#123;</span><br><span class="line">dp[j] += dp[j - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h2><p>leetcode 1049</p><p>思路：转化为找出一个数组中最接近和的一半的子序列和。答案就是sum - 2 * 子序列和，找最接近和的一半的子序列和就是01背包问题。背包容量为一半，然后找出价值最高的子序列和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">        sum+=stone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">near</span> <span class="operator">=</span> findLSW(stones,sum/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> sum - near - near;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLSW</span><span class="params">(<span class="type">int</span>[] stones, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=stone;j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-stone]+stone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>同一个组的物品只能选一个，求最大价值。</p><p>思路：还是分为要跟不要。但是要的情况需要讨论要一组里的哪一个。所以dp[i][j] 中的i表示物品组，j表示背包容量。开始时可以按组号排序，一组一组处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">teams</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i - <span class="number">1</span>][<span class="number">2</span>] != arr[i][<span class="number">2</span>]) &#123;</span><br><span class="line">teams++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组的编号1~teams</span></span><br><span class="line"><span class="comment">// dp[i][j] : 1~i是组的范围，每个组的物品挑一件，容量不超过j的情况下，最大收益</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[teams + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// dp[0][....] = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>, i = <span class="number">1</span>; start &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start ... end-1 -&gt; i组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="comment">// arr[start...end-1]是当前组，组号一样</span></span><br><span class="line"><span class="comment">// 其中的每一件商品枚举一遍</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line"><span class="comment">// k是组内的一个商品编号</span></span><br><span class="line"><span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - arr[k][<span class="number">0</span>]] + arr[k][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start去往下一组的第一个物品</span></span><br><span class="line"><span class="comment">// 继续处理剩下的组</span></span><br><span class="line">start = end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[teams][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][...] = 0</span></span><br><span class="line">Arrays.fill(dp, <span class="number">0</span>, m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>; start &lt;= n;) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start....end-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], arr[k][<span class="number">1</span>] + dp[j - arr[k][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">start = end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从栈中取出k个硬币的最大面值和"><a href="#从栈中取出k个硬币的最大面值和" class="headerlink" title="从栈中取出k个硬币的最大面值和"></a>从栈中取出k个硬币的最大面值和</h2><p>leetcode 2218</p><p>思路：以一个栈里面的硬币为分组。一组里面的元素就是拿一个硬币，两个硬币，三个硬币…得到的面值。一组我也只能拿一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// piles是一组一组的硬币</span></span><br><span class="line"><span class="comment">// m是容量，表示一定要进行m次操作</span></span><br><span class="line"><span class="comment">// dp[i][j] : 1~i组上，一共拿走j个硬币的情况下，获得的最大价值</span></span><br><span class="line"><span class="comment">// 1) 不要i组的硬币 : dp[i-1][j]</span></span><br><span class="line"><span class="comment">// 2) i组里尝试每一种方案</span></span><br><span class="line"><span class="comment">// 比如，i组里拿走前k个硬币的方案 : dp[i-1][j-k] + 从顶部开始前k个硬币的价值和</span></span><br><span class="line"><span class="comment">// 枚举每一个k，选出最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins1</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.size();</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">// i从1组开始（我们的设定），但是题目中的piles是从下标0开始的</span></span><br><span class="line"><span class="comment">// 所以来到i的时候，piles.get(i-1)是当前组</span></span><br><span class="line">List&lt;Integer&gt; team = piles.get(i - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.min(team.size(), m);</span><br><span class="line"><span class="comment">// 预处理前缀和，为了加速计算</span></span><br><span class="line"><span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">sum += team.get(j);</span><br><span class="line">preSum[j + <span class="number">1</span>] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新动态规划表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="comment">// 当前组一个硬币也不拿的方案</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= Math.min(t, j); k++) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k] + preSum[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (List&lt;Integer&gt; team : piles) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.min(team.size(), m);</span><br><span class="line"><span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">sum += team.get(j);</span><br><span class="line">preSum[j + <span class="number">1</span>] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= Math.min(t, j); k++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - k] + preSum[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="模板题-1"><a href="#模板题-1" class="headerlink" title="模板题"></a>模板题</h2><p>一个物品可以重复取，求最大价值。</p><p>dp[i][j] = Max(dp[i-1][j],dp[i][j-w[i]]+v[i]) //拿了之后i也不减一，就可以拿多次。空间压缩需要正着遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// 会空间不够，导致无法通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][.....] = 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="comment">// 可以通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>, t + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cost[i]; j &lt;= t; j++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>leetcode 10</p><p>思路：在dfs注解里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch1</span><span class="params">(String str, String pat)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] p = pat.toCharArray();</span><br><span class="line"><span class="keyword">return</span> f1(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s[i....]能不能被p[j....]完全匹配出来</span></span><br><span class="line"><span class="comment">// p[j]这个字符，一定不是&#x27;*&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line"><span class="comment">// s没了</span></span><br><span class="line"><span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line"><span class="comment">// 如果p也没了，返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// p还剩下一些后缀</span></span><br><span class="line"><span class="comment">// 如果p[j+1]是*，那么p[j..j+1]可以消掉，然后看看p[j+2....]是不是都能消掉</span></span><br><span class="line"><span class="keyword">return</span> j + <span class="number">1</span> &lt; p.length &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f1(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line"><span class="comment">// s有后缀</span></span><br><span class="line"><span class="comment">// p没后缀了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// s有后缀</span></span><br><span class="line">    <span class="comment">// p有后缀</span></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> == p.length || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// s[i....]</span></span><br><span class="line"><span class="comment">// p[j....]</span></span><br><span class="line"><span class="comment">// 如果p[j+1]不是*，那么当前的字符必须能匹配：(s[i] == p[j] || p[j] == &#x27;?&#x27;)</span></span><br><span class="line"><span class="comment">// 同时，后续也必须匹配上：process1(s, p, i + 1, j + 1);</span></span><br><span class="line"><span class="keyword">return</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f1(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果p[j+1]是*</span></span><br><span class="line"><span class="comment">// 完全背包！</span></span><br><span class="line"><span class="comment">// s[i....]</span></span><br><span class="line"><span class="comment">// p[j....]</span></span><br><span class="line"><span class="comment">// 选择1: 当前p[j..j+1]是x*，就是不让它搞定s[i]，那么继续 : process1(s, p, i, j + 2)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">p1</span> <span class="operator">=</span> f1(s, p, i, j + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 选择2: 当前p[j..j+1]是x*，如果可以搞定s[i]，那么继续 : process1(s, p, i + 1, j)</span></span><br><span class="line"><span class="comment">// 如果可以搞定s[i] : (s[i] == p[j] || p[j] == &#x27;.&#x27;)</span></span><br><span class="line"><span class="comment">// 继续匹配 : process1(s, p, i + 1, j)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">p2</span> <span class="operator">=</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f1(s, p, i + <span class="number">1</span>, j);</span><br><span class="line"><span class="comment">// 两个选择，有一个可以搞定就返回true，都无法搞定返回false</span></span><br><span class="line"><span class="keyword">return</span> p1 || p2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s1, String p1)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = p1.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// s到头了 ， p还没结束</span></span><br><span class="line">        dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            dp[n][j] = j+<span class="number">1</span> &lt; m &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普遍情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> == m || p[j+<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || ( (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h2><p>leetcode 44</p><p>思路： 还是一样的。先初始化边界条件。然后如果遇到不是’<em>‘ 就正常判断 dp[i][j] = dp[i+1][j+1] &amp;&amp; (s[i] == p[j] || p[j] == ‘？’);’ 。遇到</em>就是完全背包问题，可以用<em>匹配一个之后不移动j , 也可以直接跳过 </em>。 dp[i][j] = dp[i][j+1] || dp[i+1][j];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s1, String p1)</span> &#123;</span><br><span class="line">     <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">     <span class="type">char</span>[] p = p1.toCharArray();</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">     <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">     <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">     <span class="comment">//填s1完了但p1没完</span></span><br><span class="line">    dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        dp[n][j] = p[j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普遍情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//不是* 就正常递推</span></span><br><span class="line">                dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line">                dp[i][j] = dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="干草问题"><a href="#干草问题" class="headerlink" title="干草问题"></a>干草问题</h2><p>购买足量干草的最小花费</p><p>有n个提供干草的公司，每个公司都有两个信息</p><p>cost[i]代表购买1次产品需要花的钱</p><p>val[i]代表购买1次产品所获得的干草数量</p><p>每个公司的产品都可以购买任意次</p><p>你一定要至少购买h数量的干草，返回最少要花多少钱</p><p>测试链接 : <a href="https://www.luogu.com.cn/problem/P2918">https://www.luogu.com.cn/problem/P2918</a></p><p>思路：还是完全背包但是定义dp。 dp[i][j] 表示1….i公司购买严格等于j份甘草时花费最小。 那么最后只用遍历 h 到 m 找出最小值即可。 m = h + max(val[i])。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] : 1...i里挑公司，购买严格j磅干草，需要的最少花费</span></span><br><span class="line"><span class="comment">// 1) dp[i-1][j]</span></span><br><span class="line"><span class="comment">// 2) dp[i][j-val[i]] + cost[i]</span></span><br><span class="line"><span class="comment">// 两种可能性中选最小</span></span><br><span class="line"><span class="comment">// 但是关于j需要进行一定的扩充，原因视频里讲了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>, m + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - val[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j - val[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j], dp[i][j - val[i]] + cost[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// &gt;= h</span></span><br><span class="line"><span class="comment">// h h+1 h+2 ... m</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h; j &lt;= m; j++) &#123;</span><br><span class="line">ans = Math.min(ans, dp[n][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>, m + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> val[i]; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[j - val[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[j] = Math.min(dp[j], dp[j - val[i]] + cost[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h; j &lt;= m; j++) &#123;</span><br><span class="line">ans = Math.min(ans, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包问题：就是有数量限制的完全背包。每个物品有一定数量，不能无限拿。</p><p>思路：每到一个物品就枚举拿多少个的情况，求出最大值即可。但这里没用枚举优化可能会超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n * t * 每种商品的平均个数)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][....] = 0，表示没有货物的情况下，背包容量不管是多少，最大价值都是0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= c[i] &amp;&amp; w[i] * k &lt;= j; k++) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k * w[i]] + k * v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="comment">// 部分测试用例超时</span></span><br><span class="line"><span class="comment">// 因为没有优化枚举</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n * t * 每种商品的平均个数)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= c[i] &amp;&amp; w[i] * k &lt;= j; k++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - k * w[i]] + k * v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制分组优化枚举。假如一个货物有13个，那么可以拆分为 1，2，4，6 。然后将这四个数看出四个物品即可。转化为了01背包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">       <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">       <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">       a=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">           n = (<span class="type">int</span>)in.nval;</span><br><span class="line">           in.nextToken(); W = (<span class="type">int</span>) in.nval;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,v,w,m;i&lt;=n;i++)&#123;</span><br><span class="line">               in.nextToken(); v = (<span class="type">int</span>) in.nval;</span><br><span class="line">               in.nextToken(); w = (<span class="type">int</span>) in.nval;</span><br><span class="line">               in.nextToken(); m = (<span class="type">int</span>) in.nval;</span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; m&gt;=j ; j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                   val[a] =  v*j;</span><br><span class="line">                   weight[a++] = w*j;</span><br><span class="line">                   m-=j;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   val[a] = m*v;</span><br><span class="line">                   weight[a++] = w*m;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           out.println(compute());</span><br><span class="line">       &#125;</span><br><span class="line">       out.flush();</span><br><span class="line">       out.close();</span><br><span class="line">       br.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01背包</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">       Arrays.fill(dp,<span class="number">0</span>,W+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W;j&gt;=weight[i];j--)&#123;</span><br><span class="line">               dp[j] = Math.max(dp[j],dp[j-weight[i]]+val[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[W];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h1&gt;&lt;h2 id=&quot;基础背包&quot;&gt;&lt;a href=&quot;#基础背包&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（十四）动态规划</title>
    <link href="https://nmcb666.vip/posts/915e2077.html"/>
    <id>https://nmcb666.vip/posts/915e2077.html</id>
    <published>2026-02-02T19:58:44.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<p>关于动态规划内容很多，这里只列举一些我觉都有意思的题目。</p><h1 id="二维简单动态规划"><a href="#二维简单动态规划" class="headerlink" title="二维简单动态规划"></a>二维简单动态规划</h1><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>leetcode 64</p><p>思路：状态转移方程：f[i][j] = Math.min(f[i-1][j],f[i][j-1]) + grid[i][j] 因为一个位置只能从上或者左转移过来，所以状态转移方程就是这个样子的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i] = grid[<span class="number">0</span>][i]+dp[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>]+=grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">           dp[j] = Math.min(dp[j-<span class="number">1</span>],dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>leetcode 1143</p><p>思路：状态转移方程：f[i][j] = if(s1[i]==s2[j]) f[i-1][j-1]+1 else max(f[i-1][j],f[i][j-1])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s1 = text1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] s2 = text2.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>s1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>leetcode 516</p><p>思路：第一种思路，把原字符串翻转，然后求最长子序列。</p><p>第二种思路，二维dp,记录从l到r的回文子序列的长度。 初始化dp[i][i] = 1;,dp[i][i+1] = s[i] == s[i+1] ? 2 : 1; 每个格子依赖于左下，下，左边的格子。于是dp的顺序就是从下到上，从左到右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n-<span class="number">1</span>;l&gt;=<span class="number">0</span>;l--)&#123;</span><br><span class="line">        dp[l][l] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            dp[l][l+<span class="number">1</span>] = c[l] == c[l+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l+<span class="number">2</span>;r&lt;n;r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[r] == c[l])&#123;</span><br><span class="line">                dp[l][r] = dp[l+<span class="number">1</span>][r-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[l][r] = Math.max(dp[l+<span class="number">1</span>][r],dp[l][r-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>leetcode 115</p><p>思路：dp[i][j] 表示s1的前i个字符，s2的前j个字符，有多少个不同的子序列。 那么当s1[i]==s2[j] 时，dp[i][j] = dp[i-1][j-1]+dp[i-1][j] 否则dp[i][j] = dp[i-1][j]<br>然后初始化dp[i][0] = 1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= Math.min(i,n-<span class="number">1</span>); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.min(i,n); j &gt;=<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>leetcode 72 在此基础上新增了每种操作的代价。</p><p>思路：dp[i][j]含义为需要多少代价才能使得s1前i个字符和s2前j个字符相等。当s1[i] == s2[j]时，dp[i][j] = dp[i-1][j-1] 此时不用任何操作。如果不相等，就可以进行三种操作。</p><ol><li>插入s1[i]， 但需要s1前i个字符和s2前j-1个字符相等。就是dp[i][j-1]。最后加上插入代价 + a</li><li>删除s1[i]， 但需要s1前i-1个字符和s2前j个字符相等。就是dp[i-1][j]。最后加上删除代价 + b</li><li>替换s1[i]， 但需要s1前i-1个字符和s2前j-1个字符相等。就是dp[i-1][j-1]。最后加上替换代价 + c</li></ol><p>初始化时dp[0][j] = j <em> a（因为从空字符串到s2只能插入）; dp[i][0] = i </em> b（从s1到空字符串只能删除）;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistance2</span><span class="params">(String str1, String str2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line"><span class="comment">// dp[i][j] :</span></span><br><span class="line"><span class="comment">// s1[前缀长度为i]想变成s2[前缀长度为j]，至少付出多少代价</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + b, dp[i][j - <span class="number">1</span>] + a), dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//空间压缩</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fff</span><span class="params">(<span class="type">char</span>[] s1, <span class="type">char</span>[] s2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">           dp[i] = i*a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">leftup</span> <span class="operator">=</span> dp[<span class="number">0</span>] ,backup;</span><br><span class="line">           dp[<span class="number">0</span>] = i*b;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">               backup = dp[j];</span><br><span class="line">               <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                   dp[j] = leftup;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   dp[j] = Math.min(Math.min(dp[j-<span class="number">1</span>]+a,dp[j]+b),leftup+c);</span><br><span class="line">               &#125;</span><br><span class="line">               leftup = backup;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h2><p>leetcode 97</p><p>思路： dp[i][j]表示s1的前i个字符和s2的前j个字符是否可以交错组成s3的前i+j个字符。然后判断</p><ol><li>如果s1[i-1] == s3[i+j-1]，说明是s1提供了最后一个字符，那么此时我就保证s1的前i-1个字符和s2的前j个字符可以交错组成s3的前i+j-1个字符。即dp[i-1][j];</li><li>如果s2[j-1] == s3[i+j-1]，说明是s2提供了最后一个字符，那么此时我就保证s1的前i个字符和s2的前j-1个字符可以交错组成s3的前i+j-1个字符。即dp[i][j-1];</li></ol><p>初始化： dp[i][0] 表示 s2不参与拼接，就是纯靠s1去拼接s3的前i个字符。 dp[0][j] 表示 s1不参与拼接，就是纯靠s2去拼接s3的前j个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave1</span><span class="params">(String str1, String str2, String str3)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str1.length() + str2.length() != str3.length()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s3 = str3.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line"><span class="comment">// dp[i][j]:</span></span><br><span class="line"><span class="comment">// s1[前缀长度为i]和s2[前缀长度为j]，能否交错组成出s3[前缀长度为i+j]</span></span><br><span class="line"><span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i - <span class="number">1</span>] != s3[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s2[j - <span class="number">1</span>] != s3[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[i][j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子数组和相关问题"><a href="#子数组和相关问题" class="headerlink" title="子数组和相关问题"></a>子数组和相关问题</h1><h2 id="子数组最大和"><a href="#子数组最大和" class="headerlink" title="子数组最大和"></a>子数组最大和</h2><p>leetcode 53</p><p>思路：dp[i]表示以i为结尾的子数组的和最大是多少。那么dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// dp[i] : 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和</span></span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre = nums[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">pre = Math.max(nums[i], pre + nums[i]);</span><br><span class="line">ans = Math.max(ans, pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环数组中子数组的最大和"><a href="#循环数组中子数组的最大和" class="headerlink" title="循环数组中子数组的最大和"></a>循环数组中子数组的最大和</h2><p>leetcode 918</p><p>思路：求子数组最大和跟最小和即可。用sum - minSum 就是分开的子数组的最大和。 但需要特判一下是不是全是负数的情况.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>] ,minSum = nums[<span class="number">0</span>],preMax=nums[<span class="number">0</span>],preMin=nums[<span class="number">0</span>],sum=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        preMax = Math.max(preMax+nums[i],nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum,preMax);</span><br><span class="line">        preMin = Math.min(preMin+nums[i],nums[i]);</span><br><span class="line">        minSum = Math.min(minSum,preMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == minSum ? maxSum : (Math.max(maxSum, sum - minSum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍2"><a href="#打家劫舍2" class="headerlink" title="打家劫舍2"></a>打家劫舍2</h2><p>leetcode 213</p><p>思路：分开讨论即可，要么不偷第一家，在2-n之间偷，要么偷第一家，在1-n-1之间偷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分开讨论</span></span><br><span class="line">    <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不拿第一家</span></span><br><span class="line">    dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp1[<span class="number">2</span>] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不拿最后一家</span></span><br><span class="line">    dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp2[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp1[n],dp2[n-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍4"><a href="#打家劫舍4" class="headerlink" title="打家劫舍4"></a>打家劫舍4</h2><p>leetcode 2560</p><p>思路：二分+dp。 转化为给定能力，小偷最多偷多少家即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCapability</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        max = Math.max(nums[i],max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>max;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f(nums,mid,k))&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> cap,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = cap &gt;= nums[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &gt; cap)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] &gt;= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>leetcode 152</p><p>思路：dp1[i] 表示以i为结尾的子数组乘积最大是多少。dp2[i] 表示以i为结尾的子数组乘积最小是多少。 每次正在一个位置比较最小值乘以自己，最大值乘以自己，跟自己的大小即可。并且更新dp1[i]，dp2[i]。  代码直接给出空间压缩版本.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        temp = max;</span><br><span class="line">        temp = Math.max(Math.max(max*nums[i],min*nums[i]),nums[i]);</span><br><span class="line">        min = Math.min(Math.min(min*nums[i],max*nums[i]),nums[i]);</span><br><span class="line">        max = temp;</span><br><span class="line">        ans = Math.max(max,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="被7整除的最大子序列和"><a href="#被7整除的最大子序列和" class="headerlink" title="被7整除的最大子序列和"></a>被7整除的最大子序列和</h2><p>思路：dp[i][j] 表示以第i个数为结尾，模数为j的子序列和最大是多少。那么dp[i][j] = dp[i-1][j]  或者 dp[i-1][(j+7-nums[i-1]%7)%7] + nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// dp[i][j] : nums[0...i-1]</span></span><br><span class="line"><span class="comment">// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j</span></span><br><span class="line"><span class="comment">// 这样的子序列最大累加和是多少</span></span><br><span class="line"><span class="comment">// 注意 : dp[i][j] == -1代表不存在这样的子序列</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">7</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, x, cur, need; i &lt;= n; i++) &#123;</span><br><span class="line">x = nums[i - <span class="number">1</span>];</span><br><span class="line">cur = nums[i - <span class="number">1</span>] % <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="comment">// 这里求need是核心</span></span><br><span class="line">need = cur &lt;= j ? (j - cur) : (j - cur + <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 或者如下这种写法也对</span></span><br><span class="line"><span class="comment">// need = (7 + j - cur) % 7;</span></span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][need] != -<span class="number">1</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][need] + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以翻转1次的情况下子数组最大累加和"><a href="#可以翻转1次的情况下子数组最大累加和" class="headerlink" title="可以翻转1次的情况下子数组最大累加和"></a>可以翻转1次的情况下子数组最大累加和</h2><p>给定一个数组nums，</p><p>现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整</p><p>比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]</p><p>返回必须随意翻转1次之后，子数组的最大累加和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumReverse2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// start[i] : 所有必须以i开头的子数组中，最大累加和是多少</span></span><br><span class="line"><span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">start[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// nums[i]</span></span><br><span class="line"><span class="comment">// nums[i] + start[i+1]</span></span><br><span class="line">start[i] = Math.max(nums[i], nums[i] + start[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> start[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// end : 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// maxEnd :</span></span><br><span class="line"><span class="comment">// 0~i-1范围上，</span></span><br><span class="line"><span class="comment">// 子数组必须以0结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// 子数组必须以1结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// 所有情况中，最大的那个累加和就是maxEnd</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// maxend   i....</span></span><br><span class="line"><span class="comment">// 枚举划分点 i...</span></span><br><span class="line">ans = Math.max(ans, maxEnd + start[i]);</span><br><span class="line"><span class="comment">// 子数组必须以i结尾，其中的最大累加和</span></span><br><span class="line">end = Math.max(nums[i], end + nums[i]);</span><br><span class="line">maxEnd = Math.max(maxEnd, end);</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(ans, maxEnd);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最长递增子序列相关题目"><a href="#最长递增子序列相关题目" class="headerlink" title="最长递增子序列相关题目"></a>最长递增子序列相关题目</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>leetcode 300</p><p>思路：最基础的复杂度O(n^2)，优化版本</p><p>维护一个ends[]数组，表示ends[i]表示长度为i+1的递增子序列的最小末尾元素。那么以后我要新增一个元素，那么我需要二分找到大于等于这个元素的最左位置，然后更新这个位置的元素为这个元素。如果没找到，那么就插入到数组末尾。并且len++。最后返回len即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n * logn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line"><span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">find = bs1(ends, len, nums[i]);</span><br><span class="line"><span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">ends[len++] = nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ends[find] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line"><span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line"><span class="comment">// 如果不存在返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="俄罗斯套娃信封"><a href="#俄罗斯套娃信封" class="headerlink" title="俄罗斯套娃信封"></a>俄罗斯套娃信封</h2><p>leetcode 354</p><p>思路：先将宽高进行排序，按宽度升序，高度降序。然后对于高度求最长递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    Arrays.sort(envelopes,(a,b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> bs1(ends,len,envelopes[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(find == -<span class="number">1</span>)&#123;</span><br><span class="line">            ends[len++] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ends[find] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ends[mid] &gt;= target)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长对数链"><a href="#最长对数链" class="headerlink" title="最长对数链"></a>最长对数链</h2><p>leetcode 646</p><p>思路：每个数对按第一个数降序排列。然后求最长递增子序列。但是注意，这里在二分查找的时候，查找跟放入的不是一个数。按开始位置进行查找，但是放入自己的结束位置，所以不能直接放入，应该判断跟原位置的大小（因为这里只能知道开始的值是小于等于找到的位置的，结束值跟这个位置的大小关系不确定）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ends[mid] &gt;= target)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLongestChain</span><span class="params">(<span class="type">int</span>[][] pairs)</span> &#123;</span><br><span class="line">    Arrays.sort(pairs,(a,b)-&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>pairs.length;</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//根据开始值进行二分查找 找个大于等于自己的最左位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> bs1(ends,len,pairs[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(find == -<span class="number">1</span>)&#123;</span><br><span class="line">            ends[len++] = pairs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里不能直接放入 而是应该判断跟原位置的大小关系</span></span><br><span class="line">            ends[find] = Math.min(pairs[i][<span class="number">1</span>],ends[find]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于动态规划内容很多，这里只列举一些我觉都有意思的题目。&lt;/p&gt;
&lt;h1 id=&quot;二维简单动态规划&quot;&gt;&lt;a href=&quot;#二维简单动态规划&quot; class=&quot;headerlink&quot; title=&quot;二维简单动态规划&quot;&gt;&lt;/a&gt;二维简单动态规划&lt;/h1&gt;&lt;h2 id=&quot;最小路径和</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我们讨论分布式中的一致性到底是什么</title>
    <link href="https://nmcb666.vip/posts/2db9d40c.html"/>
    <id>https://nmcb666.vip/posts/2db9d40c.html</id>
    <published>2026-02-02T12:22:49.000Z</published>
    <updated>2026-02-22T12:13:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？"><a href="#分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？" class="headerlink" title="分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？"></a>分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？</h1><p>在技术圈里摸爬滚打，你一定听过无数次“分布式系统”这个词，也背过无数次 CAP 定理、BASE 理论。</p><p>但你是否在某个深夜调试代码时感到困惑：</p><ul><li><em>“为什么 Seata 的文档里在谈一致性，Raft 的论文里也在谈一致性，但我总感觉它们说的不是一回事？”</em></li><li><em>“微服务拆分后的一致性，和 Redis 集群的一致性，是一样的吗？”</em></li></ul><p>其实，你的直觉是对的。<strong>“分布式系统”这个词是个大筐，里面装了两个完全不同的流派。</strong> 它们虽然都叫分布式，都追求一致性，但它们的灵魂截然不同。</p><p>今天，我们就把这两个流派拆开来看一看。</p><hr><h2 id="流派一：为了“分工与解耦”-——-分布式计算-服务化"><a href="#流派一：为了“分工与解耦”-——-分布式计算-服务化" class="headerlink" title="流派一：为了“分工与解耦” —— 分布式计算/服务化"></a>流派一：为了“分工与解耦” —— 分布式计算/服务化</h2><p>这个流派的典型代表是 <strong>微服务架构（Spring Cloud, Dubbo, gRPC）</strong>。</p><h3 id="1-它的本质：从“一个人干”变成“一群人干”"><a href="#1-它的本质：从“一个人干”变成“一群人干”" class="headerlink" title="1. 它的本质：从“一个人干”变成“一群人干”"></a>1. 它的本质：从“一个人干”变成“一群人干”</h3><p>在这个流派里，我们把一个巨大的单体应用（Monolith）拆成了订单服务、库存服务、支付服务。</p><ul><li><strong>目的：</strong> 为了解耦，为了让不同的团队开发不同的模块，为了逻辑清晰。</li><li><strong>物理形态：</strong> 哪怕每个服务只部署在一台机器上（没有副本），它依然是标准的分布式系统。</li></ul><h3 id="2-这个流派的“痛点”：事务（Transaction）"><a href="#2-这个流派的“痛点”：事务（Transaction）" class="headerlink" title="2. 这个流派的“痛点”：事务（Transaction）"></a>2. 这个流派的“痛点”：事务（Transaction）</h3><p>因为业务逻辑被拆散到了不同的机器上，原本在单机数据库里一个 <code>Begin Transaction ... Commit</code> 就能搞定的事，现在变成了跨越网络的难题。</p><ul><li><strong>场景：</strong> 支付服务扣了钱，库存服务却因为报错没扣库存。</li><li><strong>后果：</strong> 账不平了，老板发火了。</li></ul><h3 id="3-这里的一致性：事务一致性-ACID"><a href="#3-这里的一致性：事务一致性-ACID" class="headerlink" title="3. 这里的一致性：事务一致性 (ACID)"></a>3. 这里的一致性：事务一致性 (ACID)</h3><p>当我们在这个流派下讨论“一致性”时，我们指的是 <strong>“多步操作的原子性”</strong>。</p><ul><li><strong>核心定义：</strong> 一连串的操作，要么全做完，要么全不做，不能停在中间。</li><li><strong>学术术语：</strong> <strong>可串行化 (Serializability)</strong>。</li><li><strong>解决方案：</strong><ul><li><strong>强一致性（刚性事务）：</strong> 比如 <strong>XA/2PC</strong>。通过长时间加锁，保证在事务结束前，外界谁也看不见中间状态。</li><li><strong>最终一致性（柔性事务）：</strong> 比如 <strong>Seata 的 AT/TCC 模式</strong>，或者基于消息队列的 <strong>Saga 模式</strong>。为了性能，允许外界看到短暂的中间状态（脏读/预扣），但保证最终数据是对齐的。</li></ul></li></ul><blockquote><p><strong>一句话总结：</strong> 这里的“一致性”，是<strong>逻辑与时间</strong>的保卫战，防止业务逻辑跑偏。</p></blockquote><hr><h2 id="流派二：为了“生存与扩容”-——-分布式存储-副本"><a href="#流派二：为了“生存与扩容”-——-分布式存储-副本" class="headerlink" title="流派二：为了“生存与扩容” —— 分布式存储/副本"></a>流派二：为了“生存与扩容” —— 分布式存储/副本</h2><p>这个流派的典型代表是 <strong>Redis Cluster, HDFS, Cassandra, Zookeeper, TiDB</strong>。</p><h3 id="1-它的本质：从“一份数据”变成“多份副本”"><a href="#1-它的本质：从“一份数据”变成“多份副本”" class="headerlink" title="1. 它的本质：从“一份数据”变成“多份副本”"></a>1. 它的本质：从“一份数据”变成“多份副本”</h3><p>在这个流派里，我们要解决的不是逻辑复杂的问题，而是机器不可靠的问题。我们把同一份数据（State）复制到 A、B、C 三台机器上。</p><ul><li><strong>目的：</strong> 为了高可用（A 挂了 B 顶上）和高性能（读写分离）。</li><li><strong>物理形态：</strong> 必须是多节点集群，且持有数据副本。</li></ul><h3 id="2-这个流派的“痛点”：同步（Replication）"><a href="#2-这个流派的“痛点”：同步（Replication）" class="headerlink" title="2. 这个流派的“痛点”：同步（Replication）"></a>2. 这个流派的“痛点”：同步（Replication）</h3><p>既然有副本，就涉及到了“我改了 A，B 什么时候改”的问题。</p><ul><li><strong>场景：</strong> 用户在这个毫秒往主节点写了“x=10”，下一个毫秒去从节点读“x”。</li><li><strong>后果：</strong> 如果同步慢了，用户读到了旧值“x=5”，用户会觉得系统在骗人。</li></ul><h3 id="3-这里的一致性：数据一致性-CAP"><a href="#3-这里的一致性：数据一致性-CAP" class="headerlink" title="3. 这里的一致性：数据一致性 (CAP)"></a>3. 这里的一致性：数据一致性 (CAP)</h3><p>当我们在这个流派下讨论“一致性”时，我们指的是 <strong>“多个副本的实时同步”</strong>。</p><ul><li><strong>核心定义：</strong> 写入成功后，所有的副本是否能立刻读到最新值？</li><li><strong>学术术语：</strong> <strong>线性一致性 (Linearizability)</strong>。</li><li><strong>解决方案：</strong> 这就是 <strong>CAP 定理</strong> 的主场。<ul><li><strong>CP (强一致)：</strong> 像 <strong>Zookeeper, Etcd, TiKV</strong>。为了保证所有节点数据一样，必须使用 Paxos/Raft 协议，甚至在网络分区时牺牲可用性（拒绝服务）。</li><li><strong>AP (高可用)：</strong> 像 <strong>Eureka, Cassandra</strong>。为了保证服务永远能连上，允许不同节点暂时数据不一样（最终一致）。</li></ul></li></ul><blockquote><p><strong>一句话总结：</strong> 这里的“一致性”，是<strong>空间与物理</strong>的保卫战，防止数据分身乏术。</p></blockquote><hr><h2 id="终极对决：一张表看懂区别"><a href="#终极对决：一张表看懂区别" class="headerlink" title="终极对决：一张表看懂区别"></a>终极对决：一张表看懂区别</h2><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">流派一：微服务/分布式事务</th><th style="text-align:left">流派二：分布式存储/副本</th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left"><strong>怎么把事情做对？</strong> (Transaction)</td><td style="text-align:left"><strong>怎么把数据存对？</strong> (Storage)</td></tr><tr><td style="text-align:left"><strong>典型组件</strong></td><td style="text-align:left">Spring Cloud, Seata, RocketMQ</td><td style="text-align:left">Redis, Zookeeper, MySQL主从</td></tr><tr><td style="text-align:left"><strong>一致性学术名</strong></td><td style="text-align:left"><strong>Serializability (可串行化)</strong></td><td style="text-align:left"><strong>Linearizability (线性一致性)</strong></td></tr><tr><td style="text-align:left"><strong>关注点</strong></td><td style="text-align:left"><strong>原子性 (Atomicity)</strong> <br> 要么全成功，要么全失败。</td><td style="text-align:left"><strong>可见性 (Visibility)</strong> <br> 写完能不能立刻读到？</td></tr><tr><td style="text-align:left"><strong>指导理论</strong></td><td style="text-align:left"><strong>ACID, BASE</strong></td><td style="text-align:left"><strong>CAP, PACELC</strong></td></tr><tr><td style="text-align:left"><strong>强一致意味着</strong></td><td style="text-align:left">加锁，直到整个业务流程结束，别人<strong>看不见中间状态</strong>。</td><td style="text-align:left">同步，写入主节点成功后，从节点<strong>必须也是新值</strong>。</td></tr><tr><td style="text-align:left"><strong>常见算法</strong></td><td style="text-align:left">2PC, 3PC, TCC</td><td style="text-align:left">Paxos, Raft, Gossip</td></tr></tbody></table></div><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所以，下次当你和别人争论“这个系统是不是强一致性”的时候，先停下来问一句：</p><p><strong>“哥们，我们现在是在聊业务逻辑的原子性（流派一），还是在聊数据库副本的同步（流派二）？”</strong></p><ul><li>如果是前者，<strong>Seata 的 AT 模式</strong> 虽然叫“最终一致性”，但它解决的是<strong>业务</strong>的一致性。 <strong>Seata 的 XA 模式</strong> 是‘强一致性’，解决的是也是<strong>业务</strong>的强一致性。</li><li>如果是后者，<strong>Redis 的主从异步复制</strong> 虽然也叫“最终一致性”，但它解决的是<strong>数据副本</strong>的一致性。<strong>Raft算法</strong> 是‘强一致性’，解决的是<strong>数据副本</strong>的强一致性。</li></ul><p><strong>分布式系统没有银弹，只有权衡（Trade-off）。</strong> 理解了这两个流派的区别，你才能在架构设计中，准确地选择你手中的武器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？&quot;&gt;&lt;a href=&quot;#分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的“人格分裂”：当我们在谈论一致性时，我们</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（十三） 图</title>
    <link href="https://nmcb666.vip/posts/ad899ecc.html"/>
    <id>https://nmcb666.vip/posts/ad899ecc.html</id>
    <published>2026-02-01T22:20:20.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建图的几种方式-邻接矩阵、邻接表、链式前向星"><a href="#建图的几种方式-邻接矩阵、邻接表、链式前向星" class="headerlink" title="建图的几种方式 邻接矩阵、邻接表、链式前向星"></a>建图的几种方式 邻接矩阵、邻接表、链式前向星</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点的最大数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的最大数量</span></span><br><span class="line"><span class="comment">// 只有链式前向星方式建图需要这个数量</span></span><br><span class="line"><span class="comment">// 注意如果无向图的最大数量是m条边，数量要准备m*2</span></span><br><span class="line"><span class="comment">// 因为一条无向边要加两条有向边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵方式建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] graph1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表方式建图</span></span><br><span class="line"><span class="comment">// public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph2 = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星方式建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果边有权重，那么需要这个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵清空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">graph1[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表清空和准备</span></span><br><span class="line">graph2.clear();</span><br><span class="line"><span class="comment">// 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">graph2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星清空</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">Arrays.fill(head, <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星加边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line"><span class="comment">// u -&gt; v , 边权重是w</span></span><br><span class="line">next[cnt] = head[u];</span><br><span class="line">to[cnt] = v;</span><br><span class="line">weight[cnt] = w;</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种方式建立有向图带权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line"><span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line">graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种方式建立无向图带权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undirectGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">graph1[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line"><span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line"><span class="comment">// graph2.get(edge[1]).add(edge[0]);</span></span><br><span class="line">graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">graph2.get(edge[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">0</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;邻接矩阵遍历 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">System.out.print(graph1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;邻接表遍历 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : graph2.get(i)) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;(&quot;</span> + edge[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + edge[<span class="number">1</span>] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;链式前向星 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line"><span class="comment">// 注意这个for循环，链式前向星的方式遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[i]; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;(&quot;</span> + to[ei] + <span class="string">&quot;,&quot;</span> + weight[ei] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课程表二（拓扑排序）"><a href="#课程表二（拓扑排序）" class="headerlink" title="课程表二（拓扑排序）"></a>课程表二（拓扑排序）</h2><p>leetcode 210</p><p>思路：判断入度，每次找到入度为0的点，加入队列，然后遍历这个点的所有边，将边指向的点的入度减1，如果减1后为0，则加入队列。最后判断加入队列的数量是否等于n，如果等于n，则说明有解，否则无解。排序结果就是这个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边的编号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] weight)</span> &#123;</span><br><span class="line">    <span class="comment">//加边逻辑</span></span><br><span class="line">    next[cnt] = head[u];</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    <span class="comment">//入度加一</span></span><br><span class="line">    weight[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numCourses;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> prerequisites.length;</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        add(prerequisites[i][<span class="number">1</span>],prerequisites[i][<span class="number">0</span>],head,next,to,weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历得到所有0入度的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(weight[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            queue[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始消除所有0入度</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[i];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">toi</span> <span class="operator">=</span> to[ie];</span><br><span class="line">            <span class="keyword">if</span>(--weight[toi] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = toi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n ? queue : <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="火星词典"><a href="#火星词典" class="headerlink" title="火星词典"></a>火星词典</h2><p>leetcode LCR114</p><p>思路：依次比较相邻的两个字符串，从字符串开头依次比较两个的字符。直到遇到不同的字符，那么就说明就是因为这个位置上的字符让前面的字符排在前面。于是增加一条从前面的字符指向后面的字符的边。这样得到一个图之后，就可以进行拓扑排序了。拓扑排序的结果就是字典序.但返回答案之前要判断得到的字典序里面的字符个数是否等于出现的字符个数，少了说明存在环，返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] in)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alienOrder</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(cnt,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    cnt[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//开始遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">curNext</span> <span class="operator">=</span> words[i+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(cur.length(),curNext.length());</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.charAt(j)!=curNext.charAt(j))&#123;</span><br><span class="line">                    <span class="comment">//添加边</span></span><br><span class="line">                    add(cur.charAt(j) - <span class="string">&#x27;a&#x27;</span>,curNext.charAt(j)-<span class="string">&#x27;a&#x27;</span>,head,next,to,cnt);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j&lt;cur.length() &amp;&amp; j == curNext.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始拓扑排序</span></span><br><span class="line">        <span class="comment">//有多少个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出初始入度为0的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                kinds++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="type">char</span> <span class="variable">ansChar</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + temp);</span><br><span class="line">            kinds --;</span><br><span class="line">            sb.append(ansChar);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[temp];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--cnt[to[ie]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = to[ie];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kinds == <span class="number">0</span> ? sb.toString(): <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大食物链计数"><a href="#最大食物链计数" class="headerlink" title="最大食物链计数"></a>最大食物链计数</h2><p>思路：拓扑排序，只不过每次出队时的节点要把自己的信息告诉自己的邻居节点。(其实这道题也能用dfs,而且更简单)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_FoodLines</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的入度表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的推送信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] lines = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">Arrays.fill(indegree, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(lines, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(head, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">next[cnt] = head[u];</span><br><span class="line">to[cnt] = v;</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">n = (<span class="type">int</span>) in.nval;</span><br><span class="line">in.nextToken();</span><br><span class="line">m = (<span class="type">int</span>) in.nval;</span><br><span class="line">build(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, u, v; i &lt; m; i++) &#123;</span><br><span class="line">in.nextToken();</span><br><span class="line">u = (<span class="type">int</span>) in.nval;</span><br><span class="line">in.nextToken();</span><br><span class="line">v = (<span class="type">int</span>) in.nval;</span><br><span class="line">addEdge(u, v);</span><br><span class="line">indegree[v]++;</span><br><span class="line">&#125;</span><br><span class="line">out.println(ways());</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">queue[r++] = i;</span><br><span class="line">lines[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue[l++];</span><br><span class="line"><span class="keyword">if</span> (head[u] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 当前的u节点不再有后续邻居了</span></span><br><span class="line">ans = (ans + lines[u]) % MOD;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[u], v; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line"><span class="comment">// u -&gt; v</span></span><br><span class="line">v = to[ei];</span><br><span class="line">lines[v] = (lines[v] + lines[u]) % MOD;</span><br><span class="line"><span class="keyword">if</span> (--indegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">queue[r++] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="喧闹与富有"><a href="#喧闹与富有" class="headerlink" title="喧闹与富有"></a>喧闹与富有</h2><p>leetcode 851</p><p>思路：拓扑排序，但出队的时候把自己的答案推送到下一个节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] in)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] loudAndRich(<span class="type">int</span>[][] richer, <span class="type">int</span>[] quiet) &#123;</span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> quiet.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> richer.length;</span><br><span class="line">        <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            add(richer[i][<span class="number">0</span>],richer[i][<span class="number">1</span>],head,next,to,in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[pos];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextP</span> <span class="operator">=</span> to[ie];</span><br><span class="line">                <span class="comment">// 如果我的答案更好，推送给你进行更新，之后我就可以出队了</span></span><br><span class="line">                <span class="keyword">if</span>(quiet[ans[pos]] &lt; quiet[ans[nextP]])&#123;</span><br><span class="line">                    ans[nextP] = ans[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(--in[nextP] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = nextP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是图论基本内容，其实就是建图加拓扑排序。或者有简单的bfs或者dfs。 至于更复杂的图论，以后再学吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建图的几种方式-邻接矩阵、邻接表、链式前向星&quot;&gt;&lt;a href=&quot;#建图的几种方式-邻接矩阵、邻接表、链式前向星&quot; class=&quot;headerlink&quot; title=&quot;建图的几种方式 邻接矩阵、邻接表、链式前向星&quot;&gt;&lt;/a&gt;建图的几种方式 邻接矩阵、邻接表、链式前</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（十二）并查集</title>
    <link href="https://nmcb666.vip/posts/19844410.html"/>
    <id>https://nmcb666.vip/posts/19844410.html</id>
    <published>2026-01-31T16:05:26.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-31%20172011.png" alt="用法"/></div><span class="image-caption">用法</span></div><h2 id="并查集模板-扁平化-小挂大"><a href="#并查集模板-扁平化-小挂大" class="headerlink" title="并查集模板 扁平化+小挂大"></a>并查集模板 扁平化+小挂大</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i号节点，往上一直找，找到代表节点返回！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="comment">// 沿途收集了几个点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != father[i]) &#123;</span><br><span class="line">stack[size++] = i;</span><br><span class="line">i = father[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 沿途节点收集好了，i已经跳到代表节点了</span></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">father[stack[--size]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line"><span class="comment">// fx是集合的代表：拿大小</span></span><br><span class="line"><span class="comment">// fy是集合的代表：拿大小</span></span><br><span class="line"><span class="keyword">if</span> (size[fx] &gt;= size[fy]) &#123;</span><br><span class="line">size[fx] += size[fy];</span><br><span class="line">father[fy] = fx;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">size[fy] += size[fx];</span><br><span class="line">father[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板2-只有扁平化"><a href="#模板2-只有扁平化" class="headerlink" title="模板2 只有扁平化"></a>模板2 只有扁平化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">father[find(x)] = find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情侣牵手"><a href="#情侣牵手" class="headerlink" title="情侣牵手"></a>情侣牵手</h2><p>leetcode 765</p><p>思路：把编号i，i+1的情侣看出编号为i/2的情侣对.按顺序每次让两个人的情侣编号两两进行合并，如果是一对情侣（情侣编号一样）那么集合个数不会变，如果不是比如第一个人属于第3对，第二个人属于第5对，那么把3，5合成一个集合。最后原始的情侣对数减去剩下的集合个数就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">        father[i] = find(father[i]); <span class="comment">// 路径压缩：递归更新父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        cnts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnts;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>row.length;</span><br><span class="line">    cnts = n/<span class="number">2</span>;</span><br><span class="line">    build(n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        union(row[i]/<span class="number">2</span>,row[i+<span class="number">1</span>]/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n/<span class="number">2</span> - cnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相似字符串组"><a href="#相似字符串组" class="headerlink" title="相似字符串组"></a>相似字符串组</h2><p>leetcode 839</p><p>思路：两层for循环每次判断两个字符串是否相似，相似的话就合并两个字符串的集合。最后返回集合个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sets = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">father[fx] = fy;</span><br><span class="line">sets--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSimilarGroups</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">build(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (find(i) != find(j)) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m &amp;&amp; diff &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (strs[i].charAt(k) != strs[j].charAt(k)) &#123;</span><br><span class="line">diff++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (diff == <span class="number">0</span> || diff == <span class="number">2</span>) &#123;</span><br><span class="line">union(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>leetcode 200</p><p>思路：其实这道题最优解是洪水填充，但是这里用并查集也可以做。把二维下标转为一维编号 i*n+j。然后依次遍历，如果自己是1 的话就 查看 右边 跟 下边是不是1，如果是的话就合并。最后返回集合个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    cnts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                father[i*n+j] = i*n+j;</span><br><span class="line">                cnts++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i != father[i])&#123;</span><br><span class="line">        father[i] = find(father[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        cnts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    build(grid,m,n);</span><br><span class="line">    <span class="comment">//合并岛屿</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//只用合并右边跟下边即可</span></span><br><span class="line">                <span class="keyword">if</span>( i!=m-<span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    union(i*n+j,(i+<span class="number">1</span>)*n+j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j!=n-<span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    union(i*n+j,i*n+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="专家开会"><a href="#专家开会" class="headerlink" title="专家开会"></a>专家开会</h2><p>leetcode 2092</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的标签信息 : 设置集合的一些属性</span></span><br><span class="line"><span class="comment">// 属性在哪？secret[代表元素] 代表集合的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] secret = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> first)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">secret[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">father[first] = <span class="number">0</span>;</span><br><span class="line">secret[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">father[fx] = fy;</span><br><span class="line">secret[fy] |= secret[fx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议排序 : m * log m</span></span><br><span class="line"><span class="comment">// 处理过程 : O(m)</span></span><br><span class="line"><span class="comment">// 收集答案 : O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">findAllPeople</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">build(n, first);</span><br><span class="line"><span class="comment">// &#123;0 : 专家   1 : 专家编号   2 : 时刻&#125;</span></span><br><span class="line">Arrays.sort(meetings, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> meetings.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r; l &lt; m;) &#123;</span><br><span class="line">r = l;</span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; m &amp;&amp; meetings[l][<span class="number">2</span>] == meetings[r + <span class="number">1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l....r这些会议，一定是一个时刻</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">union(meetings[i][<span class="number">0</span>], meetings[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有小的撤销行为，但这不是可撤销并查集</span></span><br><span class="line"><span class="comment">// 只是每一批没有知道秘密的专家重新建立集合而已</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, a, b; i &lt;= r; i++) &#123;</span><br><span class="line">a = meetings[i][<span class="number">0</span>];</span><br><span class="line">b = meetings[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!secret[find(a)]) &#123;</span><br><span class="line">father[a] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!secret[find(b)]) &#123;</span><br><span class="line">father[b] = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l = r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (secret[find(i)]) &#123;</span><br><span class="line">ans.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img&quot; src=&quot;https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AQS是什么？</title>
    <link href="https://nmcb666.vip/posts/6079905e.html"/>
    <id>https://nmcb666.vip/posts/6079905e.html</id>
    <published>2026-01-31T01:30:22.000Z</published>
    <updated>2026-02-22T12:13:28.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Java并发】AQS详解：JUC包背后的“幕后大佬”"><a href="#【Java并发】AQS详解：JUC包背后的“幕后大佬”" class="headerlink" title="【Java并发】AQS详解：JUC包背后的“幕后大佬”"></a>【Java并发】AQS详解：JUC包背后的“幕后大佬”</h1><p>在 Java 并发编程（JUC）的世界里，我们经常使用 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 这些赫赫有名的工具类。</p><p>但你是否想过，这些功能各异的工具背后，其实共用着同一套“底盘”？</p><p>这就是我们今天要聊的主角——<strong>AQS (AbstractQueuedSynchronizer，抽象队列同步器)</strong>。它是 JUC 包的心脏，掌握了它，你就掌握了 Java 并发的半壁江山。</p><h2 id="一、-什么是-AQS？"><a href="#一、-什么是-AQS？" class="headerlink" title="一、 什么是 AQS？"></a>一、 什么是 AQS？</h2><p><strong>AQS 是一个用于构建锁和同步器的框架。</strong></p><p>如果把 <code>ReentrantLock</code>、<code>CountDownLatch</code> 等比作是<strong>成品的汽车</strong>（跑车、卡车、公交车），那么 AQS 就是通用的<strong>汽车底盘和引擎</strong>。</p><ul><li><strong>AQS 负责脏活累活</strong>：它处理了线程的排队、阻塞、唤醒、线程安全等最复杂的底层逻辑。</li><li><strong>同步器负责业务逻辑</strong>：具体的工具类只需要告诉 AQS，“什么时候算获取锁成功”，“资源一共有多少”，剩下的交给 AQS 即可。</li></ul><p>简单来说，<strong>AQS 是一个“原材料”，我们可以根据它加工出各种各样的同步器。</strong></p><h2 id="二、-AQS-的核心架构"><a href="#二、-AQS-的核心架构" class="headerlink" title="二、 AQS 的核心架构"></a>二、 AQS 的核心架构</h2><p>AQS 的内部并没有多么神秘，它的核心逻辑主要由三部分组成：</p><h3 id="1-核心资源：State-volatile-int"><a href="#1-核心资源：State-volatile-int" class="headerlink" title="1. 核心资源：State (volatile int)"></a>1. 核心资源：State (volatile int)</h3><p>AQS 内部维护了一个 <code>state</code> 变量，用来表示<strong>“同步状态”</strong>。</p><ul><li>这是一个 <code>volatile</code> 修饰的 <code>int</code> 变量，保证了多线程下的可见性。</li><li>AQS 提供了 CAS (Compare And Swap) 方法来原子性地修改这个值。</li></ul><p><strong>这个 state 具体代表什么？AQS 不关心，由子类定义：</strong></p><ul><li>在 <strong>ReentrantLock</strong> 中，<code>state=0</code> 代表没锁，<code>state=1</code> 代表上锁。</li><li>在 <strong>CountDownLatch</strong> 中，<code>state</code> 代表倒计时的数值。</li><li>在 <strong>Semaphore</strong> 中，<code>state</code> 代表剩余的许可证数量。</li></ul><h3 id="2-等待队列：CLH-队列"><a href="#2-等待队列：CLH-队列" class="headerlink" title="2. 等待队列：CLH 队列"></a>2. 等待队列：CLH 队列</h3><p>如果有线程想抢资源（修改 state）失败了怎么办？总不能让它一直死循环空转（自旋）吧？</p><p>AQS 会把这些竞争失败的线程包装成一个 <strong>Node 节点</strong>，加入到一个<strong>双向链表</strong>（CLH队列）的尾部，并将线程<strong>阻塞</strong>（Park）。等待持有资源的线程释放后，再唤醒队列头部的线程。</p><h3 id="3-阻塞与唤醒工具"><a href="#3-阻塞与唤醒工具" class="headerlink" title="3. 阻塞与唤醒工具"></a>3. 阻塞与唤醒工具</h3><p>AQS 底层利用 <code>LockSupport</code> 类中的 <code>park()</code> 和 <code>unpark()</code> 方法，真正实现了操作系统的线程挂起和唤醒。</p><hr><h2 id="三、-AQS-是如何工作的？（以抢锁为例）"><a href="#三、-AQS-是如何工作的？（以抢锁为例）" class="headerlink" title="三、 AQS 是如何工作的？（以抢锁为例）"></a>三、 AQS 是如何工作的？（以抢锁为例）</h2><p>我们可以把 AQS 的工作流程想象成<strong>“去银行柜台办理业务”</strong>：</p><ol><li><strong>尝试获取 (TryAcquire)</strong>：<ul><li>线程 A 来了，看到柜台窗口（State）是空的（0），立马坐下办理，把窗口状态改为“忙碌”（1）。</li></ul></li><li><strong>入队 (Enqueue)</strong>：<ul><li>线程 B 来了，发现窗口状态是“忙碌”（1）。</li><li>AQS 这位大堂经理就会把线程 B 领到旁边的<strong>等待区（CLH 队列）</strong>，让它排在队伍后面，并告诉它：“你先睡会儿（Block），轮到你了叫你”。</li></ul></li><li><strong>释放与唤醒 (Release &amp; Unpark)</strong>：<ul><li>线程 A 办完业务了，离开柜台，把窗口状态改回“空闲”（0）。</li><li>AQS 大堂经理发现窗口空了，就去等待区叫醒排在最前面的线程 B：“醒醒，轮到你了”。</li><li>线程 B 醒来，高高兴兴去柜台办理业务。</li></ul></li></ol><hr><h2 id="四、-AQS-的设计模式：模板方法模式"><a href="#四、-AQS-的设计模式：模板方法模式" class="headerlink" title="四、 AQS 的设计模式：模板方法模式"></a>四、 AQS 的设计模式：模板方法模式</h2><p>AQS 之所以强大，是因为它使用了<strong>模板方法设计模式</strong>。</p><p>AQS 把“排队”、“阻塞”、“唤醒”这些通用的逻辑都写死了（<code>acquire</code>、<code>release</code> 方法）。但是，<strong>“如何判断资源是否足够”</strong>、<strong>“如何修改 state”</strong> 这些逻辑是留给子类去实现的。</p><p><strong>作为开发者，我们如果想自定义一个锁，只需要继承 AQS 并重写以下几个“钩子方法”：</strong></p><ul><li><code>tryAcquire(int)</code>: 独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li><code>tryRelease(int)</code>: 独占方式。尝试释放资源。</li><li><code>tryAcquireShared(int)</code>: 共享方式。尝试获取资源。</li><li><code>tryReleaseShared(int)</code>: 共享方式。尝试释放资源。</li><li><code>isHeldExclusively()</code>: 该线程是否正在独占资源。</li></ul><h2 id="五、-AQS-的“成品”展示"><a href="#五、-AQS-的“成品”展示" class="headerlink" title="五、 AQS 的“成品”展示"></a>五、 AQS 的“成品”展示</h2><p>让我们看看 Java 大佬们是如何利用 AQS 这个“原材料”加工出著名工具类的：</p><h3 id="1-ReentrantLock（可重入锁）"><a href="#1-ReentrantLock（可重入锁）" class="headerlink" title="1. ReentrantLock（可重入锁）"></a>1. ReentrantLock（可重入锁）</h3><ul><li><strong>模式</strong>：独占模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为 0。</li><li>线程 A 抢锁，通过 CAS 把 <code>state</code> 变成 1。</li><li>如果是同一个线程 A 再次抢锁（重入），就把 <code>state</code> 加 1（变成 2, 3…）。</li><li>释放锁时，<code>state</code> 减 1，直到减为 0 时才真正释放。</li></ul></li></ul><h3 id="2-CountDownLatch（倒计时器）"><a href="#2-CountDownLatch（倒计时器）" class="headerlink" title="2. CountDownLatch（倒计时器）"></a>2. CountDownLatch（倒计时器）</h3><ul><li><strong>模式</strong>：共享模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为 N（比如 5）。</li><li>主线程调用 <code>await()</code>，如果 <code>state &gt; 0</code>，就进入队列等待。</li><li>其他线程调用 <code>countDown()</code>，通过 CAS 把 <code>state</code> 减 1。</li><li>当 <code>state</code> 减到 0 时，AQS 唤醒队列里所有等待的主线程。</li></ul></li></ul><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong>模式</strong>：共享模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为许可证数量（比如 3）。</li><li>线程来获取许可，<code>state</code> 减 1。</li><li>如果 <code>state</code> 变为负数或者不足，线程进入队列等待。</li><li>释放许可时，<code>state</code> 加 1。</li></ul></li></ul><hr><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>AQS 是 Java 并发编程的基石。</p><ul><li><strong>宏观上</strong>：它是一个框架，通过<strong>State（资源状态）</strong>和<strong>CLH Queue（等待队列）</strong>来管理线程的同步。</li><li><strong>设计上</strong>：它采用了模板方法模式，将复杂的队列管理封装起来，只暴露简单的状态修改接口给子类。</li><li><strong>应用上</strong>：它是 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等工具类的父类（的内部实现）。</li></ul><p>理解了 AQS，你就理解了 Java 锁机制的灵魂。下次面试官问你：“ReentrantLock 是怎么实现的？”你就可以自信地从 AQS 的 <code>state</code> 和队列讲起了！</p><p>AQS的具体原理可以参考： <a href="https://javaguide.cn/java/concurrent/aqs.html">https://javaguide.cn/java/concurrent/aqs.html</a></p><hr><p><em>希望这篇文章能帮你彻底搞懂 AQS！如果有帮助，欢迎点赞收藏。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【Java并发】AQS详解：JUC包背后的“幕后大佬”&quot;&gt;&lt;a href=&quot;#【Java并发】AQS详解：JUC包背后的“幕后大佬”&quot; class=&quot;headerlink&quot; title=&quot;【Java并发】AQS详解：JUC包背后的“幕后大佬”&quot;&gt;&lt;/a&gt;【Java</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法（十一） 单调队列</title>
    <link href="https://nmcb666.vip/posts/435449ef.html"/>
    <id>https://nmcb666.vip/posts/435449ef.html</id>
    <published>2026-01-30T16:41:51.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1><p>配合滑动窗口，可以快速得到滑动窗口内的最大值或者最小值。如果要最大值，那维护一个大到小队列（存的是下标），如果要最小值，那维护一个小到大的队列。</p><p>拿最大值举例：</p><p>扩大窗口的时候，判断新加入的元素跟队尾元素的大小，只要队尾元素小于等于新值，则队尾元素出队，直到队尾元素大于新值或者队列为空。然后这个新值的下标从队尾入队</p><p>缩小窗口时，判断这个要出去的元素下标跟单调队列队头的下标是否相等，如果相等则队头元素出队。l++.否则就不移除队头。</p><p>如果要最大值，就是数组的队头元素位置的值。 nums[deque[l]]</p><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>leetcode 239</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">h = t = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="comment">// 先形成长度为k-1的窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 大 -&gt; 小</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[i]) &#123;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line">deque[t++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - k + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="comment">// 当前窗口k-1长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k - <span class="number">1</span>; l &lt; m; l++, r++) &#123;</span><br><span class="line"><span class="comment">// 少一个，要让r位置的数进来</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[r]) &#123;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line">deque[t++] = r;</span><br><span class="line"><span class="comment">// 收集答案</span></span><br><span class="line">ans[l] = arr[deque[h]];</span><br><span class="line"><span class="comment">// l位置的数出去</span></span><br><span class="line"><span class="keyword">if</span> (deque[h] == l) &#123;</span><br><span class="line">h++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绝对差不超过限制的最长连续数组"><a href="#绝对差不超过限制的最长连续数组" class="headerlink" title="绝对差不超过限制的最长连续数组"></a>绝对差不超过限制的最长连续数组</h2><p>leetcode 1438</p><p>思路：利用两个单调队列，一个记录窗口的最小值，一个记录窗口的最大值。窗口开始滑动，每新加一个元素，就维护队列。然后一直缩窗口直到窗口内最大值和最小值之差小于等于limit。之后记录答案，j-i+1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    l2 = <span class="number">0</span>;</span><br><span class="line">    r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">        <span class="comment">//进队</span></span><br><span class="line">        <span class="keyword">while</span>( r &gt; l &amp;&amp; nums[queue[r-<span class="number">1</span>]] &lt;= nums[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="keyword">while</span>( r2 &gt; l2 &amp;&amp; nums[queue2[r2-<span class="number">1</span>]] &gt;= nums[j])&#123;</span><br><span class="line">            r2--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue2[r2++] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( nums[queue[l]] - nums[queue2[l2]] &gt; limit )&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue2[l2] == i)&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(j - i + <span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非经典用法"><a href="#非经典用法" class="headerlink" title="非经典用法"></a>非经典用法</h1><h2 id="和至少为K的最短子数组"><a href="#和至少为K的最短子数组" class="headerlink" title="和至少为K的最短子数组"></a>和至少为K的最短子数组</h2><p>leetcode 862</p><p>思路：计算以每个位置结尾的最小长度。这里最关键的是如果已经算出一个答案的时候，你的窗口右扩，你想找到更短的就只能左缩窗口才行（不用从头开始缩）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以一个位置结尾，向前面走多远能达标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="comment">//加入窗口</span></span><br><span class="line">        <span class="keyword">while</span>( l&lt;r &amp;&amp; prefix[queue[r-<span class="number">1</span>]] &gt;= prefix[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="comment">//看当前是否满足</span></span><br><span class="line">        <span class="keyword">if</span>(prefix[j] - prefix[queue[l]] &gt;= k)&#123;</span><br><span class="line">            <span class="comment">//缩小窗口，直到不行</span></span><br><span class="line">            <span class="keyword">while</span> (prefix[j] - prefix[queue[l]] &gt;= k)&#123;</span><br><span class="line">                <span class="comment">//左边缩小</span></span><br><span class="line">                <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i前面那个位置就是至少的位置</span></span><br><span class="line">            ans = Math.min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="满足不等式的最大值"><a href="#满足不等式的最大值" class="headerlink" title="满足不等式的最大值"></a>满足不等式的最大值</h2><p>leetcode 1499</p><p>给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 &lt;= i &lt; j &lt;= points.length 的前提下， xi &lt; xj 总成立。</p><p>请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| &lt;= k 且 1 &lt;= i &lt; j &lt;= points.length。</p><p>题目测试数据保证至少存在一对能够满足 |xi - xj| &lt;= k 的点。</p><p>思路：还是以每个点为结尾。窗口左边从0下标开始，判断是否合法，不合法就左缩窗口，直到合法。这个过程一直记录窗口内点的y-x的最大值。合法之后，用结尾的点加上这个窗口内的最大值就是这个点的对应的最大值，然后把这个点也加入窗口，并且更新单调队列，单调队列以y-x为单调递减。即头部为y-x最大的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxValueOfEquation</span><span class="params">(<span class="type">int</span>[][] points, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>points.length;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//把第一个点放进去</span></span><br><span class="line">    queue[r++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//缩小窗口到合法</span></span><br><span class="line">        <span class="keyword">while</span>( j&gt;i &amp;&amp; points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>] &gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到答案</span></span><br><span class="line">        <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> queue[l];</span><br><span class="line">            ans = Math.max(ans,points[j][<span class="number">0</span>]+points[j][<span class="number">1</span>]-points[best][<span class="number">0</span>]+points[best][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 j 加入</span></span><br><span class="line">        <span class="keyword">while</span> ( l&lt;r &amp;&amp; (points[j][<span class="number">1</span>] - points[j][<span class="number">0</span>]) &gt;= (points[queue[r-<span class="number">1</span>]][<span class="number">1</span>]-points[queue[r-<span class="number">1</span>]][<span class="number">0</span>]))&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预算内最多机器人的数目"><a href="#预算内最多机器人的数目" class="headerlink" title="预算内最多机器人的数目"></a>预算内最多机器人的数目</h2><p>leetcode 2389</p><p>思路：单调队列算窗口内的最大值，前缀和算窗口的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue  =<span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRobots</span><span class="params">(<span class="type">int</span>[] chargeTimes, <span class="type">int</span>[] runningCosts, <span class="type">long</span> budget)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chargeTimes.length;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//搞一个前缀和，快速计算子数组的和</span></span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        prefix[i+<span class="number">1</span>] = prefix[i] + runningCosts[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始滑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//把 j 放进去</span></span><br><span class="line">        <span class="keyword">while</span> ( l&lt;r &amp;&amp; chargeTimes[queue[r-<span class="number">1</span>]] &lt;= chargeTimes[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="comment">// 左移直到合法</span></span><br><span class="line">        <span class="keyword">while</span>( i&lt;=j &amp;&amp; chargeTimes[queue[l]]+ (<span class="type">long</span>) (j - i + <span class="number">1</span>) *(prefix[j+<span class="number">1</span>]-prefix[i]) &gt; budget)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计答案</span></span><br><span class="line">        ans = Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三个无重叠子数组的最大和"><a href="#三个无重叠子数组的最大和" class="headerlink" title="三个无重叠子数组的最大和"></a>三个无重叠子数组的最大和</h2><p>leetcode 689</p><p>思路：化成三个部分，中间部分一定为i…i+k-1,左边为0….i-1 右边为i+k…n-1。此时只要知道截至到i位置最大的开始下标就可以知道前面的最大值。知道从i位置到n-1的最大值开始下标就可以确定后面最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSumOfThreeSubarrays(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sumNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//求sum[] 代表从i位置开始连续k个数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">        sumNum+=nums[r];</span><br><span class="line">        <span class="keyword">if</span>(r-l+<span class="number">1</span> == k)&#123;</span><br><span class="line">            sum[l] = sumNum;</span><br><span class="line">            sumNum-=nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求一个prefix[]  prefix[i]代表从0.....i 连续k个数和最大的开始下标</span></span><br><span class="line">    <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    queue[r++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; sum[queue[l]] &lt; sum[i-k+<span class="number">1</span>])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = i-k+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//为最小下标</span></span><br><span class="line">        prefix[i] = queue[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求suffix[]  suffix[]代表从 i....n-1 连续k个数和最大的开始下标</span></span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    suffix[n-k] = n-k;</span><br><span class="line">    queue[r++] = n-k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; sum[queue[l]] &lt;= sum[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = i;</span><br><span class="line">        suffix[i] = queue[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//借助这三个数组开始解答</span></span><br><span class="line">    <span class="comment">// （0....) (i...i+k-1) (i+k....n-1) 三个部分 中间部分和确定，只需要考虑前面跟后面即可</span></span><br><span class="line">    <span class="comment">// 它们的结果又从prefix 和 suffix可以拿到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= k,j=k*<span class="number">2</span>-<span class="number">1</span>;j&lt;n-k;i++,j++)&#123;</span><br><span class="line">        <span class="comment">//前面最大的开始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> prefix[i-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//后面最大的开始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> suffix[j+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> sum[m] + sum[i] + sum[p];</span><br><span class="line">        <span class="keyword">if</span>(all &gt; max)&#123;</span><br><span class="line">            max = all;</span><br><span class="line">            a=m;</span><br><span class="line">            b=i;</span><br><span class="line">            c=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典用法&quot;&gt;&lt;a href=&quot;#经典用法&quot; class=&quot;headerlink&quot; title=&quot;经典用法&quot;&gt;&lt;/a&gt;经典用法&lt;/h1&gt;&lt;p&gt;配合滑动窗口，可以快速得到滑动窗口内的最大值或者最小值。如果要最大值，那维护一个大到小队列（存的是下标），如果要最小值，那维</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（十） 单调栈</title>
    <link href="https://nmcb666.vip/posts/b11a54f5.html"/>
    <id>https://nmcb666.vip/posts/b11a54f5.html</id>
    <published>2026-01-29T21:32:22.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1><p>单调栈问题，就是当你分析问题时，需要你找到一个索引左右两边大于或者小于自己的最近索引时，就使用单调栈！</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-29%20232614.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="每日最高温度"><a href="#每日最高温度" class="headerlink" title="每日最高温度"></a>每日最高温度</h2><p>leetcode 739</p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>思路：将下标一次放入栈，但遵循以下要求，如果当前的温度大于栈顶的温度，则栈顶的索引出栈，并记录当前索引与栈顶索引的差值，即当前索引与栈顶索引的差值就是当前索引对应的天数。循环弹出，直到栈为空或者栈顶的索引对应的温度大于等于当前索引对应的温度。则当前索引入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>( size&gt;<span class="number">0</span> &amp;&amp; temperatures[stack[size-<span class="number">1</span>]] &lt; temperatures[i])&#123;</span><br><span class="line">            ans[stack[size-<span class="number">1</span>]] = i - stack[size-<span class="number">1</span>];</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子数组的最小值之和"><a href="#子数组的最小值之和" class="headerlink" title="子数组的最小值之和"></a>子数组的最小值之和</h2><p>leetcode 907</p><p>思路：根据单调栈，可以知道每个索引左边跟右边小于他的最近索引，那么对于每个索引，左边小于它的最近索引为left[i]，右边小于它的最近索引为right[i]，则对于索引i，最小值之和为(right[i] - i) <em> (i - left[i]) </em> arr[i]。（这就是包含了i的且i为最小值的所有子数组的最小值之和）。最后剩在栈里面的它的右边索引就在n的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注意课上讲的相等情况的修正</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[stack[r - <span class="number">1</span>]] &gt;= arr[i]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = (ans + (<span class="type">long</span>) (cur - left) * (i - cur) * arr[cur]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = (ans + (<span class="type">long</span>) (cur - left) * (arr.length - cur) * arr[cur]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h2><p>leetcode 84</p><p>思路：单调栈，对于每个索引，左边小于它最近索引为left[i]，右边小于它最近索引为right[i]，则对于索引i，最大矩形为(right[i] - left[i] - 1) * heights[i]。这道题就是一个非常标准的单调栈问题。</p><p>标准模板<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>heights.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span> &amp;&amp; heights[stack[size-<span class="number">1</span>]] &gt;= heights[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">            ansArr[temp][<span class="number">0</span>] = size == <span class="number">0</span> ? -<span class="number">1</span> : stack[size-<span class="number">1</span>];</span><br><span class="line">            ansArr[temp][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">        ansArr[temp][<span class="number">0</span>] = size==<span class="number">0</span>? -<span class="number">1</span> :stack[size-<span class="number">1</span>];</span><br><span class="line">        ansArr[temp][<span class="number">1</span>] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修正右边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansArr[i][<span class="number">1</span>] != n &amp;&amp; heights[ansArr[i][<span class="number">1</span>]] == heights[i])&#123;</span><br><span class="line">            ansArr[i][<span class="number">1</span>] = ansArr[ansArr[i][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans = Math.max((ansArr[i][<span class="number">1</span>] - ansArr[i][<span class="number">0</span>] -<span class="number">1</span>)*heights[i],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简化分析相等情况  因为就算相等你也给我弹出，可能这时你无法得到你对应的最大值。但你的那个最后一个相等的就会帮你结算你的最大值！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>heights.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span> &amp;&amp; heights[stack[size-<span class="number">1</span>]] &gt;= heights[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> size == <span class="number">0</span> ? -<span class="number">1</span> : stack[size-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            ans = Math.max((right-left-<span class="number">1</span>)*heights[temp],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> size==<span class="number">0</span>? -<span class="number">1</span> :stack[size-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        ans = Math.max((right-left-<span class="number">1</span>)*heights[temp],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>leetcode 85</p><p>思路：压缩数组！把问题转化为以每一行作为底部时的最大矩形问题 跟上一题一样。每一个的高度就是从该行开始连续的1的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">Arrays.fill(height, <span class="number">0</span>, m, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 来到i行，长方形一定要以i行做底！</span></span><br><span class="line"><span class="comment">// 加工高度数组(压缩数组)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">height[j] = grid[i][j] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : height[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(largestRectangleArea(m), ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, cur, left;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="comment">// i -&gt; arr[i]</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; height[stack[r - <span class="number">1</span>]] &gt;= height[i]) &#123;</span><br><span class="line">cur = stack[--r];</span><br><span class="line">left = r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = Math.max(ans, height[cur] * (i - left - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cur = stack[--r];</span><br><span class="line">left = r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = Math.max(ans, height[cur] * (m - left - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非经典用法"><a href="#非经典用法" class="headerlink" title="非经典用法"></a>非经典用法</h1><p><strong>下面的题目利用单调栈思想，而不是经典的用法。</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-29%20232336.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="最大宽度坡"><a href="#最大宽度坡" class="headerlink" title="最大宽度坡"></a>最大宽度坡</h2><p>leetcode 962</p><p>思路：先进行一次遍历把可能作为坡的起点的下标找到。怎么找？ 每次只入栈比当前栈顶元素更小的元素。为什么？因为如果我比栈顶大，我找到一个坡的终点，那么栈顶元素它比我的下标还要小，那他跟这个坡的终点构成的坡宽度肯定比我大，所以我没资格入栈。</p><p>然后倒着遍历找坡的终点。一旦栈顶的元素发现一个值可以作为自己终点那么弹出，并且这个坡就是以自己为起点的最大坡，为什么？因为当前终点已经是最靠右边的索引了，再往前遍历得到的结果只会更小！ 循环一直把栈里面的元素全部弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxWidthRamp</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    stack[size++] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找可能的起点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[stack[size-<span class="number">1</span>]])&#123;</span><br><span class="line">            stack[size++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒着遍历找终点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(size &gt; <span class="number">0</span> &amp;&amp; i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>( size &gt; <span class="number">0</span> &amp;&amp; nums[stack[size-<span class="number">1</span>]] &lt;= nums[i])&#123;</span><br><span class="line">            ans = Math.max(ans,i-stack[size-<span class="number">1</span>]);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h2><p>leetcode 316</p><p>思路： 单调栈大压小，遇到更小的尽量往前面走，但有条件限制，即被弹出的元素还有剩余。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line">Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(enter, <span class="literal">false</span>);</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : s) &#123;</span><br><span class="line">cnts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cur : s) &#123;</span><br><span class="line"><span class="comment">// 从左往右依次遍历字符，a -&gt; 0 b -&gt; 1 ... z -&gt; 25</span></span><br><span class="line"><span class="comment">// cur -&gt; cur - &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!enter[cur - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="comment">// 栈顶元素比当前元素大，并且栈顶元素还有剩余，那么弹出栈顶元素</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; stack[r - <span class="number">1</span>] &gt; cur &amp;&amp; cnts[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">enter[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = cur;</span><br><span class="line">enter[cur - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnts[cur - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(stack, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大鱼吃小鱼"><a href="#大鱼吃小鱼" class="headerlink" title="大鱼吃小鱼"></a>大鱼吃小鱼</h2><p>leetcode 2289</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Max</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] stackT = <span class="keyword">new</span> <span class="title class_">int</span>[Max][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSteps</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( r &gt; <span class="number">0</span> &amp;&amp; stackT[r-<span class="number">1</span>][<span class="number">0</span>] &lt; nums[i])&#123;</span><br><span class="line">            cnt = Math.max(cnt+<span class="number">1</span>,stackT[r-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        stackT[r][<span class="number">0</span>] = nums[i];</span><br><span class="line">        stackT[r++][<span class="number">1</span>] = cnt;</span><br><span class="line">        ans = Math.max(ans,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典用法&quot;&gt;&lt;a href=&quot;#经典用法&quot; class=&quot;headerlink&quot; title=&quot;经典用法&quot;&gt;&lt;/a&gt;经典用法&lt;/h1&gt;&lt;p&gt;单调栈问题，就是当你分析问题时，需要你找到一个索引左右两边大于或者小于自己的最近索引时，就使用单调栈！&lt;/p&gt;
&lt;div c</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java实现基于raft算法的kv存储系统</title>
    <link href="https://nmcb666.vip/posts/6eb88918.html"/>
    <id>https://nmcb666.vip/posts/6eb88918.html</id>
    <published>2026-01-29T02:02:09.000Z</published>
    <updated>2026-02-22T12:13:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java手写Raft篇：核心流程与并发模型优化"><a href="#Java手写Raft篇：核心流程与并发模型优化" class="headerlink" title="Java手写Raft篇：核心流程与并发模型优化"></a>Java手写Raft篇：核心流程与并发模型优化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇基于Java实现raft分布式KV存储系统的博客。本项目基于 <a href="https://github.com/stateIs0/lu-raft-kv">https://github.com/stateIs0/lu-raft-kv</a> 该开源项目进行的二次开发。主要按照Raft协议的生命周期（选主、日志复制、安全性、一致性读）进行了改造。本篇博客记录了我的改造思路，以及一些值得注意的地方。Raft 算法作为分布式一致性协议的标准解法，以其清晰的模块化设计著称。本文将基于我如何改造原开源项目，深入剖析其中的核心机制。从选主逻辑、日志复制的细节，到解决“幽灵复现”问题的 No-Op 日志，再到利用 <code>CompletableFuture</code> 对并发模型的重构，以此记录构建高一致性分布式存储系统的思考过程。</p><hr><h2 id="一、-选举机制-Leader-Election"><a href="#一、-选举机制-Leader-Election" class="headerlink" title="一、 选举机制 (Leader Election)"></a>一、 选举机制 (Leader Election)</h2><p>选主是集群启动或 Leader 宕机后的首要任务。在此阶段，不仅要保证票数过半，更要严格校验节点资格。</p><h3 id="1-状态流转与拉票"><a href="#1-状态流转与拉票" class="headerlink" title="1. 状态流转与拉票"></a>1. 状态流转与拉票</h3><p>当 Follower 的心跳倒计时结束（在一定范围内随机时间，我选择的是跟最大选举时间到它的两倍这个范围，避免同时存在多个候选人导致效率下降）仍未收到 Leader 消息时，将触发选举流程：</p><ul><li><strong>自增任期</strong>：将 <code>term + 1</code>，并将状态流转为 Candidate。</li><li><strong>给自己投票</strong>：先投自己一票，避免 split vote。</li><li><strong>广播请求</strong>：向所有节点发起拉票请求，请求中必须携带 <code>lastLogTerm</code> 和 <code>lastLogIndex</code>，以便其他节点校验“日志是否足够新”。</li></ul><h3 id="2-投票方逻辑与并发控制"><a href="#2-投票方逻辑与并发控制" class="headerlink" title="2. 投票方逻辑与并发控制"></a>2. 投票方逻辑与并发控制</h3><p>节点收到投票请求时的处理逻辑非常关键：</p><ul><li><strong>Term 更新</strong>：如果请求中的 Term 严格大于自身，需将之前的投票记录（votedFor）置空，防止因持有旧锁导致无法投票，这样也尽可能的保证在一个投票间隔中能选出Leader。</li><li><strong>加锁防重</strong>：整个投票判断过程需要上锁，避免高并发下的重复投票。</li><li><strong>资格校验</strong>：只有当请求者的 Term &gt;= 自身 Term，且日志比自己新（Log Completeness），且自己在本任期未投过票时，才予以投票。</li><li><strong>收尾</strong>：更新本地 Term 和投票信息，释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RvoteResult <span class="title function_">requestVote</span><span class="params">(RvoteParam param)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RvoteResult.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RvoteResult.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (!voteLock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.term(node.getCurrentTerm()).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对方任期没有自己新</span></span><br><span class="line">        <span class="keyword">if</span> (param.getTerm() &lt; node.getCurrentTerm()) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.term(node.getCurrentTerm()).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新的投票term来临，应该放弃之前的投票</span></span><br><span class="line">        <span class="keyword">if</span> (param.getTerm() &gt; node.getCurrentTerm()) &#123;</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line">            node.setVotedFor(<span class="literal">null</span>);</span><br><span class="line">            node.status = NodeStatus.FOLLOWER; <span class="comment">// 任期升级后回归Follower</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (当前节点并没有投票 或者 已经投票过了且是对方节点) &amp;&amp; 对方日志和自己一样新</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;node &#123;&#125; current vote for [&#123;&#125;], param candidateId : &#123;&#125;&quot;</span>, node.peerSet.getSelf(), node.getVotedFor(), param.getCandidateId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((StringUtil.isNullOrEmpty(node.getVotedFor()) || node.getVotedFor().equals(param.getCandidateId()))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.getLogModule().getLast() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 对方没有自己新</span></span><br><span class="line">                <span class="keyword">if</span> (node.getLogModule().getLast().getTerm() &gt; param.getLastLogTerm()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;节点&#123;&#125; 拒绝给 候选人 &#123;&#125; 投票,因为日志的term值更大&quot;</span>,node.peerSet.getSelf(),param.getCandidateId());</span><br><span class="line">                    <span class="keyword">return</span> RvoteResult.fail();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对方没有自己新</span></span><br><span class="line">                <span class="keyword">if</span> (node.getLogModule().getLastIndex() &gt; param.getLastLogIndex()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;节点&#123;&#125; 拒绝给 候选人 &#123;&#125; 投票,因为日志的Index更大&quot;</span>,node.peerSet.getSelf(),param.getCandidateId());</span><br><span class="line">                    <span class="keyword">return</span> RvoteResult.fail();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换状态</span></span><br><span class="line">            node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            node.peerSet.setLeader(<span class="keyword">new</span> <span class="title class_">Peer</span>(param.getCandidateId()));</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line">            node.setVotedFor(param.getCandidateId());</span><br><span class="line">            log.warn(<span class="string">&quot;节点 &#123;&#125; 在第 &#123;&#125; 轮中 ， 投给了 &#123;&#125; 节点&quot;</span>,node.peerSet.getSelf(),node.currentTerm,node.getVotedFor());</span><br><span class="line">            <span class="comment">// 返回成功</span></span><br><span class="line">            <span class="keyword">return</span> builder.term(node.currentTerm).voteGranted(<span class="literal">true</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.term(node.currentTerm).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        voteLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-异步并发模型的优化"><a href="#3-异步并发模型的优化" class="headerlink" title="3. 异步并发模型的优化"></a>3. 异步并发模型的优化</h3><p>在实现拉票请求时，我对并发模型进行了重构：</p><ul><li><strong>旧方案</strong>：<code>线程池 + Future + CountDownLatch</code>。<code>Future.get()</code> 会阻塞调用线程，且 CountDownLatch 代码冗余。</li><li><strong>新方案</strong>：<code>CompletableFuture + 线程池</code>。<ul><li>使用 <code>List&lt;CompletableFuture&lt;&gt;&gt;</code> 保存所有 RPC 请求。</li><li>利用 <code>CompletableFuture.allOf(...)</code> 实现多线程的非阻塞同步。</li><li>配合 <code>AtomicInteger</code> 记录获胜票数，线程安全且代码更优雅。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == NodeStatus.LEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 基于 RAFT 的随机时间,解决冲突.（范围为[electiontimeout, 2 * electiontimeout - 1]）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">myElectionTime</span> <span class="operator">=</span> electionTime + ThreadLocalRandom.current().nextInt(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (current - preElectionTime &lt; myElectionTime) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">status = NodeStatus.CANDIDATE;</span><br><span class="line">log.error(<span class="string">&quot;node &#123;&#125; will become CANDIDATE and start election leader, current term : [&#123;&#125;], LastEntry : [&#123;&#125;]&quot;</span>,</span><br><span class="line">        peerSet.getSelf(), currentTerm, logModule.getLast());</span><br><span class="line"></span><br><span class="line">preElectionTime = System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(<span class="number">200</span>) + <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">currentTerm = currentTerm + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 推荐自己.</span></span><br><span class="line">votedFor = peerSet.getSelf().getAddr();</span><br><span class="line"></span><br><span class="line">List&lt;Peer&gt; peers = peerSet.getPeersWithOutSelf();</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用CompletableFuture 改造</span></span><br><span class="line">ArrayList&lt;CompletableFuture&lt;RvoteResult&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//成功次数</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">NumberOfVotesInFavor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">log.info(<span class="string">&quot;peerList size : &#123;&#125;, peer list content : &#123;&#125;&quot;</span>, peers.size(), peers);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Peer peer : peers) &#123;</span><br><span class="line"></span><br><span class="line">    futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装自己最后一个日志的term</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">lastTerm</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">last</span> <span class="operator">=</span> logModule.getLast();</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">            lastTerm = last.getTerm();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以及最后一条日志的索引</span></span><br><span class="line">        <span class="type">RvoteParam</span> <span class="variable">param</span> <span class="operator">=</span> RvoteParam.builder().</span><br><span class="line">                term(currentTerm).</span><br><span class="line">                candidateId(peerSet.getSelf().getAddr()).</span><br><span class="line">                lastLogIndex(LongConvert.convert(logModule.getLastIndex())).</span><br><span class="line">                lastLogTerm(lastTerm).</span><br><span class="line">                build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> Request.builder()</span><br><span class="line">                .cmd(Request.R_VOTE)</span><br><span class="line">                .obj(param)</span><br><span class="line">                .url(peer.getAddr())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送投票请求，500ms超时</span></span><br><span class="line">            <span class="keyword">return</span> getRpcClient().&lt;RvoteResult&gt;send(request,<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RaftRemotingException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;ElectionTask RPC Fail , URL : &quot;</span> + request.getUrl());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,RaftThreadPool.giveMePool())</span><br><span class="line">            .whenComplete((result,throwable) -&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isVoteGranted</span> <span class="operator">=</span> result.isVoteGranted();</span><br><span class="line">                <span class="keyword">if</span> (isVoteGranted) &#123;</span><br><span class="line">                    <span class="comment">//增加选票</span></span><br><span class="line">                    NumberOfVotesInFavor.incrementAndGet();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对方拒绝投票。</span></span><br><span class="line">                    <span class="comment">// 更新自己的任期。</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">resTerm</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                    <span class="keyword">if</span> (resTerm &gt;= currentTerm) &#123;</span><br><span class="line">                        currentTerm = resTerm;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待所有结果出来</span></span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">//多个任务</span></span><br><span class="line">    CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">    CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">success</span> <span class="operator">=</span> NumberOfVotesInFavor.get();</span><br><span class="line">log.warn(<span class="string">&quot;node &#123;&#125; maybe become leader , success count = &#123;&#125; , status : &#123;&#125;&quot;</span>, peerSet.getSelf(), success, NodeStatus.Enum.value(status));</span><br><span class="line"><span class="comment">// 如果投票期间,有其他服务器发送 appendEntry 或者心跳 , 就可能变成 follower ,这时,应该停止.</span></span><br><span class="line"><span class="keyword">if</span> (status == NodeStatus.FOLLOWER) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;节点 &#123;&#125; 目前不是候选人 ，无法成为领导者&quot;</span>, peerSet.getSelf().getAddr());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加上自身.</span></span><br><span class="line"><span class="keyword">if</span> (success &gt;= (peers.size()+<span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;node &#123;&#125; become leader 他的选票有 &#123;&#125; 票&quot;</span>, peerSet.getSelf(),success+<span class="number">1</span>);</span><br><span class="line">    status = NodeStatus.LEADER;</span><br><span class="line">    peerSet.setLeader(peerSet.getSelf());</span><br><span class="line">    votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这个会马上插入一条空日志</span></span><br><span class="line">    becomeLeaderToDoThing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else 重新选举</span></span><br><span class="line">    votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    log.warn(<span class="string">&quot;节点 &#123;&#125; 在 &#123;&#125; 轮落选,他获得的选票有 &#123;&#125; 票&quot;</span>,peerSet.getSelf(),currentTerm,success+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次更新选举时间 随机更新</span></span><br><span class="line">preElectionTime = System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(<span class="number">200</span>) + <span class="number">150</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="二、-日志复制与心跳-Log-Replication-amp-Heartbeat"><a href="#二、-日志复制与心跳-Log-Replication-amp-Heartbeat" class="headerlink" title="二、 日志复制与心跳 (Log Replication &amp; Heartbeat)"></a>二、 日志复制与心跳 (Log Replication &amp; Heartbeat)</h2><p>Leader 确立后，进入正常的日志同步阶段。</p><h3 id="1-心跳与日志同步的合并"><a href="#1-心跳与日志同步的合并" class="headerlink" title="1. 心跳与日志同步的合并"></a>1. 心跳与日志同步的合并</h3><p>为了简化逻辑，我将“同步日志”与“发送心跳”合并处理：</p><ul><li>Leader 周期性遍历所有 Follower。</li><li><strong>判断同步需求</strong>：检查 <code>Leader.lastIndex &gt;= Follower.nextIndex</code>。<ul><li>如果满足，说明有新日志，发送从 <code>nextIndex</code> 开始的日志条目。</li><li>如果不满足，说明日志已经同步，仅发送空的心跳包保活(根据心跳结果，判断自己是否还能继续当leader)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != NodeStatus.LEADER) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (current - preHeartBeatTime &lt; heartBeatTick) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;=========== NextIndex =============&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Peer &#123;&#125; nextIndex=&#123;&#125;&quot;</span>, peer.getAddr(), nextIndexs.get(peer));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preHeartBeatTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            List&lt;CompletableFuture&lt;Boolean&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            List&lt;Boolean&gt; resultList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 日志跟心跳放在一起</span></span><br><span class="line">            <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">nextIndex</span> <span class="operator">=</span> nextIndexs.get(peer);</span><br><span class="line">                <span class="comment">//我的最后一条日志大于你应该写入的日志位置，那我就要复制给你日志</span></span><br><span class="line">                <span class="keyword">if</span>(logModule.getLastIndex() &gt;= nextIndex)&#123;</span><br><span class="line">                    CompletableFuture&lt;Boolean&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; replication(peer), RaftThreadPool.giveMePool()</span><br><span class="line">                    ).exceptionally( ex -&gt;&#123;</span><br><span class="line">                        log.error(<span class="string">&quot;&#123;&#125; 节点发送日志失败&quot;</span>, peer.getAddr());</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">                    ).whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                            resultList.add(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;&#123;&#125; 节点发送日志失败&quot;</span>, peer.getAddr());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    futureList.add(future);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//发送心跳</span></span><br><span class="line">                    <span class="type">AentryParam</span> <span class="variable">param</span> <span class="operator">=</span> AentryParam.builder()</span><br><span class="line">                            .entries(<span class="literal">null</span>)<span class="comment">// 心跳,空日志.</span></span><br><span class="line">                            .leaderId(peerSet.getSelf().getAddr())</span><br><span class="line">                            .serverId(peer.getAddr())</span><br><span class="line">                            .term(currentTerm)</span><br><span class="line">                            .leaderCommit(commitIndex) <span class="comment">// 心跳时与跟随者同步 commit index</span></span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                            Request.A_ENTRIES,</span><br><span class="line">                            param,</span><br><span class="line">                            peer.getAddr());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    CompletableFuture.supplyAsync(()-&gt; getRpcClient().&lt;AentryResult&gt;send(request,<span class="number">450</span>),RaftThreadPool.giveMePool())</span><br><span class="line">                            .exceptionally( ex -&gt; <span class="literal">null</span>).whenComplete((result, throwable)-&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                            log.error(<span class="string">&quot;无法收到&#123;&#125; 节点的心跳回应，该节点可能已经宕机&quot;</span>,peer.getAddr());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">term</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                        <span class="keyword">if</span> (term &gt; currentTerm) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;self will become follower, he&#x27;s term : &#123;&#125;, my term : &#123;&#125;&quot;</span>, term, currentTerm);</span><br><span class="line">                            currentTerm = term;</span><br><span class="line">                            votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            status = NodeStatus.FOLLOWER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待所有日志完成</span></span><br><span class="line">            <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="comment">//多个任务</span></span><br><span class="line">                CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">                CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在一个满足N &gt; commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，</span></span><br><span class="line">            <span class="comment">// 并且log[N].term == currentTerm成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</span></span><br><span class="line">            List&lt;Long&gt; matchIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchIndexs.values());</span><br><span class="line">            <span class="comment">// 小于 2, 没有意义</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (matchIndexList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                Collections.sort(matchIndexList);</span><br><span class="line">                median = matchIndexList.size() / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">N</span> <span class="operator">=</span> matchIndexList.get(median);</span><br><span class="line">            <span class="keyword">if</span> (N &gt; commitIndex) &#123;</span><br><span class="line">                <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> logModule.read(N);</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getTerm() == currentTerm) &#123;</span><br><span class="line">                    commitIndex = N;</span><br><span class="line">                    <span class="comment">// 应用到状态机</span></span><br><span class="line">                    RaftThreadPool.execute(()-&gt;&#123;</span><br><span class="line">                        commitLock.lock();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">myCommitIndex</span> <span class="operator">=</span> commitIndex;</span><br><span class="line">                            <span class="comment">//应该从lastApplied开始应用，直到异步开始时的commitIndex（防止重复提交）</span></span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= myCommitIndex; i++)&#123;</span><br><span class="line">                                getStateMachine().apply(logModule.read(i));</span><br><span class="line">                                log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                            &#125;</span><br><span class="line">                            lastApplied = myCommitIndex;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            commitLock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-批量发送与回溯"><a href="#2-批量发送与回溯" class="headerlink" title="2. 批量发送与回溯"></a>2. 批量发送与回溯</h3><ul><li><strong>批量优化</strong>：发送日志时，会把从 <code>nextIndex</code> 到 Leader <code>lastIndex</code> 的所有日志打包发送。Follower 匹配成功后可批量写入，极大提升同步吞吐。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AentryParam</span> <span class="variable">aentryParam</span> <span class="operator">=</span> AentryParam.builder().build();</span><br><span class="line">aentryParam.setTerm(currentTerm);</span><br><span class="line">aentryParam.setServerId(peer.getAddr());</span><br><span class="line">aentryParam.setLeaderId(peerSet.getSelf().getAddr());</span><br><span class="line"></span><br><span class="line">aentryParam.setLeaderCommit(commitIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以我这边为准。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">nextIndex</span> <span class="operator">=</span> nextIndexs.get(peer);</span><br><span class="line"><span class="type">Long</span> <span class="variable">myNewIndex</span> <span class="operator">=</span> logModule.getLastIndex();</span><br><span class="line">LinkedList&lt;LogEntry&gt; logEntries = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (myNewIndex &gt;= nextIndex) &#123;</span><br><span class="line">    <span class="comment">// 把nextIndex 到 自己的最后一条日志都复制给follower</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex; i &lt;= myNewIndex; i++) &#123;</span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">l</span> <span class="operator">=</span> logModule.read(i);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            logEntries.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的日志(如果nextIndex为0 ，会返回一条term为-1，index为-1的日志，follower收到后会跳过匹配因为已经到底了)</span></span><br><span class="line"><span class="type">LogEntry</span> <span class="variable">preLog</span> <span class="operator">=</span> getPreLog(logEntries.getFirst());</span><br><span class="line">aentryParam.setPreLogTerm(preLog.getTerm());</span><br><span class="line">aentryParam.setPrevLogIndex(preLog.getIndex());</span><br><span class="line"></span><br><span class="line">aentryParam.setEntries(logEntries.toArray(<span class="keyword">new</span> <span class="title class_">LogEntry</span>[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> Request.builder()</span><br><span class="line">        .cmd(Request.A_ENTRIES)</span><br><span class="line">        .obj(aentryParam)</span><br><span class="line">        .url(peer.getAddr())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></li></ul><p>getPreLog() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LogEntry <span class="title function_">getPreLog</span><span class="params">(LogEntry logEntry)</span> &#123;</span><br><span class="line"></span><br><span class="line">    LogEntry entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(logEntry.getIndex() == <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;已经匹配到底了，需要从头开始覆盖&quot;</span>);</span><br><span class="line">        entry = LogEntry.builder().index(-<span class="number">1L</span>).term(-<span class="number">1</span>).command(<span class="literal">null</span>).build();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        entry = logModule.read(logEntry.getIndex() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>失败回溯</strong>：发送请求会携带 <code>prevLogTerm</code> 和 <code>prevLogIndex</code>。如果 Follower 返回失败（日志不匹配或 Leader Term 过旧）：<ul><li>如果是Leader Term 过旧，那就降级为Follower。</li><li>如果不是因为Term过旧，Leader 就将该 Follower 的 <code>nextIndex</code> 减一。</li><li>下次心跳时重试前一条日志，直到找到匹配点（MatchIndex）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">AentryResult</span> <span class="variable">result</span> <span class="operator">=</span> getRpcClient().send(request,<span class="number">450</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;append follower entry success , follower=[&#123;&#125;], entry=[&#123;&#125;]&quot;</span>, peer, aentryParam.getEntries());</span><br><span class="line">        <span class="comment">// update 这两个追踪值</span></span><br><span class="line">        nextIndexs.put(peer, myNewIndex+<span class="number">1</span>);</span><br><span class="line">        matchIndexs.put(peer, myNewIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 对方比我大</span></span><br><span class="line">        <span class="keyword">if</span> (result.getTerm() &gt; currentTerm) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;follower [&#123;&#125;] term [&#123;&#125;] than more self, and my term = [&#123;&#125;], so, I will become follower&quot;</span>,</span><br><span class="line">                    peer, result.getTerm(), currentTerm);</span><br><span class="line">            currentTerm = result.getTerm();</span><br><span class="line">            <span class="comment">// 认怂, 变成跟随者</span></span><br><span class="line">            status = NodeStatus.FOLLOWER;</span><br><span class="line">        &#125; <span class="comment">// 没我大, 却失败了,说明 index 不对.或者 term 不对.</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将nextIndex 减一 下一次心跳继续匹配。</span></span><br><span class="line">            nextIndexs.put(peer, nextIndex - <span class="number">1</span>);</span><br><span class="line">            log.warn(<span class="string">&quot;follower &#123;&#125; nextIndex not match, will reduce nextIndex and retry RPC append, nextIndex : [&#123;&#125;]&quot;</span>, peer.getAddr(),</span><br><span class="line">                    nextIndex);</span><br><span class="line">            <span class="comment">// 下次心跳重来, 直到成功.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;当前接受节点 &#123;&#125; 已宕机&quot;</span>, peer.getAddr());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="3-Follower-的处理逻辑"><a href="#3-Follower-的处理逻辑" class="headerlink" title="3. Follower 的处理逻辑"></a>3. Follower 的处理逻辑</h3><p>Follower 在接收端的处理也做了细致的锁管理：</p><ul><li><strong>日志写入</strong>：收到日志后严格校验匹配性。匹配成功则<strong>加锁</strong>写入本地日志,之后根据leader 的 <code>commitIndex</code>跟自己的 <code>lastIndex</code> 更新自己 <code>commitIndex</code>，异步应用到状态机，并返回成功。</li><li><strong>心跳处理</strong>：收到心跳时，若 Leader Term 小于自己，则拒绝并告知对方退位。若 Term 合法，重置选举超时，转为 Follower（因为自己之前可能是候选人，或者分区之后又合区的老leader）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AentryResult <span class="title function_">appendEntries</span><span class="params">(AentryParam param)</span> &#123;</span><br><span class="line">        <span class="type">AentryResult</span> <span class="variable">result</span> <span class="operator">=</span> AentryResult.fail();</span><br><span class="line">        <span class="comment">// 原appendLock仅保护日志写入/删除等临界操作，锁范围缩小</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!appendLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.setTerm(node.getCurrentTerm());</span><br><span class="line">            <span class="comment">// 1. 任期检查：对方任期更小，直接返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (param.getTerm() &lt; node.getCurrentTerm()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 更新节点状态（Follower）和时间戳</span></span><br><span class="line">            node.preHeartBeatTime = System.currentTimeMillis();</span><br><span class="line">            node.preElectionTime = System.currentTimeMillis();</span><br><span class="line">            node.peerSet.setLeader(<span class="keyword">new</span> <span class="title class_">Peer</span>(param.getLeaderId()));</span><br><span class="line">            <span class="keyword">if</span> (param.getTerm() &gt;= node.getCurrentTerm()) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">&quot;node &#123;&#125; become FOLLOWER, currentTerm : &#123;&#125;, param Term : &#123;&#125;, param serverId = &#123;&#125;&quot;</span>,</span><br><span class="line">                        node.peerSet.getSelf(), node.currentTerm, param.getTerm(), param.getServerId());</span><br><span class="line">                <span class="comment">// 退为跟随者</span></span><br><span class="line">                node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            &#125;</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 处理心跳请求</span></span><br><span class="line">            <span class="keyword">if</span> (param.getEntries() == <span class="literal">null</span> || param.getEntries().length == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;node &#123;&#125; append heartbeat success , he&#x27;s term : &#123;&#125;, my term : &#123;&#125;&quot;</span>,</span><br><span class="line">                        param.getLeaderId(), param.getTerm(), node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 心跳仅更新commitIndex，状态机提交异步执行</span></span><br><span class="line">                <span class="keyword">if</span> (param.getLeaderCommit() &gt; node.getCommitIndex()) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">newCommitIndex</span> <span class="operator">=</span> Math.min(param.getLeaderCommit(), node.getLogModule().getLastIndex());</span><br><span class="line">                    node.setCommitIndex(newCommitIndex);</span><br><span class="line">                    <span class="comment">// 异步提交状态机（核心改造点）</span></span><br><span class="line">                    submitToStateMachineAsync();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 心跳直接返回成功，无需等待提交</span></span><br><span class="line">                <span class="keyword">return</span> AentryResult.newBuilder().term(node.getCurrentTerm()).success(<span class="literal">true</span>).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理真实日志同步请求</span></span><br><span class="line">            <span class="comment">// 4.1 前置日志检查：prevLogIndex/prevLogTerm不匹配则返回失败</span></span><br><span class="line">            <span class="comment">// 如果prevLogIndex=-1，则代表该日志是leader的第一条日志，此时不需要匹配，因为已经是第一个了。</span></span><br><span class="line">            <span class="keyword">if</span> (param.getPrevLogIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> node.getLogModule().read(param.getPrevLogIndex());</span><br><span class="line">                <span class="keyword">if</span> (logEntry == <span class="literal">null</span> || logEntry.getTerm() != param.getPreLogTerm()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 冲突日志处理：索引相同但任期不同则删除后续所有日志</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nextLogIndex</span> <span class="operator">=</span> param.getPrevLogIndex() + <span class="number">1</span>;</span><br><span class="line">            <span class="type">LogEntry</span> <span class="variable">existLog</span> <span class="operator">=</span> node.getLogModule().read(nextLogIndex);</span><br><span class="line">            <span class="keyword">if</span> (existLog != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existLog.getTerm() != param.getEntries()[<span class="number">0</span>].getTerm()) &#123;</span><br><span class="line">                    <span class="comment">// 删除冲突日志及后续</span></span><br><span class="line">                    node.getLogModule().removeOnStartIndex(nextLogIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 日志已存在，无需重复写入，直接返回成功</span></span><br><span class="line">                    result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">                    result.setTerm(node.getCurrentTerm());</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.3 写入日志（核心：写入完成即可返回成功）</span></span><br><span class="line">            <span class="keyword">for</span> (LogEntry entry : param.getEntries()) &#123;</span><br><span class="line">                node.getLogModule().write(entry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 日志写入成功，先标记结果为成功</span></span><br><span class="line">            result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">            result.setTerm(node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.4 更新commitIndex，状态机提交异步执行</span></span><br><span class="line">            <span class="keyword">if</span> (param.getLeaderCommit() &gt; node.getCommitIndex()) &#123;</span><br><span class="line">                <span class="comment">// 更新commitIndex为leaderCommit跟本节点的lastIndex取最小值</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">newCommitIndex</span> <span class="operator">=</span> Math.min(param.getLeaderCommit(), node.getLogModule().getLastIndex());</span><br><span class="line">                node.setCommitIndex(newCommitIndex);</span><br><span class="line">                <span class="comment">// 异步提交状态机（核心改造点）</span></span><br><span class="line">                submitToStateMachineAsync();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.5 立即返回成功，无需等待状态机提交</span></span><br><span class="line">            node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放日志操作锁</span></span><br><span class="line">            <span class="keyword">if</span> (appendLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                appendLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>异步应用 (Async Apply)</strong>：<ul><li>心跳包中包含 Leader 的 <code>commitIndex</code>。</li><li>Follower 取 <code>min(leaderCommit, lastLogIndex)</code> 作为本地提交点。</li><li><strong>优化点</strong>：写入本地日志后，或者更新 commitIndex 后，采用<strong>异步方式</strong>将日志应用（Apply）到状态机，避免阻塞 IO 线程，提升效率。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitToStateMachineAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提交到专用线程池，异步执行</span></span><br><span class="line">        commitExecutor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 加锁保证串行提交，避免重复/并发提交</span></span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 基于lastApplied计算下一个要提交的索引（断点续传核心）</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">nextCommit</span> <span class="operator">=</span> node.getLastApplied() + <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">commitIndex</span> <span class="operator">=</span> node.getCommitIndex();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextCommit &gt; commitIndex) &#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">&quot;暂无需要提交的日志，lastApplied=&#123;&#125;, commitIndex=&#123;&#125;&quot;</span>, nextCommit-<span class="number">1</span>, commitIndex);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOGGER.info(<span class="string">&quot;开始异步提交日志，从索引&#123;&#125;到&#123;&#125;&quot;</span>, nextCommit, commitIndex);</span><br><span class="line">                <span class="comment">// 循环提交日志到状态机</span></span><br><span class="line">                <span class="keyword">while</span> (nextCommit &lt;= commitIndex) &#123;</span><br><span class="line">                    <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> node.getLogModule().read(nextCommit);</span><br><span class="line">                    <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            node.stateMachine.apply(logEntry);</span><br><span class="line">                            <span class="comment">// 每提交一条更新一次lastApplied，保证断点续传</span></span><br><span class="line">                            node.setLastApplied(nextCommit);</span><br><span class="line">                            LOGGER.info(<span class="string">&quot;异步提交日志成功，索引=&#123;&#125;&quot;</span>, nextCommit);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOGGER.error(<span class="string">&quot;异步提交日志到状态机失败，索引=&#123;&#125;&quot;</span>, nextCommit, e);</span><br><span class="line">                            <span class="comment">// 提交失败则终止，避免后续日志错位</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOGGER.warn(<span class="string">&quot;日志不存在，索引=&#123;&#125;&quot;</span>, nextCommit);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextCommit++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放提交锁</span></span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、-CommitIndex-的计算与安全性"><a href="#三、-CommitIndex-的计算与安全性" class="headerlink" title="三、 CommitIndex 的计算与安全性"></a>三、 CommitIndex 的计算与安全性</h2><p>如何确定一条日志可以被安全提交？</p><h3 id="1-基于中位数的-CommitIndex-计算"><a href="#1-基于中位数的-CommitIndex-计算" class="headerlink" title="1. 基于中位数的 CommitIndex 计算"></a>1. 基于中位数的 CommitIndex 计算</h3><p>不再简单依赖单次 RPC 的成功率，而是基于全局视图：</p><ul><li>在每次心跳/日志发送完成（<code>CompletableFuture.allOf</code> 结束）后，统计所有节点的 <code>matchIndex</code>。</li><li><strong>求中位数</strong>：通过排序或统计算法，找出超过半数节点都拥有的最大索引值。</li><li><strong>任期检查</strong>：Raft 规定只能提交当前任期的日志。因此，计算出的索引对应的日志 term 必须等于 <code>currentTerm</code> 才能更新 <code>commitIndex</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待所有日志完成</span></span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">//多个任务</span></span><br><span class="line">    CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">    CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在一个满足N &gt; commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，</span></span><br><span class="line"><span class="comment">// 并且log[N].term == currentTerm成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</span></span><br><span class="line">List&lt;Long&gt; matchIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchIndexs.values());</span><br><span class="line"><span class="comment">// 小于 2, 没有意义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (matchIndexList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Collections.sort(matchIndexList);</span><br><span class="line">    median = matchIndexList.size() / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Long</span> <span class="variable">N</span> <span class="operator">=</span> matchIndexList.get(median);</span><br><span class="line"><span class="keyword">if</span> (N &gt; commitIndex) &#123;</span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> logModule.read(N);</span><br><span class="line">    <span class="comment">// 只能提交当前任期日志</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getTerm() == currentTerm) &#123;</span><br><span class="line">        commitIndex = N;</span><br><span class="line">        <span class="comment">// 异步应用到状态机</span></span><br><span class="line">        RaftThreadPool.execute(()-&gt;&#123;</span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">myCommitIndex</span> <span class="operator">=</span> commitIndex;</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到异步开始时的commitIndex（防止重复提交）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= myCommitIndex; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = myCommitIndex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-解决“幽灵复现”：No-Op-Log"><a href="#2-解决“幽灵复现”：No-Op-Log" class="headerlink" title="2. 解决“幽灵复现”：No-Op Log"></a>2. 解决“幽灵复现”：No-Op Log</h3><p>针对“只能提交当前任期日志”导致旧日志可能无法及时提交的问题（如果允许提交可能会导致同一个位置的日志重复提交），采用了<strong>插入空日志</strong>策略：</p><ul><li>新 Leader 上任后，立即append一条空日志（No-Op Log）。</li><li>一旦这条当前任期的空日志被提交，根据日志连续性原则，之前所有未提交的旧日志也会被间接提交。</li><li>初始化：新 Leader 将所有 Follower 的 <code>nextIndex</code> 初始化为 <code>lastIndex + 1</code>， <code>matchIndex</code> 初始化为 <code>0</code>。利用后续的心跳回溯机制自动对其。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">becomeLeaderToDoThing</span><span class="params">()</span> &#123;</span><br><span class="line">        nextIndexs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        matchIndexs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">            nextIndexs.put(peer, logModule.getLastIndex() + <span class="number">1</span>);</span><br><span class="line">            matchIndexs.put(peer, <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建[空日志]并提交，用于处理前任领导者未提交的日志</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> LogEntry.builder()</span><br><span class="line">                .command(<span class="literal">null</span>)</span><br><span class="line">                .term(currentTerm)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只用提交到本地日志 ， 同步操作在下一次发送心跳时进行。</span></span><br><span class="line">        logModule.write(logEntry);</span><br><span class="line">        log.info(<span class="string">&quot;write logModule success, logEntry info : &#123;&#125;, log index : &#123;&#125;&quot;</span>, logEntry, logEntry.getIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、-线性一致性读-Linearizable-Read"><a href="#四、-线性一致性读-Linearizable-Read" class="headerlink" title="四、 线性一致性读 (Linearizable Read)"></a>四、 线性一致性读 (Linearizable Read)</h2><p>为了防止读取到旧数据（Stale Read），实现了 Follower Read 和 Leader Read。</p><ul><li><strong>Leader Read</strong>：Leader 收到读请求后，不能直接返回。需先广播一轮心跳（同样使用 <code>CompletableFuture</code> 机制），确认自己仍持有过半数选票（未发生脑裂）。确认成功后，等待状态机应用到 <code>commitIndex</code> 后返回结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断自己是否还是leader</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isStillLeader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">Agree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        List&lt;CompletableFuture&lt;AentryResult&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">            <span class="type">AentryParam</span> <span class="variable">param</span> <span class="operator">=</span> AentryParam.builder()</span><br><span class="line">                    .entries(<span class="literal">null</span>)<span class="comment">// 心跳,空日志.</span></span><br><span class="line">                    .leaderId(peerSet.getSelf().getAddr())</span><br><span class="line">                    .serverId(peer.getAddr())</span><br><span class="line">                    .term(currentTerm)</span><br><span class="line">                    .leaderCommit(commitIndex) <span class="comment">// 心跳时与跟随者同步 commit index</span></span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                    Request.A_ENTRIES,</span><br><span class="line">                    param,</span><br><span class="line">                    peer.getAddr());</span><br><span class="line">            futureList.add(CompletableFuture.supplyAsync(()-&gt; getRpcClient().&lt;AentryResult&gt;send(request,<span class="number">300</span>)</span><br><span class="line">                    ,RaftThreadPool.giveMePool()).exceptionally(ex -&gt; <span class="literal">null</span>)</span><br><span class="line">                    .whenComplete((result,throwable)-&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                            log.error(<span class="string">&quot;无法收到 &#123;&#125; 节点的心跳回应，该节点可能已经宕机&quot;</span>,peer.getAddr());</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">term</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                            <span class="keyword">if</span>(term &gt; currentTerm)&#123;</span><br><span class="line">                                log.error(<span class="string">&quot;收到更大的term来自节点&#123;&#125;  当前节点&#123;&#125;目前已不适合当leader&quot;</span>,peer.getAddr(),peerSet.getSelf().getAddr());</span><br><span class="line">                                currentTerm = term;</span><br><span class="line">                                votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                                status = NodeStatus.FOLLOWER;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">//成功回复</span></span><br><span class="line">                                <span class="keyword">if</span>(result.isSuccess())&#123;</span><br><span class="line">                                    log.info(<span class="string">&quot;成功收到来自节点&#123;&#125;的心跳回复且合法&quot;</span>,peer.getAddr());</span><br><span class="line">                                    Agree.incrementAndGet();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有心跳回应</span></span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">            <span class="comment">//多个任务</span></span><br><span class="line">            CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">            CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断现在自己还是不是leader</span></span><br><span class="line">        <span class="keyword">if</span>(status!=NodeStatus.LEADER)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断收到的回复数是否大于等于一半（加上自己即大于一半）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">agreeNum</span> <span class="operator">=</span> Agree.get();</span><br><span class="line">        <span class="keyword">if</span>(agreeNum &gt;= (peerSet.getPeersWithOutSelf().size()+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Follower Read</strong>：<ol><li>Follower 收到读请求，向 Leader 发送 <code>ReadIndex</code> RPC。</li><li>Leader 收到后，执行上述“确认领导权”流程，返回当前的 <code>commitIndex</code>。</li><li>Follower 拿到 <code>commitIndex</code> 后，等待本地 <code>appliedIndex &gt;= commitIndex</code>，再将数据返回给客户端。</li></ol></li></ul><p>响应客户端请求的接口代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  ClientKVAck <span class="title function_">handlerClientRequest</span><span class="params">(ClientKVReq request)</span> &#123;</span><br><span class="line"></span><br><span class="line">    log.warn(<span class="string">&quot;handlerClientRequest handler &#123;&#125; operation,  and key : [&#123;&#125;], value : [&#123;&#125;]&quot;</span>,</span><br><span class="line">            ClientKVReq.Type.value(request.getType()), request.getKey(), request.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写请求必须转给leader</span></span><br><span class="line">    <span class="keyword">if</span> (status != NodeStatus.LEADER &amp;&amp; request.getType() == ClientKVReq.PUT) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;I not am leader , only invoke redirect write method, leader addr : &#123;&#125;, my addr : &#123;&#125;&quot;</span>,</span><br><span class="line">                peerSet.getLeader(), peerSet.getSelf().getAddr());</span><br><span class="line">        <span class="keyword">return</span> redirect(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader收到读请求。</span></span><br><span class="line">    <span class="comment">//为了满足顺序一致性要求，必须让lastApplied == commitIndex才行</span></span><br><span class="line">    <span class="keyword">if</span> (request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.LEADER) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断自己是否还是leader</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeader</span> <span class="operator">=</span> isStillLeader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLeader)&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证自己的lastApplied == commitIndex</span></span><br><span class="line">        <span class="keyword">if</span>(lastApplied != commitIndex)&#123;</span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到commitIndex</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= commitIndex; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = commitIndex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> stateMachine.get(request.getKey());</span><br><span class="line">        <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(logEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是follower收到读请求</span></span><br><span class="line">    <span class="comment">//可以实现follower read , follower向leader发送查询当前readIndex的请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.FOLLOWER)&#123;</span><br><span class="line">        <span class="comment">//向leader发送获取当前最新commitIndex的请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                Request.GET_READ_INDEX,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                peerSet.getLeader().getAddr());</span><br><span class="line"></span><br><span class="line">        GetCommitIndexResult result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             result = getRpcClient().send(request1,<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;无法与leader &#123;&#125; 取得连续，无法返回读请求&quot;</span>,peerSet.getLeader().getAddr());</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result.isSuccess())&#123;</span><br><span class="line">            <span class="comment">//说明当前发送的已经不是leader</span></span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">readIndex</span> <span class="operator">=</span> result.getReadIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须在2s内响应</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        commitLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">2</span>*<span class="number">1000</span>)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastIndex</span> <span class="operator">=</span> logModule.getLastIndex();</span><br><span class="line">                <span class="type">long</span> <span class="variable">shouldCommit</span> <span class="operator">=</span> Math.min(readIndex,lastIndex);</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到shouldCommit</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= shouldCommit; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = shouldCommit;</span><br><span class="line">                <span class="comment">//满足要求</span></span><br><span class="line">                <span class="keyword">if</span>(lastApplied == readIndex)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待一段时间，继续</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    commitLock.unlock();</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    log.error(<span class="string">&quot;同步 ReadIndex 时线程被中断&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    commitLock.lock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            commitLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2秒过后还是没同步</span></span><br><span class="line">        <span class="keyword">if</span>(lastApplied!=readIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> stateMachine.get(request.getKey());</span><br><span class="line">        <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(logEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是候选人响应读请求，则返回失败，因为自己是不稳定的</span></span><br><span class="line">    <span class="keyword">if</span>(request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.CANDIDATE)&#123;</span><br><span class="line">        <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是leader处理写请求，但他只会写入本地，同步日志在心跳时完成。</span></span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> LogEntry.builder()</span><br><span class="line">            .command(Command.builder().</span><br><span class="line">                    key(request.getKey()).</span><br><span class="line">                    value(request.getValue()).</span><br><span class="line">                    build())</span><br><span class="line">            .term(currentTerm)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到本地日志</span></span><br><span class="line">    logModule.write(logEntry);</span><br><span class="line">    log.info(<span class="string">&quot;write logModule success, logEntry info : &#123;&#125;, log index : &#123;&#125;&quot;</span>, logEntry, logEntry.getIndex());</span><br><span class="line">    <span class="keyword">return</span> ClientKVAck.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五、-原项目的一些问题"><a href="#五、-原项目的一些问题" class="headerlink" title="五、 原项目的一些问题"></a>五、 原项目的一些问题</h2><ol><li>原项目只有在有新日志来的时候才会进行日志同步，没有新日志来的时候不会进行日志同步，但是一个落后的节点恢复之后，应该让他同步日志，这样就不会同步及时，于是我改造成了每次心跳时进行日志同步。</li><li>原项目在多个异步线程的同步（比如拉票请求，使用多线程进行发送拉票，但必须都完成之后才开始统计）上使用了 线程池+future+countDownLatch 使用future.get()获得结果，然后使用countDownLatch.await()等待所有线程完成，但是future.get()这个方法会阻塞线程，导致无法进行下一步操作。于是我改造成了CompletableFuture+线程池的方式实现。具体见前文中的代码。</li><li>原项目把lastApplied初始化为0，我认为并不合理，因为这个就默认0位置的日志已经应用了。所以应该改为-1。（我看了一下原项目并没有说明0位置的日志是垃圾日志，并且写入日志也都是从0开始，所以0位置是有用的，不应该跳过）。</li><li>原项目没有对RPC请求进行超时限制。这样在投票中极有可能发生如下情况：一个节点发起拉票请求，但有一个节点宕机，其他节点都投了赞成票。这个宕机节点会导致RPC请求一直处于等待状态，在最后统计得票的时候，会在多个异步任务同步这里超时（一般设为3秒）。但就是在这个时候，其他节点也极有可能发起新一轮的拉票请求，这样本来第一次发送拉票的节点，本应该在他那一轮变成leader但是在3秒之后，虽然拿到了多数票数，但是自己状态是follower（这里参考前文写的节点处理拉票请求），于是失败。这样就会导致多轮无效投票，导致效率低。于是设置一个RPC超时时间（500ms）保证能快速结算票数，让其他节点发起新一轮投票的概率变小。（其实原项目在投票的时候跟我的实现有一定出入，他并未对新一轮投票作出管理（我在当新一轮投票来临时，把自己得投票人置为空，并且把自己变成follower），只有自己变成候选人，然后落选之后才会把投票人清空，我觉得这样效率不高）</li><li>针对第5点的补充说明，原项目只有自己变成候选人，然后落选之后才会把投票人清空。这样做的话，在一个周期内如果没选出来领导人，那就必须等到下一个周期（因为重置投票人会在一个周期后，而不是一个新的term）。而我的改进，让一个节点收到更大的term之后会让出自己的位置，并且释放投票人，这样在每次新的term中每个节点都可以进行投票。这样在一个选举周期内大概率可以成功选举。我这种方案的随机时间设置范围最好为[electiontimeout, 2 * electiontimeout - 1],避免冲突。 （其实我这个思路跟6.824 lab2思路一样）</li><li>原项目并未实现Follower Read。我的具体实现见前文</li></ol><hr><h2 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h2><p>以下是我的一些心得 共12条</p><ol><li>投票时，如果遇到更新的term则把之前的投票人置空，防止无法投票（投票时也需要上锁，避免重复投票），然后判断自己没有投过票，当前发送请求的候选人是否有资格，即持有比自己更新的日志，如果都满足这个followe节点就可以投票给该节点。并更新相应的信息，释放锁。</li><li>Follower收到日志时，判断日志是否匹配，不匹配返回失败，匹配则写入本地。写入本地之后，根据leader的commitIndex异步应用日志，提升效率。但都需要上锁（写入与提交都需要）</li><li>follower收到心跳时，判断leader的term是否小于自己，如果小于返回失败，并且告诉leader自己的term，让他退位。如果大于等于自己，则把自己的状态变为follower(因为节点的状态可能是候选人，或者分区之后又加入的老leader)。然后重置投票倒计时。然后每次心跳还会带有leader的commitIndex，把这个跟自己最后的日志索引取最小值，然后异步应用日志到这个位置，跟leader保持同步。</li><li>在learder中把同步日志到followe操作 跟 心跳放在一起，即每次判断不同的follower是否需要同步日志，如果不需要则发送心跳。通过判断自己的lastIndex&gt;=每个follower的nextIndex（对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一））。如果是则发送nextIndex对应的日志。</li><li>在发送日志阶段，每次发送会带上indexIndex的前一条日志的term和index用于日志匹配。如果follower拒收，那就是日志不匹配（也有可能是leader的term小了，那么leader就应该退为follower），那么就把他的nextIndex 减一。这样下次心跳时就会发送前一个日志给他。直到成功，更新他对应的nextIndex以及matchIndex（对于每一个服务器，已经复制给他的日志的最高索引值）</li><li>合并发送，每次发送日志时，会把nextindex对应日志一直到自己的lastIndex日志一起发送，这样follower一旦匹配就可以批量写入新日志，快速同步。</li><li>当一个节点的投票倒计时结束后，还没收到leader的心跳。自己则会把自己的term+1,把自己变成候选人，投自己一票，然后向所有其他节点发起拉票，这个请求会携带自己的term,最后一个日志的term,index。通过这个其他节点才能判断你是否有资格。</li><li>把实现发起拉票操作的 线程池+Future+CountDownLatch 改成了 CompletableFuture+线程池。因为Future的get方法会阻塞调用，性能不如直接使用CompletableFuture的whenComplete。并且使用一个List<CompletableFuture>去保存这些对象，使用CompletableFuture.allOf方法保持多个异步线程的同步，从而不使用CountDownLatch进行同步。使用AtomicInteger记录投票成功数量，保证安全性。</li><li>在确定Leader的commitIndex时，不再使用每次同步的结果来判断（如果大部分成功就提交）。因为现在是在心跳时同步日志，给每个follower同步的不一定是同一个索引的日志。而是在每次心跳（日志）发送完成之后（跟8一样必须在发送都完成之后），使用每个follower的matchIndex 来判断leade的commitIndex。转化为已知每个节点的最大匹配数，求超过一半的匹配索引（其实就是求中位数即可）。得到对应的commitIndex。判断当前commitIndex的日志是否是自己当前任期的，否则不能提交（防止幽灵复现问题，即重复提交同一个位置的日志），但是可以通过提交当前任期的日志顺带一并提交之前的，但是如果当前任期一直没新日志难道迟迟不提交吗？</li><li>插入空日志，插入空日志就是解决9中提到的幽灵复现问题。每次新leader上任就插入一条空日志，这样就可以实现顺带提交之前任期未提交的日志。也可以及时提交，不依赖于新的日志。新上任的leader初始化所有的 nextIndex 值为自己的最后一条日志的 index + 1，这样下次心跳如果不匹配就会跟第5步一样。</li><li>Leader发送心跳也是使用的CompletableFuture但是这时就不用同步了，根据follower的返回值中的term是否大于自己的term来判断自己是否还能继续当，否则变成follower。</li><li>实现线性一致性的follower read。如果是leader收到读请求，先广播请求来判断当前自己是否还是leader(具体实现还是跟拉票类似，CompletableFuture+线程池)，如果收到过半数的成功回复，则保证将日志应用至commitIndex的位置之后返回读取请求。如果失败则不响应或者返回失败。如果是follower收到了此次读请求，那么发送一个请求当前最新commitIndex(readIndex)的RPC给leader,leader收到请求也会先判断自己是否还是leader,之后返回当前的commitIndex。Follower拿到之后即保证应用至commitIndex位置之后返回读请求，否则返回失败。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java手写Raft篇：核心流程与并发模型优化&quot;&gt;&lt;a href=&quot;#Java手写Raft篇：核心流程与并发模型优化&quot; class=&quot;headerlink&quot; title=&quot;Java手写Raft篇：核心流程与并发模型优化&quot;&gt;&lt;/a&gt;Java手写Raft篇：核心流程与</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（九） 二分</title>
    <link href="https://nmcb666.vip/posts/14894eda.html"/>
    <id>https://nmcb666.vip/posts/14894eda.html</id>
    <published>2026-01-28T16:23:15.000Z</published>
    <updated>2026-02-22T12:13:28.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="狒狒吃香蕉"><a href="#狒狒吃香蕉" class="headerlink" title="狒狒吃香蕉"></a>狒狒吃香蕉</h2><p>思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计答案，右侧二分寻找更大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : piles) &#123;</span><br><span class="line">        r = Math.max(r,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(fMinEatingSpeed(piles,mid) &lt;= h)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">fMinEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles,<span class="type">int</span> speed)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">        cnt += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割数组最大值"><a href="#分割数组最大值" class="headerlink" title="分割数组最大值"></a>分割数组最大值</h2><p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。</p><p>返回分割后最小的和的最大值。</p><p>子数组 是数组中连续的部份。</p><p>思路： 对答案进行二分，答案范围为[0,sum(nums)]。f函数为当最小值为limit的时候，我需要的最小划分数。如果这个最小划分数&lt;=k,则记录答案，并且去左侧二分，寻找更小的答案。反之，则去右侧二分，不记录答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0,sum]二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = sum, m, need; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// 中点m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 必须让数组每一部分的累加和 &lt;= m，请问划分成几个部分才够!</span></span><br><span class="line">need = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (need &lt;= k) &#123;</span><br><span class="line"><span class="comment">// 达标</span></span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须让数组arr每一部分的累加和 &lt;= limit，请问划分成几个部分才够!</span></span><br><span class="line"><span class="comment">// 返回需要的部分数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">parts</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &gt; limit) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum + num &gt; limit) &#123;</span><br><span class="line">parts++;</span><br><span class="line">sum = num;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出第k小的数对距离"><a href="#找出第k小的数对距离" class="headerlink" title="找出第k小的数对距离"></a>找出第k小的数对距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0, 最大-最小]，不停二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>], m, cnt; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// m中点，arr中任意两数的差值 &lt;= m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回数字对的数量</span></span><br><span class="line">cnt = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr中任意两数的差值 &lt;= limit</span></span><br><span class="line"><span class="comment">// 这样的数字配对，有几对？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line"><span class="comment">// l......r r+1</span></span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; arr.length &amp;&amp; arr[r + <span class="number">1</span>] - arr[l] &lt;= limit) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[l...r]范围上的数差值的绝对值都不超过limit</span></span><br><span class="line"><span class="comment">// arr[0...3]</span></span><br><span class="line"><span class="comment">// 0,1</span></span><br><span class="line"><span class="comment">// 0,2</span></span><br><span class="line"><span class="comment">// 0,3</span></span><br><span class="line">ans += r - l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同时运行n台电脑的最长时间"><a href="#同时运行n台电脑的最长时间" class="headerlink" title="同时运行n台电脑的最长时间"></a>同时运行n台电脑的最长时间</h2><p>leelcode2141</p><p>你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。</p><p>一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p><p>注意，你不能给电池充电。</p><p>请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</p><p>思路：还是二分答案。答案范围是[0,sum(batteries)]。f函数为当运行时间为m的时候，我能运行的最多电脑数量。如果这个数量大于等于规定的数量，那么我记录mid,然后去右边二分，寻找更长的时间。反之，不计入答案，去左侧二分。 还有一个贪心优化，可以减少二分的次数。详见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> batteries.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            r+=batteries[i];</span><br><span class="line">            max= Math.max(max,batteries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r&gt; (<span class="type">long</span>) max * n) &#123;</span><br><span class="line">            <span class="comment">// 所有电池的最大电量是max</span></span><br><span class="line">            <span class="comment">// 如果此时sum &gt; (long) max * n，</span></span><br><span class="line">            <span class="comment">// 说明 : 最终的供电时间一定在 &gt;= max，而如果最终的供电时间 &gt;= max</span></span><br><span class="line">            <span class="comment">// 说明 : 对于最终的答案X来说，所有电池都是课上讲的&quot;碎片拼接&quot;的概念</span></span><br><span class="line">            <span class="comment">// 那么寻找 ? * n &lt;= sum 的情况中，尽量大的 ? 即可</span></span><br><span class="line">            <span class="comment">// 即sum / n</span></span><br><span class="line">            <span class="keyword">return</span> r / n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        r = max;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f(batteries,mid);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= n )&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] batteries,<span class="type">long</span> maxTime)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxTime == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">litterTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;batteries.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(batteries[i]&lt;maxTime)&#123;</span><br><span class="line">                litterTime+=batteries[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="type">int</span>) (litterTime/maxTime);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二分总结"><a href="#二分总结" class="headerlink" title="二分总结"></a>二分总结</h1><p>二分答案法，其实都可以看成给了三个变量，数组，限制以及答案。正向推导需要我们根据数组以及限制得到答案。但现在根据二分答案法，我们可以先把答案确定下来，然后算出一个跟限制相关的东西，把这个东西跟原限制作比较（这里就观察单调性），来判断下一步应该去哪边找答案。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-28%20212134.png" alt="总结"/></div><span class="image-caption">总结</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;狒狒吃香蕉&quot;&gt;&lt;a href=&quot;#狒狒吃香蕉&quot; class=&quot;headerlink&quot; title=&quot;狒狒吃香蕉&quot;&gt;&lt;/a&gt;狒狒吃香蕉&lt;/h2&gt;&lt;p&gt;思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（八）双指针</title>
    <link href="https://nmcb666.vip/posts/6fd57b4.html"/>
    <id>https://nmcb666.vip/posts/6fd57b4.html</id>
    <published>2026-01-27T16:04:39.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-27%20160658.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="寻找重复数-leetcode-hot100-最后一题"><a href="#寻找重复数-leetcode-hot100-最后一题" class="headerlink" title="寻找重复数 leetcode hot100 最后一题"></a>寻找重复数 leetcode hot100 最后一题</h2><p>思路：当成链表找环处理。每到一个位置i 那下一次就到arr[i]对应的位置。显然入环节点就是重复的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kuai</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">man</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        kuai = nums[nums[kuai]];</span><br><span class="line">        man = nums[man];</span><br><span class="line">        <span class="keyword">if</span>(kuai == man)&#123;</span><br><span class="line">            kuai = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(kuai != man)&#123;</span><br><span class="line">                kuai = nums[kuai];</span><br><span class="line">                man = nums[man];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kuai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>思路：初始版，类似与前缀和跟后缀和，我开两个数组记录i左边的最大值和右边的最大值，然后求出当前位置能接的雨水。sum+=Math.max(0,Math.min(left[i],right[i])-nums[i])</p><p>优化: 双指针思路，左右两边各一个指针。并且维护两个变量记录，左指针左边的最大值和右指针右边的最大值。对于左指针来说左边的最大值肯定是确定的，右指针同理。所以只需要判断两边谁的最大值更小，那么这一边就可以结算了，并且移动指针，更新最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">1</span>,r=height.length-<span class="number">2</span>,lmax = height[<span class="number">0</span>],rmax = height[height.length-<span class="number">1</span>],sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lmax&gt;=rmax)&#123;</span><br><span class="line">            <span class="comment">//结算右边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,rmax-height[r]);</span><br><span class="line">            rmax = Math.max(rmax,height[r--]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//结算左边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,lmax-height[l]);</span><br><span class="line">            lmax= Math.max(lmax,height[l++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="胖娃坐船"><a href="#胖娃坐船" class="headerlink" title="胖娃坐船"></a>胖娃坐船</h2><p>给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回 承载所有人所需的最小船数 。</p><p>思路：排序，然后双指针，一个指针指向最轻的，一个指针指向最重的，如果最轻的+最重的&lt;=limit，那么可以一起载，两个指针同时移动，ans++。否则，最重的指针移动,ans++。即胖子自己一个船。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    Arrays.sort(people);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>people.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[r]+people[l] &lt;= limit)&#123;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种：如果要求两个的体重加起来等于偶数呢？ 很简单，分为奇偶两个数组，然后分别处理，把两个结果加起来即可。</p><h2 id="供暖器"><a href="#供暖器" class="headerlink" title="供暖器"></a>供暖器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">    Arrays.sort(houses);</span><br><span class="line">    Arrays.sort(heaters);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">heaterIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> house : houses) &#123;</span><br><span class="line">        <span class="comment">// 找到离当前房屋最近的加热器</span></span><br><span class="line">        <span class="keyword">while</span> (heaterIndex &lt; heaters.length - <span class="number">1</span> &amp;&amp; </span><br><span class="line">               Math.abs(heaters[heaterIndex] - house) &gt;= </span><br><span class="line">               Math.abs(heaters[heaterIndex + <span class="number">1</span>] - house)) &#123;</span><br><span class="line">            heaterIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(result, Math.abs(heaters[heaterIndex] - house));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><p>思路：我现在就想让每个位置都对应，即i位置上放的就是i+1。此时，我维护两个指针，l的左边是满足我这个条件的，r的右边是肯定不满足的垃圾。初始化l=0,r=n。</p><p>现在开始遍历：每次都观察l位置上的是否满足，如果满足那就l++。如果不满足判断它是不是我需要的，即它在不在当前l到r范围内（因为小于l的已经就位了，不需要你，大于r的已经超过了，不需要你）。关于为什么大于r就算超过这里解释一下。因为理想状态下我数组长度为n那么我就有1-n这些数，但一旦一个数不满足（r—），那我肯定到不了n了,最大就是r。还有一种情况，现在我需要你，但是在num[num[l]-1] 已经有一个相同的你了，说明你重复了。所以也会被当成垃圾。以上三种情况会被当成垃圾，跟—r位置交换。剩下最后一种情况，你是我需要的而且你还没到应该到的位置，于是我把你交换到对应的位置。下次循环，继续看i位置的数。 直到l&lt;r。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n)，额外空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="comment">// l的左边，都是做到i位置上放着i+1的区域</span></span><br><span class="line"><span class="comment">// 永远盯着l位置的数字看，看能不能扩充(l++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [r....]垃圾区</span></span><br><span class="line"><span class="comment">// 最好的状况下，认为1~r是可以收集全的，每个数字收集1个，不能有垃圾</span></span><br><span class="line"><span class="comment">// 有垃圾呢？预期就会变差(r--)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] == l + <span class="number">1</span>) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]) &#123;</span><br><span class="line">swap(arr, l, --r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, l, arr[l] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img&quot; src=&quot;https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（七） 滑动窗口</title>
    <link href="https://nmcb666.vip/posts/aad8ff6.html"/>
    <id>https://nmcb666.vip/posts/aad8ff6.html</id>
    <published>2026-01-26T16:59:21.000Z</published>
    <updated>2026-02-22T12:13:28.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="累加和大于等于k的最小长度子数组"><a href="#累加和大于等于k的最小长度子数组" class="headerlink" title="累加和大于等于k的最小长度子数组"></a>累加和大于等于k的最小长度子数组</h2><p>都是正数，所以滑动窗口具有单调性，加入新数肯定会导致累加和变大，减少数字会导致累加和变小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">sum += nums[r];</span><br><span class="line"><span class="keyword">while</span> (sum - nums[l] &gt;= target) &#123;</span><br><span class="line"><span class="comment">// sum : nums[l....r]</span></span><br><span class="line"><span class="comment">// 如果l位置的数从窗口出去，还能继续达标，那就出去</span></span><br><span class="line">sum -= nums[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">ans = Math.min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复子串的最长长度"><a href="#无重复子串的最长长度" class="headerlink" title="无重复子串的最长长度"></a>无重复子串的最长长度</h2><p>记录上次这个字符出现的位置，每次更新左边界，就用当前左边界跟（上次重复位置+1）的最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line"><span class="comment">// char -&gt; int -&gt; 0 ~ 255</span></span><br><span class="line"><span class="comment">// 每一种字符上次出现的位置</span></span><br><span class="line"><span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 所有字符都没有上次出现的位置</span></span><br><span class="line">Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 不含有重复字符的 最长子串 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">l = Math.max(l, last[s[r]] + <span class="number">1</span>);</span><br><span class="line">ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 更新当前字符上一次出现的位置</span></span><br><span class="line">last[s[r]] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>描述：给定两个字符串 s 和 t，长度分别是 m 和 n，返回 s 中的 最短窗口 子串，使得该子串包含 t 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 “”。</p><p>等到满足覆盖条件之后，再开始考虑移动左边界。，只有移动左边界不会导致覆盖条件失效，才能移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String str, String tar)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] t = tar.toCharArray();</span><br><span class="line"><span class="comment">// 每种字符的欠债情况</span></span><br><span class="line"><span class="comment">// cnts[i] = 负数，代表字符i有负债</span></span><br><span class="line"><span class="comment">// cnts[i] = 正数，代表字符i有盈余</span></span><br><span class="line"><span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : t) &#123;</span><br><span class="line">cnts[cha]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小覆盖子串的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// 从哪个位置开头，发现的最小覆盖子串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总债务</span></span><br><span class="line"><span class="type">int</span> <span class="variable">debt</span> <span class="operator">=</span> t.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length; r++) &#123;</span><br><span class="line"><span class="comment">// 窗口右边界向右，给出字符</span></span><br><span class="line"><span class="keyword">if</span> (cnts[s[r]]++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">debt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (debt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 窗口左边界向右，拿回字符</span></span><br><span class="line"><span class="keyword">while</span> (cnts[s[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnts[s[l++]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以r位置结尾的达标窗口，更新答案</span></span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">len = r - l + <span class="number">1</span>;</span><br><span class="line">start = l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : str.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换子串得到平衡字符串"><a href="#替换子串得到平衡字符串" class="headerlink" title="替换子串得到平衡字符串"></a>替换子串得到平衡字符串</h2><p>解释：有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>思路：跟最小覆盖子串思路一样。只需要找到哪些字符超过了多少，我们替换他即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        cnt[pos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">debat</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] &lt;= n/<span class="number">4</span>)&#123;</span><br><span class="line">            cnt[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cnt[i] = n/<span class="number">4</span> - cnt[i];</span><br><span class="line">            debat-=cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>;r&lt;s.length();r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(cnt[pos]++ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            debat--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">            c = s.charAt(l);</span><br><span class="line">            pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>( cnt[pos] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cnt[pos]--;</span><br><span class="line">                l++;</span><br><span class="line">                c = s.charAt(l);</span><br><span class="line">                pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans,r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K个不同整数的子数组"><a href="#K个不同整数的子数组" class="headerlink" title="K个不同整数的子数组"></a>K个不同整数的子数组</h2><p>描述：给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</p><p>如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</p><p>例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。<br>子数组 是数组的 连续 部分。</p><p>思路：转化为求不超过k个不同整数问题，用k 减去 k-1 对应的答案 就是刚好个数为k的个数。</p><p>对于不超过这个问题用滑动窗口解决，只要种类不超过就扩大窗口，否则缩小窗口直到种类不超过。然后统计以窗口右边结尾的子数组的个数。即r-l+1.每次累加这个结果即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 不超过k个不同整数</span></span><br><span class="line">    <span class="keyword">return</span> find(nums,k) - find(nums,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">20001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    Arrays.fill(cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;nums.length;r++)&#123;</span><br><span class="line">        <span class="comment">// 窗口右边界向右，给出字符,并判断是不是新的</span></span><br><span class="line">        <span class="keyword">if</span>(++cnt[nums[r]] == <span class="number">1</span>)&#123;</span><br><span class="line">            kinds++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (kinds &gt; k)&#123;</span><br><span class="line">            <span class="comment">// 窗口左边界向右，拿回字符，如果一个字符没有了，则种类减一</span></span><br><span class="line">            <span class="keyword">if</span>( -- cnt[nums[l++]] == <span class="number">0</span>)&#123;</span><br><span class="line">                kinds--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以r位置结尾的达标窗口，累加个数</span></span><br><span class="line">        sum+= r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;累加和大于等于k的最小长度子数组&quot;&gt;&lt;a href=&quot;#累加和大于等于k的最小长度子数组&quot; class=&quot;headerlink&quot; title=&quot;累加和大于等于k的最小长度子数组&quot;&gt;&lt;/a&gt;累加和大于等于k的最小长度子数组&lt;/h2&gt;&lt;p&gt;都是正数，所以滑动窗口具有单</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聚合与聚合根</title>
    <link href="https://nmcb666.vip/posts/6758315a.html"/>
    <id>https://nmcb666.vip/posts/6758315a.html</id>
    <published>2026-01-26T01:21:51.000Z</published>
    <updated>2026-02-22T12:13:28.636Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。</p><p>1.只能通过聚合根来修改内部对象，不能绕过聚合根。</p><p>2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回！</p><p>3.只有聚合根有repository。（实体可以有factory）</p><p>4.设计聚合最好小而全，最好能做到一个实体就是聚合。但做不到也不强求，能满足要求即可，但切记不能过大，也不能太小。</p><p>5.聚合根不能在内部直接引用其他聚合根，只能根据唯一id去查询另一个聚合根，由服务进行统排。</p><p>6.一个事务只对一个聚合根保存生效。</p><p>7.跨聚合采用最终一致性（因为规定了第6条，所以在跨聚合中经常会对不同的表进行操作），具体可以由领域事件实现。</p><p>8.如果聚合根内部有一个实体列表（1：N关系）那么可以考虑把这个实体也变成聚合根，原聚合根只保留他的唯一id列表。如果是多对多关系，可以考虑再新建一个表示它们两个关系的聚合根。</p><p>9.为什么要拆分聚合根？ 因为一个聚合根保留的信息越多，那么在并发的情况下，保存聚合根时冲突的概率就越大。比如我的用户保留了资源列表，而且我是保留了完整的资源信息，那么可能资源的信息修改（只是修改了资源的更新日期），也会导致我的用户保存失败（乐观锁，数据不一样）。但如果把资源单独变成聚合根，用户聚合只保留资源id那么将会避免这种情况。同时考虑资源跟用户是多对多的关系，所以最好最新建一个角色跟资源绑定的聚合根，角色聚合根里面不会有任何资源相关的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。&lt;/p&gt;
&lt;p&gt;1.只能通过聚合根来修改内部对象，不能绕过聚合根。&lt;/p&gt;
&lt;p&gt;2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>算法（六）前缀和</title>
    <link href="https://nmcb666.vip/posts/3fdde4bd.html"/>
    <id>https://nmcb666.vip/posts/3fdde4bd.html</id>
    <published>2026-01-25T17:52:09.000Z</published>
    <updated>2026-02-22T12:13:28.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和（子数组相关问题）"><a href="#一维前缀和（子数组相关问题）" class="headerlink" title="一维前缀和（子数组相关问题）"></a>一维前缀和（子数组相关问题）</h1><h2 id="和等于k的最长子数组长度"><a href="#和等于k的最长子数组长度" class="headerlink" title="和等于k的最长子数组长度"></a>和等于k的最长子数组长度</h2><p>思路：前缀和+哈希表。哈希表存的是key是前缀和，value是出现的位置。但这个位置必须是最早出现的，而且必须预先插入一条 0 ,-1表示0一开始就是。<br>然后，依次遍历数组计算前缀和，用当前的前缀和减去k的值去哈希表里面查找，当前位置减去对应的位置就是以当前位置结尾的最长子数组长度。遍历求最大即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">map.clear();</span><br><span class="line"><span class="comment">// 重要 : 0这个前缀和，一个数字也没有的时候，就存在了</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - aim)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - aim));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找正负数相等的最长子数组"><a href="#找正负数相等的最长子数组" class="headerlink" title="找正负数相等的最长子数组"></a>找正负数相等的最长子数组</h2><p>思路： 构造前缀和，但是前缀和记录正负数数量的差值。正数为1，负数为-1，0为0.然后每到一个位置靠哈希表查询跟自己前缀和相同的位置，然后求长度，即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+= arr[i] == <span class="number">0</span> ? <span class="number">0</span> : arr[i]&lt;<span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cnt))&#123;</span><br><span class="line">              ans = Math.max(ans,i-map.get(cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(cnt))&#123;</span><br><span class="line">                map.put(cnt,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval"><a href="#表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval" class="headerlink" title="表现良好的最长时间段 链接： https://leetcode.cn/problems/longest-well-performing-interval/"></a>表现良好的最长时间段 链接： <a href="https://leetcode.cn/problems/longest-well-performing-interval/">https://leetcode.cn/problems/longest-well-performing-interval/</a></h2><p>思路：还是前缀和+哈希表。超过时长+1，小于时长-1。如果遇到前缀和为正数说明从一开始就是满足的，返回i+1.如果为负数或者0，那么就找前缀和-1的位置（拉格朗日中值定理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line"><span class="comment">// 某个前缀和，最早出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 0这个前缀和，最早出现在-1，一个数也没有的时候</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">sum += hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// sum &lt;= 0</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - <span class="number">1</span>)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="移除最少子数组长度使数组和可以被p整除"><a href="#移除最少子数组长度使数组和可以被p整除" class="headerlink" title="移除最少子数组长度使数组和可以被p整除"></a>移除最少子数组长度使数组和可以被p整除</h2><p>思路：以余数为前缀和，求出整个数组和的余数mod。然后在遍历过程中遇到当前余数curMod，我们就需要找到之前最后一个余数为 (curMod + p - mod)%p 的位置，然后求出长度。就是需要在当前位置移除的子数组的长度。需要最后判断长度是等于数组长度的时候，返回-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="comment">// 整体余数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">mod = (mod + num) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mod == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key : 前缀和%p的余数</span></span><br><span class="line"><span class="comment">// value : 最晚出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>, find; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="comment">// 0...i这部分的余数</span></span><br><span class="line">cur = (cur + nums[i]) % p;</span><br><span class="line">find = cur &gt;= mod ? (cur - mod) : (cur + p - mod);</span><br><span class="line"><span class="comment">// find = (cur + p - mod) % p;</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(find)) &#123;</span><br><span class="line">ans = Math.min(ans, i - map.get(find));</span><br><span class="line">&#125;</span><br><span class="line">map.put(cur, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == nums.length ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p>解释：现在要进行如下操作：</p><ol><li>给定一个数组，我要在给定区间加上一个同样的数。循环多次</li><li>加完之后返回给我每个位置上的值。</li></ol><p>一维差分：</p><ol><li>区间如果为l,r 要加上a,那么我在arr[l]+a,arr[r+1]-a.</li><li>之后对这个数组求前缀和，就是结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookings</span></span><br><span class="line"><span class="comment">// [1,5,6]</span></span><br><span class="line"><span class="comment">// [2,9,3]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line"><span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 设置差分数组，每一个操作对应两个设置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] book : bookings) &#123;</span><br><span class="line">cnt[book[<span class="number">0</span>]] += book[<span class="number">2</span>];</span><br><span class="line">cnt[book[<span class="number">1</span>] + <span class="number">1</span>] -= book[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加工前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans[i] = cnt[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="等差差分"><a href="#等差差分" class="headerlink" title="等差差分"></a>等差差分</h1><p>解释： 跟一维差分类似，但是我要从l到r 依次加上一个等差数列，而不是一个数。</p><p>结论： 假设这个等差数列 首项为 s , 公差为 d, 末项为 e。那对arr[l]+=s,arr[l+1]+=d-s,arr[r+1]-=d+e,arr[r+2]+=e; 然后进行两次前缀和即可。</p><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>公式： sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + arr[i][j]<br>计算从（a,b）到 （c,d）的子矩阵的和 : sum[c][d] - sum[a-1][d] - sum[c][b-1] + sum[a-1][b-1]</p><h2 id="最大以1为边界的正方形"><a href="#最大以1为边界的正方形" class="headerlink" title="最大以1为边界的正方形"></a>最大以1为边界的正方形</h2><p>描述：给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>核心思路：构造出二维前缀和，依次枚举以（i,j）为左上角的正方形是否合法。假设以(c,d)为右下角。这个正方形的和减去以(i+1,j+1),(c-1,d-1)为对角的正方形和的值应该等于他的（边长-1） * 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> g[<span class="number">0</span>].length;</span><br><span class="line">build(n, m, g);</span><br><span class="line"><span class="keyword">if</span> (sum(g, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, m - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到的最大合法正方形的边长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; m; b++) &#123;</span><br><span class="line"><span class="comment">// (a,b)所有左上角点</span></span><br><span class="line"><span class="comment">//     (c,d)更大边长的右下角点，k是当前尝试的边长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + ans, d = b + ans, k = ans + <span class="number">1</span>; c &lt; n &amp;&amp; d &lt; m; c++, d++, k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum(g, a, b, c, d) - sum(g, a + <span class="number">1</span>, b + <span class="number">1</span>, c - <span class="number">1</span>, d - <span class="number">1</span>) == (k - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>) &#123;</span><br><span class="line">ans = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g : 原始二维数组</span></span><br><span class="line"><span class="comment">// 把g变成原始二维数组的前缀和数组sum，复用自己</span></span><br><span class="line"><span class="comment">// 不能补0行，0列，都是0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">g[i][j] += get(g, i, j - <span class="number">1</span>) + get(g, i - <span class="number">1</span>, j) - get(g, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; c ? <span class="number">0</span> : (g[c][d] - get(g, c, b - <span class="number">1</span>) - get(g, a - <span class="number">1</span>, d) + get(g, a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) ? <span class="number">0</span> : g[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>跟一维差分差不多这里直接给公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维差分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">diff[a][b] += k;</span><br><span class="line">diff[c + <span class="number">1</span>][b] -= k;</span><br><span class="line">diff[a][d + <span class="number">1</span>] -= k;</span><br><span class="line">diff[c + <span class="number">1</span>][d + <span class="number">1</span>] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一维前缀和（子数组相关问题）&quot;&gt;&lt;a href=&quot;#一维前缀和（子数组相关问题）&quot; class=&quot;headerlink&quot; title=&quot;一维前缀和（子数组相关问题）&quot;&gt;&lt;/a&gt;一维前缀和（子数组相关问题）&lt;/h1&gt;&lt;h2 id=&quot;和等于k的最长子数组长度&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
