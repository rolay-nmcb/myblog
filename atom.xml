<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2025-09-28T06:22:14.466Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows11安装docker</title>
    <link href="https://nmcb666.vip/posts/fd5326b3.html"/>
    <id>https://nmcb666.vip/posts/fd5326b3.html</id>
    <published>2025-09-28T14:13:48.000Z</published>
    <updated>2025-09-28T06:22:14.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-11下安装Docker并修改安装位置至非C盘教程"><a href="#Windows-11下安装Docker并修改安装位置至非C盘教程" class="headerlink" title="Windows 11下安装Docker并修改安装位置至非C盘教程"></a>Windows 11下安装Docker并修改安装位置至非C盘教程</h1><h1 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a>一、安装前准备</h1><h2 id="1-1-检查系统要求"><a href="#1-1-检查系统要求" class="headerlink" title="1.1 检查系统要求"></a>1.1 检查系统要求</h2><p>在安装Docker前，需确保Windows 11系统满足以下条件：</p><ul><li><p>系统版本：Windows 11 64位专业版、企业版或教育版（家庭版需通过WSL 2支持）。</p></li><li><p>硬件要求：支持硬件虚拟化技术（VT-x/AMD-V），并在BIOS/UEFI中启用。</p></li><li><p>WSL 2要求：已安装并启用Windows Subsystem for Linux 2，且内核版本更新至最新。</p></li><li><p>存储空间：非C盘预留至少20GB空闲空间（用于Docker安装及镜像存储）。</p></li></ul><h2 id="1-2-启用必要功能"><a href="#1-2-启用必要功能" class="headerlink" title="1.2 启用必要功能"></a>1.2 启用必要功能</h2><p>打开“控制面板”→“程序”→“程序和功能”→“启用或关闭Windows功能”，勾选以下选项并点击“确定”，等待系统配置完成后重启电脑：</p><ul><li><p>Hyper-V（全部组件）</p></li><li><p>容器</p></li><li><p>Windows虚拟机监控程序平台</p></li></ul><p>若为Windows 11家庭版，需先安装WSL 2：以管理员身份打开PowerShell，输入命令 <code>wsl --install</code>，重启电脑后完成WSL 2安装。</p><h1 id="二、下载Docker安装程序"><a href="#二、下载Docker安装程序" class="headerlink" title="二、下载Docker安装程序"></a>二、下载Docker安装程序</h1><p>访问Docker官方网站（<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>），点击“Download for Windows”下载最新版Docker Desktop安装包（.exe文件），保存至非C盘的临时文件夹（如D:\Temp）。</p><h1 id="三、修改安装位置（已有安装程序时）"><a href="#三、修改安装位置（已有安装程序时）" class="headerlink" title="三、修改安装位置（已有安装程序时）"></a>三、修改安装位置（已有安装程序时）</h1><h2 id="3-1-解压安装程序（可选）"><a href="#3-1-解压安装程序（可选）" class="headerlink" title="3.1 解压安装程序（可选）"></a>3.1 解压安装程序（可选）</h2><p>若已下载Docker安装包，可通过以下方式查看安装文件结构（非必需步骤）：</p><ol><li><p>以管理员身份打开PowerShell，切换至安装包所在目录，例如：<code>cd D:\Temp</code>。</p></li><li><p>输入命令解压安装包：<code>Docker Desktop Installer.exe extract --destination D:\DockerTemp</code>，将安装文件提取至D:\DockerTemp文件夹。</p></li></ol><h2 id="3-2-通过命令行指定安装路径"><a href="#3-2-通过命令行指定安装路径" class="headerlink" title="3.2 通过命令行指定安装路径"></a>3.2 通过命令行指定安装路径</h2><p>这是修改Docker安装位置的核心步骤，需通过命令行参数指定非C盘安装目录：</p><ol><li><p>以<strong>管理员身份</strong>打开PowerShell，切换至Docker安装包所在目录（如D:\Temp）。</p></li><li><p>输入以下命令，将安装位置指定为非C盘路径（以D:\Docker为例）：<br><code>.\Docker Desktop Installer.exe install --installation-dir=D:\Docker --windows-containers=false --wsl2=true</code></p></li><li><p>命令参数说明：</p><pre><code> `--installation-dir=D:\Docker`：指定Docker主程序安装目录（非C盘路径）。</code></pre></li><li><p><code>--windows-containers=false</code>：默认启用Linux容器（如需Windows容器可改为true）。</p></li><li><p><code>--wsl2=true</code>：强制使用WSL 2作为容器运行时（推荐）。</p></li><li><p>执行命令后，等待安装进度完成，期间可能会提示重启电脑，点击“确定”即可。</p></li></ol><div class="tip warning faa-horizontal animated-hover"><p>若之前已安装过Docker并默认在C盘，需先卸载旧版本：打开“设置”→“应用”→“应用和功能”，找到“Docker Desktop”，点击“卸载”，并删除残留文件后再执行上述命令。</p></div><h1 id="四、验证安装结果"><a href="#四、验证安装结果" class="headerlink" title="四、验证安装结果"></a>四、验证安装结果</h1><h2 id="4-1-启动Docker-Desktop"><a href="#4-1-启动Docker-Desktop" class="headerlink" title="4.1 启动Docker Desktop"></a>4.1 启动Docker Desktop</h2><p>安装完成后，在开始菜单中找到“Docker Desktop”并启动，首次启动可能需要几分钟时间（初始化WSL 2环境）。启动成功后，任务栏右下角会显示Docker图标（蓝色鲸鱼图标）。</p><h2 id="4-2-检查安装路径"><a href="#4-2-检查安装路径" class="headerlink" title="4.2 检查安装路径"></a>4.2 检查安装路径</h2><p>打开文件资源管理器，导航至之前指定的安装目录（如D:\Docker），可看到Docker的主程序文件及相关组件，确认安装位置正确。</p><h2 id="4-3-测试Docker功能"><a href="#4-3-测试Docker功能" class="headerlink" title="4.3 测试Docker功能"></a>4.3 测试Docker功能</h2><p>以管理员身份打开PowerShell，输入以下命令测试Docker是否正常工作：</p><ol><li><p>查看Docker版本：<code>docker --version</code>，若输出类似“Docker version 26.1.4, build 5650f9b”则说明版本查询正常。</p></li><li><p>运行Hello World镜像：<code>docker run hello-world</code>，若输出“Hello from Docker!”等信息，说明Docker已成功拉取并运行镜像，功能正常。</p></li></ol><h1 id="五、后续配置（可选）"><a href="#五、后续配置（可选）" class="headerlink" title="五、后续配置（可选）"></a>五、后续配置（可选）</h1><h2 id="5-1-修改镜像存储位置"><a href="#5-1-修改镜像存储位置" class="headerlink" title="5.1 修改镜像存储位置"></a>5.1 修改镜像存储位置</h2><p>默认情况下，Docker镜像存储在WSL 2分发版的虚拟磁盘中（通常位于C盘），可通过以下步骤迁移至非C盘：</p><ol><li><p>关闭Docker Desktop：右键任务栏Docker图标，点击“Quit Docker Desktop”。</p></li><li><p>导出WSL 2分发版：在PowerShell中输入<code>wsl --export docker-desktop-data D:\Docker\wsl\data\docker-desktop-data.tar</code>。</p></li><li><p>注销现有分发版：<code>wsl --unregister docker-desktop-data</code>。</p></li><li><p>重新导入分发版至非C盘：<code>wsl --import docker-desktop-data D:\Docker\wsl\data D:\Docker\wsl\data\docker-desktop-data.tar --version 2</code>。</p></li><li><p>重启Docker Desktop，镜像存储位置即迁移至D:\Docker\wsl\data。</p></li></ol><h2 id="5-2-配置国内镜像源"><a href="#5-2-配置国内镜像源" class="headerlink" title="5.2 配置国内镜像源"></a>5.2 配置国内镜像源</h2><p>为加快镜像拉取速度，可配置国内镜像源：打开Docker Desktop，点击“Settings”→“Docker Engine”，在JSON配置中添加镜像源，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.1ms.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker-0.unsee.tech&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>点击“Apply &amp; Restart”保存配置并重启Docker。</p><h1 id="六、常见问题解决"><a href="#六、常见问题解决" class="headerlink" title="六、常见问题解决"></a>六、常见问题解决</h1><ul><li><p><strong>问题1：安装时提示“Hyper-V未启用”</strong>：重新检查“启用或关闭Windows功能”中Hyper-V组件是否全部勾选，若已勾选仍报错，可能是BIOS中虚拟化未启用，需重启电脑进入BIOS开启VT-x/AMD-V。</p></li><li><p><strong>问题2：Docker启动卡在“Starting…”</strong>：关闭Docker后，在PowerShell中输入<code>wsl --shutdown</code>关闭WSL 2，再重新启动Docker。</p></li><li><p><strong>问题3：命令行输入docker命令提示“command not found”</strong>：检查系统环境变量PATH中是否包含Docker安装目录（如D:\Docker\resources\bin），若未包含需手动添加后重启PowerShell。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-11下安装Docker并修改安装位置至非C盘教程&quot;&gt;&lt;a href=&quot;#Windows-11下安装Docker并修改安装位置至非C盘教程&quot; class=&quot;headerlink&quot; title=&quot;Windows 11下安装Docker并修改安装位置至非</summary>
      
    
    
    
    
    <category term="docker" scheme="https://nmcb666.vip/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>快排与归并排序</title>
    <link href="https://nmcb666.vip/posts/4e7c2b21.html"/>
    <id>https://nmcb666.vip/posts/4e7c2b21.html</id>
    <published>2025-09-23T22:03:13.000Z</published>
    <updated>2025-09-28T06:22:14.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序与归并排序：两种高效排序算法的深度解析"><a href="#快速排序与归并排序：两种高效排序算法的深度解析" class="headerlink" title="快速排序与归并排序：两种高效排序算法的深度解析"></a>快速排序与归并排序：两种高效排序算法的深度解析</h1><p>排序算法是计算机科学中的基础内容，在日常开发中有着广泛应用。本文将深入探讨两种经典的高效排序算法：快速排序和归并排序，分析它们的工作原理、实现方式、时间复杂度以及适用场景。</p><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h2><p>快速排序由计算机科学家Tony Hoare于1960年提出，是一种分治法策略的排序算法。它的核心思想是”分而治之”，通过选择一个”基准”元素，将数组分为两部分，一部分所有元素都小于基准，另一部分所有元素都大于基准，然后递归地对这两部分进行排序。</p><h3 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序算法实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :return: 排序后的列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基本情况：如果列表长度小于等于1，则已经是排序好的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择基准元素（这里选择中间元素）</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分区：小于基准、等于基准、大于基准</span></span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序并合并结果</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(left) + middle + quick_sort(right)</span><br></pre></td></tr></table></figure><p>上面的实现采用了列表推导式，使代码更加简洁。实际应用中，为了减少内存开销，更常见的是采用原地(in-place)分区的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort_in_place</span>(<span class="params">arr, low=<span class="literal">None</span>, high=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原地快速排序实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :param low: 排序起始索引</span></span><br><span class="line"><span class="string">    :param high: 排序结束索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化low和high参数</span></span><br><span class="line">    <span class="keyword">if</span> low <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> high <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        high = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基本情况：如果起始索引大于等于结束索引，则无需排序</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分区操作，返回基准元素的最终位置</span></span><br><span class="line">    pivot_index = partition(arr, low, high)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序基准元素左右两部分</span></span><br><span class="line">    quick_sort_in_place(arr, low, pivot_index - <span class="number">1</span>)</span><br><span class="line">    quick_sort_in_place(arr, pivot_index + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    分区操作</span></span><br><span class="line"><span class="string">    :param arr: 要分区的列表</span></span><br><span class="line"><span class="string">    :param low: 分区起始索引</span></span><br><span class="line"><span class="string">    :param high: 分区结束索引</span></span><br><span class="line"><span class="string">    :return: 基准元素的最终位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择最右边的元素作为基准</span></span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># i是小于基准区域的边界</span></span><br><span class="line">    i = low - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历数组，将小于基准的元素放到左边</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将基准元素放到正确的位置</span></span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="快速排序的特性"><a href="#快速排序的特性" class="headerlink" title="快速排序的特性"></a>快速排序的特性</h3><ol><li><p><strong>时间复杂度</strong>：</p><ul><li>平均情况：O(n log n)</li><li>最坏情况：O(n²)（当输入数组已经排序或接近排序时）</li><li>最好情况：O(n log n)</li></ul></li><li><p><strong>空间复杂度</strong>：</p><ul><li>递归实现：O(log n) ~ O(n)（取决于递归深度）</li><li>原地实现：O(log n)（主要是递归调用栈的开销）</li></ul></li><li><p><strong>稳定性</strong>：不稳定排序（相等元素的相对顺序可能改变）</p></li><li><p><strong>特点</strong>：</p><ul><li>实际应用中通常比其他O(n log n)算法快</li><li>缓存友好，因为它具有良好的局部性</li><li>对已经排序的数据性能较差，可以通过随机选择基准元素来改善</li><li>不适合对链表进行排序</li></ul></li></ol><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h2><p>归并排序是另一种基于分治法的排序算法，由John von Neumann于1945年提出。它将数组分成两个 halves，分别对它们进行排序，然后将排序好的两半合并在一起。</p><h3 id="归并排序的实现"><a href="#归并排序的实现" class="headerlink" title="归并排序的实现"></a>归并排序的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序算法实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :return: 排序后的列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基本情况：如果列表长度小于等于1，则已经是排序好的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将列表分成两半</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(arr[:mid])</span><br><span class="line">    right = merge_sort(arr[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并两个已排序的子列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个已排序的列表</span></span><br><span class="line"><span class="string">    :param left: 第一个已排序列表</span></span><br><span class="line"><span class="string">    :param right: 第二个已排序列表</span></span><br><span class="line"><span class="string">    :return: 合并后的排序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较两个列表的元素，按顺序添加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加剩余元素</span></span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>归并排序也可以实现为原地排序，但实现较为复杂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort_in_place</span>(<span class="params">arr, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原地归并排序实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :param left: 排序起始索引</span></span><br><span class="line"><span class="string">    :param right: 排序结束索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基本情况：如果起始索引大于等于结束索引，则无需排序</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 找到中间点</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归排序左半部分和右半部分</span></span><br><span class="line">        merge_sort_in_place(arr, left, mid)</span><br><span class="line">        merge_sort_in_place(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 合并已排序的两部分</span></span><br><span class="line">        merge_in_place(arr, left, mid, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_in_place</span>(<span class="params">arr, left, mid, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原地合并两个已排序的子数组</span></span><br><span class="line"><span class="string">    :param arr: 包含两个已排序子数组的数组</span></span><br><span class="line"><span class="string">    :param left: 第一个子数组的起始索引</span></span><br><span class="line"><span class="string">    :param mid: 第一个子数组的结束索引</span></span><br><span class="line"><span class="string">    :param right: 第二个子数组的结束索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算两个子数组的长度</span></span><br><span class="line">    n1 = mid - left + <span class="number">1</span></span><br><span class="line">    n2 = right - mid</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建临时数组</span></span><br><span class="line">    L = [<span class="number">0</span>] * n1</span><br><span class="line">    R = [<span class="number">0</span>] * n2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">        L[i] = arr[left + i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">        R[j] = arr[mid + <span class="number">1</span> + j]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 原地合并临时数组到原数组</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    k = left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">            arr[k] = L[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = R[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1:</span><br><span class="line">        arr[k] = L[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> j &lt; n2:</span><br><span class="line">        arr[k] = R[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="归并排序的特性"><a href="#归并排序的特性" class="headerlink" title="归并排序的特性"></a>归并排序的特性</h3><ol><li><p><strong>时间复杂度</strong>：</p><ul><li>平均情况：O(n log n)</li><li>最坏情况：O(n log n)</li><li>最好情况：O(n log n)</li></ul></li><li><p><strong>空间复杂度</strong>：</p><ul><li>标准实现：O(n)（需要额外的存储空间）</li><li>原地实现：O(log n)（主要是递归调用栈的开销）</li></ul></li><li><p><strong>稳定性</strong>：稳定排序（相等元素的相对顺序保持不变）</p></li><li><p><strong>特点</strong>：</p><ul><li>性能稳定，不受输入数据分布影响</li><li>适合对链表进行排序</li><li>需要额外的存储空间（除非使用复杂的原地实现）</li><li>并行性好，可以很容易地并行化处理</li></ul></li></ol><h2 id="快速排序与归并排序的对比"><a href="#快速排序与归并排序的对比" class="headerlink" title="快速排序与归并排序的对比"></a>快速排序与归并排序的对比</h2><div class="table-container"><table><thead><tr><th>特性</th><th>快速排序</th><th>归并排序</th></tr></thead><tbody><tr><td>平均时间复杂度</td><td>O(n log n)</td><td>O(n log n)</td></tr><tr><td>最坏时间复杂度</td><td>O(n²)</td><td>O(n log n)</td></tr><tr><td>空间复杂度</td><td>O(log n) ~ O(n)</td><td>O(n) 或 O(log n)</td></tr><tr><td>稳定性</td><td>不稳定</td><td>稳定</td></tr><tr><td>原地排序</td><td>可以</td><td>可以，但实现复杂</td></tr><tr><td>对缓存友好性</td><td>好</td><td>一般</td></tr><tr><td>对已排序数据</td><td>性能差</td><td>性能稳定</td></tr><tr><td>并行性</td><td>一般</td><td>好</td></tr><tr><td>实现复杂度</td><td>较简单</td><td>较复杂</td></tr></tbody></table></div><h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><div class="tip cogs"><ul><li><p><strong>快速排序</strong>通常在实际应用中表现更好，因为它的缓存利用率高，并且不需要额外的大量内存。适合大多数一般情况的排序需求。</p></li><li><p><strong>归并排序</strong>的优势在于其稳定性和可预测的O(n log n)时间复杂度，适合对排序稳定性有要求的场景，或者处理链表排序。</p></li></ul></div><p>在选择排序算法时，应根据具体的应用场景、数据特征和性能要求进行选择。在许多标准库中，会结合两种算法的优点，例如Java的<code>Arrays.sort()</code>对于原始类型使用双轴快速排序，对于对象类型使用归并排序（Java 7及之前）或TimSort（Java 8及之后）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序与归并排序：两种高效排序算法的深度解析&quot;&gt;&lt;a href=&quot;#快速排序与归并排序：两种高效排序算法的深度解析&quot; class=&quot;headerlink&quot; title=&quot;快速排序与归并排序：两种高效排序算法的深度解析&quot;&gt;&lt;/a&gt;快速排序与归并排序：两种高效排序算</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于爬取贴吧的两种网页差异</title>
    <link href="https://nmcb666.vip/posts/cf38f81c.html"/>
    <id>https://nmcb666.vip/posts/cf38f81c.html</id>
    <published>2025-09-19T21:16:00.000Z</published>
    <updated>2025-09-28T06:22:14.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度贴吧爬取时两种网页结构的差异"><a href="#百度贴吧爬取时两种网页结构的差异" class="headerlink" title="百度贴吧爬取时两种网页结构的差异"></a>百度贴吧爬取时两种网页结构的差异</h1><p>百度贴吧作为国内极具影响力的中文社区，其海量的用户生成内容（UGC）是进行市场调研、情感分析、热点追踪的宝贵数据资源。但在实际爬取过程中，很多开发者会遇到“明明XPath规则正确却爬不到数据”的问题，其核心原因在于百度贴吧存在两种差异化的前端渲染结构。</p><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h3 id="1-1-贴吧URL结构分析"><a href="#1-1-贴吧URL结构分析" class="headerlink" title="1.1 贴吧URL结构分析"></a>1.1 贴吧URL结构分析</h3><p>贴吧的帖子URL遵循固定格式，掌握后可批量构造爬取链接：</p><ul><li><p><strong>单页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]</code>（默认显示第一页）</p></li><li><p><strong>分页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]?pn=[页码]</code>（pn参数指定页码，如pn=2表示第二页）</p></li></ul><p>例如：帖子<code>https://tieba.baidu.com/p/789012345?pn=3</code>表示ID为789012345的帖子的第三页内容。</p><h2 id="二、两种网页结构的深度对比"><a href="#二、两种网页结构的深度对比" class="headerlink" title="二、两种网页结构的深度对比"></a>二、两种网页结构的深度对比</h2><p>通过Chrome开发者工具（F12）查看网页源码，我们发现两种结构的核心差异集中在<strong>帖子内容容器</strong>和<strong>发布时间节点</strong>，以下是具体对比：</p><h3 id="2-1-结构一：传统版（无clearfix后缀）"><a href="#2-1-结构一：传统版（无clearfix后缀）" class="headerlink" title="2.1 结构一：传统版（无clearfix后缀）"></a>2.1 结构一：传统版（无clearfix后缀）</h3><p>通过“检查”功能定位到帖子内容和发布时间节点，其HTML结构如下：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/2.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code></p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#39;)</code><br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//span[@class=&quot;tail-info&quot;]/text()&#39;)[-1] for i in create_time]</code>（取最后一个tail-info的文本）</p></li></ul><h3 id="2-2-结构二：新版（含clearfix后缀）"><a href="#2-2-结构二：新版（含clearfix后缀）" class="headerlink" title="2.2 结构二：新版（含clearfix后缀）"></a>2.2 结构二：新版（含clearfix后缀）</h3><p>其HTML结构调整了class属性和节点层级：</p><p><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/3.png" alt="code"><br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/4.png" alt="code"></p><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code>（注意两个空格）</p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail &quot;]&#39;)</code>（<br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#39;)[-1] for i in create_time]</code>取p_tail最后一个li的span文本）</p></li></ul><p><strong>关键提醒</strong>：XPath中class属性的匹配是<strong>精确匹配</strong>，空格和后缀的差异会导致解析失败。在编写规则时，必须完全复制网页源码中的class值。</p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 提取帖子评论数据第一种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#x27;</span>)</span><br><span class="line">create_time = [i.xpath(<span class="string">&#x27;.//span[@class=&quot;tail-info&quot;]/text()&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> create_time]</span><br><span class="line"><span class="comment"># 提取帖子评论数据第二种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail &quot;]&#x27;</span>)</span><br><span class="line">create_time_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> create_time:</span><br><span class="line">    time_elements = i.xpath(<span class="string">&#x27;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> time_elements:</span><br><span class="line">        create_time_list.append(time_elements[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        create_time_list.append(<span class="string">&#x27;未知&#x27;</span>)</span><br><span class="line">create_time = create_time_list</span><br></pre></td></tr></table></figure><h2 id="四、关于爬取贴吧列表"><a href="#四、关于爬取贴吧列表" class="headerlink" title="四、关于爬取贴吧列表"></a>四、关于爬取贴吧列表</h2><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h3><p>贴吧列表页面如下所示<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/5.png" alt="code"><br>现在我们想要获取列表页的贴子名称，帖子作者，帖子链接，帖子时间<br>原来的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">        title_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@title&#x27;</span>)</span><br><span class="line">        link_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@href&#x27;</span>)</span><br><span class="line">        creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot;]/@title&#x27;</span>)</span><br><span class="line">        create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>看上去似乎没有什么问题 ，但是运行代码的时候，发现爬取的帖子有些标题跟时间对不上这会导致一些问题。<br>所以这到底是为什么呢？<br>我们可以打开f12查看网页源代码，查看列表页面的html结构，通过观察可以发现，一些帖子的标题，链接，发帖人的html结构跟大部分还不一样。<br>例如普通的标题页面结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/6.png" alt="code"><br>但是某些帖子标题的html结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/7.png" alt="code"><br>可以发现少部分贴子的标题比普通的多了member_thread_title_frs 这一段文字 导致获取不到一些帖子标题，所以也就造成了之后的时间不一致的问题。</p><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><p>解决方法很简单只需要在多匹配那少部分的内容即可。<br>可以把原来的正则表达式替换为<code>//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title</code>。<br>这样就能匹配只要有threadlist_title pull_left j_th_tit 的内容了。<br>但是注意这里的作者名称，一个帖子会有两个作者名称。第一个是帖子作者，第二个是最后评论的人的名称。这里我们只需要获取第一个作者名称即可。<br>于是关于作者名称的正则表达式用or即可。<br>修改的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">title_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title&#x27;</span>)</span><br><span class="line">link_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@href&#x27;</span>)</span><br><span class="line"><span class="comment"># 修改后的作者匹配规则，只匹配指定的两种形式</span></span><br><span class="line">creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot; or @class=&quot;tb_icon_author no_icon_author&quot;]/@title&#x27;</span>)</span><br><span class="line">create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>这样修改之后就可以匹配到正确的完整的数据了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度贴吧爬取时两种网页结构的差异&quot;&gt;&lt;a href=&quot;#百度贴吧爬取时两种网页结构的差异&quot; class=&quot;headerlink&quot; title=&quot;百度贴吧爬取时两种网页结构的差异&quot;&gt;&lt;/a&gt;百度贴吧爬取时两种网页结构的差异&lt;/h1&gt;&lt;p&gt;百度贴吧作为国内极具影响力的</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://nmcb666.vip/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬取微博移动端评论</title>
    <link href="https://nmcb666.vip/posts/eb47d163.html"/>
    <id>https://nmcb666.vip/posts/eb47d163.html</id>
    <published>2025-09-19T16:58:21.000Z</published>
    <updated>2025-09-28T06:22:14.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬取微博移动端评论完整教程（基础-常见问题）"><a href="#Python爬取微博移动端评论完整教程（基础-常见问题）" class="headerlink" title="Python爬取微博移动端评论完整教程（基础+常见问题）"></a>Python爬取微博移动端评论完整教程（基础+常见问题）</h1><p>在数据采集领域，微博作为国内主流的社交媒体平台，其评论数据蕴含着丰富的用户观点和舆论倾向。相较于PC端，微博移动端接口更简洁、反爬措施相对宽松，是获取评论数据的优选方案。本文将以<strong>Python</strong>为工具，从环境搭建到代码实现，手把手教你爬取微博移动端评论，并解答过程中可能遇到的常见问题。</p><hr><h2 id="一、基础教程：从零实现微博评论爬取"><a href="#一、基础教程：从零实现微博评论爬取" class="headerlink" title="一、基础教程：从零实现微博评论爬取"></a>一、基础教程：从零实现微博评论爬取</h2><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><p>首先需要搭建Python爬虫环境，核心依赖库如下：</p><ul><li><p><strong>requests</strong>：发送HTTP请求，获取接口数据</p></li><li><p><strong>json</strong>：解析接口返回的JSON数据（Python内置，无需安装）</p></li><li><p><strong>pandas</strong>：数据存储与导出（可选，用于生成Excel文件）</p></li><li><p><strong>time</strong>：设置请求间隔，避免被反爬（Python内置）</p></li></ul><p>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install requests pandas</span><br></pre></td></tr></table></figure><h3 id="1-2-核心原理：找到评论接口"><a href="#1-2-核心原理：找到评论接口" class="headerlink" title="1.2 核心原理：找到评论接口"></a>1.2 核心原理：找到评论接口</h3><p>微博移动端评论通过AJAX异步加载，我们需要先找到真实的评论接口。步骤如下：</p><ol><li><p>打开手机浏览器（或电脑浏览器切换到<strong>移动端模式</strong>），登录微博账号，找到目标微博（例如：<a href="https://m.weibo.cn/detail/4900000000000000">https://m.weibo.cn/detail/4900000000000000</a>）</p></li><li><p>按F12打开开发者工具，切换到<strong>Network</strong>标签，勾选<strong>XHR</strong>（筛选AJAX请求）</p></li><li><p>下拉页面加载评论，此时会看到名为<strong>comment</strong>的请求，点击该请求查看详情</p></li><li><p>在<strong>Request URL</strong>中可以看到评论接口地址，在<strong>Response</strong>中可以看到JSON格式的评论数据</p></li></ol><div class="note primary modern"><p>典型的微博评论接口格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://m.weibo.cn/comments/hotflow?id=微博ID&amp;mid=微博ID&amp;max_id=下一页标识&amp;max_id_type=0</span><br></pre></td></tr></table></figure></div><p>参数说明：</p><ul><li><p><strong>id/mid</strong>：目标微博的ID（从微博详情页URL中获取，例如URL末尾的数字串）</p></li><li><p><strong>max_id</strong>：分页标识，初始为0，后续页面的max_id从当前响应中获取</p></li><li><p><strong>max_id_type</strong>：固定为0即可</p></li></ul><h3 id="1-3-代码实现步骤"><a href="#1-3-代码实现步骤" class="headerlink" title="1.3 代码实现步骤"></a>1.3 代码实现步骤</h3><h4 id="步骤1：获取请求头（Headers）"><a href="#步骤1：获取请求头（Headers）" class="headerlink" title="步骤1：获取请求头（Headers）"></a>步骤1：获取请求头（Headers）</h4><p>为了模拟真实用户请求，需要在请求中添加Headers，核心参数包括<strong>User-Agent</strong>和<strong>Cookie</strong>：</p><ul><li><p><strong>User-Agent</strong>：标识浏览器类型，移动端UA示例：<code>Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1</code></p></li><li><p><strong>Cookie</strong>：包含登录状态信息，从浏览器开发者工具的Request Headers中复制（登录后才能获取更多评论）</p></li></ul><h4 id="步骤2：发送请求并解析数据"><a href="#步骤2：发送请求并解析数据" class="headerlink" title="步骤2：发送请求并解析数据"></a>步骤2：发送请求并解析数据</h4><p>编写代码发送GET请求，解析JSON响应中的评论内容（用户名、评论时间、评论内容等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置信息</span></span><br><span class="line">weibo_id = <span class="string">&quot;4900000000000000&quot;</span>  <span class="comment"># 目标微博ID</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;你的Cookie信息&quot;</span>  <span class="comment"># 替换为自己的Cookie</span></span><br><span class="line">&#125;</span><br><span class="line">comments = []  <span class="comment"># 存储评论数据</span></span><br><span class="line">max_id = <span class="number">0</span>  <span class="comment"># 初始分页标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 构建请求URL</span></span><br><span class="line">    url = <span class="string">f&quot;https://m.weibo.cn/comments/hotflow?id=<span class="subst">&#123;weibo_id&#125;</span>&amp;mid=<span class="subst">&#123;weibo_id&#125;</span>&amp;max_id=<span class="subst">&#123;max_id&#125;</span>&amp;max_id_type=0&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">        response.raise_for_status()  <span class="comment"># 若状态码不是200，抛出异常</span></span><br><span class="line">        data = json.loads(response.text)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取评论列表</span></span><br><span class="line">        comment_list = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;data&quot;</span>, [])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> comment_list:  <span class="comment"># 没有更多评论时退出循环</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已获取所有评论&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解析每条评论</span></span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> comment_list:</span><br><span class="line">            item = &#123;</span><br><span class="line">                <span class="string">&quot;用户名&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;screen_name&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;用户ID&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论时间&quot;</span>: comment.get(<span class="string">&quot;created_at&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论内容&quot;</span>: comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;点赞数&quot;</span>: comment.get(<span class="string">&quot;like_count&quot;</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="string">&quot;回复数&quot;</span>: comment.get(<span class="string">&quot;reply_count&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            comments.append(item)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;已获取<span class="subst">&#123;<span class="built_in">len</span>(comments)&#125;</span>条评论&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新下一页的max_id</span></span><br><span class="line">        max_id = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;max_id&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> max_id == <span class="number">0</span>:  <span class="comment"># 没有下一页时退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置请求间隔，避免被封IP</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;请求出错：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="步骤3：数据存储"><a href="#步骤3：数据存储" class="headerlink" title="步骤3：数据存储"></a>步骤3：数据存储</h4><p>将爬取到的评论数据导出为Excel文件，方便后续分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 转换为DataFrame并导出</span></span><br><span class="line">df = pd.DataFrame(comments)</span><br><span class="line">df.to_excel(<span class="string">&quot;微博评论.xlsx&quot;</span>, index=<span class="literal">False</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;评论数据已保存到微博评论.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="二、常见问题及解决方案"><a href="#二、常见问题及解决方案" class="headerlink" title="二、常见问题及解决方案"></a>二、常见问题及解决方案</h2><h3 id="2-1-问题1：请求返回403-401错误"><a href="#2-1-问题1：请求返回403-401错误" class="headerlink" title="2.1 问题1：请求返回403/401错误"></a>2.1 问题1：请求返回403/401错误</h3><p><strong>原因</strong>：Headers参数不完整或Cookie失效，服务器识别为爬虫请求。</p><p><strong>解决方案</strong>：</p><ul><li><p>检查Cookie是否正确，重新登录微博后复制最新的Cookie</p></li><li><p>补充Headers中的其他参数（如<strong>Referer</strong>：设置为目标微博详情页URL）</p></li><li><p>确保User-Agent是移动端格式，避免使用PC端UA</p></li></ul><h3 id="2-2-问题2：只能爬取前20条评论"><a href="#2-2-问题2：只能爬取前20条评论" class="headerlink" title="2.2 问题2：只能爬取前20条评论"></a>2.2 问题2：只能爬取前20条评论</h3><p><strong>原因</strong>：未正确处理分页参数max_id，或未登录导致只能获取公开评论。</p><p><strong>解决方案</strong>：</p><ul><li><p>确保登录状态（Cookie有效），登录后可获取更多评论</p></li><li><p>检查max_id是否正确从响应中提取，避免手动设置固定值</p></li><li><p>部分微博可能限制评论查看权限，属于正常情况</p></li></ul><h3 id="2-3-问题3：IP被封禁，无法发送请求"><a href="#2-3-问题3：IP被封禁，无法发送请求" class="headerlink" title="2.3 问题3：IP被封禁，无法发送请求"></a>2.3 问题3：IP被封禁，无法发送请求</h3><p><strong>原因</strong>：请求频率过高，触发微博反爬机制。</p><p><strong>解决方案</strong>：</p><ul><li><p>增加请求间隔时间（如time.sleep(3-5秒)），避免高频请求</p></li><li><p>使用代理IP池，轮换IP地址发送请求（推荐使用高匿代理）</p></li><li><p>暂停爬取1-2小时，IP封禁通常是临时的</p></li></ul><h3 id="2-4-问题4：评论内容含HTML标签"><a href="#2-4-问题4：评论内容含HTML标签" class="headerlink" title="2.4 问题4：评论内容含HTML标签"></a>2.4 问题4：评论内容含HTML标签</h3><p><strong>原因</strong>：接口返回的text字段包含HTML格式（如表情、话题链接等）。</p><p><strong>解决方案</strong>：使用<strong>BeautifulSoup</strong>清理HTML标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理评论内容中的HTML标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_html</span>(<span class="params">text</span>):</span><br><span class="line">    soup = BeautifulSoup(text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> soup.get_text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在解析评论时调用</span></span><br><span class="line"><span class="string">&quot;评论内容&quot;</span>: clean_html(comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>)),</span><br></pre></td></tr></table></figure><h3 id="2-5-问题5：响应数据格式异常"><a href="#2-5-问题5：响应数据格式异常" class="headerlink" title="2.5 问题5：响应数据格式异常"></a>2.5 问题5：响应数据格式异常</h3><p><strong>原因</strong>：接口参数变化或微博更新反爬策略。</p><p><strong>解决方案</strong>：</p><ul><li><p>重新通过浏览器开发者工具抓取最新的评论接口，确认参数是否变化</p></li><li><p>打印response.text查看原始响应，分析数据格式是否与预期一致</p></li><li><p>关注微博接口的官方变化（若有），及时调整代码</p></li></ul><h3 id="2-6-问题6：请求第一页之后的数据响应ok-0"><a href="#2-6-问题6：请求第一页之后的数据响应ok-0" class="headerlink" title="2.6 问题6：请求第一页之后的数据响应ok{0}"></a>2.6 问题6：请求第一页之后的数据响应ok{0}</h3><p><strong>原因</strong>：请求的Cookie已失效，需要重新登录获取Cookie。(因为微博需要登录才能查看更多评论)</p><p><strong>解决方案</strong>：</p><ul><li>登录微博账号，打开浏览器开发者工具，选择Network选项卡，点击刷新按钮。</li><li>在Network选项卡中，找到对应的请求，查看响应头，找到Cookie字段，复制Cookie值。</li><li>将Cookie值替换为配置文件中的Cookie字段。</li><li>重新运行代码，即可获取最新数据。</li></ul><hr><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ul><li><p><strong>合规性</strong>：爬取微博数据需遵守《微博服务使用协议》，不得用于商业用途或恶意攻击，建议仅用于个人学习研究</p></li><li><p><strong>登录状态</strong>：尽量使用小号登录，避免主号因爬虫行为被限制</p></li><li><p><strong>请求频率</strong>：保持低调，避免短时间内发送大量请求，友好对待服务器</p></li><li><p><strong>数据备份</strong>：定期保存爬取到的数据，防止程序异常导致数据丢失</p></li></ul><p>通过以上步骤，你可以成功爬取微博移动端评论数据。如果遇到其他问题，欢迎在评论区留言交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python爬取微博移动端评论完整教程（基础-常见问题）&quot;&gt;&lt;a href=&quot;#Python爬取微博移动端评论完整教程（基础-常见问题）&quot; class=&quot;headerlink&quot; title=&quot;Python爬取微博移动端评论完整教程（基础+常见问题）&quot;&gt;&lt;/a&gt;Py</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://nmcb666.vip/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于GitHub Pages加载静态文件失败</title>
    <link href="https://nmcb666.vip/posts/b1168866.html"/>
    <id>https://nmcb666.vip/posts/b1168866.html</id>
    <published>2025-09-17T23:50:28.000Z</published>
    <updated>2025-09-28T06:22:14.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决Github-Pages不加载Vue框架项目静态文件问题"><a href="#解决Github-Pages不加载Vue框架项目静态文件问题" class="headerlink" title="解决Github Pages不加载Vue框架项目静态文件问题"></a>解决Github Pages不加载Vue框架项目静态文件问题</h1><p>在使用Vue框架开发项目并部署到Github Pages时，很多开发者都会遇到一个头疼的问题：页面能够正常访问，但项目中的JS、CSS等静态文件却无法加载，导致页面样式错乱、功能失效。其实这个问题的核心在于静态文件的路径配置不当，本文将详细介绍如何通过配置打包工具的路径以及Github Pages设置来解决这一问题，并分别以Vite和Webpack两种常用打包工具进行演示。</p><h2 id="一、问题原因分析"><a href="#一、问题原因分析" class="headerlink" title="一、问题原因分析"></a>一、问题原因分析</h2><p>Github Pages部署的项目，其访问路径通常是 <code>https://[用户名].github.io/[项目名]/</code>，而Vue项目默认的静态文件路径是基于根目录（<code>/</code>）的。当项目部署到Github Pages后，静态文件会被请求从根目录获取，而实际静态文件却在<code>/[项目名]/</code>目录下，这就导致了路径不匹配，静态文件加载失败。</p><h2 id="二、不同打包工具的配置方法"><a href="#二、不同打包工具的配置方法" class="headerlink" title="二、不同打包工具的配置方法"></a>二、不同打包工具的配置方法</h2><div class="note primary modern"><p>解决该问题的关键是修改打包工具的静态文件公共路径（publicPath），使其指向Github Pages的项目地址。</p></div><div class="tip success"><p>如果你不想打包，直接在根目录下有一个index.html静态网页文件。那么将里面js,css等静态文件的引用路径前面加上<code>/[项目名]/</code>即可。例如：/static/js/app.js —&gt; /[项目名]/static/js/app.js 如果成功则无需打包</p></div><p>下面分别介绍Vite和Webpack的配置步骤。</p><h3 id="2-1-Vite打包工具配置"><a href="#2-1-Vite打包工具配置" class="headerlink" title="2.1 Vite打包工具配置"></a>2.1 Vite打包工具配置</h3><p>Vite是目前Vue项目常用的构建工具，配置方式较为简洁，只需修改项目根目录下的<code>vite.config.js</code>文件。</p><ol><li><p><strong>找到vite.config.js文件</strong>：该文件位于Vue项目的根目录下，如果没有则手动创建。</p></li><li><p><strong>配置publicPath</strong>：在<code>defineConfig</code>对象中添加<code>base</code>属性（Vite中publicPath对应的是base），其值设置为你的Github Pages项目地址。格式为 <code>&#39;https://[用户名].github.io/[项目名]/&#39;</code>，例如如果用户名为<code>testuser</code>，项目名为<code>vue-demo</code>，则配置为 <code>base: &#39;https://testuser.github.io/vue-demo/&#39;</code>。</p></li><li><p><strong>设置打包输出目录</strong>：默认情况下Vite打包输出到<code>dist</code>目录，我们需要将其改为<code>docs</code>目录，方便后续Github Pages配置。在<code>defineConfig</code>中添加<code>build</code>选项，设置<code>outDir: &#39;docs&#39;</code>。</p></li></ol><p>配置完成后的<code>vite.config.js</code>文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;https://testuser.github.io/vue-demo/&#x27;</span>, <span class="comment">// 替换为你的项目地址</span></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">outDir</span>: <span class="string">&#x27;docs&#x27;</span> <span class="comment">// 打包输出到docs目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>base路径不唯一 可自行在浏览器控制台中查看请求路径  将请求路径调整为 https://&lt;你的名称&gt;.github.io/&lt;项目名称&gt;/静态文件路径。即可<br>配置完成后，执行<code>npm run build</code>命令进行打包，此时项目根目录下会生成<code>docs</code>文件夹，里面包含了打包后的静态文件。</p><h3 id="2-2-Webpack打包工具配置（Vue-CLI项目）"><a href="#2-2-Webpack打包工具配置（Vue-CLI项目）" class="headerlink" title="2.2 Webpack打包工具配置（Vue CLI项目）"></a>2.2 Webpack打包工具配置（Vue CLI项目）</h3><p>如果你的Vue项目是使用Vue CLI创建的，那么使用的打包工具是Webpack，需要修改<code>vue.config.js</code>文件。</p><ol><li><p><strong>找到vue.config.js文件</strong>：该文件位于Vue项目的根目录下，若不存在则手动创建。</p></li><li><p><strong>配置publicPath</strong>：在配置对象中添加<code>publicPath</code>属性，值设置为你的Github Pages项目地址，格式与Vite相同，即 <code>&#39;https://[用户名].github.io/[项目名]/&#39;</code>。</p></li><li><p><strong>设置打包输出目录</strong>：同样将打包输出目录改为<code>docs</code>，在配置对象中添加<code>outputDir: &#39;docs&#39;</code>。</p></li></ol><p>配置完成后的<code>vue.config.js</code>文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;https://testuser.github.io/vue-demo/&#x27;</span>, <span class="comment">// 替换为你的项目地址</span></span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&#x27;docs&#x27;</span> <span class="comment">// 打包输出到docs目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npm run build</code>命令打包，项目根目录会生成<code>docs</code>文件夹，包含打包后的静态资源。</p><h2 id="三、Github-Pages配置步骤"><a href="#三、Github-Pages配置步骤" class="headerlink" title="三、Github Pages配置步骤"></a>三、Github Pages配置步骤</h2><p>完成打包工具配置并生成<code>docs</code>文件夹后，需要在Github仓库中设置Github Pages的部署源。</p><ol><li><p><strong>推送代码到Github仓库</strong>：将包含<code>docs</code>文件夹的项目代码推送到Github仓库的<code>main</code>分支（或你使用的主分支）。</p></li><li><p><strong>进入仓库设置</strong>：打开你的Github项目仓库，点击右上角的<code>Settings</code>选项。</p></li><li><p><strong>找到Github Pages设置</strong>：在左侧导航栏中找到<code>Pages</code>选项并点击进入。</p></li><li><p><strong>设置部署源</strong>：在<code>Build and deployment</code>下的<code>Source</code>选项中，选择<code>Deploy from a branch</code>。然后在<code>Branch</code>选项中，选择<code>main</code>分支，并在后面的文件夹选择框中选择<code>/docs</code>，点击<code>Save</code>保存设置。</p></li></ol><p>设置完成后，Github Pages会自动部署你的项目，通常几分钟后即可通过<code>https://[用户名].github.io/[项目名]/</code>访问，此时JS、CSS等静态文件就能正常加载了。</p><h2 id="四、常见问题排查"><a href="#四、常见问题排查" class="headerlink" title="四、常见问题排查"></a>四、常见问题排查</h2><ul><li><p><strong>publicPath配置错误</strong>：确保publicPath（Vite中为base）的路径正确，末尾必须加上<code>/</code>，否则可能导致部分静态文件路径拼接错误。</p></li><li><p><strong>docs文件夹未推送</strong>：检查是否将打包生成的<code>docs</code>文件夹推送到了Github仓库，若未推送则需要执行<code>git add docs</code>、<code>git commit -m &quot;add docs&quot;</code>、<code>git push</code>命令。</p></li><li><p><strong>分支或文件夹选择错误</strong>：确认Github Pages设置中选择的分支是<code>main</code>（或你的项目主分支），文件夹是<code>/docs</code>。</p></li></ul><h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、<wavy>额外注意</wavy></h2><div class="tip warning faa-horizontal animated-hover"><p>github pages 默认是使用jekyll作为静态文件处理引擎，这个会默认删除静态文件名的下划线_导致静态文件无法加载。</p></div><p>解决方法：即在跟目录下创建一个名为.nojekyll的文件即可取消jekyll<br>关于jekyll的详细介绍可以参考：<a href="https://jekyllcn.com/docs/home/">https://jekyllcn.com/docs/home/</a></p><p>通过以上步骤，就能顺利解决Github Pages不加载Vue项目静态文件的问题。核心在于正确配置打包工具的publicPath路径，并将打包文件输出到docs目录，再配合Github Pages的部署源设置，即可实现项目的正常访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解决Github-Pages不加载Vue框架项目静态文件问题&quot;&gt;&lt;a href=&quot;#解决Github-Pages不加载Vue框架项目静态文件问题&quot; class=&quot;headerlink&quot; title=&quot;解决Github Pages不加载Vue框架项目静态文件问题&quot;&gt;</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://nmcb666.vip/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机与数学的那些事</title>
    <link href="https://nmcb666.vip/posts/f8b7ba6f.html"/>
    <id>https://nmcb666.vip/posts/f8b7ba6f.html</id>
    <published>2025-09-16T14:12:43.000Z</published>
    <updated>2025-09-28T06:22:14.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学计算机一定要数学好吗？不同岗位需求大不同"><a href="#学计算机一定要数学好吗？不同岗位需求大不同" class="headerlink" title="学计算机一定要数学好吗？不同岗位需求大不同"></a>学计算机一定要数学好吗？不同岗位需求大不同</h1><p>“我数学不好，是不是学不了计算机？”这是很多想入行计算机领域的人都会问的问题。其实这个问题没有绝对的答案，核心在于你想从事计算机领域的哪个岗位。在我看来，<strong>普通开发岗对数学功底的要求并不高，而算法岗和人工智能岗则需要扎实且甚至高于计算机知识本身的数学基础</strong>。今天就来详细聊聊不同岗位对数学的真实需求，帮大家消除认知误区。</p><h2 id="一、普通开发岗：数学是“加分项”而非“必需品”"><a href="#一、普通开发岗：数学是“加分项”而非“必需品”" class="headerlink" title="一、普通开发岗：数学是“加分项”而非“必需品”"></a>一、普通开发岗：数学是“加分项”而非“必需品”</h2><p>普通开发岗涵盖的范围很广，比如前端开发、后端开发、移动端开发、全栈开发等，这些岗位的核心是“实现业务需求”，更看重的是编程能力、逻辑思维和业务理解能力，对数学的要求远没有大家想象中那么高。</p><p>以前端开发为例，日常工作主要是用HTML、CSS、JavaScript构建用户界面，实现页面交互效果。即使是用到React、Vue等框架，核心也是组件化思想和状态管理，涉及到的数学知识可能最多就是简单的布局计算（比如用Flex或Grid布局时的百分比、像素换算），连初中数学知识都能应对。后端开发虽然会接触到数据库、服务器等，但更多是掌握编程语言（如Java、Python、Go）、框架（如Spring、Django）和数据库优化技巧，数学知识的应用场景少之又少。</p><p>我身边有不少做普通开发的学长，大学时数学成绩并不突出，但凭借扎实的编程基础和不断积累的业务经验，照样能成为团队里的骨干。当然，这并不是说数学对普通开发岗毫无用处——如果懂一点离散数学，在理解数据结构（如树、图）时会更轻松；如果懂一点线性代数，在处理图形相关的开发任务时可能会更得心应手。但这些都属于“加分项”，而非“入门必备项”，不会成为阻碍你入行和发展的绊脚石。</p><h2 id="二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要"><a href="#二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要" class="headerlink" title="二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要"></a>二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要</h2><p>与普通开发岗不同，算法岗（如机器学习算法工程师、推荐算法工程师）和人工智能岗（如AI研究员、深度学习工程师）对数学的要求极高，数学知识是开展工作的核心基础，甚至在很多场景下比单纯的计算机知识更重要。</p><p>这些岗位的工作本质是“解决复杂问题”，需要通过数学模型来抽象现实问题，并设计高效的算法来求解。这就要求从业者必须掌握多门高等数学知识：</p><ul><li><p><strong>线性代数</strong>：是机器学习的基础，比如数据的表示（向量、矩阵）、特征变换（矩阵乘法、特征值分解）、降维算法（PCA）等，都离不开线性代数的知识。如果不懂矩阵运算，连最简单的神经网络前向传播都无法理解。</p></li><li><p><strong>概率论与数理统计</strong>：在处理不确定性问题时至关重要，比如贝叶斯分类器、概率模型（如隐马尔可夫模型）、模型评估指标（准确率、召回率、ROC曲线）等，都需要概率论和统计学的支撑。</p></li><li><p><strong>微积分</strong>：主要用于优化算法，比如机器学习中的梯度下降法，就是通过求导来找到函数的最小值点，从而更新模型参数。如果不懂导数、偏导数，就无法理解优化算法的原理，更谈不上调优模型。</p></li><li><p><strong>离散数学</strong>：在图算法、组合优化等领域应用广泛，比如最短路径算法（Dijkstra、Floyd）、图神经网络（GNN）等，都需要离散数学的知识作为铺垫。</p></li></ul><p>举个例子，如果你想做深度学习工程师，搭建一个神经网络模型可能用TensorFlow或PyTorch几行代码就能实现，但要想让模型达到更好的效果——比如调整网络结构、优化损失函数、解决过拟合问题，就必须深入理解模型背后的数学原理。如果数学基础薄弱，只能停留在“调参工程师”的层面，无法真正成为一名优秀的算法或AI工程师。很多顶尖的AI研究员，本身就是数学专业出身，可见数学在这个领域的重要性。</p><h2 id="三、总结：根据目标岗位，合理规划数学学习"><a href="#三、总结：根据目标岗位，合理规划数学学习" class="headerlink" title="三、总结：根据目标岗位，合理规划数学学习"></a>三、总结：根据目标岗位，合理规划数学学习</h2><p>回到最初的问题“学计算机一定要数学好吗？”，答案已经很清晰了：</p><div class="tip warning faa-horizontal animated"><p>如果你目标是普通开发岗，不用因为数学不好而焦虑，重点放在提升编程能力和逻辑思维上，数学可以作为后续提升的补充；如果你目标是算法岗或人工智能岗，那么一定要打好数学基础，把线性代数、概率论、微积分等核心知识学扎实，这比单纯掌握编程语言和框架更重要。</p></div><p>计算机领域博大精深，不同岗位的需求差异很大。关键是明确自己的职业方向，然后有针对性地学习。不要被“数学不好就不能学计算机”的误区吓住，也不要忽视算法和AI岗对数学的高要求。希望这篇文章能帮大家更清晰地认识计算机与数学的关系，祝大家在计算机的道路上走得更远！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学计算机一定要数学好吗？不同岗位需求大不同&quot;&gt;&lt;a href=&quot;#学计算机一定要数学好吗？不同岗位需求大不同&quot; class=&quot;headerlink&quot; title=&quot;学计算机一定要数学好吗？不同岗位需求大不同&quot;&gt;&lt;/a&gt;学计算机一定要数学好吗？不同岗位需求大不同&lt;/</summary>
      
    
    
    
    
    <category term="计算机杂谈" scheme="https://nmcb666.vip/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>jsdelivr不可用替代方案</title>
    <link href="https://nmcb666.vip/posts/6acc4ad2.html"/>
    <id>https://nmcb666.vip/posts/6acc4ad2.html</id>
    <published>2025-09-16T09:57:48.000Z</published>
    <updated>2025-09-28T06:22:14.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客提速实战：cdn-jsdelivr-net不可用"><a href="#Hexo博客提速实战：cdn-jsdelivr-net不可用" class="headerlink" title="Hexo博客提速实战：cdn.jsdelivr.net不可用"></a>Hexo博客提速实战：cdn.jsdelivr.net不可用</h1><p>对于使用Hexo搭建个人博客的开发者和博主而言，网站加载速度直接影响用户体验与内容传播效果。不少用户在运营过程中会发现，博客打开缓慢、样式加载延迟甚至部分资源失效，排查后往往能定位到核心问题——默认依赖的<code>cdn.jsdelivr.net</code>在国内网络环境下表现不佳。本文将从问题根源出发，提供一套完整的CDN替换方案，帮助你快速解决Hexo博客速度难题。</p><h2 id="一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？"><a href="#一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？" class="headerlink" title="一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？"></a>一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？</h2><p>在分析解决方案前，我们先明确<code>cdn.jsdelivr.net</code>导致Hexo博客速度慢的核心原因，避免盲目优化：</p><h3 id="1-网络环境的天然限制"><a href="#1-网络环境的天然限制" class="headerlink" title="1. 网络环境的天然限制"></a>1. 网络环境的天然限制</h3><p><code>jsDelivr</code>作为全球通用的开源CDN服务，其核心节点主要分布在北美、欧洲等海外地区。国内用户访问时，数据需经过跨境网络链路传输，受国际带宽、路由跳转等因素影响，延迟通常高达100-800ms，部分地区甚至出现数据包丢失。</p><h3 id="2-资源加载的连锁反应"><a href="#2-资源加载的连锁反应" class="headerlink" title="2. 资源加载的连锁反应"></a>2. 资源加载的连锁反应</h3><p>Hexo主题（如Next、Butterfly、Matery）默认依赖<code>jsDelivr</code>加载大量关键资源，包括：</p><ul><li>样式文件：CSS框架（Bootstrap）、图标库（Font Awesome）</li><li>脚本文件：交互插件（jQuery）、代码高亮（Prism.js）、评论系统（Valine）</li><li>静态资源：字体文件、主题图片、第三方组件</li></ul><p>这些资源若加载延迟，会导致页面“白屏时间”延长、样式错乱，甚至触发浏览器的“资源加载超时”错误。</p><h3 id="3-国内镜像的优势"><a href="#3-国内镜像的优势" class="headerlink" title="3. 国内镜像的优势"></a>3. 国内镜像的优势</h3><p><code>cdn.jsdmirror.com</code>是专为国内用户搭建的<code>jsDelivr</code>镜像服务，具备三大核心优势：</p><ul><li><strong>节点覆盖广</strong>：在国内30+城市部署节点，用户访问时自动匹配最近节点，延迟可降至50ms以内</li><li><strong>同步速度快</strong>：实时同步<code>jsDelivr</code>的GitHub仓库与npm包资源，资源更新无延迟</li><li><strong>访问稳定性高</strong>：规避跨境网络波动，支持HTTPS加密访问，兼容所有主流浏览器</li></ul><h2 id="二、替换前的准备工作"><a href="#二、替换前的准备工作" class="headerlink" title="二、替换前的准备工作"></a>二、替换前的准备工作</h2><p>为确保替换过程顺利，避免操作失误导致博客异常，需提前完成以下准备：</p><h3 id="1-核心文件备份"><a href="#1-核心文件备份" class="headerlink" title="1. 核心文件备份"></a>1. 核心文件备份</h3><ul><li>备份Hexo根目录下的<code>_config.yml</code>（全局配置文件）</li><li>备份主题目录（如<code>themes/next</code>、<code>themes/butterfly</code>），建议压缩为ZIP文件存储</li><li>若使用Git管理博客，可先提交当前版本，便于后续回滚</li></ul><h3 id="2-资源依赖排查"><a href="#2-资源依赖排查" class="headerlink" title="2. 资源依赖排查"></a>2. 资源依赖排查</h3><p>通过浏览器开发者工具（F12）定位所有<code>jsDelivr</code>资源：</p><ol><li>打开博客页面，按F12打开“开发者工具”</li><li>切换至“Network”标签，刷新页面</li><li>在搜索框输入<code>cdn.jsdelivr.net</code>，筛选出所有依赖该CDN的资源</li><li>记录资源类型（CSS/JS/Font）、链接地址及所在文件，避免替换遗漏</li></ol><h3 id="3-本地环境确认"><a href="#3-本地环境确认" class="headerlink" title="3. 本地环境确认"></a>3. 本地环境确认</h3><p>确保本地已搭建完整的Hexo运行环境：</p><ul><li>检查Node.js版本（建议v14+）：<code>node -v</code></li><li>检查Hexo CLI版本（建议v6+）：<code>hexo -v</code></li><li>测试本地服务可用性：在根目录执行<code>hexo s</code>，确认<code>http://localhost:4000</code>可正常访问</li></ul><h2 id="三、分主题替换教程（覆盖主流主题）"><a href="#三、分主题替换教程（覆盖主流主题）" class="headerlink" title="三、分主题替换教程（覆盖主流主题）"></a>三、分主题替换教程（覆盖主流主题）</h2><p>不同Hexo主题的资源配置位置存在差异，以下针对3个最常用主题，提供 step-by-step 替换指南：</p><u>为了方便可以直接在编辑器中进行全局替换，将所有`cdn.jsdelivr.net`替换为`cdn.jsdmirror.com`</u><emp>如果生效，则无需下面的步骤</emp><h3 id="1-Next主题（v8-x-v9-x）"><a href="#1-Next主题（v8-x-v9-x）" class="headerlink" title="1. Next主题（v8.x - v9.x）"></a>1. Next主题（v8.x - v9.x）</h3><p>Next主题的CDN配置分散在<strong>主题配置文件</strong>和<strong>布局模板文件</strong>中，需分两步替换：</p><h4 id="步骤1：修改主题配置文件（themes-next-config-yml）"><a href="#步骤1：修改主题配置文件（themes-next-config-yml）" class="headerlink" title="步骤1：修改主题配置文件（themes/next/_config.yml）"></a>步骤1：修改主题配置文件（themes/next/_config.yml）</h4><p>用文本编辑器打开该文件，按<code>Ctrl+F</code>搜索<code>cdn.jsdelivr.net</code>，逐一替换以下资源：</p><ul><li><strong>字体图标（Font Awesome）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdmirror.com/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>代码高亮（Prism.js）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdmirror.com/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>评论系统（Valine）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdmirror.com/npm/valine@1.4.18/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="步骤2：修改布局模板中的硬编码资源"><a href="#步骤2：修改布局模板中的硬编码资源" class="headerlink" title="步骤2：修改布局模板中的硬编码资源"></a>步骤2：修改布局模板中的硬编码资源</h4><p>进入<code>themes/next/layout</code>目录，搜索所有文件中的<code>cdn.jsdelivr.net</code>：</p><ol><li>打开<code>_partials/head.swig</code>，替换CSS资源引用</li><li>打开<code>_partials/footer.swig</code>，替换JS资源引用</li><li>打开<code>_third-party/comments/valine.swig</code>（若使用Valine），确认评论组件CDN已替换</li></ol><h3 id="2-Butterfly主题（v4-x-v5-x）"><a href="#2-Butterfly主题（v4-x-v5-x）" class="headerlink" title="2. Butterfly主题（v4.x - v5.x）"></a>2. Butterfly主题（v4.x - v5.x）</h3><p>Butterfly主题的CDN配置高度集中，主要在<strong>主题配置文件</strong>中：</p><h4 id="步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）"><a href="#步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）" class="headerlink" title="步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）"></a>步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）</h4><p>找到<code>CDN</code>相关配置段，替换以下关键资源：</p><ul><li><strong>基础框架（jQuery + Bootstrap）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdmirror.com/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br></pre></td></tr></table></figure></li><li><strong>图标与高亮</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdelivr.net/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdmirror.com/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdmirror.com/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>第三方插件（如阅读进度、目录）</strong><br>继续向下搜索，替换<code>tocbot</code>、<code>nprogress</code>等插件的CDN链接，确保无遗漏。</li></ul><h4 id="步骤2：检查自定义页面资源"><a href="#步骤2：检查自定义页面资源" class="headerlink" title="步骤2：检查自定义页面资源"></a>步骤2：检查自定义页面资源</h4><p>若在<code>source</code>目录下创建了自定义页面（如<code>about.md</code>、<code>links.md</code>），需打开文件检查是否有内嵌的<code>jsDelivr</code>链接，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原链接 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 替换后 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="3-Matery主题（v1-x）"><a href="#3-Matery主题（v1-x）" class="headerlink" title="3. Matery主题（v1.x）"></a>3. Matery主题（v1.x）</h3><p>Matery主题的资源配置在<strong>主题配置文件</strong>和<strong>HTML模板</strong>中：</p><h4 id="步骤1：修改主题配置（themes-matery-config-yml）"><a href="#步骤1：修改主题配置（themes-matery-config-yml）" class="headerlink" title="步骤1：修改主题配置（themes/matery/_config.yml）"></a>步骤1：修改主题配置（themes/matery/_config.yml）</h4><p>替换<code>CDN</code>部分的资源：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdelivr.net/npm/layer@3.5.1/dist/layer.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdmirror.com/npm/layer@3.5.1/dist/layer.min.js</span></span><br></pre></td></tr></table></figure></p><h4 id="步骤2：修改HTML模板（themes-matery-layout-partial）"><a href="#步骤2：修改HTML模板（themes-matery-layout-partial）" class="headerlink" title="步骤2：修改HTML模板（themes/matery/layout/_partial）"></a>步骤2：修改HTML模板（themes/matery/layout/_partial）</h4><p>打开<code>head.html</code>和<code>footer.html</code>，替换模板中硬编码的CDN链接，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 替换后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="四、替换后的验证与测试"><a href="#四、替换后的验证与测试" class="headerlink" title="四、替换后的验证与测试"></a>四、替换后的验证与测试</h2><p>完成替换后，需通过多维度测试确保博客正常运行且速度提升：</p><h3 id="1-本地环境验证"><a href="#1-本地环境验证" class="headerlink" title="1. 本地环境验证"></a>1. 本地环境验证</h3><p>在Hexo根目录执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存（关键步骤，避免旧资源干扰）</span></span><br><span class="line">hexo s      <span class="comment"># 启动本地服务器</span></span><br></pre></td></tr></table></figure><br>打开浏览器访问<code>http://localhost:4000</code>，进行以下检查：</p><ul><li><strong>视觉检查</strong>：页面样式是否完整（无错位、无缺失图标）</li><li><strong>控制台检查</strong>：按F12打开“Console”标签，确认无“404 Not Found”或“Failed to load”错误</li><li><strong>网络检查</strong>：在“Network”标签中搜索<code>jsdmirror</code>，确认所有资源均从该CDN加载</li></ul><h3 id="2-线上部署与速度测试"><a href="#2-线上部署与速度测试" class="headerlink" title="2. 线上部署与速度测试"></a>2. 线上部署与速度测试</h3><p>若本地验证无问题，部署到线上（如GitHub Pages、Gitee Pages、Vercel）后，使用以下工具测试速度提升效果：</p><h4 id="（1）基础速度检测"><a href="#（1）基础速度检测" class="headerlink" title="（1）基础速度检测"></a>（1）基础速度检测</h4><ul><li><strong>17CE</strong>：检测国内多地区节点的访问延迟，对比替换前后数据</li><li><strong>Ping.pe</strong>：测试全球节点响应速度，确保海外用户访问不受影响</li></ul><h4 id="（2）性能评分工具"><a href="#（2）性能评分工具" class="headerlink" title="（2）性能评分工具"></a>（2）性能评分工具</h4><ul><li><strong>Google PageSpeed Insights</strong>：重点关注“首次内容绘制（FCP）”和“最大内容绘制（LCP）”指标，替换后通常可提升10-30分</li><li><strong>WebPageTest</strong>：生成详细的资源加载瀑布图，查看<code>jsdmirror</code>资源的加载时间（目标：单个资源加载时间&lt;100ms）</li></ul><h2 id="五、进阶优化与风险规避"><a href="#五、进阶优化与风险规避" class="headerlink" title="五、进阶优化与风险规避"></a>五、进阶优化与风险规避</h2><h3 id="1-资源加载优化补充"><a href="#1-资源加载优化补充" class="headerlink" title="1. 资源加载优化补充"></a>1. 资源加载优化补充</h3><p>替换CDN后，可结合以下措施进一步提升速度：</p><ul><li><strong>开启Gzip压缩</strong>：在GitHub Pages中可通过配置<code>_config.yml</code>启用，或在Vercel中直接开启</li><li><strong>图片优化</strong>：使用<code>hexo-image-compressor</code>插件压缩图片，或迁移至国内图床（如阿里云OSS、腾讯云COS）</li><li><strong>减少第三方插件</strong>：卸载无用的评论、统计插件，降低资源请求数量</li></ul><h3 id="2-CDN服务风险规避"><a href="#2-CDN服务风险规避" class="headerlink" title="2. CDN服务风险规避"></a>2. CDN服务风险规避</h3><p><code>cdn.jsdmirror.com</code>作为第三方镜像，若后续出现服务不稳定，可切换至其他国内<code>jsDelivr</code>镜像，常用备选：</p><ul><li><code>https://cdn.jsdelivr.fusesearch.net/</code></li><li><code>https://jsd.onmicrosoft.cn/</code></li><li><code>https://jsdelivr.b-cdn.net/</code></li></ul><p>切换时仅需替换“域名”，保持资源路径完全一致，无需修改其他配置。</p><h3 id="3-定期检查与更新"><a href="#3-定期检查与更新" class="headerlink" title="3. 定期检查与更新"></a>3. 定期检查与更新</h3><p>建议每3-6个月检查一次CDN资源：</p><ul><li>确认使用的npm包/GitHub仓库资源是否有更新，避免使用过时版本导致安全风险</li><li>测试当前CDN的响应速度，若出现延迟升高，及时切换至其他镜像</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过将Hexo博客的<code>cdn.jsdelivr.net</code>替换为<code>cdn.jsdmirror.com</code>，可有效解决国内网络环境下的资源加载慢问题，通常能带来30%-70%的加载速度提升。整个过程核心在于“精准定位资源位置+完整替换域名”，配合本地测试与线上验证，即可确保博客稳定运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo博客提速实战：cdn-jsdelivr-net不可用&quot;&gt;&lt;a href=&quot;#Hexo博客提速实战：cdn-jsdelivr-net不可用&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客提速实战：cdn.jsdelivr.net不可用&quot;&gt;</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://nmcb666.vip/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于Task定时任务的一些事</title>
    <link href="https://nmcb666.vip/posts/12ed125b.html"/>
    <id>https://nmcb666.vip/posts/12ed125b.html</id>
    <published>2025-09-15T15:13:27.000Z</published>
    <updated>2025-09-28T06:22:14.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-定时任务（Task）使用教程：从入门到精通"><a href="#Spring-Boot-定时任务（Task）使用教程：从入门到精通" class="headerlink" title="Spring Boot 定时任务（Task）使用教程：从入门到精通"></a>Spring Boot 定时任务（Task）使用教程：从入门到精通</h1><p>在日常开发中，定时任务是一个非常常见的需求，比如定时发送短信、定时生成报表、定时清理缓存等。Spring Boot 内置了 <code>spring-boot-starter</code> 模块，其中就包含了对定时任务的支持，无需额外引入复杂的第三方框架（如 Quartz），就能快速实现定时任务功能。本文将从基础到进阶，详细讲解 Spring Boot 定时任务的使用方法。</p><h2 id="一、Spring-Boot-定时任务基础"><a href="#一、Spring-Boot-定时任务基础" class="headerlink" title="一、Spring Boot 定时任务基础"></a>一、Spring Boot 定时任务基础</h2><h3 id="1-1-什么是定时任务？"><a href="#1-1-什么是定时任务？" class="headerlink" title="1.1 什么是定时任务？"></a>1.1 什么是定时任务？</h3><p>定时任务是指在预定的时间点或按照固定的时间间隔自动执行的任务。在 Java 生态中，常见的定时任务实现方式有 <code>Timer</code>、<code>ScheduledExecutorService</code>、Quartz 等，而 Spring Boot 提供的 <code>@Scheduled</code> 注解则是对这些底层实现的封装，简化了开发流程。</p><h3 id="1-2-启用定时任务"><a href="#1-2-启用定时任务" class="headerlink" title="1.2 启用定时任务"></a>1.2 启用定时任务</h3><p>Spring Boot 中启用定时任务非常简单，只需两步：</p><ol><li><strong>添加依赖</strong>：Spring Boot 的 <code>spring-boot-starter</code> 已经包含了定时任务相关的依赖，无需额外引入。如果是 Maven 项目，<code>pom.xml</code> 中默认的 <code>spring-boot-starter</code> 即可满足需求：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>开启定时任务注解</strong>：在 Spring Boot 启动类上添加 <code>@EnableScheduling</code> 注解，用于启用定时任务的自动配置：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TaskDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、简单定时任务实现"><a href="#二、简单定时任务实现" class="headerlink" title="二、简单定时任务实现"></a>二、简单定时任务实现</h2><p>启用定时任务后，只需在需要定时执行的方法上添加 <code>@Scheduled</code> 注解，并指定任务的执行时机即可。<code>@Scheduled</code> 注解支持多种定时方式，下面介绍最常用的几种。</p><h3 id="2-1-固定延迟执行（fixedDelay）"><a href="#2-1-固定延迟执行（fixedDelay）" class="headerlink" title="2.1 固定延迟执行（fixedDelay）"></a>2.1 固定延迟执行（fixedDelay）</h3><p><code>fixedDelay</code> 表示上一次任务执行完成后，间隔固定时间再执行下一次任务。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 交给 Spring 管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次任务执行完成后，间隔 3 秒执行下一次</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;固定延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间为 <code>3000ms + 任务执行耗时（1000ms）</code>，即约 4 秒。</p><h3 id="2-2-固定频率执行（fixedRate）"><a href="#2-2-固定频率执行（fixedRate）" class="headerlink" title="2.2 固定频率执行（fixedRate）"></a>2.2 固定频率执行（fixedRate）</h3><p><code>fixedRate</code> 表示按照固定的频率执行任务，无论上一次任务是否执行完成。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每隔 3 秒执行一次，不管上一次任务是否完成</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间约为 3 秒（因为任务耗时 1 秒，小于频率间隔）。如果任务耗时超过频率间隔（如任务耗时 4 秒），则上一次任务执行完成后会立即执行下一次任务。</p><h3 id="2-3-初始延迟执行（initialDelay）"><a href="#2-3-初始延迟执行（initialDelay）" class="headerlink" title="2.3 初始延迟执行（initialDelay）"></a>2.3 初始延迟执行（initialDelay）</h3><p><code>initialDelay</code> 表示任务启动后，延迟指定时间再开始执行第一次任务，之后按照 <code>fixedDelay</code> 或 <code>fixedRate</code> 执行。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 启动后延迟 5 秒执行第一次任务，之后每隔 3 秒执行一次</span></span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 5000, fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：应用启动 5 秒后，第一次执行任务，之后每 3 秒执行一次。</p><h2 id="三、Cron-表达式：灵活的定时配置"><a href="#三、Cron-表达式：灵活的定时配置" class="headerlink" title="三、Cron 表达式：灵活的定时配置"></a>三、Cron 表达式：灵活的定时配置</h2><p>如果需要更灵活的定时规则（如每天凌晨 2 点执行、每周一上午 10 点执行等），<code>fixedDelay</code> 和 <code>fixedRate</code> 就无法满足需求了，此时需要使用 <strong>Cron 表达式</strong>。</p><h3 id="3-1-Cron-表达式格式"><a href="#3-1-Cron-表达式格式" class="headerlink" title="3.1 Cron 表达式格式"></a>3.1 Cron 表达式格式</h3><p>Cron 表达式是一个字符串，由 6 或 7 个字段组成，字段之间用空格分隔。Spring Boot 中的 Cron 表达式支持 6 个字段（不支持年份），格式如下：</p><div class="callout">秒 分 时 日 月 星期</div><p>每个字段的取值范围和允许的特殊字符如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>取值范围</th><th>特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日</td><td>1-31</td><td>, - * / ? L W C</td></tr><tr><td>月</td><td>1-12 或 JAN-DEC</td><td>, - * /</td></tr><tr><td>星期</td><td>1-7 或 SUN-SAT（1 表示星期日）</td><td>, - * / ? L C #</td></tr></tbody></table></div><h3 id="3-2-常用特殊字符说明"><a href="#3-2-常用特殊字符说明" class="headerlink" title="3.2 常用特殊字符说明"></a>3.2 常用特殊字符说明</h3><ul><li><p><strong>*</strong>：表示所有可能的值，例如“秒”字段为 <code>*</code>，表示每秒执行。</p></li><li><p><strong>?</strong>：用于“日”和“星期”字段，表示不指定具体值，避免两者冲突。例如每月 10 日执行，不管是星期几，“星期”字段就填 <code>?</code>。</p></li><li><p><strong>/</strong>：表示增量，例如“分”字段为 <code>0/5</code>，表示从 0 分开始，每 5 分钟执行一次。</p></li><li><p><strong>-</strong>：表示范围，例如“时”字段为 <code>9-17</code>，表示 9 点到 17 点之间执行。</p></li><li><p><strong>,</strong>：表示多个值，例如“星期”字段为 <code>1,3,5</code>，表示星期日、星期二、星期四执行。</p></li><li><p><strong>L</strong>：表示“最后”，例如“日”字段为 <code>L</code>，表示每月最后一天；“星期”字段为 <code>L</code>，表示星期六。</p></li><li><p><strong>#</strong>：用于“星期”字段，表示每月的第几个星期几，例如 <code>6#3</code> 表示每月第三个星期五（6 表示星期五）。</p></li></ul><h3 id="3-3-Cron-表达式示例"><a href="#3-3-Cron-表达式示例" class="headerlink" title="3.3 Cron 表达式示例"></a>3.3 Cron 表达式示例</h3><ul><li><p>每秒执行：<code>* * * * * ?</code></p></li><li><p>每 5 分钟执行：<code>0 */5 * * * ?</code></p></li><li><p>每天凌晨 2 点执行：<code>0 0 2 * * ?</code></p></li><li><p>每月 10 日上午 10 点执行：<code>0 0 10 10 * ?</code></p></li><li><p>每周一到周五下午 5 点执行：<code>0 0 17 ? * 2-6</code>（2 表示星期一，6 表示星期五）</p></li><li><p>每月最后一天晚上 11 点执行：<code>0 0 23 L * ?</code></p></li></ul><h3 id="3-4-在-Scheduled-中使用-Cron-表达式"><a href="#3-4-在-Scheduled-中使用-Cron-表达式" class="headerlink" title="3.4 在 @Scheduled 中使用 Cron 表达式"></a>3.4 在 @Scheduled 中使用 Cron 表达式</h3><p>只需将 <code>@Scheduled</code> 注解的 <code>cron</code> 属性设置为对应的表达式即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每天凌晨 2 点执行</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、定时任务参数外部化配置"><a href="#四、定时任务参数外部化配置" class="headerlink" title="四、定时任务参数外部化配置"></a>四、定时任务参数外部化配置</h2><p>在实际开发中，定时任务的执行规则可能需要根据环境动态调整（如开发环境和生产环境的执行频率不同）。此时，不建议将参数硬编码在 <code>@Scheduled</code> 注解中，而是通过 <code>application.properties</code> 或 <code>application.yml</code> 进行外部化配置。</p><h3 id="4-1-使用-properties-文件配置"><a href="#4-1-使用-properties-文件配置" class="headerlink" title="4.1 使用 properties 文件配置"></a>4.1 使用 properties 文件配置</h3><p>在 <code>application.properties</code> 中添加定时任务参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 定时任务参数配置</span></span><br><span class="line"><span class="attr">task.fixedRate</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">task.cron</span>=<span class="string">0 0 2 * * ?</span></span><br></pre></td></tr></table></figure><p>在代码中通过 <code>$&#123;&#125;</code> 引用配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 fixedRate</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRateString = &quot;$&#123;task.fixedRate&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalFixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 cron 表达式</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalCronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置 Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于数值类型的参数（如 <code>fixedRate</code>、<code>fixedDelay</code>），需要使用 <code>fixedRateString</code>、<code>fixedDelayString</code> 属性来引用字符串类型的配置值。</p><h2 id="五、定时任务的高级特性"><a href="#五、定时任务的高级特性" class="headerlink" title="五、定时任务的高级特性"></a>五、定时任务的高级特性</h2><h3 id="5-1-定时任务线程池配置"><a href="#5-1-定时任务线程池配置" class="headerlink" title="5.1 定时任务线程池配置"></a>5.1 定时任务线程池配置</h3><p>Spring Boot 定时任务默认使用单线程执行，如果多个任务同时触发，会出现任务排队的情况。为了提高任务执行效率，可以配置定时任务线程池。</p><p>通过实现 <code>SchedulingConfigurer</code> 接口来配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为 5</span></span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        scheduler.setPoolSize(<span class="number">5</span>);</span><br><span class="line">        scheduler.setThreadNamePrefix(<span class="string">&quot;scheduled-task-&quot;</span>); <span class="comment">// 线程名前缀</span></span><br><span class="line">        scheduler.initialize();</span><br><span class="line">        </span><br><span class="line">        taskRegistrar.setTaskScheduler(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，定时任务会通过线程池中的线程并行执行，避免单线程瓶颈。</p><h3 id="5-2-动态调整定时任务"><a href="#5-2-动态调整定时任务" class="headerlink" title="5.2 动态调整定时任务"></a>5.2 动态调整定时任务</h3><p>如果需要在应用运行过程中动态修改定时任务的执行规则（如修改 Cron 表达式），可以通过 <code>ScheduledTaskRegistrar</code> 和 <code>Trigger</code> 接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTaskConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中读取 Cron 表达式，支持动态刷新</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;task.dynamic.cron&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String cronExpression;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态注册定时任务</span></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">            () -&gt; System.out.println(<span class="string">&quot;动态定时任务执行时间：&quot;</span> + LocalDateTime.now()),</span><br><span class="line">            triggerContext -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每次执行前重新读取 Cron 表达式，实现动态调整</span></span><br><span class="line">                <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cronExpression);</span><br><span class="line">                <span class="keyword">return</span> trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供方法修改 cronExpression</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCronExpression</span><span class="params">(String cronExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cronExpression = cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>setCronExpression</code> 方法，可以在应用运行时修改任务的执行规则。如果结合配置中心（如 Nacos、Apollo），还能实现配置的动态推送。</p><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><ul><li><p><strong>任务执行时长</strong>：如果任务执行时长超过了定时频率，会导致任务堆积。建议通过线程池配置或优化任务逻辑来避免。</p></li><li><p><strong>异常处理</strong>：定时任务方法中如果抛出未捕获的异常，会导致任务终止。建议在方法内部添加 try-catch 块，或通过全局异常处理器捕获异常。</p></li><li><p><strong>分布式环境</strong>：Spring Boot 内置的定时任务不支持分布式锁，在分布式环境下可能出现多个节点同时执行任务的情况。此时需要结合分布式锁（如 Redis 分布式锁）来保证任务的唯一性。</p></li><li><p><strong>幂等性</strong>：即使使用了分布式锁，也建议保证任务的幂等性，避免因网络抖动等问题导致任务重复执行。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Spring Boot 定时任务通过 <code>@EnableScheduling</code> 和 <code>@Scheduled</code> 注解，极大地简化了定时任务的开发。本文从基础的固定延迟、固定频率任务，到灵活的 Cron 表达式，再到参数外部化和线程池配置，最后介绍了动态任务和注意事项，覆盖了定时任务的大部分使用场景。</p><p>在实际开发中，需要根据业务需求选择合适的定时方式，并注意异常处理、分布式环境下的任务唯一性等问题。希望本文能帮助你快速掌握 Spring Boot 定时任务的使用😊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Boot-定时任务（Task）使用教程：从入门到精通&quot;&gt;&lt;a href=&quot;#Spring-Boot-定时任务（Task）使用教程：从入门到精通&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 定时任务（Task）使用教程</summary>
      
    
    
    
    
    <category term="Spring Boot" scheme="https://nmcb666.vip/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>关于Spring Security的一些事</title>
    <link href="https://nmcb666.vip/posts/3f6c5c0b.html"/>
    <id>https://nmcb666.vip/posts/3f6c5c0b.html</id>
    <published>2025-09-14T13:54:10.000Z</published>
    <updated>2025-09-28T06:22:14.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security-使用教程：从入门到实战"><a href="#Spring-Security-使用教程：从入门到实战" class="headerlink" title="Spring Security 使用教程：从入门到实战"></a>Spring Security 使用教程：从入门到实战</h1><p>在Web应用开发中，安全永远是不可忽视的环节。Spring Security作为Spring生态中成熟的安全框架，提供了全面的认证（Authentication）和授权（Authorization）解决方案。本文将从基础到进阶，带你一步步掌握Spring Security的核心用法，构建安全可靠的Java Web应用。(对的，这是Spring Security的入门篇)</p><h2 id="一、Spring-Security-核心概念"><a href="#一、Spring-Security-核心概念" class="headerlink" title="一、Spring Security 核心概念"></a>一、Spring Security 核心概念</h2><p>在开始实战前，先理解几个核心概念，有助于后续学习：</p><ul><li><p><strong>认证（Authentication）</strong>：验证用户身份的过程，比如登录时校验用户名和密码是否正确。</p></li><li><p><strong>授权（Authorization）</strong>：在认证通过后，判断用户是否有权限执行某个操作（如访问特定接口、修改数据）。</p></li><li><p><strong>SecurityContext</strong>：存储当前认证用户的信息，通过<code>SecurityContextHolder</code>可以随时获取。</p></li><li><p><strong>UserDetails</strong>：封装用户信息的接口，包含用户名、密码、权限等核心字段。</p></li><li><p><strong>AuthenticationManager</strong>：认证的核心管理器，负责调度<code>AuthenticationProvider</code>完成认证。</p></li></ul><h2 id="二、环境搭建：快速集成Spring-Security"><a href="#二、环境搭建：快速集成Spring-Security" class="headerlink" title="二、环境搭建：快速集成Spring Security"></a>二、环境搭建：快速集成Spring Security</h2><p>本文基于<strong>Spring Boot 3.x</strong>进行演示，Spring Boot已为Spring Security提供了自动配置，集成过程非常简单。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><p>在<code>pom.xml</code>（Maven）或<code>build.gradle</code>（Gradle）中添加Spring Security依赖：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0-M2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="2-2-启动应用，体验默认安全配置"><a href="#2-2-启动应用，体验默认安全配置" class="headerlink" title="2.2 启动应用，体验默认安全配置"></a>2.2 启动应用，体验默认安全配置</h3><p>添加依赖后，直接启动Spring Boot应用，Spring Security会自动生效，默认做了以下安全配置：</p><ol><li><p>所有接口默认需要认证才能访问。</p></li><li><p>生成一个默认用户，用户名是<code>user</code>，密码会在控制台输出（格式如：<code>Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code>）。</p></li><li><p>提供一个默认的登录页面（访问任意接口会自动跳转）。</p></li></ol><p>测试：访问<code>http://localhost:8080/hello</code>（需先编写一个简单的Hello接口），会跳转至登录页，输入默认用户名和密码即可访问。</p><h2 id="三、自定义认证：从默认到数据库"><a href="#三、自定义认证：从默认到数据库" class="headerlink" title="三、自定义认证：从默认到数据库"></a>三、自定义认证：从默认到数据库</h2><p>默认配置仅用于测试，实际项目中需要对接数据库用户，下面实现自定义认证逻辑。</p><h3 id="3-1-编写配置类"><a href="#3-1-编写配置类" class="headerlink" title="3.1 编写配置类"></a>3.1 编写配置类</h3><p>创建<code>SecurityConfig</code>类，继承<code>WebSecurityConfigurerAdapter</code>（Spring Boot 3.x中已 deprecated，推荐使用函数式风格配置）：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入自定义的UserDetailsService（后续实现）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityConfig</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置密码加密器（Spring Security 5+要求必须指定密码加密方式）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置SecurityFilterChain（核心配置）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 关闭CSRF（测试环境可关闭，生产环境需开启）</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            <span class="comment">// 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                <span class="comment">// 放行登录接口、静态资源等</span></span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 其他所有接口需要认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置表单登录</span></span><br><span class="line">            .formLogin(form -&gt; form</span><br><span class="line">                <span class="comment">// 自定义登录页面路径（可选，默认是/spring-security-login）</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/custom-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录请求的接口路径（默认是/login）</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/do-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录成功后的跳转路径</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 登录失败后的跳转路径</span></span><br><span class="line">                .failureUrl(<span class="string">&quot;/custom-login?error=true&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置退出登录</span></span><br><span class="line">            .logout(logout -&gt; logout</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/custom-login?logout=true&quot;</span>)</span><br><span class="line">                .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 销毁session</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="3-2-实现UserDetailsService"><a href="#3-2-实现UserDetailsService" class="headerlink" title="3.2 实现UserDetailsService"></a>3.2 实现UserDetailsService</h3><p><code>UserDetailsService</code>负责从数据库加载用户信息，我们需要实现它来对接自己的用户表：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用户DAO（实际项目中替换为MyBatis或JPA的Repository）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomUserDetailsService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 从数据库查询用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据库用户转换为UserDetails对象（包含权限信息）</span></span><br><span class="line">        <span class="keyword">return</span> User.withUsername(user.getUsername())</span><br><span class="line">                .password(user.getPassword()) <span class="comment">// 数据库中存储的密码必须是加密后的</span></span><br><span class="line">                .roles(user.getRoles().split(<span class="string">&quot;,&quot;</span>)) <span class="comment">// 假设roles字段是逗号分隔的角色字符串</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="callout">注意：数据库中存储的密码必须是通过`BCryptPasswordEncoder`加密后的字符串，不能存储明文。可以通过`passwordEncoder.encode("123456")`生成加密密码。</div><h2 id="四、授权控制：基于角色和权限"><a href="#四、授权控制：基于角色和权限" class="headerlink" title="四、授权控制：基于角色和权限"></a>四、授权控制：基于角色和权限</h2><p>认证通过后，需要对不同用户授予不同权限，Spring Security支持多种授权方式。</p><h3 id="4-1-基于角色的URL授权"><a href="#4-1-基于角色的URL授权" class="headerlink" title="4.1 基于角色的URL授权"></a>4.1 基于角色的URL授权</h3><p>在<code>securityFilterChain</code>中通过<code>hasRole</code>或<code>hasAnyRole</code>配置URL的角色权限：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// 只有ADMIN角色可访问/admin下的接口</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>) <span class="comment">// ADMIN或USER角色可访问</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/public/**&quot;</span>).permitAll() <span class="comment">// 公开接口，无需认证</span></span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="4-2-基于注解的方法级授权"><a href="#4-2-基于注解的方法级授权" class="headerlink" title="4.2 基于注解的方法级授权"></a>4.2 基于注解的方法级授权</h3><p>在Controller方法上使用注解控制权限，需先开启全局方法安全：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span> <span class="comment">// 开启PreAuthorize注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在Controller方法上使用注解：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有ADMIN角色的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-manage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">manageUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户管理页面&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有DELETE权限的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;DELETE&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除用户：&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="五、进阶功能：记住我与JWT"><a href="#五、进阶功能：记住我与JWT" class="headerlink" title="五、进阶功能：记住我与JWT"></a>五、进阶功能：记住我与JWT</h2><p>除了基础的认证授权，Spring Security还支持“记住我”、JWT令牌等高级功能。</p><h3 id="5-1-实现“记住我”功能"><a href="#5-1-实现“记住我”功能" class="headerlink" title="5.1 实现“记住我”功能"></a>5.1 实现“记住我”功能</h3><p>只需在<code>securityFilterChain</code>中添加<code>rememberMe</code>配置：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.rememberMe(remember -&gt; remember</span><br><span class="line">    .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中的记住我参数名</span></span><br><span class="line">    .tokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>) <span class="comment">// 记住我有效期（7天）</span></span><br><span class="line">    .userDetailsService(userDetailsService) <span class="comment">// 加载用户信息</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在登录表单中添加一个名为<code>remember-me</code>的复选框即可。</p><h3 id="5-2-集成JWT实现无状态认证"><a href="#5-2-集成JWT实现无状态认证" class="headerlink" title="5.2 集成JWT实现无状态认证"></a>5.2 集成JWT实现无状态认证</h3><p>对于前后端分离项目，通常使用JWT（JSON Web Token）实现无状态认证，核心步骤如下：</p><ol><li><p><strong>引入JWT依赖</strong>：添加<code>jjwt-api</code>、<code>jjwt-impl</code>、<code>jjwt-jackson</code>依赖。</p></li><li><p><strong>编写JWT工具类</strong>：实现Token的生成、解析、验证逻辑。</p></li><li><p><strong>自定义JwtAuthenticationFilter</strong>：从请求头中获取Token，解析后完成认证。</p></li><li><p><strong>配置SecurityFilterChain</strong>：关闭session，添加JWT过滤器，放行登录接口等。</p></li></ol><p>由于JWT集成步骤较多，后续会单独写一篇实战文章，感兴趣的可以关注。</p><h2 id="六、常见问题与排查"><a href="#六、常见问题与排查" class="headerlink" title="六、常见问题与排查"></a>六、常见问题与排查</h2><ul><li><p><strong>密码加密失败</strong>：确保数据库中存储的是加密后的密码，且配置了正确的<code>PasswordEncoder</code>。</p></li><li><p><strong>接口授权不生效</strong>：检查URL匹配规则的顺序（具体规则要放在通用规则前面），以及角色/权限名称是否正确（<code>hasRole</code>会自动添加<code>ROLE_</code>前缀，<code>hasAuthority</code>需要完整名称）。</p></li><li><p><strong>CSRF问题</strong>：前后端分离项目中，若关闭CSRF，需确保请求头中没有携带CSRF Token；若开启，需在前端请求中添加Token。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本文介绍了Spring Security的核心概念、环境搭建、自定义认证、授权控制及进阶功能，涵盖了大部分实际项目中的常用场景。Spring Security功能强大且灵活，掌握它能有效提升应用的安全性。建议结合实际项目多动手实践，深入理解其核心原理（如过滤器链、认证流程等），以便应对更复杂的安全需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Security-使用教程：从入门到实战&quot;&gt;&lt;a href=&quot;#Spring-Security-使用教程：从入门到实战&quot; class=&quot;headerlink&quot; title=&quot;Spring Security 使用教程：从入门到实战&quot;&gt;&lt;/a&gt;Sprin</summary>
      
    
    
    
    
    <category term="Spring Boot" scheme="https://nmcb666.vip/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>计算机技术</title>
    <link href="https://nmcb666.vip/posts/b67a9f87.html"/>
    <id>https://nmcb666.vip/posts/b67a9f87.html</id>
    <published>2025-09-13T22:53:06.000Z</published>
    <updated>2025-09-28T06:22:14.467Z</updated>
    
    <content type="html"><![CDATA[<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg><h1 id="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"><a href="#从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互" class="headerlink" title="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"></a>从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互</h1><p>在十年前，打开一个大型文档需要等待几十秒、视频通话时频繁出现“马赛克”、手机多开几个APP就会闪退，这些场景对大多数人来说都司空见惯。而如今，我们早已习惯了“即点即开”的文档编辑、4K画质的实时视频会议、手机后台同时运行十几个应用仍流畅切换——这些“丝滑”体验的背后，并非只是“硬件变好了”这么简单，而是计算机技术在<strong>存储架构、网络传输、系统优化</strong>等多个维度协同进化的结果。今天，我们就从日常场景切入，聊聊那些“看不见却离不开”的技术进步。</p><h2 id="一、存储技术：从“机械等待”到“电子秒达”"><a href="#一、存储技术：从“机械等待”到“电子秒达”" class="headerlink" title="一、存储技术：从“机械等待”到“电子秒达”"></a>一、存储技术：从“机械等待”到“电子秒达”</h2><p>打开电脑时，系统启动速度的快慢，很大程度上取决于存储设备的性能。十年前主流的机械硬盘（HDD），就像一个“带转盘的档案柜”：读写数据时，需要先让磁盘高速旋转（通常是5400转/分钟或7200转/分钟），再让磁头移动到指定位置“查找”数据——这个过程虽然比早期的软盘快，但仍有明显的“等待时间”（平均寻道时间约8-12毫秒）。</p><p>而现在主流的固态硬盘（SSD），彻底抛弃了“机械结构”，改用<strong>NAND闪存芯片</strong>存储数据，就像把“档案柜”换成了“电子货架”：数据通过电信号直接读写，无需等待磁盘旋转或磁头移动，平均响应时间可以做到0.1毫秒以内——这意味着，从“点击开机”到“进入桌面”，时间从原来的1-2分钟压缩到了10-20秒，甚至更短。</p><p>更关键的是，SSD的进步还在持续：</p><ul><li><strong>NVMe协议</strong>的普及：相比早期SSD使用的SATA接口，NVMe直接通过PCIe总线与CPU通信，带宽提升了10倍以上，读写速度从“几百MB/s”跃升到“几GB/s”，打开4K视频文件、大型设计软件时几乎没有延迟。</li><li><strong>QLC闪存的成本下降</strong>：早期SSD因成本高，容量普遍在128GB-256GB；而现在1TB容量的QLC SSD价格已非常亲民，既能满足日常文件存储，也能装下多个大型游戏或专业软件。</li></ul><p>对普通用户来说，存储技术的进步不是“参数的胜利”，而是“打开文件不用等、编辑视频不卡顿”的实在体验。</p><h2 id="二、网络传输：从“断断续续”到“实时互动”"><a href="#二、网络传输：从“断断续续”到“实时互动”" class="headerlink" title="二、网络传输：从“断断续续”到“实时互动”"></a>二、网络传输：从“断断续续”到“实时互动”</h2><p>疫情期间，远程办公和在线学习成为常态，很多人都经历过“视频会议卡成PPT”“在线课堂声音延迟”的尴尬。这背后的核心问题，是早期网络传输在<strong>带宽、延迟、稳定性</strong>上的不足。而现在，这些问题的缓解，离不开两项关键技术的成熟：</p><h3 id="1-5G与Wi-Fi-6：解决“带宽不够用”的问题"><a href="#1-5G与Wi-Fi-6：解决“带宽不够用”的问题" class="headerlink" title="1. 5G与Wi-Fi 6：解决“带宽不够用”的问题"></a>1. 5G与Wi-Fi 6：解决“带宽不够用”的问题</h3><ul><li>5G网络的峰值速率可达10Gbps，是4G的10-100倍，即使在户外用手机开热点参加视频会议，也能支持4K画质的实时传输；</li><li>Wi-Fi 6（802.11ax）的单设备速率提升到9.6Gbps，同时支持更多设备连接（最多可同时连接100+设备）——这意味着，家里的电视、手机、电脑、智能音箱同时联网，也不会出现“抢网速”导致的卡顿。</li></ul><h3 id="2-边缘计算：降低“数据跑太远”的延迟"><a href="#2-边缘计算：降低“数据跑太远”的延迟" class="headerlink" title="2. 边缘计算：降低“数据跑太远”的延迟"></a>2. 边缘计算：降低“数据跑太远”的延迟</h3><p>传统的网络架构中，我们的视频通话数据需要先传到远方的“中心服务器”，再转发给对方，这个过程会产生几十甚至上百毫秒的延迟（即“网络时延”）。而边缘计算则把“服务器”搬到了离用户更近的地方（比如城市的基站、区域数据中心），数据传输距离缩短，时延可以降低到10毫秒以内——这也是为什么现在的“实时连麦”“云游戏”能做到“操作无延迟”的关键。</p><p>举个例子：以前玩云游戏，按下“射击”按钮后，需要等1-2秒才能看到画面反应；现在有了边缘计算和高速网络，延迟几乎可以忽略，体验和在本地玩游戏没什么区别。</p><h2 id="三、系统优化：从“资源浪费”到“智能调度”"><a href="#三、系统优化：从“资源浪费”到“智能调度”" class="headerlink" title="三、系统优化：从“资源浪费”到“智能调度”"></a>三、系统优化：从“资源浪费”到“智能调度”</h2><p>除了硬件和网络，操作系统的优化同样重要。早期的系统（比如Windows XP、安卓4.0）对硬件资源的调度能力较弱，比如：</p><ul><li>打开多个APP后，后台应用不会“主动释放内存”，导致可用内存越来越少，手机或电脑越来越卡；</li><li>CPU资源分配“一刀切”，不管是微信聊天还是视频渲染，都用同样的性能模式，既浪费电量，又无法满足高负载需求。</li></ul><p>而现在的操作系统（如Windows 11、安卓14），通过<strong>智能资源调度</strong>技术，让硬件性能“用在刀刃上”：</p><h3 id="1-内存管理：“动态回收”与“压缩优化”"><a href="#1-内存管理：“动态回收”与“压缩优化”" class="headerlink" title="1. 内存管理：“动态回收”与“压缩优化”"></a>1. 内存管理：“动态回收”与“压缩优化”</h3><ul><li>安卓系统的“墓碑机制”（Android 12后优化）：当APP进入后台时，系统会“冻结”其占用的内存，不再让它消耗资源；如果内存不足，会自动回收优先级低的后台APP内存，保证前台应用流畅运行。</li><li>Windows的“内存压缩”：当物理内存不足时，系统会将不常用的内存数据压缩（压缩率可达50%以上），而不是直接写入硬盘（虚拟内存），避免了因硬盘速度慢导致的卡顿。</li></ul><h3 id="2-CPU调度：“按需分配”与“能效平衡”"><a href="#2-CPU调度：“按需分配”与“能效平衡”" class="headerlink" title="2. CPU调度：“按需分配”与“能效平衡”"></a>2. CPU调度：“按需分配”与“能效平衡”</h3><ul><li>手机的“异构计算”：现在的手机CPU大多是“多核心架构”（比如4个小核+4个大核），系统会根据任务轻重分配核心：聊微信时用低功耗小核，省电量；玩游戏时调用高性能大核，保证帧率稳定。</li><li>Windows的“性能模式”：用户可以根据需求切换“节能模式”“平衡模式”“高性能模式”，比如外出办公时用节能模式延长续航，做视频剪辑时开高性能模式提升效率。</li></ul><h2 id="四、技术的终极目标：让“复杂”隐于“无形”"><a href="#四、技术的终极目标：让“复杂”隐于“无形”" class="headerlink" title="四、技术的终极目标：让“复杂”隐于“无形”"></a>四、技术的终极目标：让“复杂”隐于“无形”</h2><p>回顾计算机技术的发展，我们会发现一个规律：真正优秀的技术，从来不是让用户去“理解它”，而是让用户“感受不到它的存在”——就像我们不会在意SSD的闪存芯片如何工作，也不会关心Wi-Fi 6的协议细节，我们只需要“打开文件很快”“视频通话很流畅”。</p><p>未来，随着AI与计算机技术的融合（比如AI驱动的智能内存调度、AI优化的网络传输路径），我们的交互体验还会进一步升级：可能电脑会“预判”你要打开的文件，提前加载到内存；可能网络会“自动避开”拥堵路段，保证视频会议不卡顿。</p><p>技术的进步，最终是为了“让工具回归工具的本质”——让我们不再被“卡顿”“等待”困扰，而是更专注于内容创作、沟通协作，或者单纯地享受数字生活的乐趣。这，或许就是计算机技术最动人的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;object class=&quot;ghbdage&quot; style=&quot;margin-inline:5px&quot; title=&quot;&quot; standby=&quot;loading...&quot; data=&quot;https://img.shields.io/badge/Butterfly-Theme-orange?lo</summary>
      
    
    
    
    
    <category term="计算机杂谈" scheme="https://nmcb666.vip/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
