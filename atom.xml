<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2025-12-31T02:05:23.122Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>feign的三种异常处理关系</title>
    <link href="https://nmcb666.vip/posts/20b8d2ff.html"/>
    <id>https://nmcb666.vip/posts/20b8d2ff.html</id>
    <published>2025-12-31T10:00:37.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"><a href="#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘" class="headerlink" title="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"></a>Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘</h1><p>在微服务架构中，Feign作为声明式HTTP客户端，是服务间调用的核心组件。而异常处理是保障微服务稳定性的关键环节——当Feign调用下游服务抛出异常时，我们常通过 <code>ErrorDecoder</code>、容错组件的 <code>Fallback</code>（如Sentinel/Hystrix）、Spring全局异常捕获器（<code>@RestControllerAdvice</code>）三种方式处理异常。但三者并存时，执行顺序如何？优先级背后的原理是什么？特殊场景下又会出现哪些变化？本文将结合实践拆解这一核心问题。</p><h2 id="一、核心结论：三者的优先执行顺序"><a href="#一、核心结论：三者的优先执行顺序" class="headerlink" title="一、核心结论：三者的优先执行顺序"></a>一、核心结论：三者的优先执行顺序</h2><p>当Feign调用发生异常（非2xx HTTP状态码、超时、网络异常等）时，三者的执行优先级从高到低依次为：</p><p><strong>ErrorDecoder（Feign原生） → Fallback（容错组件） → 全局异常捕获器（Spring MVC）</strong></p><p>完整执行链路可概括为：</p><blockquote><p>Feign调用触发异常 → ResponseInterceptor（OpenFeign 12.0+ 可选预处理） → ErrorDecoder（异常解码/转换） → 容错组件拦截异常 → Fallback（异常兜底，返回正常数据） → （Fallback失效时）全局异常捕获器 → （均未处理时）向上抛出原始异常</p></blockquote><p>其中，前两者属于Feign调用链路的“前置处理”，全局异常捕获器属于“后置兜底”，且Fallback默认会阻断异常向上传播，使全局异常捕获器无法触发。</p><h2 id="二、优先级原理：层级与职责边界决定执行顺序"><a href="#二、优先级原理：层级与职责边界决定执行顺序" class="headerlink" title="二、优先级原理：层级与职责边界决定执行顺序"></a>二、优先级原理：层级与职责边界决定执行顺序</h2><p>三者优先级的本质的是执行层级和职责边界的差异，不同层级对应不同的异常处理目标，形成了“层层拦截、各司其职”的链路。</p><h3 id="1-第一优先级：ErrorDecoder（Feign原生扩展点）"><a href="#1-第一优先级：ErrorDecoder（Feign原生扩展点）" class="headerlink" title="1. 第一优先级：ErrorDecoder（Feign原生扩展点）"></a>1. 第一优先级：ErrorDecoder（Feign原生扩展点）</h3><p><code>ErrorDecoder</code> 是Feign原生提供的异常解码扩展点，属于「Feign调用响应处理层级」，是异常进入业务链路前的“第一道关口”。</p><p>其核心职责是：拦截Feign调用返回的非2xx异常响应，将Feign默认抛出的 <code>FeignException</code>（包含杂乱的HTTP响应信息）转换为标准化的自定义业务异常，同时可解析异常响应体、提取下游服务异常详情，为后续处理提供统一的异常格式。</p><p>优先级最高的原因的是：它直接嵌入Feign的响应处理流程，在异常被传递给业务层或容错组件前，就完成了解码和转换。后续的Fallback和全局异常捕获器，处理的都是经过它转换后的异常（或未自定义时的默认异常）。</p><h3 id="2-第二优先级：Fallback（容错组件能力）"><a href="#2-第二优先级：Fallback（容错组件能力）" class="headerlink" title="2. 第二优先级：Fallback（容错组件能力）"></a>2. 第二优先级：Fallback（容错组件能力）</h3><p><code>Fallback</code> 是Sentinel、Hystrix、Resilience4j等容错组件提供的兜底能力，属于「微服务容错防护层级」，是异常传播的“第二道关口”。</p><p>其核心职责是：通过AOP或代理模式，拦截Feign调用/业务方法抛出的异常（已被ErrorDecoder处理），将“异常结果”转换为“合法的业务返回数据”，消化异常以防止服务雪崩，同时避免业务层手动try-catch。</p><p>优先级高于全局异常捕获器的原因的是：它在异常产生点附近直接拦截，且处理后返回正常数据——异常被完全“消化”，不再向上传播，导致全局异常捕获器失去触发前提（全局异常捕获器仅处理未被拦截的传播异常）。</p><h3 id="3-第三优先级：全局异常捕获器（Spring-MVC层级）"><a href="#3-第三优先级：全局异常捕获器（Spring-MVC层级）" class="headerlink" title="3. 第三优先级：全局异常捕获器（Spring MVC层级）"></a>3. 第三优先级：全局异常捕获器（Spring MVC层级）</h3><p>全局异常捕获器（基于 <code>@RestControllerAdvice</code> + <code>@ExceptionHandler</code>）是Spring MVC提供的全局能力，属于「应用层异常兜底层级」，是异常处理的“最后一道关口”。</p><p>其核心职责是：捕获所有向上传播到Controller层及以上的未处理异常，统一返回标准化错误响应，避免裸异常暴露给前端。</p><p>优先级最低的原因的是：它的执行依赖“异常未被前置逻辑处理且成功传播”，而Fallback通常会提前消化异常，只有在Fallback失效时，它才会补位生效。</p><h2 id="三、实战验证：直观感受执行顺序"><a href="#三、实战验证：直观感受执行顺序" class="headerlink" title="三、实战验证：直观感受执行顺序"></a>三、实战验证：直观感受执行顺序</h2><p>我们以「OpenFeign 12.0+ + Sentinel + Spring Boot」为例，通过代码验证三者的执行顺序，同时覆盖正常场景与特殊场景。</p><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>依赖核心组件：OpenFeign（12.0+）、Spring Cloud Alibaba Sentinel、Spring Web。</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><h4 id="（1）自定义ErrorDecoder（第一优先级）"><a href="#（1）自定义ErrorDecoder（第一优先级）" class="headerlink" title="（1）自定义ErrorDecoder（第一优先级）"></a>（1）自定义ErrorDecoder（第一优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【1. 执行 ErrorDecoder】：解码Feign异常，状态码=&quot;</span> + response.status());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorBody</span> <span class="operator">=</span> Util.toString(response.body().asReader(Util.UTF_8));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;服务调用异常（ErrorDecoder转换）：&quot;</span> + errorBody);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义业务异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）配置Fallback（第二优先级）"><a href="#（2）配置Fallback（第二优先级）" class="headerlink" title="（2）配置Fallback（第二优先级）"></a>（2）配置Fallback（第二优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Feign接口</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-service&quot;, fallback = ProviderFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/provider/getData&quot;)</span></span><br><span class="line">    String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback兜底类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id + <span class="string">&quot;（服务调用异常）&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）全局异常捕获器（第三优先级）"><a href="#（3）全局异常捕获器（第三优先级）" class="headerlink" title="（3）全局异常捕获器（第三优先级）"></a>（3）全局异常捕获器（第三优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleAllException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【3. 执行全局异常捕获器】：捕获异常：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;全局兜底：&quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）业务调用层"><a href="#（4）业务调用层" class="headerlink" title="（4）业务调用层"></a>（4）业务调用层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProviderClient providerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getData&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providerClient.getData(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-场景测试结果"><a href="#3-场景测试结果" class="headerlink" title="3. 场景测试结果"></a>3. 场景测试结果</h3><h4 id="（1）正常场景：三者并存，Fallback正常触发"><a href="#（1）正常场景：三者并存，Fallback正常触发" class="headerlink" title="（1）正常场景：三者并存，Fallback正常触发"></a>（1）正常场景：三者并存，Fallback正常触发</h4><p>当下游服务抛出异常时，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br></pre></td></tr></table></figure><p>接口返回：<code>兜底数据：id=123（服务调用异常）</code>，全局异常捕获器未触发（被Fallback阻断）。</p><h4 id="（2）特殊场景：Fallback自身抛出异常"><a href="#（2）特殊场景：Fallback自身抛出异常" class="headerlink" title="（2）特殊场景：Fallback自身抛出异常"></a>（2）特殊场景：Fallback自身抛出异常</h4><p>修改Fallback逻辑，故意抛出空指针异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nullStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        nullStr.length(); <span class="comment">// 空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：null</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：null</code>，Fallback异常向上传播，触发全局异常捕获器。</p><h4 id="（3）特殊场景：Fallback未触发（配置失效）"><a href="#（3）特殊场景：Fallback未触发（配置失效）" class="headerlink" title="（3）特殊场景：Fallback未触发（配置失效）"></a>（3）特殊场景：Fallback未触发（配置失效）</h4><p>若未开启Sentinel与Feign的整合（未配置 <code>feign.sentinel.enabled=true</code>），Fallback配置失效，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：服务调用异常（ErrorDecoder转换）：xxx</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：服务调用异常（ErrorDecoder转换）：xxx</code>，Fallback未触发，异常传播至全局捕获器。</p><h2 id="四、实践建议：三者协同的最佳姿势"><a href="#四、实践建议：三者协同的最佳姿势" class="headerlink" title="四、实践建议：三者协同的最佳姿势"></a>四、实践建议：三者协同的最佳姿势</h2><p>三者并非互斥关系，而是互补关系，合理搭配可实现“异常标准化+容错兜底+最终补位”的三层防护体系，提升微服务稳定性。</p><h3 id="1-分工明确，各司其职"><a href="#1-分工明确，各司其职" class="headerlink" title="1. 分工明确，各司其职"></a>1. 分工明确，各司其职</h3><ul><li><p><strong>ErrorDecoder</strong>：专注“异常标准化”，统一转换Feign原生异常为业务异常，解析异常详情，不做兜底逻辑；</p></li><li><p><strong>Fallback</strong>：专注“容错兜底”，针对核心服务调用，返回预设兜底数据（如缓存数据、默认值），防止服务雪崩；</p></li><li><p><strong>全局异常捕获器</strong>：专注“最终补位”，捕获所有漏网异常（Fallback异常、配置错误导致的异常），统一返回前端友好响应。</p></li></ul><h3 id="2-规避常见坑点"><a href="#2-规避常见坑点" class="headerlink" title="2. 规避常见坑点"></a>2. 规避常见坑点</h3><ul><li><p>Fallback方法签名必须与原方法一致（参数、返回值类型匹配），否则配置失效，异常直接传播；</p></li><li><p>Hystrix会忽略 <code>HystrixBadRequestException</code> 及 <code>ignoreExceptions</code> 配置的异常，这类异常不触发Fallback，需通过全局捕获器处理；</p></li><li><p>ErrorDecoder中避免抛出非业务异常，建议统一转换为自定义异常，便于Fallback和全局捕获器识别。</p></li></ul><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><ul><li>异常多层包装（含 Error 类型）会阻断 Spring 自动穿透。当异常链中存在 AssertionError 等 Error 类型异常时（如 Sentinel 整合 Feign 场景，在fallback函数中抛出RuntimeException异常会被Sentinel自动包装为AssertionError 继承 Error分支，然后又被Spring MVC DispatcherServlet自动抛出为NestedServletException异常），Spring 的 @ExceptionHandler 自动穿透功能仅支持 Exception 分支，无法穿透 Error 类型异常，导致自定义异常（CommonException）无法被精准捕获，最终被 Exception 兜底处理器捕获（或者被NestedServletException异常捕获器捕获）；</li><li><p>解决方案：手动解析完整的 Throwable 链（包含 Error 和 Exception），通过循环遍历 cause 链主动提取目标自定义异常，再手动分发到对应异常处理器；</p></li><li><p>下面是spring对于异常处理的源码。可以看见如果遇到非Exception的Throwable。它会自动抛出NestedServletException</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用处理器方法（Controller方法、Feign调用、Service方法等都在这一步执行）</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 捕获Exception类型异常，直接赋值给dispatchException，不包装</span></span><br><span class="line">    dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    <span class="comment">// 捕获Throwable类型（非Exception，如Error、AssertionError等），包装为NestedServletException</span></span><br><span class="line">    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-组件选择建议"><a href="#4-组件选择建议" class="headerlink" title="4. 组件选择建议"></a>4. 组件选择建议</h3><p>Hystrix已进入维护模式，推荐使用 <strong>Resilience4j</strong>（轻量、Spring官方推荐）或 <strong>Sentinel</strong>（阿里生态，支持流量控制、熔断降级等丰富特性）作为Fallback载体；OpenFeign 12.0+ 建议搭配 <code>ResponseInterceptor</code> 做响应日志预处理，与ErrorDecoder协同提升异常排查效率。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Feign异常处理的三重机制，本质是不同层级的“异常拦截-处理”链路：ErrorDecoder负责“入口标准化”，Fallback负责“中间容错”，全局异常捕获器负责“最终补位”。优先级的核心逻辑是“先处理异常、再消化异常、最后补位异常”。</p><p>在实际开发中，三者协同使用，既能保证异常处理的规范性和灵活性，又能提升微服务的高可用性，避免因单一异常处理机制失效导致的服务不稳定问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘&quot;&gt;&lt;a href=&quot;#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://nmcb666.vip/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>微服务之间的全局异常捕获</title>
    <link href="https://nmcb666.vip/posts/df97f9d4.html"/>
    <id>https://nmcb666.vip/posts/df97f9d4.html</id>
    <published>2025-12-24T02:09:18.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<p>在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是500，错误信息固定为INTERNAL_SERVER_ERROR，全局异常捕获器形同虚设，尤其在微服务间通过OpenFeign调用API时，该问题更为突出。本文将围绕这一问题，从原因分析、解决方案到特殊场景适配，逐步拆解实战过程中的思考与踩坑。</p><h2 id="一、问题现象：单体架构异常捕获在微服务中失效"><a href="#一、问题现象：单体架构异常捕获在微服务中失效" class="headerlink" title="一、问题现象：单体架构异常捕获在微服务中失效"></a>一、问题现象：单体架构异常捕获在微服务中失效</h2><p>在单体应用中，我们通常会编写如下全局异常捕获器，针对不同业务异常返回自定义状态码和信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(e.getCode(), e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在微服务架构中，当服务A通过OpenFeign调用服务B，服务B抛出BusinessException并被自身全局异常捕获器处理，返回400状态码和自定义信息时，服务A接收到的响应却依然是500 INTERNAL_SERVER_ERROR，无法获取服务B返回的真实异常信息，导致异常排查困难，也无法根据真实异常类型做后续业务处理。</p><h2 id="二、根源分析：OpenFeign对非2XX响应的默认处理机制"><a href="#二、根源分析：OpenFeign对非2XX响应的默认处理机制" class="headerlink" title="二、根源分析：OpenFeign对非2XX响应的默认处理机制"></a>二、根源分析：OpenFeign对非2XX响应的默认处理机制</h2><p>问题的核心在于微服务间的调用方式——OpenFeign的异常处理逻辑。当被调用方（服务B）抛出异常后，其自身的全局异常捕获器会正常工作，返回自定义的非2XX状态码（如400、502）和错误信息。但调用方（服务A）通过OpenFeign调用时，OpenFeign有一个默认规则：<strong>对所有非2XX的HTTP响应，都会自动抛出FeignException异常</strong>。</p><p>这就导致服务A无法直接获取服务B返回的自定义异常信息，只能捕获到OpenFeign封装的FeignException，而该异常默认对应500 INTERNAL_SERVER_ERROR状态码，最终呈现出“所有异常都返回500”的现象。本质上是OpenFeign的默认异常转换，覆盖了被调用方的自定义异常响应。</p><h2 id="三、解决方案一：自定义ErrorDecoder处理状态码异常"><a href="#三、解决方案一：自定义ErrorDecoder处理状态码异常" class="headerlink" title="三、解决方案一：自定义ErrorDecoder处理状态码异常"></a>三、解决方案一：自定义ErrorDecoder处理状态码异常</h2><p>要解决上述问题，我们可以通过自定义ErrorDecoder接口实现，覆写decode方法，对不同状态码的响应进行差异化处理，还原被调用方的真实异常信息，甚至返回自定义异常类型。</p><h3 id="3-1-自定义ErrorDecoder实现"><a href="#3-1-自定义ErrorDecoder实现" class="headerlink" title="3.1 自定义ErrorDecoder实现"></a>3.1 自定义ErrorDecoder实现</h3><p>注意：decode方法的核心是<strong>返回FeignException，而非直接抛出异常</strong>，OpenFeign会对该返回值做进一步处理并传递给调用方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultErrorDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeignException</span>.InternalServerError(methodKey, response, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据响应状态码自定义异常</span></span><br><span class="line">        <span class="keyword">switch</span> (response.status()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                <span class="comment">// 解析响应体，封装自定义业务异常信息</span></span><br><span class="line">                <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">                <span class="keyword">return</span> FeignException.badRequest(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>)</span><br><span class="line">                        .reason(errorResponse.getMsg());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                <span class="keyword">return</span> FeignException.serviceUnavailable(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 其他状态码可按需扩展</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 默认使用OpenFeign原生解码器</span></span><br><span class="line">                <span class="keyword">return</span> defaultErrorDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-配置FeignConfig注册Bean"><a href="#3-2-配置FeignConfig注册Bean" class="headerlink" title="3.2 配置FeignConfig注册Bean"></a>3.2 配置FeignConfig注册Bean</h3><p>将自定义的CustomErrorDecoder配置为Spring Bean，纳入Feign的配置体系中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ErrorDecoder <span class="title function_">errorDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomErrorDecoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，当服务A通过OpenFeign调用服务B时，若服务B返回非2XX状态码，CustomErrorDecoder会解析响应体，返回对应状态码的FeignException，并携带真实错误信息，服务A即可通过捕获FeignException获取详细异常内容，再结合自身全局异常捕获器做进一步处理。</p><h2 id="四、特殊场景：基于业务状态码的响应处理"><a href="#四、特殊场景：基于业务状态码的响应处理" class="headerlink" title="四、特殊场景：基于业务状态码的响应处理"></a>四、特殊场景：基于业务状态码的响应处理</h2><p>上述方案适用于HTTP状态码区分异常的场景，但在实际项目开发中，很多团队会采用“统一HTTP状态码”的设计：所有接口均返回200 OK，异常信息通过响应体中的自定义业务状态码（如code字段）、msg字段区分，data字段存储业务数据，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">10001</span><span class="punctuation">,</span> <span class="comment">// 10001代表业务异常，200代表成功</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;参数校验失败&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种场景下，ErrorDecoder将完全失效——因为ErrorDecoder仅拦截HTTP状态码为4XX、5XX的响应，而当前所有请求的HTTP状态码都是200，无法触发自定义解码逻辑。此时需要寻找新的解决方案。</p><h2 id="五、解决方案二：CustomResponseInterceptor（版本限制）"><a href="#五、解决方案二：CustomResponseInterceptor（版本限制）" class="headerlink" title="五、解决方案二：CustomResponseInterceptor（版本限制）"></a>五、解决方案二：CustomResponseInterceptor（版本限制）</h2><p>针对HTTP 200响应中嵌入业务状态码的场景，可通过自定义ResponseInterceptor接口实现，覆写intercept方法，在响应返回后解析业务状态码，判断是否存在异常并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResponseInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ResponseInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intercept</span><span class="params">(Response response, Chain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析响应体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">            <span class="comment">// 根据业务状态码判断是否抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (errorResponse.getCode() != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorResponse.getCode(), errorResponse.getMsg());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(<span class="string">&quot;响应解析异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.proceed(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要在FeignConfig中配置该拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ResponseInterceptor <span class="title function_">responseInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomResponseInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该方案存在明显局限性：<strong>ResponseInterceptor接口仅在OpenFeign 12.0+版本中提供</strong>，对于一些基于低版本OpenFeign（如Spring Cloud Netflix早期版本）的老项目，无法使用该方案，兼容性较差。</p><h2 id="六、尝试方案：AOP拦截Feign调用（失效原因分析）"><a href="#六、尝试方案：AOP拦截Feign调用（失效原因分析）" class="headerlink" title="六、尝试方案：AOP拦截Feign调用（失效原因分析）"></a>六、尝试方案：AOP拦截Feign调用（失效原因分析）</h2><p>针对低版本OpenFeign无法使用ResponseInterceptor的问题，我尝试通过AOP切面，在Feign客户端调用API后，对响应结果进行解析，根据业务状态码抛出对应异常。但实际测试发现，AOP切面完全不生效，无法拦截Feign客户端的方法调用。</p><p>查阅资料后，明确了失效的核心原因：</p><ol><li><p><strong>Feign客户端的创建机制</strong>：Feign客户端是通过动态代理生成的，而非Spring容器管理的普通Bean，其代理逻辑由Feign自身控制。</p></li><li><p><strong>Spring AOP的拦截限制</strong>：Spring AOP默认采用JDK动态代理，仅能拦截Spring容器管理的Bean的方法调用，无法直接拦截Feign生成的动态代理对象。</p></li><li><p><strong>代理优先级问题</strong>：Feign动态代理的优先级高于Spring AOP代理，导致AOP切面无法切入Feign客户端的方法执行流程。</p></li></ol><p>即便尝试切换为CGLIB代理，也无法有效拦截Feign客户端的调用，该方案最终宣告失败。</p><h2 id="七、现状与思考：待解决的痛点"><a href="#七、现状与思考：待解决的痛点" class="headerlink" title="七、现状与思考：待解决的痛点"></a>七、现状与思考：待解决的痛点</h2><p>综合以上实践，目前针对微服务间异常捕获的解决方案存在明显的场景局限性：</p><ul><li><p>基于ErrorDecoder的方案：适用于HTTP状态码区分异常的场景，兼容性好，无版本限制，是目前最成熟的方案。</p></li><li><p>基于ResponseInterceptor的方案：适用于HTTP 200+业务状态码的场景，但仅支持OpenFeign 12.0+版本，老项目无法适配。</p></li><li><p>AOP方案：理论上可适配所有版本，但因Feign动态代理机制限制，无法生效，暂无可行的优化方向。</p></li></ul><p>对于“低版本OpenFeign + HTTP 200 + 业务状态码”的组合场景，目前仍没有优雅且兼容的解决方案。可以考虑在调用api的方法中，去接受api返回的响应结果，根据业务状态码判断是否抛出异常，但这种方案侵入性强，违背了面向切面编程的思想。</p><p>在此也欢迎各位同行分享实践经验，探讨更优的解决方案，共同完善微服务异常处理体系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>微服务间的异常捕获相比单体架构更复杂，核心难点在于OpenFeign的代理机制和响应处理逻辑。在实际开发中，建议优先采用“HTTP状态码+自定义响应体”的方式设计接口，通过CustomErrorDecoder实现异常透传，兼顾兼容性和优雅性；若因业务需求必须使用统一HTTP 200状态码，则需评估升级OpenFeign版本的可行性，或权衡侵入性方案的取舍。后续将持续关注OpenFeign的版本更新和社区实践，寻找更完善的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://nmcb666.vip/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus的分页查询原理</title>
    <link href="https://nmcb666.vip/posts/3ecdcd9c.html"/>
    <id>https://nmcb666.vip/posts/3ecdcd9c.html</id>
    <published>2025-12-11T22:27:30.000Z</published>
    <updated>2025-12-31T02:05:23.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus分页查询底层原理"><a href="#MyBatis-Plus分页查询底层原理" class="headerlink" title="MyBatis-Plus分页查询底层原理"></a>MyBatis-Plus分页查询底层原理</h1><h3 id="一、分页查询的核心痛点与-MP-的解决方案"><a href="#一、分页查询的核心痛点与-MP-的解决方案" class="headerlink" title="一、分页查询的核心痛点与 MP 的解决方案"></a>一、分页查询的核心痛点与 MP 的解决方案</h3><p>在传统 MyBatis 开发中，分页实现往往需要手动拼接<code>LIMIT</code>语句（MySQL）或<code>ROWNUM</code>（Oracle），不仅繁琐且易出错，还存在两个核心问题：</p><ol><li><p><strong>SQL 侵入性强</strong>：业务 SQL 与分页语法耦合，切换数据库时需批量修改；</p></li><li><p><strong>总条数统计冗余</strong>：需手动编写 count 查询，且需处理复杂查询（如多表关联、分组统计）的 count 适配。</p></li></ol><p>MyBatis-Plus（以下简称 MP）的分页插件通过<strong>拦截器机制</strong>+<strong>数据库方言适配</strong>，实现了 “无侵入式分页”，其核心设计思路是：<strong>在 SQL 执行前动态改写 SQL，自动添加分页语法和 count 查询，同时封装分页结果</strong>。</p><h3 id="二、MP-分页的核心组件与依赖关系"><a href="#二、MP-分页的核心组件与依赖关系" class="headerlink" title="二、MP 分页的核心组件与依赖关系"></a>二、MP 分页的核心组件与依赖关系</h3><p>MP 分页功能的实现依赖 3 个核心组件，它们的协作流程决定了分页的底层逻辑：</p><div class="table-container"><table><thead><tr><th>组件名称</th><th>作用说明</th></tr></thead><tbody><tr><td><code>PaginationInnerInterceptor</code></td><td>核心拦截器，负责拦截 SQL 执行、改写 SQL、统计总条数（MP 3.4.0 + 推荐使用）</td></tr><tr><td><code>Page</code></td><td>分页参数载体，封装页码、每页条数、总条数、分页结果集等信息</td></tr><tr><td><code>Dialect</code></td><td>数据库方言接口，适配不同数据库的分页语法（如 MySQL 的 LIMIT、PostgreSQL 的 OFFSET）</td></tr></tbody></table></div><p><strong>依赖关系</strong>：<code>Page</code>传递分页参数 → <code>PaginationInnerInterceptor</code>拦截 SQL → 调用<code>Dialect</code>生成适配 SQL → 执行查询并封装结果。</p><h3 id="三、底层核心流程：从-SQL-拦截到结果返回"><a href="#三、底层核心流程：从-SQL-拦截到结果返回" class="headerlink" title="三、底层核心流程：从 SQL 拦截到结果返回"></a>三、底层核心流程：从 SQL 拦截到结果返回</h3><h4 id="1-拦截器触发条件"><a href="#1-拦截器触发条件" class="headerlink" title="1. 拦截器触发条件"></a>1. 拦截器触发条件</h4><p>MP 的分页插件本质是 MyBatis 的<code>Interceptor</code>接口实现类，通过<code>@Intercepts</code>注解指定拦截<code>StatementHandler</code>的<code>prepare</code>方法（SQL 预处理阶段）和<code>query</code>方法（结果查询阶段）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;),</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaginationInnerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InnerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 核心逻辑实现</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>mapper.selectPage(page, queryWrapper)</code>时，MyBatis 的插件链会触发该拦截器。</p><h4 id="2-SQL-动态改写原理"><a href="#2-SQL-动态改写原理" class="headerlink" title="2. SQL 动态改写原理"></a>2. SQL 动态改写原理</h4><p>这是分页功能的核心步骤，MP 会根据数据库方言，将原始查询 SQL 改写成 “分页查询 SQL” 和 “总条数查询 SQL”：</p><h5 id="（1）原始-SQL-示例（MySQL）"><a href="#（1）原始-SQL-示例（MySQL）" class="headerlink" title="（1）原始 SQL 示例（MySQL）"></a>（1）原始 SQL 示例（MySQL）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM user WHERE age &gt; 18</span><br></pre></td></tr></table></figure><h5 id="（2）分页-SQL-改写（添加-LIMIT）"><a href="#（2）分页-SQL-改写（添加-LIMIT）" class="headerlink" title="（2）分页 SQL 改写（添加 LIMIT）"></a>（2）分页 SQL 改写（添加 LIMIT）</h5><p>MP 通过<code>BoundSql</code>解析原始 SQL，拼接分页语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM user WHERE age &gt; 18 LIMIT 0, 10  -- 第1页，每页10条</span><br></pre></td></tr></table></figure><p><strong>关键逻辑</strong>：在<code>prepare</code>方法中，通过<code>Dialect.buildPaginationSql</code>生成适配 SQL，不同数据库的方言实现不同：</p><ul><li><p>MySQL：<code>LIMIT offset, size</code></p></li><li><p>Oracle：<code>SELECT * FROM (SELECT t.*, ROWNUM rn FROM (...) t WHERE ROWNUM  ?) WHERE rn &gt; ?</code></p></li><li><p>PostgreSQL：<code>OFFSET ? LIMIT ?</code></p></li></ul><h5 id="（3）总条数-SQL-自动生成"><a href="#（3）总条数-SQL-自动生成" class="headerlink" title="（3）总条数 SQL 自动生成"></a>（3）总条数 SQL 自动生成</h5><p>MP 会自动剥离原始 SQL 的<code>SELECT</code>字段和<code>ORDER BY</code>（避免 count 统计错误），生成 count 查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(1) FROM user WHERE age &gt; 18</span><br></pre></td></tr></table></figure><p><strong>优化点</strong>：</p><ul><li><p>若原始 SQL 含<code>GROUP BY</code>，count 会改为<code>COUNT(DISTINCT 分组字段)</code>；</p></li><li><p>可通过<code>page.setSearchCount(false)</code>关闭总条数统计（适用于无需总页数的场景）。</p></li></ul><h4 id="3-分页参数传递与结果封装"><a href="#3-分页参数传递与结果封装" class="headerlink" title="3. 分页参数传递与结果封装"></a>3. 分页参数传递与结果封装</h4><ul><li><p><strong>参数传递</strong>：<code>Page</code>对象中的<code>current</code>（当前页）和<code>size</code>（每页条数）会被转换为<code>offset = (current - 1) * size</code>，作为分页参数注入改写后的 SQL；</p></li><li><p><strong>结果封装</strong>：执行分页 SQL 后，查询结果会被设置到<code>page.getRecords()</code>；执行 countSQL 后，总条数会设置到<code>page.setTotal(total)</code>，并自动计算<code>pages = (total + size - 1) / size</code>（总页数）。</p></li></ul><h3 id="四、物理分页-vs-逻辑分页：MP-为何选择物理分页？"><a href="#四、物理分页-vs-逻辑分页：MP-为何选择物理分页？" class="headerlink" title="四、物理分页 vs 逻辑分页：MP 为何选择物理分页？"></a>四、物理分页 vs 逻辑分页：MP 为何选择物理分页？</h3><p>很多人会疑惑：MP 为何采用 “物理分页”（依赖数据库 SQL 语法）而非 “逻辑分页”（查询全量数据后内存截取）？</p><div class="table-container"><table><thead><tr><th>对比维度</th><th>物理分页（MP 实现）</th><th>逻辑分页（内存截取）</th></tr></thead><tbody><tr><td>性能</td><td>只查询当前页数据，数据库压力小</td><td>查询全量数据，大数据量下内存溢出</td></tr><tr><td>适用场景</td><td>大数据量、跨库兼容</td><td>小数据量、本地测试</td></tr><tr><td>依赖</td><td>数据库方言支持</td><td>无依赖，纯 Java 逻辑</td></tr></tbody></table></div><p>MP 选择物理分页的核心原因是<strong>性能优化</strong>—— 对于百万级数据，逻辑分页会导致全表扫描，而物理分页通过数据库的索引优化，仅返回当前页数据，大幅降低 IO 开销。</p><h3 id="五、源码关键片段解析（MP-3-5-3-版本）"><a href="#五、源码关键片段解析（MP-3-5-3-版本）" class="headerlink" title="五、源码关键片段解析（MP 3.5.3 版本）"></a>五、源码关键片段解析（MP 3.5.3 版本）</h3><h4 id="1-分页-SQL-改写核心代码"><a href="#1-分页-SQL-改写核心代码" class="headerlink" title="1. 分页 SQL 改写核心代码"></a>1. 分页 SQL 改写核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaginationInnerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrepare</span><span class="params">(StatementHandler sh, Connection conn, Integer transactionTimeout)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 获取原始BoundSql（封装SQL和参数）</span></span><br><span class="line"></span><br><span class="line">   <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> sh.getBoundSql();</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 判断是否需要分页（是否包含Page参数）</span></span><br><span class="line"></span><br><span class="line">   <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> getPage(sh);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; page.isNeedPagination()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 获取数据库方言（根据Connection自动识别）</span></span><br><span class="line"></span><br><span class="line">       <span class="type">Dialect</span> <span class="variable">dialect</span> <span class="operator">=</span> getDialect(conn);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 改写分页SQL</span></span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">paginationSql</span> <span class="operator">=</span> dialect.buildPaginationSql(sql, page.getOffset(), page.getSize());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 替换原始SQL</span></span><br><span class="line"></span><br><span class="line">      ReflectUtil.setFieldValue(boundSql, <span class="string">&quot;sql&quot;</span>, paginationSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-总条数统计核心代码"><a href="#2-总条数统计核心代码" class="headerlink" title="2. 总条数统计核心代码"></a>2. 总条数统计核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaginationInnerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(Connection conn, String sql, List Class</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   // <span class="number">1.</span> 生成count SQL</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   String countSql = DialectBuilder.buildCountSql(sql)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 执行count查询</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> SqlHelper.executeQuery(conn, countSql, paramList, rs -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> rs.getLong(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、常见问题与底层原理关联分析"><a href="#六、常见问题与底层原理关联分析" class="headerlink" title="六、常见问题与底层原理关联分析"></a>六、常见问题与底层原理关联分析</h3><h4 id="1-分页失效？——-拦截器未注册"><a href="#1-分页失效？——-拦截器未注册" class="headerlink" title="1. 分页失效？—— 拦截器未注册"></a>1. 分页失效？—— 拦截器未注册</h4><p>若分页 SQL 未添加 LIMIT，大概率是分页插件未注入 Spring 容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确配置（Spring Boot）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 添加分页拦截器，并指定数据库类型</span></span><br><span class="line"></span><br><span class="line">       interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：未注册拦截器时，SQL 不会被改写，自然无法实现分页。</p><h4 id="2-总条数统计错误？——-SQL-解析异常"><a href="#2-总条数统计错误？——-SQL-解析异常" class="headerlink" title="2. 总条数统计错误？—— SQL 解析异常"></a>2. 总条数统计错误？—— SQL 解析异常</h4><p>若 count 结果与实际不符，可能是原始 SQL 含复杂语法（如<code>UNION</code>、<code>子查询</code>），导致 MP 的 SQL 解析失败。此时可手动指定 countSQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.setCountSql(&quot;SELECT COUNT(1) FROM (原始复杂SQL) t&quot;);</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：MP 的自动 countSQL 生成依赖 SQL 解析器，复杂语法可能导致解析偏差，手动指定可绕过解析逻辑。</p><h4 id="3-跨库分页兼容问题？——-方言未适配"><a href="#3-跨库分页兼容问题？——-方言未适配" class="headerlink" title="3. 跨库分页兼容问题？—— 方言未适配"></a>3. 跨库分页兼容问题？—— 方言未适配</h4><p>切换数据库后分页失效，需确保<code>DbType</code>与实际数据库一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 适配PostgreSQL</span><br><span class="line"></span><br><span class="line">interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.POSTGRE\_SQL));</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：不同数据库的分页语法差异，方言是连接 SQL 改写与数据库的桥梁。</p><h3 id="七、总结与思考"><a href="#七、总结与思考" class="headerlink" title="七、总结与思考"></a>七、总结与思考</h3><p>MyBatis-Plus 的分页功能之所以强大，核心在于 **“无侵入式设计” 和 “数据库方言适配”**：</p><ol><li><p>基于 MyBatis 拦截器机制，无需修改业务 SQL，实现分页逻辑与业务逻辑解耦；</p></li><li><p>通过方言接口封装不同数据库的分页语法，解决跨库兼容问题；</p></li><li><p>自动生成 countSQL，减少重复编码，同时支持灵活配置（关闭统计、手动指定 countSQL）。</p></li></ol><p>从底层原理来看，MP 的分页插件本质是 “SQL 解析与改写的自动化工具”，其设计思路值得借鉴：<strong>将通用逻辑（分页）抽离为插件，通过拦截器嵌入框架流程，既不破坏原有架构，又能提升开发效率</strong>。</p><p>在实际开发中，需注意：</p><ul><li><p>复杂 SQL 场景下，建议手动验证分页 SQL 和 countSQL 的正确性；</p></li><li><p>大数据量分页（如千万级数据），可结合<code>PageHelper</code>的 “合理化分页” 或 MP 的<code>page.setReasonable(true)</code>避免页码越界；</p></li><li><p>无需总条数时，关闭<code>searchCount</code>可提升查询性能。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis-Plus分页查询底层原理&quot;&gt;&lt;a href=&quot;#MyBatis-Plus分页查询底层原理&quot; class=&quot;headerlink&quot; title=&quot;MyBatis-Plus分页查询底层原理&quot;&gt;&lt;/a&gt;MyBatis-Plus分页查询底层原理&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="MyBatis-Plus" scheme="https://nmcb666.vip/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>bitMap实现签到功能</title>
    <link href="https://nmcb666.vip/posts/61e739c3.html"/>
    <id>https://nmcb666.vip/posts/61e739c3.html</id>
    <published>2025-12-07T17:44:51.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，用户签到是一个非常常见的功能需求，比如APP的每日签到领积分、连续签到奖励等。面对海量用户的签到数据，如果使用传统的关系型数据库存储，不仅会占用大量的存储空间，而且在统计签到情况时效率也会比较低下。那么，有没有更高效、更节省空间的方案呢？答案是肯定的，那就是利用Redis中的Bitmap（位图）来实现用户签到功能。本文就来详细探讨一下如何使用Redis Bitmap结合Java实现用户签到，并分析其优势和注意事项。</p><h2 id="一、为什么选择Redis-Bitmap实现用户签到？"><a href="#一、为什么选择Redis-Bitmap实现用户签到？" class="headerlink" title="一、为什么选择Redis Bitmap实现用户签到？"></a>一、为什么选择Redis Bitmap实现用户签到？</h2><p>在介绍具体实现之前，我们先来思考一下为什么Redis Bitmap适合用来实现用户签到。首先，我们来回顾一下Bitmap的基本概念：Bitmap是一种基于位的数据结构，它使用一个位（bit）来表示一个元素的状态，0表示不存在或未发生，1表示存在或已发生。在用户签到场景中，我们可以用一个位来表示用户某一天是否签到，这样就能够极大地节省存储空间。</p><p>假设我们有1000万用户，每个用户每年签到数据需要365个 bit 来存储，那么一年的签到数据总存储空间为：1000万 <em> 365 bit = 10000000 </em> 365 / 8 / 1024 / 1024 ≈ 430MB。如果使用传统的数据库表，每个签到记录至少需要存储用户ID、签到日期等字段，假设每条记录占用20字节，那么1000万用户一年的签到数据存储空间为：1000万 <em> 365 </em> 20 byte = 10000000 <em> 365 </em> 20 / 1024 / 1024 / 1024 ≈ 6.8GB。通过对比可以明显看出，Bitmap在存储空间上具有巨大的优势。</p><p>除此之外，Redis Bitmap还提供了丰富的位操作命令，比如<code>SETBIT</code>（设置某一位的值）、<code>GETBIT</code>（获取某一位的值）、<code>BITCOUNT</code>（统计值为1的位的个数）、<code>BITOP</code>（位运算）等，这些命令能够高效地满足签到功能中的签到标记、签到查询、连续签到统计等需求，操作效率非常高。</p><h2 id="二、Redis-Bitmap实现用户签到的具体方案"><a href="#二、Redis-Bitmap实现用户签到的具体方案" class="headerlink" title="二、Redis Bitmap实现用户签到的具体方案"></a>二、Redis Bitmap实现用户签到的具体方案</h2><h3 id="2-1-键的设计"><a href="#2-1-键的设计" class="headerlink" title="2.1 键的设计"></a>2.1 键的设计</h3><p>要使用Bitmap实现用户签到，首先需要设计合理的键名。为了方便区分不同用户、不同年份和月份的签到数据，我们可以采用这样的键名格式：<code>user:checkin:uid:year:month</code>。其中，<code>uid</code>是用户的唯一标识，<code>year</code>是年份，<code>month</code>是月份。这样设计的好处是，每个用户每个月的签到数据都存储在一个独立的Bitmap中，既方便管理，又能避免单个Bitmap过大导致的性能问题。</p><h3 id="2-2-签到标记（SETBIT命令）"><a href="#2-2-签到标记（SETBIT命令）" class="headerlink" title="2.2 签到标记（SETBIT命令）"></a>2.2 签到标记（SETBIT命令）</h3><p>当用户进行签到操作时，我们需要将对应日期的位设置为1。具体步骤如下：</p><ol><li><p>获取当前日期，并计算出该日期在当月是第几天（假设为day，取值范围1-31）。</p></li><li><p>由于Bitmap的位是从0开始计数的，所以需要将day减1得到对应的位索引（index = day - 1）。</p></li><li><p>使用Redis的<code>SETBIT</code>命令，将键<code>user:checkin:uid:year:month</code>对应index位置的位设置为1。</p></li></ol><p><code>SETBIT</code>命令的语法为：<code>SETBIT key offset value</code>，其中offset是位索引，value是要设置的值（0或1）。该命令的返回值是该位在设置前的值。</p><h3 id="2-3-签到查询（GETBIT命令）"><a href="#2-3-签到查询（GETBIT命令）" class="headerlink" title="2.3 签到查询（GETBIT命令）"></a>2.3 签到查询（GETBIT命令）</h3><p>当需要查询用户某一天是否签到时，可以使用<code>GETBIT</code>命令。具体步骤如下：</p><ol><li><p>获取要查询的日期，并计算出该日期在当月是第几天（day）。</p></li><li><p>计算位索引index = day - 1。</p></li><li><p>使用<code>GETBIT</code>命令，获取键<code>user:checkin:uid:year:month</code>对应index位置的位值。如果返回1，表示用户当天已签到；如果返回0，表示用户当天未签到。</p></li></ol><p><code>GETBIT</code>命令的语法为：<code>GETBIT key offset</code>。</p><h3 id="2-4-签到统计（BITCOUNT命令）"><a href="#2-4-签到统计（BITCOUNT命令）" class="headerlink" title="2.4 签到统计（BITCOUNT命令）"></a>2.4 签到统计（BITCOUNT命令）</h3><p>在签到功能中，经常需要统计用户在某个时间段内的签到天数，比如当月签到天数、近7天签到天数等。这时候可以使用<code>BITCOUNT</code>命令，该命令用于统计Bitmap中值为1的位的个数。</p><p><code>BITCOUNT</code>命令的语法为：<code>BITCOUNT key [start end]</code>，其中start和end是字节的索引（注意不是位的索引），用于指定统计的范围。如果不指定start和end，则统计整个Bitmap。</p><p>例如，要统计用户当月的签到天数，直接使用<code>BITCOUNT user:checkin:uid:year:month</code>即可。如果要统计用户近7天的签到天数，需要先确定这7天对应的位索引范围，然后将位索引转换为字节索引（字节索引 = 位索引 / 8），再使用<code>BITCOUNT</code>命令进行统计。</p><h3 id="2-5-连续签到统计"><a href="#2-5-连续签到统计" class="headerlink" title="2.5 连续签到统计"></a>2.5 连续签到统计</h3><p>连续签到统计是签到功能中的一个难点，比如统计用户当前的连续签到天数。实现思路如下：</p><ol><li><p>从当前日期开始，依次向前查询每天的签到状态（使用<code>GETBIT</code>命令）。</p></li><li><p>如果查询到某一天未签到，则停止查询，连续签到天数为已查询到的签到天数。</p></li><li><p>如果查询到本月第一天都已签到，则继续查询上一个月的签到数据，直到查询到未签到的日期为止。</p></li></ol><p>在实现过程中，需要注意跨月份的情况，需要分别处理不同月份的Bitmap。</p><h2 id="三、Java代码实现"><a href="#三、Java代码实现" class="headerlink" title="三、Java代码实现"></a>三、Java代码实现</h2><p>接下来，我们通过Java代码来具体实现Redis Bitmap用户签到功能。首先，我们需要引入Redis的Java客户端依赖，这里以Jedis为例。</p><h3 id="3-1-依赖引入（Maven）"><a href="#3-1-依赖引入（Maven）" class="headerlink" title="3.1 依赖引入（Maven）"></a>3.1 依赖引入（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-签到工具类实现"><a href="#3-2-签到工具类实现" class="headerlink" title="3.2 签到工具类实现"></a>3.2 签到工具类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckinUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;user:checkin:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">YEAR_MONTH_FORMATTER</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckinUtil</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户签到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 签到日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签到前的状态（0：未签到，1：已签到）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">checkin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> dayOfMonth - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.setbit(key, offset, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户某一天是否签到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 查询日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：已签到，false：未签到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isCheckin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> dayOfMonth - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.getbit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计用户当月签到天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当月任意一天</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签到天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">countMonthCheckin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="keyword">return</span> jedis.bitcount(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计用户当前连续签到天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连续签到天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countContinuousCheckin</span><span class="params">(Long uid)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">currentDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">continuousDays</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">tempDate</span> <span class="operator">=</span> currentDate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">isCheckin</span> <span class="operator">=</span> isCheckin(uid, tempDate);</span><br><span class="line">            <span class="keyword">if</span> (isCheckin) &#123;</span><br><span class="line">                continuousDays++;</span><br><span class="line">                tempDate = tempDate.minusDays(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 避免无限循环，当查询到一年前仍未断签时，停止查询</span></span><br><span class="line">                <span class="keyword">if</span> (tempDate.isBefore(currentDate.minusYears(<span class="number">1</span>))) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> continuousDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取签到Redis键名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getCheckinKey</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">yearMonth</span> <span class="operator">=</span> date.format(YEAR_MONTH_FORMATTER);</span><br><span class="line">        <span class="keyword">return</span> REDIS_KEY_PREFIX + uid + <span class="string">&quot;:&quot;</span> + yearMonth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul><li><p><strong>Bitmap的大小限制</strong>：Redis中单个BitMap的偏移量最大为 2^32-1。在设计键名时，按用户每月拆分Bitmap，可以有效控制单个Bitmap的大小，避免因Bitmap过大导致报错。</p></li><li><p><strong>日期处理的准确性</strong>：在计算位索引时，一定要注意日期的准确性，特别是跨月份和闰年的情况。使用Java 8的<code>LocalDate</code>类可以方便、准确地处理日期相关操作。</p></li><li><p><strong>Redis连接管理</strong>：在实际项目中，不能每次操作都创建新的Jedis连接，应该使用连接池来管理Redis连接，以提高性能和避免资源泄露。（这个无需担心，实际开发大多采用spring-data-redis进行操作 会自行管理）</p></li><li><p><strong>数据持久化</strong>：Redis支持RDB和AOF两种持久化方式，为了防止签到数据丢失，需要合理配置Redis的持久化策略。</p></li><li><p><strong>过期策略</strong>：对于一些过期的签到数据（比如几年前的签到数据），如果业务上不再需要，可以设置键的过期时间，让Redis自动清理这些数据，节省存储空间。</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>使用Redis Bitmap实现用户签到功能，具有存储空间小、操作效率高、命令丰富等优点，非常适合处理海量用户的签到数据。通过合理的键名设计和Java代码实现，我们可以轻松地完成签到标记、签到查询、签到统计等功能。同时，在实际应用中，还需要注意Bitmap的大小限制、日期处理、Redis连接管理等问题，以确保系统的稳定性和性能。</p><p>总的来说，Redis Bitmap是实现用户签到功能的一种优秀方案，值得在项目中推广和应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发中，用户签到是一个非常常见的功能需求，比如APP的每日签到领积分、连续签到奖励等。面对海量用户的签到数据，如果使用传统的关系型数据库存储，不仅会占用大量的存储空间，而且在统计签到情况时效率也会比较低下。那么，有没有更高效、更节省空间的方案呢？答案是肯定的，那就是利</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>利用Redis Sorted Set实现Java滚动分页查询</title>
    <link href="https://nmcb666.vip/posts/7be5306f.html"/>
    <id>https://nmcb666.vip/posts/7be5306f.html</id>
    <published>2025-12-06T19:13:16.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，分页查询是一个非常常见的需求。传统的基于数据库的Limit Offset分页方式虽然简单，但在数据量较大或数据实时变动（如插入新数据）的场景下，会出现<strong>重复数据</strong>或<strong>数据遗漏</strong>的问题。本文将探讨如何利用Redis的Sorted Set（有序集合）数据结构来实现高效、准确的滚动分页查询，并结合具体Java代码进行详细解析。</p><h2 id="一、传统分页的痛点：为什么需要滚动分页？"><a href="#一、传统分页的痛点：为什么需要滚动分页？" class="headerlink" title="一、传统分页的痛点：为什么需要滚动分页？"></a>一、传统分页的痛点：为什么需要滚动分页？</h2><p>我们先回顾一下传统的Limit Offset分页。假设我们有一张博客表，要查询第2页数据（每页2条），SQL通常是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> blog <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> LIMIT <span class="number">2</span> <span class="keyword">OFFSET</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这种方式的问题在于：如果在查询第1页后、第2页前，有一条新的博客插入（create_time比第1页的部分数据更新），那么第2页的结果就会包含原本第1页的最后一条数据，导致重复查询。如下图所示：</p><ul><li><p>初始数据：[A(时间10), B(时间9), C(时间8), D(时间7)]</p></li><li><p>第1页（LIMIT 2 OFFSET 0）：[A, B]</p></li><li><p>插入新数据E(时间11)，数据变为：[E(11), A(10), B(9), C(8), D(7)]</p></li><li><p>第2页（LIMIT 2 OFFSET 2）：[B, C] → B重复出现</p></li></ul><p>滚动分页（也叫游标分页）则通过<strong>上一页的最后一个标记（如时间戳）</strong>来定位下一页的起始位置，避免了Offset带来的问题。而Redis的Sorted Set恰好能完美支持这种场景。</p><h2 id="二、Redis-Sorted-Set的特性：为什么适合滚动分页？"><a href="#二、Redis-Sorted-Set的特性：为什么适合滚动分页？" class="headerlink" title="二、Redis Sorted Set的特性：为什么适合滚动分页？"></a>二、Redis Sorted Set的特性：为什么适合滚动分页？</h2><p>Redis的Sorted Set（有序集合）是一种特殊的数据结构，它为每个元素分配一个<strong>分数（Score）</strong>，并按照分数对元素进行排序。其核心特性包括：</p><ol><li><p><strong>有序性</strong>：元素天然按照Score升序或降序排列，无需额外排序操作。</p></li><li><p><strong>范围查询</strong>：支持通过Score范围（如0到maxScore）查询元素，这是实现滚动分页的关键。</p></li><li><p><strong>高效性</strong>：无论是插入、查询还是删除操作，时间复杂度均为O(logN)，适合大数据量场景。</p></li></ol><p>在滚动分页场景中，我们可以将<strong>业务数据的唯一标识（如博客ID）</strong>作为Sorted Set的元素（Value），将<strong>排序字段（如创建时间戳）</strong>作为元素的分数（Score）。这样，通过Score范围就能快速定位下一页数据。</p><h2 id="三、滚动分页的实现思路与代码解析"><a href="#三、滚动分页的实现思路与代码解析" class="headerlink" title="三、滚动分页的实现思路与代码解析"></a>三、滚动分页的实现思路与代码解析</h2><p>下面结合提供的Java代码，详细拆解利用Redis Sorted Set实现滚动分页的完整流程。本文以“查询关注的博客动态”为例进行说明。</p><h3 id="3-1-核心流程概览"><a href="#3-1-核心流程概览" class="headerlink" title="3.1 核心流程概览"></a>3.1 核心流程概览</h3><p>滚动分页的核心是通过“上一页的最小时间戳（minTime）”和“偏移量（offset）”来定位下一页数据，具体流程如下：</p><ol><li><p>定义Redis的Sorted Set键：以用户ID为维度，存储该用户关注的博客ID集合（如<code>feed:1001</code>表示用户1001的关注动态）。</p></li><li><p>查询上一页数据：通过<code>reverseRangeByScoreWithScores</code>方法，查询Score在0到max（上一页的minTime）之间的元素，同时指定偏移量和每页数量。</p></li><li><p>处理查询结果：提取博客ID、计算当前页的最小时间戳和偏移量，用于下一页查询。</p></li><li><p>封装并返回结果：将博客详情、minTime、offset返回给前端，作为下一页请求的参数。</p></li></ol><h3 id="3-2-代码逐行解析"><a href="#3-2-代码逐行解析" class="headerlink" title="3.2 代码逐行解析"></a>3.2 代码逐行解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;feed:&quot;</span> + userId; <span class="comment">// Redis键：feed:用户ID</span></span><br><span class="line">    <span class="comment">// 2. 从Redis查询blogId列表</span></span><br><span class="line">    <span class="comment">// reverseRangeByScoreWithScores：倒序查询Score在[0, max]之间的元素</span></span><br><span class="line">    <span class="comment">// 参数说明：key, 最小Score, 最大Score, 偏移量, 每页数量</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; result = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3. 处理空结果</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;无新数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 提取博客ID、计算当前页的minTime和offset</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 初始化为当前时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 初始偏移量为1</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result.size());</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : result) &#123;</span><br><span class="line">        <span class="comment">// 提取博客ID</span></span><br><span class="line">        ids.add(Long.valueOf(Objects.requireNonNull(tuple.getValue())));</span><br><span class="line">        <span class="comment">// 提取Score（即博客创建时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> Objects.requireNonNull(tuple.getScore()).longValue();</span><br><span class="line">        <span class="comment">// 处理相同时间戳的情况：若时间等于当前minTime，偏移量+1；否则更新minTime和偏移量</span></span><br><span class="line">        <span class="keyword">if</span>(time == minTime) &#123;</span><br><span class="line">            offset1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            offset1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 查询博客详情（批量查询避免N+1问题，此处为简化示例）</span></span><br><span class="line">    List&lt;Blog&gt; blogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ids.size());</span><br><span class="line">    ids.forEach(id -&gt; &#123;</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id); <span class="comment">// 从数据库查询博客详情</span></span><br><span class="line">        setBlogIsLiked(blog); <span class="comment">// 处理博客点赞状态</span></span><br><span class="line">        queryUser(blog); <span class="comment">// 填充博客作者信息</span></span><br><span class="line">        blogs.add(blog);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 6. 封装滚动分页结果</span></span><br><span class="line">    ScrollResult&lt;Blog&gt; scrollResult = <span class="keyword">new</span> <span class="title class_">ScrollResult</span>&lt;&gt;();</span><br><span class="line">    scrollResult.setList(blogs); <span class="comment">// 当前页博客列表</span></span><br><span class="line">    scrollResult.setMinTime(minTime); <span class="comment">// 当前页最小时间戳（下一页的max参数）</span></span><br><span class="line">    scrollResult.setOffset(offset1); <span class="comment">// 当前页最小时间戳对应的偏移量</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-关键细节说明"><a href="#3-3-关键细节说明" class="headerlink" title="3.3 关键细节说明"></a>3.3 关键细节说明</h3><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**为什么用reverseRangeByScoreWithScores？**因为我们通常需要按时间倒序展示数据（最新的在前），该方法会按照Score从大到小返回元素，正好符合需求。</p></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**max和offset参数的作用？**- `max`：上一页返回的minTime，代表下一页数据的Score不能超过这个值（即时间不能晚于这个值）。- `offset`：当存在多个Score相同的元素时，用于跳过前N个元素，避免重复。</p></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**如何处理相同时间戳的数据？**如果多条博客的创建时间戳相同（Score相同），下一页查询时需要通过offset跳过这些重复的元素。例如，当前页有3条数据的Score都是1620000000，那么minTime=1620000000，offset=3，下一页查询时会从第4个Score=1620000000的元素开始。</p></div><h2 id="四、滚动分页的优势与注意事项"><a href="#四、滚动分页的优势与注意事项" class="headerlink" title="四、滚动分页的优势与注意事项"></a>四、滚动分页的优势与注意事项</h2><h3 id="4-1-优势"><a href="#4-1-优势" class="headerlink" title="4.1 优势"></a>4.1 优势</h3><ul><li><p><strong>无重复无遗漏</strong>：基于时间戳定位，即使中间插入新数据，也不会影响下一页的查询结果。</p></li><li><p><strong>高性能</strong>：Redis的Sorted Set查询效率高，尤其适合大数据量场景，避免了数据库Limit Offset的全表扫描问题。</p></li><li><p><strong>实时性好</strong>：数据插入Redis后可立即查询，无需等待数据库同步。</p></li></ul><h3 id="4-2-注意事项"><a href="#4-2-注意事项" class="headerlink" title="4.2 注意事项"></a>4.2 注意事项</h3><ul><li><p><strong>Score的唯一性问题</strong>：如果排序字段（如时间戳）存在大量重复，需要通过offset来处理，否则可能出现数据漏查。</p></li><li><p><strong>Redis数据一致性</strong>：需要保证业务数据（如博客）与Redis中的Sorted Set同步。例如，博客删除时，要及时从Redis中移除对应的元素。</p></li><li><p><strong>分页参数的传递</strong>：前端需要将上一页返回的minTime和offset作为下一页请求的参数，因此需要在接口设计中明确这两个参数。</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>相比传统的Limit Offset分页，基于Redis Sorted Set的滚动分页在实时性、准确性和高性能方面都有明显优势，尤其适合动态数据（如关注动态、消息流）的分页场景。其核心是利用Sorted Set的Score有序性和范围查询能力，通过“上一页的最小时间戳+偏移量”来定位下一页数据，从根本上解决了传统分页的重复和遗漏问题。</p><p>在实际开发中，我们还可以根据业务需求优化细节，例如结合Redis的过期策略清理历史数据、使用管道（Pipeline）减少Redis交互次数等，进一步提升系统性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发中，分页查询是一个非常常见的需求。传统的基于数据库的Limit Offset分页方式虽然简单，但在数据量较大或数据实时变动（如插入新数据）的场景下，会出现&lt;strong&gt;重复数据&lt;/strong&gt;或&lt;strong&gt;数据遗漏&lt;/strong&gt;的问题。本文将探讨如何利</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Stream多消费者组模式：原理、ACK机制与在Java中的实践</title>
    <link href="https://nmcb666.vip/posts/da8941bc.html"/>
    <id>https://nmcb666.vip/posts/da8941bc.html</id>
    <published>2025-12-03T18:42:18.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-Stream多消费者组模式：原理、ACK机制与Java实践"><a href="#Redis-Stream多消费者组模式：原理、ACK机制与Java实践" class="headerlink" title="Redis Stream多消费者组模式：原理、ACK机制与Java实践"></a>Redis Stream多消费者组模式：原理、ACK机制与Java实践</h1><p>在分布式系统中，消息队列是解耦服务、削峰填谷的核心组件。Redis作为高性能的内存数据库，从5.0版本开始引入Stream数据结构，原生支持消息队列功能。相较于Redis以往的Pub/Sub（无持久化）、List（简单队列），Stream提供了<strong>持久化、多消费者组、ACK确认、消息回溯</strong>等企业级特性，尤其在多消费者组场景下，能灵活实现消息的分发与处理。本文将深入剖析Stream多消费者组的实现原理，重点解读ACK确认机制与Pending List的作用，并结合Java代码演示实际运用场景。</p><h1 id="一、Redis-Stream核心概念与多消费者组模型"><a href="#一、Redis-Stream核心概念与多消费者组模型" class="headerlink" title="一、Redis Stream核心概念与多消费者组模型"></a>一、Redis Stream核心概念与多消费者组模型</h1><p>在理解多消费者组之前，我们先明确Stream的几个基础概念：</p><ul><li><p><strong>Stream</strong>：消息的载体，类似日志文件的结构，每条消息有唯一的ID（格式为“时间戳-序列号”，如1690000000000-0），消息内容以键值对存储。</p></li><li><p><strong>消费者组（Consumer Group）</strong>：一组消费者的集合，同一个Stream可以创建多个消费者组。<strong>不同消费者组之间是独立的</strong>，即同一条消息会被每个消费者组消费一次；而同一个消费者组内的消费者则竞争消费消息，确保一条消息只被组内一个消费者处理。</p></li><li><p><strong>消费者（Consumer）</strong>：隶属于某个消费者组，实际处理消息的个体。</p></li><li><p><strong>Pending List（PENDING列表）</strong>：消费者从组内获取消息后，若未发送ACK确认，消息会被放入该消费者的Pending List中，标记为“已读取但未确认”。</p></li></ul><p>多消费者组的核心模型如下图所示（概念示意）：</p><blockquote><p>Stream（消息队列） → 消费者组A（Consumer1、Consumer2） → 各自Pending List</p><pre><code>  └→ 消费者组B（Consumer3、Consumer4） → 各自Pending List</code></pre></blockquote><p>例如，一个订单Stream可以创建“支付组”和“物流组”，支付组处理订单支付状态，物流组处理订单发货，两者独立消费同一条订单消息，互不干扰。</p><h1 id="二、关键机制：ACK确认与Pending-List深度解析"><a href="#二、关键机制：ACK确认与Pending-List深度解析" class="headerlink" title="二、关键机制：ACK确认与Pending List深度解析"></a>二、关键机制：ACK确认与Pending List深度解析</h1><p>Stream的可靠性依赖于<strong>ACK确认机制</strong>，而Pending List则是ACK机制的核心载体。这两者共同确保消息“至少被消费一次”（At-Least-Once），避免消息丢失。</p><h2 id="2-1-ACK确认机制流程"><a href="#2-1-ACK确认机制流程" class="headerlink" title="2.1 ACK确认机制流程"></a>2.1 ACK确认机制流程</h2><p>当消费者从组内获取消息后，消息并不会立即从Stream中删除，而是需要消费者处理完成后主动发送ACK命令（<code>XACK</code>），Redis才会将消息从该消费者的Pending List中移除，标记为“已处理”。具体流程如下：</p><ol><li><p>消费者通过<code>XREADGROUP</code>命令从组内读取消息（如<code>XREADGROUP GROUP group1 consumer1 COUNT 1 STREAMS stream1 &gt;</code>，其中“&gt;”表示读取组内未被消费过的消息）。</p></li><li><p>Redis将消息标记为“已分配给consumer1”，并加入consumer1的Pending List。</p></li><li><p>消费者处理消息（如业务逻辑计算、数据库写入等）。</p></li><li><p>处理成功后，消费者发送<code>XACK stream1 group1 msgId</code>命令确认消息。</p></li><li><p>Redis收到ACK后，从consumer1的Pending List中删除该消息。</p></li></ol><h2 id="2-2-Pending-List的作用与核心操作"><a href="#2-2-Pending-List的作用与核心操作" class="headerlink" title="2.2 Pending List的作用与核心操作"></a>2.2 Pending List的作用与核心操作</h2><p>Pending List（简称PENDING）是每个消费者组内消费者独有的“未确认消息列表”，它解决了“消息已读取但处理失败”的问题。当消费者处理消息异常（如服务宕机、业务报错）时，消息会一直留在Pending List中，直到被重新处理并ACK。</p><div class="tip warning faa-horizontal animated-hover"><p><strong>核心特性</strong>：Pending List中的消息会记录三个关键信息——消息ID、消费者ID、未确认时长（idle time），方便后续进行消息重试或死信处理。</p></div><p>操作Pending List的常用命令：</p><ul><li><p><code>XPENDING</code>：查看消费者组或消费者的Pending消息统计，如<code>XPENDING stream1 group1</code>可查看group1的Pending总数、最小/最大idle time等。</p></li><li><p><code>XPENDING stream1 group1 - + 10 consumer1</code>：查看consumer1的前10条Pending消息（“-”表示最小ID，“+”表示最大ID）。</p></li><li><p><code>XCLAIM</code>：将Pending List中的消息“认领”给其他消费者处理，适用于消费者宕机后的消息转移，如<code>XCLAIM stream1 group1 consumer2 60000 1690000000000-0</code>（60000表示idle time超过60秒的消息）。</p></li></ul><h1 id="三、Java中的实践：从队列消费与Pending-List重试"><a href="#三、Java中的实践：从队列消费与Pending-List重试" class="headerlink" title="三、Java中的实践：从队列消费与Pending List重试"></a>三、Java中的实践：从队列消费与Pending List重试</h1><p>下面我们通过Java代码演示Stream的核心用法：<strong>先消费Stream中的新消息，若处理异常则将消息留在Pending List，下次消费前先处理Pending List中的消息</strong>。我们使用Spring Data Redis作为客户端（需引入依赖：<code>spring-boot-starter-data-redis</code>）。</p><h2 id="3-1-初始化Stream与消费者组"><a href="#3-1-初始化Stream与消费者组" class="headerlink" title="3.1 初始化Stream与消费者组"></a>3.1 初始化Stream与消费者组</h2><p>首先需要创建Stream并初始化消费者组（可在项目启动时执行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.Consumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ObjectRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ReadOffset;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.StreamInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_stream&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;order_group&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamInitializer</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initStreamAndGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.execute((RedisConnection connection) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 检查Stream是否存在，不存在则创建（可选，XADD会自动创建）</span></span><br><span class="line">            StreamInfo.<span class="type">XInfoStream</span> <span class="variable">info</span> <span class="operator">=</span> connection.streamCommands().xInfoStream(STREAM_KEY.getBytes());</span><br><span class="line">            <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Stream不存在，创建Stream：&quot;</span> + STREAM_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查消费者组是否存在，不存在则创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.streamCommands().xInfoGroup(STREAM_KEY.getBytes(), GROUP_NAME.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者组已存在：&quot;</span> + GROUP_NAME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// MKSTREAM选项：若Stream不存在则创建</span></span><br><span class="line">                connection.streamCommands().xGroupCreate(</span><br><span class="line">                        STREAM_KEY.getBytes(),</span><br><span class="line">                        GROUP_NAME.getBytes(),</span><br><span class="line">                        ReadOffset.latest(),</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                );</span><br><span class="line">                System.out.println(<span class="string">&quot;创建消费者组：&quot;</span> + GROUP_NAME);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-消息生产者"><a href="#3-2-消息生产者" class="headerlink" title="3.2 消息生产者"></a>3.2 消息生产者</h2><p>模拟发送订单消息到Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ObjectRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamProducer</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送订单消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOrderMessage</span><span class="params">(OrderMessage message)</span> &#123;</span><br><span class="line">        <span class="comment">// ObjectRecord会自动将对象序列化为Hash（需配置RedisTemplate的序列化方式）</span></span><br><span class="line">        ObjectRecord&lt;String, OrderMessage&gt; record = ObjectRecord.create(STREAM_KEY, message);</span><br><span class="line">        <span class="comment">// XADD命令：添加消息到Stream</span></span><br><span class="line">        redisTemplate.opsForStream().add(record);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单消息实体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderMessage</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String orderId;</span><br><span class="line">        <span class="keyword">private</span> String userId;</span><br><span class="line">        <span class="keyword">private</span> Double amount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getter、setter、toString</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-消息消费者：优先处理Pending-List"><a href="#3-3-消息消费者：优先处理Pending-List" class="headerlink" title="3.3 消息消费者：优先处理Pending List"></a>3.3 消息消费者：优先处理Pending List</h2><p>核心逻辑：消费者启动后，<strong>先处理Pending List中的消息</strong>，处理完后再持续消费Stream中的未被消费的消息；若处理消息异常，不发送ACK，消息留在Pending List下次重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SAVE_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动时执行 持续监听消息队列</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SAVE_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderTask</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从消息队列里面读取消息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order &gt;</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">if</span>(read == <span class="literal">null</span> || read.isEmpty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取消息 并且将消息转化为订单</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = read.getFirst();</span><br><span class="line">                    Map&lt;Object, Object&gt; orderMap = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(orderMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    voucherOrderSaveHandler(voucherOrder);</span><br><span class="line">                    <span class="comment">//确认消息 发送ack</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>);</span><br><span class="line">                    <span class="comment">//遇到异常应先处理pending list中的消息  确保每个消息都被处理一次</span></span><br><span class="line">                    handPendingMessagesList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handPendingMessagesList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从pending队列里面获取待处理的消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">if</span>(read == <span class="literal">null</span> || read.isEmpty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取消息 并且将消息转化为订单</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = read.getFirst();</span><br><span class="line">                Map&lt;Object, Object&gt; orderMap = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(orderMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                voucherOrderSaveHandler(voucherOrder);</span><br><span class="line">                <span class="comment">//确认消息 发送ack</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pending-list订单异常&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结与注意事项"><a href="#四、总结与注意事项" class="headerlink" title="四、总结与注意事项"></a>四、总结与注意事项</h1><p>Redis Stream的多消费者组模式通过ACK机制和Pending List，实现了消息的可靠消费，尤其适合中小型分布式系统的轻量级消息队列场景。但在使用时需注意以下几点：</p><ul><li><p><strong>消息持久化</strong>：Stream消息默认持久化到Redis的RDB/AOF中，需确保Redis的持久化配置合理，避免宕机丢失消息。</p></li><li><p><strong>Pending List积压</strong>：需定期监控Pending List的消息量，若积压过多，需排查消费者是否异常，并通过<code>XCLAIM</code>转移消息或设置死信机制（如超过重试次数后转移到其他Stream）。</p></li><li><p><strong>消费者弹性</strong>：同一个消费者组内可动态增减消费者，实现负载均衡，但需避免消费者ID重复。</p></li><li><p><strong>性能考量</strong>：Redis单线程处理命令，高并发场景下需评估Stream的消息生产速率，避免Redis成为瓶颈（可结合分片或集群扩展）。</p></li></ul><p>总之，Redis Stream以其轻量、高效、可靠的特性，为分布式系统提供了一种灵活的消息队列解决方案，尤其在多消费者组和消息重试场景下，展现了独特的优势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-Stream多消费者组模式：原理、ACK机制与Java实践&quot;&gt;&lt;a href=&quot;#Redis-Stream多消费者组模式：原理、ACK机制与Java实践&quot; class=&quot;headerlink&quot; title=&quot;Redis Stream多消费者组模式：原理</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java中Redisson锁对于可重试的实现</title>
    <link href="https://nmcb666.vip/posts/3a74c7b3.html"/>
    <id>https://nmcb666.vip/posts/3a74c7b3.html</id>
    <published>2025-12-02T08:40:27.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中Redisson锁对于可重试的实现方式"><a href="#Java中Redisson锁对于可重试的实现方式" class="headerlink" title="Java中Redisson锁对于可重试的实现方式"></a>Java中Redisson锁对于可重试的实现方式</h1><p>在分布式系统中，分布式锁是解决并发问题的关键工具，而Redisson作为基于Redis的Java客户端，其提供的分布式锁因其高效、可靠的特性被广泛应用。在实际业务场景中，由于网络抖动、Redis服务短暂不可用等原因，锁的获取可能会出现暂时性失败，此时<strong>可重试机制</strong>就显得尤为重要。本文将深入探讨Redisson锁可重试的实现方式，从核心思路到具体代码，再到注意事项，为大家梳理这一实用特性的来龙去脉。</p><h2 id="一、为什么需要Redisson锁的可重试机制？"><a href="#一、为什么需要Redisson锁的可重试机制？" class="headerlink" title="一、为什么需要Redisson锁的可重试机制？"></a>一、为什么需要Redisson锁的可重试机制？</h2><p>在分布式环境下，获取Redisson锁失败并不总是意味着“锁被占用”，还可能是由以下暂时性因素导致：</p><ul><li><p><strong>网络波动</strong>：客户端与Redis服务器之间的网络连接出现短暂不稳定，导致锁请求超时。</p></li><li><p><strong>Redis服务负载过高</strong>：Redis在高并发场景下处理请求的速度变慢，使得锁获取操作未能在预期时间内完成。</p></li><li><p><strong>锁竞争激烈</strong>：多个客户端同时竞争同一把锁，当前客户端第一次请求时锁正被占用，但短时间内锁就会被释放。</p></li></ul><p>如果此时直接返回失败，可能会导致业务流程中断，影响系统的可用性和用户体验。而可重试机制能够让客户端在一定条件下重复尝试获取锁，从而规避上述暂时性问题，提高锁获取的成功率。</p><h2 id="二、Redisson锁可重试实现的核心思路"><a href="#二、Redisson锁可重试实现的核心思路" class="headerlink" title="二、Redisson锁可重试实现的核心思路"></a>二、Redisson锁可重试实现的核心思路</h2><p>Redisson锁的可重试并非简单循环+固定等待，而是基于<strong>“Redis发布订阅的等待-唤醒机制”</strong>实现，核心是避免无意义的轮询，减少资源消耗。其本质是结合<code>tryLock</code>的阻塞等待逻辑与Redis的消息通知，具体拆解为以下步骤：</p><ol><li><p><strong>初始尝试获取锁</strong>：客户端通过<code>SET NX</code>命令尝试获取锁，若成功则返回锁实例，同时记录锁的租期(如果还需要实现可重入则需要用Hash结构去记录锁的持有者以及锁的数量，这里默认不支持可重入)。</p></li><li><p><strong>失败则订阅锁释放通知</strong>：若锁已被占用，客户端不会立即重试，而是通过Redis的<code>SUBSCRIBE</code>命令订阅该锁的释放通知频道（如<code>redisson_lock__channel:&#123;lockKey&#125;</code>）。</p></li><li><p><strong>阻塞等待通知或超时</strong>：客户端进入阻塞状态，等待两个触发条件之一：① 收到锁释放的<code>PUBLISH</code>通知；② 达到预设的最大等待时间（<code>waitTime</code>）。</p></li><li><p><strong>唤醒后重试或终止</strong>：若收到释放通知，客户端立即唤醒并重新尝试获取锁；若等待超时，则终止重试并返回失败。</p></li></ol><div class="tip warning faa-horizontal animated"><p>关键在于“精准唤醒”而非“盲目重试”：通过Redis的发布订阅机制，只有当锁真正释放时才触发重试，既减少了Redis的请求压力，又能保证重试的及时性。</p></div><h2 id="三、Redisson锁可重试的底层实现与手动封装"><a href="#三、Redisson锁可重试的底层实现与手动封装" class="headerlink" title="三、Redisson锁可重试的底层实现与手动封装"></a>三、Redisson锁可重试的底层实现与手动封装</h2><p>Redisson的原生<code>tryLock(waitTime, leaseTime, TimeUnit)</code>方法已内置“等待-唤醒”的可重试逻辑，其底层通过<code>RedissonLock#tryAcquireAsync</code>实现异步获取+通知订阅。我们无需重复开发核心机制，只需基于原生方法封装业务级的重试策略（如总超时控制、多轮等待等），以下是具体实现。</p><h3 id="方式一：基于原生tryLock的多轮等待封装"><a href="#方式一：基于原生tryLock的多轮等待封装" class="headerlink" title="方式一：基于原生tryLock的多轮等待封装"></a>方式一：基于原生tryLock的多轮等待封装</h3><p>Redisson原生<code>tryLock(waitTime, ...)</code>已实现“等待通知+单次重试”，若需支持多轮等待（如总等待时间较长时），可封装多轮<code>tryLock</code>调用，每轮利用原生的等待-唤醒机制，避免固定休眠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLockRetryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="comment">// 总最大等待时间（毫秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TOTAL_MAX_WAIT_MS</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">// 每轮等待时间（利用原生tryLock的等待-唤醒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PER_ROUND_WAIT_MS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedissonLockRetryDemo</span><span class="params">(RedissonClient redissonClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于原生tryLock等待-唤醒的多轮重试封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁租期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁实例，若获取失败则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RLock <span class="title function_">tryLockWithRetry</span><span class="params">(String lockKey, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(TOTAL_MAX_WAIT_MS);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (remainingWaitMs.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每轮调用原生tryLock，利用其等待-唤醒机制</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock(remainingWaitMs.get(), leaseTime, unit);</span><br><span class="line">                <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">usedWaitMs</span> <span class="operator">=</span> System.currentTimeMillis() - startTimestamp;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取锁成功，累计等待时间：&quot;</span> + usedWaitMs + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> lock;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新剩余等待时间（避免总等待超时）</span></span><br><span class="line">                remainingWaitMs.addAndGet(-PER_ROUND_WAIT_MS);</span><br><span class="line">                System.out.println(<span class="string">&quot;本轮等待超时，剩余等待时间：&quot;</span> + remainingWaitMs.get() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="string">&quot;获取锁过程被中断&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总等待时间已耗尽，获取锁失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<strong><code>tryLock</code></strong> <strong>核心是复用Redisson原生的等待逻辑</strong>：每轮调用<code>tryLock(remainingWaitMs, ...)</code>时，客户端会订阅锁释放通知并阻塞，直到收到通知（立即重试）或本轮等待超时。通过<code>remainingWaitMs</code>控制总等待时间，既保证了“精准唤醒”，又实现了业务级的多轮重试控制。</p><h3 id="方式二：理解Redisson原生等待-唤醒的底层逻辑"><a href="#方式二：理解Redisson原生等待-唤醒的底层逻辑" class="headerlink" title="方式二：理解Redisson原生等待-唤醒的底层逻辑"></a>方式二：理解Redisson原生等待-唤醒的底层逻辑</h3><p>为更深入理解“等待-唤醒”机制，以下简要分析RedissonLock的底层实现流程（基于Redisson 3.x版本），帮助我们更合理地使用可重试功能：</p><h4 id="1-锁获取失败后的订阅逻辑"><a href="#1-锁获取失败后的订阅逻辑" class="headerlink" title="1. 锁获取失败后的订阅逻辑"></a>1. 锁获取失败后的订阅逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RedissonLock#tryAcquireAsync简化逻辑</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 尝试获取锁</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; acquiredFuture = tryLockInnerAsync(waitTime, leaseTime, unit);</span><br><span class="line">    <span class="keyword">return</span> acquiredFuture.thenCompose(acquired -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 获取失败，订阅锁释放通知</span></span><br><span class="line">        <span class="keyword">return</span> subscribeToLockRelease(waitTime, unit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅锁释放频道</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">subscribeToLockRelease</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="type">RTopic</span> <span class="variable">topic</span> <span class="operator">=</span> redisson.getTopic(getChannelName()); <span class="comment">// 频道名：redisson_lock__channel:&#123;lockKey&#125;</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 订阅消息，收到通知后完成future</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">listenerId</span> <span class="operator">=</span> topic.addListener(String.class, (channel, message) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.equals(getLockName())) &#123; <span class="comment">// 验证是当前锁的释放通知</span></span><br><span class="line">            topic.removeListener(listenerId);</span><br><span class="line">            future.complete(<span class="literal">true</span>); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3. 同时设置超时任务，避免无限等待</span></span><br><span class="line">    scheduleTimeout(future, waitTime, unit, listenerId, topic);</span><br><span class="line">    <span class="keyword">return</span> future.thenCompose(ignored -&gt; &#123;</span><br><span class="line">        <span class="comment">// 4. 被唤醒后重新尝试获取锁</span></span><br><span class="line">        <span class="keyword">return</span> tryAcquireAsync(waitTime - usedTime, leaseTime, unit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-锁释放时的通知逻辑"><a href="#2-锁释放时的通知逻辑" class="headerlink" title="2. 锁释放时的通知逻辑"></a>2. 锁释放时的通知逻辑</h4><p>当持有锁的客户端释放锁时，会通过<code>PUBLISH</code>命令向对应频道发送通知，唤醒所有订阅的等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RedissonLock#unlockAsync简化逻辑</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 释放锁（删除Redis中的锁键）</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; releaseFuture = unlockInnerAsync();</span><br><span class="line">    <span class="keyword">return</span> releaseFuture.thenAccept(released -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (released) &#123;</span><br><span class="line">            <span class="comment">// 2. 发布锁释放通知</span></span><br><span class="line">            <span class="type">RTopic</span> <span class="variable">topic</span> <span class="operator">=</span> redisson.getTopic(getChannelName());</span><br><span class="line">            topic.publish(getLockName()); <span class="comment">// 发送当前锁的标识</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-核心优势总结"><a href="#3-核心优势总结" class="headerlink" title="3. 核心优势总结"></a>3. 核心优势总结</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// 原生tryLock的核心价值</span><br><span class="line">1. 无轮询：等待期间线程阻塞，不消耗CPU资源</span><br><span class="line">2. 精准唤醒：仅当锁释放时才触发重试，响应及时</span><br><span class="line">3. 自动超时：避免因通知丢失导致的无限等待</span><br><span class="line">4. 异步非阻塞：底层基于Netty实现异步操作，性能高效</span><br></pre></td></tr></table></figure><p>基于上述底层逻辑，我们在使用Redisson锁可重试功能时，需重点关注以下参数设计：</p><ul><li><p><code>waitTime</code>：单轮最大等待时间（非固定等待），建议设为业务可接受的单次阻塞时长，如1秒；</p></li><li><p><code>totalWaitTime</code>：业务级总等待时间，通过多轮<code>tryLock</code>累加控制，避免整体超时；</p></li><li><p><code>leaseTime</code>：锁租期，需大于业务执行时间，建议结合<code>lockWatchdogTimeout</code>（看门狗机制）自动续期，避免锁提前释放。</p></li></ul><h2 id="四、Redisson锁可重试实现的注意事项"><a href="#四、Redisson锁可重试实现的注意事项" class="headerlink" title="四、Redisson锁可重试实现的注意事项"></a>四、Redisson锁可重试实现的注意事项</h2><p>在实现Redisson锁的可重试机制时，需要注意以下几点，以确保系统的稳定性和正确性：</p><h3 id="1-合理设置重试参数"><a href="#1-合理设置重试参数" class="headerlink" title="1. 合理设置重试参数"></a>1. 合理设置重试参数</h3><p>重试次数和等待时间需要根据业务场景进行调整：</p><ul><li><p>若业务对响应时间敏感，应减少重试次数和等待时间；</p></li><li><p>若锁竞争激烈或网络不稳定，可适当增加重试次数，并采用指数退避等策略延长等待时间。</p></li></ul><h3 id="2-避免死锁风险"><a href="#2-避免死锁风险" class="headerlink" title="2. 避免死锁风险"></a>2. 避免死锁风险</h3><p>Redisson锁本身具有自动过期机制（<code>leaseTime</code>），可以避免死锁，但在重试过程中仍需注意：</p><ul><li><p>确保每次获取锁后都有对应的释放操作（建议使用<code>try-finally</code>块）；</p></li><li><p>不要在重试过程中持有其他资源，以免重试失败时导致资源泄漏。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 正确的锁释放方式</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> tryLockWithRetry(<span class="string">&quot;testLock&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-考虑Redis集群的一致性"><a href="#3-考虑Redis集群的一致性" class="headerlink" title="3. 考虑Redis集群的一致性"></a>3. 考虑Redis集群的一致性</h3><p>在Redis集群环境下，Redisson锁的实现基于Redis的<code>SET NX</code>命令，若采用主从复制架构，主节点宕机可能导致锁信息未同步到从节点，从而出现“锁丢失”问题。此时可考虑使用Redisson的<code>RedissonRedLock</code>（红锁），它通过在多个独立的Redis节点上获取锁，提高锁的可靠性，但会增加性能开销，需根据业务场景权衡。</p><h3 id="4-监控重试-metrics"><a href="#4-监控重试-metrics" class="headerlink" title="4. 监控重试 metrics"></a>4. 监控重试 metrics</h3><p>在生产环境中，建议对锁的重试情况进行监控，记录重试次数、成功率、失败原因等metrics，以便及时发现问题并调整重试策略。例如，使用Prometheus + Grafana监控重试相关指标。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Redisson锁的可重试机制是应对分布式环境中暂时性问题的有效手段，通过“循环尝试 + 条件判断 + 等待策略”的核心思路，结合手动实现或Spring Retry框架，能够灵活满足不同业务场景的需求。在实际应用中，需合理设置重试参数、避免死锁风险、考虑Redis集群一致性，并加强监控，以确保可重试机制的高效与可靠。</p><p>希望本文的思考能够为大家在使用Redisson锁时提供一些帮助，若有不同的见解或更好的实现方式，欢迎在评论区交流讨论！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中Redisson锁对于可重试的实现方式&quot;&gt;&lt;a href=&quot;#Java中Redisson锁对于可重试的实现方式&quot; class=&quot;headerlink&quot; title=&quot;Java中Redisson锁对于可重试的实现方式&quot;&gt;&lt;/a&gt;Java中Redisson锁</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>windows11安装docker</title>
    <link href="https://nmcb666.vip/posts/fd5326b3.html"/>
    <id>https://nmcb666.vip/posts/fd5326b3.html</id>
    <published>2025-09-28T14:13:48.000Z</published>
    <updated>2025-12-31T02:05:23.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-11下安装Docker并修改安装位置至非C盘教程"><a href="#Windows-11下安装Docker并修改安装位置至非C盘教程" class="headerlink" title="Windows 11下安装Docker并修改安装位置至非C盘教程"></a>Windows 11下安装Docker并修改安装位置至非C盘教程</h1><h1 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a>一、安装前准备</h1><h2 id="1-1-检查系统要求"><a href="#1-1-检查系统要求" class="headerlink" title="1.1 检查系统要求"></a>1.1 检查系统要求</h2><p>在安装Docker前，需确保Windows 11系统满足以下条件：</p><ul><li><p>系统版本：Windows 11 64位专业版、企业版或教育版（家庭版需通过WSL 2支持）。</p></li><li><p>硬件要求：支持硬件虚拟化技术（VT-x/AMD-V），并在BIOS/UEFI中启用。</p></li><li><p>WSL 2要求：已安装并启用Windows Subsystem for Linux 2，且内核版本更新至最新。</p></li><li><p>存储空间：非C盘预留至少20GB空闲空间（用于Docker安装及镜像存储）。</p></li></ul><h2 id="1-2-启用必要功能"><a href="#1-2-启用必要功能" class="headerlink" title="1.2 启用必要功能"></a>1.2 启用必要功能</h2><p>打开“控制面板”→“程序”→“程序和功能”→“启用或关闭Windows功能”，勾选以下选项并点击“确定”，等待系统配置完成后重启电脑：</p><ul><li><p>Hyper-V（全部组件）</p></li><li><p>容器</p></li><li><p>Windows虚拟机监控程序平台</p></li></ul><p>若为Windows 11家庭版，需先安装WSL 2：以管理员身份打开PowerShell，输入命令 <code>wsl --install</code>，重启电脑后完成WSL 2安装。</p><h1 id="二、下载Docker安装程序"><a href="#二、下载Docker安装程序" class="headerlink" title="二、下载Docker安装程序"></a>二、下载Docker安装程序</h1><p>访问Docker官方网站（<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>），点击“Download for Windows”下载最新版Docker Desktop安装包（.exe文件），保存至非C盘的临时文件夹（如D:\Temp）。</p><h1 id="三、修改安装位置（已有安装程序时）"><a href="#三、修改安装位置（已有安装程序时）" class="headerlink" title="三、修改安装位置（已有安装程序时）"></a>三、修改安装位置（已有安装程序时）</h1><h2 id="3-1-解压安装程序（可选）"><a href="#3-1-解压安装程序（可选）" class="headerlink" title="3.1 解压安装程序（可选）"></a>3.1 解压安装程序（可选）</h2><p>若已下载Docker安装包，可通过以下方式查看安装文件结构（非必需步骤）：</p><ol><li><p>以管理员身份打开PowerShell，切换至安装包所在目录，例如：<code>cd D:\Temp</code>。</p></li><li><p>输入命令解压安装包：<code>Docker Desktop Installer.exe extract --destination D:\DockerTemp</code>，将安装文件提取至D:\DockerTemp文件夹。</p></li></ol><h2 id="3-2-通过命令行指定安装路径"><a href="#3-2-通过命令行指定安装路径" class="headerlink" title="3.2 通过命令行指定安装路径"></a>3.2 通过命令行指定安装路径</h2><p>这是修改Docker安装位置的核心步骤，需通过命令行参数指定非C盘安装目录：</p><ol><li><p>以<strong>管理员身份</strong>打开PowerShell，切换至Docker安装包所在目录（如D:\Temp）。</p></li><li><p>输入以下命令，将安装位置指定为非C盘路径（以D:\Docker为例）：<br><code>.\Docker Desktop Installer.exe install --installation-dir=D:\Docker --windows-containers=false --wsl2=true</code></p></li><li><p>命令参数说明：</p><pre><code> `--installation-dir=D:\Docker`：指定Docker主程序安装目录（非C盘路径）。</code></pre></li><li><p><code>--windows-containers=false</code>：默认启用Linux容器（如需Windows容器可改为true）。</p></li><li><p><code>--wsl2=true</code>：强制使用WSL 2作为容器运行时（推荐）。</p></li><li><p>执行命令后，等待安装进度完成，期间可能会提示重启电脑，点击“确定”即可。</p></li></ol><div class="tip warning faa-horizontal animated-hover"><p>若之前已安装过Docker并默认在C盘，需先卸载旧版本：打开“设置”→“应用”→“应用和功能”，找到“Docker Desktop”，点击“卸载”，并删除残留文件后再执行上述命令。</p></div><h1 id="四、验证安装结果"><a href="#四、验证安装结果" class="headerlink" title="四、验证安装结果"></a>四、验证安装结果</h1><h2 id="4-1-启动Docker-Desktop"><a href="#4-1-启动Docker-Desktop" class="headerlink" title="4.1 启动Docker Desktop"></a>4.1 启动Docker Desktop</h2><p>安装完成后，在开始菜单中找到“Docker Desktop”并启动，首次启动可能需要几分钟时间（初始化WSL 2环境）。启动成功后，任务栏右下角会显示Docker图标（蓝色鲸鱼图标）。</p><h2 id="4-2-检查安装路径"><a href="#4-2-检查安装路径" class="headerlink" title="4.2 检查安装路径"></a>4.2 检查安装路径</h2><p>打开文件资源管理器，导航至之前指定的安装目录（如D:\Docker），可看到Docker的主程序文件及相关组件，确认安装位置正确。</p><h2 id="4-3-测试Docker功能"><a href="#4-3-测试Docker功能" class="headerlink" title="4.3 测试Docker功能"></a>4.3 测试Docker功能</h2><p>以管理员身份打开PowerShell，输入以下命令测试Docker是否正常工作：</p><ol><li><p>查看Docker版本：<code>docker --version</code>，若输出类似“Docker version 26.1.4, build 5650f9b”则说明版本查询正常。</p></li><li><p>运行Hello World镜像：<code>docker run hello-world</code>，若输出“Hello from Docker!”等信息，说明Docker已成功拉取并运行镜像，功能正常。</p></li></ol><h1 id="五、后续配置（可选）"><a href="#五、后续配置（可选）" class="headerlink" title="五、后续配置（可选）"></a>五、后续配置（可选）</h1><h2 id="5-1-修改镜像存储位置"><a href="#5-1-修改镜像存储位置" class="headerlink" title="5.1 修改镜像存储位置"></a>5.1 修改镜像存储位置</h2><p>默认情况下，Docker镜像存储在WSL 2分发版的虚拟磁盘中（通常位于C盘），可通过以下步骤迁移至非C盘：</p><ol><li><p>关闭Docker Desktop：右键任务栏Docker图标，点击“Quit Docker Desktop”。</p></li><li><p>导出WSL 2分发版：在PowerShell中输入<code>wsl --export docker-desktop-data D:\Docker\wsl\data\docker-desktop-data.tar</code>。</p></li><li><p>注销现有分发版：<code>wsl --unregister docker-desktop-data</code>。</p></li><li><p>重新导入分发版至非C盘：<code>wsl --import docker-desktop-data D:\Docker\wsl\data D:\Docker\wsl\data\docker-desktop-data.tar --version 2</code>。</p></li><li><p>重启Docker Desktop，镜像存储位置即迁移至D:\Docker\wsl\data。</p></li></ol><h2 id="5-2-配置国内镜像源"><a href="#5-2-配置国内镜像源" class="headerlink" title="5.2 配置国内镜像源"></a>5.2 配置国内镜像源</h2><p>为加快镜像拉取速度，可配置国内镜像源：打开Docker Desktop，点击“Settings”→“Docker Engine”，在JSON配置中添加镜像源，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.1ms.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker-0.unsee.tech&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>点击“Apply &amp; Restart”保存配置并重启Docker。</p><h1 id="六、常见问题解决"><a href="#六、常见问题解决" class="headerlink" title="六、常见问题解决"></a>六、常见问题解决</h1><ul><li><p><strong>问题1：安装时提示“Hyper-V未启用”</strong>：重新检查“启用或关闭Windows功能”中Hyper-V组件是否全部勾选，若已勾选仍报错，可能是BIOS中虚拟化未启用，需重启电脑进入BIOS开启VT-x/AMD-V。</p></li><li><p><strong>问题2：Docker启动卡在“Starting…”</strong>：关闭Docker后，在PowerShell中输入<code>wsl --shutdown</code>关闭WSL 2，再重新启动Docker。</p></li><li><p><strong>问题3：命令行输入docker命令提示“command not found”</strong>：检查系统环境变量PATH中是否包含Docker安装目录（如D:\Docker\resources\bin），若未包含需手动添加后重启PowerShell。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-11下安装Docker并修改安装位置至非C盘教程&quot;&gt;&lt;a href=&quot;#Windows-11下安装Docker并修改安装位置至非C盘教程&quot; class=&quot;headerlink&quot; title=&quot;Windows 11下安装Docker并修改安装位置至非</summary>
      
    
    
    
    
    <category term="docker" scheme="https://nmcb666.vip/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>快排与归并排序</title>
    <link href="https://nmcb666.vip/posts/4e7c2b21.html"/>
    <id>https://nmcb666.vip/posts/4e7c2b21.html</id>
    <published>2025-09-23T22:03:13.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序与归并排序：两种高效排序算法的深度解析"><a href="#快速排序与归并排序：两种高效排序算法的深度解析" class="headerlink" title="快速排序与归并排序：两种高效排序算法的深度解析"></a>快速排序与归并排序：两种高效排序算法的深度解析</h1><p>排序算法是计算机科学中的基础内容，在日常开发中有着广泛应用。本文将深入探讨两种经典的高效排序算法：快速排序和归并排序，分析它们的工作原理、实现方式、时间复杂度以及适用场景。</p><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h2><p>快速排序由计算机科学家Tony Hoare于1960年提出，是一种分治法策略的排序算法。它的核心思想是”分而治之”，通过选择一个”基准”元素，将数组分为两部分，一部分所有元素都小于基准，另一部分所有元素都大于基准，然后递归地对这两部分进行排序。</p><h3 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序算法实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :return: 排序后的列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基本情况：如果列表长度小于等于1，则已经是排序好的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择基准元素（这里选择中间元素）</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分区：小于基准、等于基准、大于基准</span></span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序并合并结果</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(left) + middle + quick_sort(right)</span><br></pre></td></tr></table></figure><p>上面的实现采用了列表推导式，使代码更加简洁。实际应用中，为了减少内存开销，更常见的是采用原地(in-place)分区的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort_in_place</span>(<span class="params">arr, low=<span class="literal">None</span>, high=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原地快速排序实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :param low: 排序起始索引</span></span><br><span class="line"><span class="string">    :param high: 排序结束索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化low和high参数</span></span><br><span class="line">    <span class="keyword">if</span> low <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> high <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        high = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基本情况：如果起始索引大于等于结束索引，则无需排序</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分区操作，返回基准元素的最终位置</span></span><br><span class="line">    pivot_index = partition(arr, low, high)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序基准元素左右两部分</span></span><br><span class="line">    quick_sort_in_place(arr, low, pivot_index - <span class="number">1</span>)</span><br><span class="line">    quick_sort_in_place(arr, pivot_index + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    分区操作</span></span><br><span class="line"><span class="string">    :param arr: 要分区的列表</span></span><br><span class="line"><span class="string">    :param low: 分区起始索引</span></span><br><span class="line"><span class="string">    :param high: 分区结束索引</span></span><br><span class="line"><span class="string">    :return: 基准元素的最终位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择最右边的元素作为基准</span></span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># i是小于基准区域的边界</span></span><br><span class="line">    i = low - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历数组，将小于基准的元素放到左边</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将基准元素放到正确的位置</span></span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="快速排序的特性"><a href="#快速排序的特性" class="headerlink" title="快速排序的特性"></a>快速排序的特性</h3><ol><li><p><strong>时间复杂度</strong>：</p><ul><li>平均情况：O(n log n)</li><li>最坏情况：O(n²)（当输入数组已经排序或接近排序时）</li><li>最好情况：O(n log n)</li></ul></li><li><p><strong>空间复杂度</strong>：</p><ul><li>递归实现：O(log n) ~ O(n)（取决于递归深度）</li><li>原地实现：O(log n)（主要是递归调用栈的开销）</li></ul></li><li><p><strong>稳定性</strong>：不稳定排序（相等元素的相对顺序可能改变）</p></li><li><p><strong>特点</strong>：</p><ul><li>实际应用中通常比其他O(n log n)算法快</li><li>缓存友好，因为它具有良好的局部性</li><li>对已经排序的数据性能较差，可以通过随机选择基准元素来改善</li><li>不适合对链表进行排序</li></ul></li></ol><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h2><p>归并排序是另一种基于分治法的排序算法，由John von Neumann于1945年提出。它将数组分成两个 halves，分别对它们进行排序，然后将排序好的两半合并在一起。</p><h3 id="归并排序的实现"><a href="#归并排序的实现" class="headerlink" title="归并排序的实现"></a>归并排序的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序算法实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :return: 排序后的列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基本情况：如果列表长度小于等于1，则已经是排序好的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将列表分成两半</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(arr[:mid])</span><br><span class="line">    right = merge_sort(arr[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并两个已排序的子列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个已排序的列表</span></span><br><span class="line"><span class="string">    :param left: 第一个已排序列表</span></span><br><span class="line"><span class="string">    :param right: 第二个已排序列表</span></span><br><span class="line"><span class="string">    :return: 合并后的排序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较两个列表的元素，按顺序添加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加剩余元素</span></span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>归并排序也可以实现为原地排序，但实现较为复杂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort_in_place</span>(<span class="params">arr, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原地归并排序实现</span></span><br><span class="line"><span class="string">    :param arr: 需要排序的列表</span></span><br><span class="line"><span class="string">    :param left: 排序起始索引</span></span><br><span class="line"><span class="string">    :param right: 排序结束索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基本情况：如果起始索引大于等于结束索引，则无需排序</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 找到中间点</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归排序左半部分和右半部分</span></span><br><span class="line">        merge_sort_in_place(arr, left, mid)</span><br><span class="line">        merge_sort_in_place(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 合并已排序的两部分</span></span><br><span class="line">        merge_in_place(arr, left, mid, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_in_place</span>(<span class="params">arr, left, mid, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原地合并两个已排序的子数组</span></span><br><span class="line"><span class="string">    :param arr: 包含两个已排序子数组的数组</span></span><br><span class="line"><span class="string">    :param left: 第一个子数组的起始索引</span></span><br><span class="line"><span class="string">    :param mid: 第一个子数组的结束索引</span></span><br><span class="line"><span class="string">    :param right: 第二个子数组的结束索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算两个子数组的长度</span></span><br><span class="line">    n1 = mid - left + <span class="number">1</span></span><br><span class="line">    n2 = right - mid</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建临时数组</span></span><br><span class="line">    L = [<span class="number">0</span>] * n1</span><br><span class="line">    R = [<span class="number">0</span>] * n2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">        L[i] = arr[left + i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">        R[j] = arr[mid + <span class="number">1</span> + j]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 原地合并临时数组到原数组</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    k = left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">            arr[k] = L[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = R[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1:</span><br><span class="line">        arr[k] = L[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> j &lt; n2:</span><br><span class="line">        arr[k] = R[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="归并排序的特性"><a href="#归并排序的特性" class="headerlink" title="归并排序的特性"></a>归并排序的特性</h3><ol><li><p><strong>时间复杂度</strong>：</p><ul><li>平均情况：O(n log n)</li><li>最坏情况：O(n log n)</li><li>最好情况：O(n log n)</li></ul></li><li><p><strong>空间复杂度</strong>：</p><ul><li>标准实现：O(n)（需要额外的存储空间）</li><li>原地实现：O(log n)（主要是递归调用栈的开销）</li></ul></li><li><p><strong>稳定性</strong>：稳定排序（相等元素的相对顺序保持不变）</p></li><li><p><strong>特点</strong>：</p><ul><li>性能稳定，不受输入数据分布影响</li><li>适合对链表进行排序</li><li>需要额外的存储空间（除非使用复杂的原地实现）</li><li>并行性好，可以很容易地并行化处理</li></ul></li></ol><h2 id="快速排序与归并排序的对比"><a href="#快速排序与归并排序的对比" class="headerlink" title="快速排序与归并排序的对比"></a>快速排序与归并排序的对比</h2><div class="table-container"><table><thead><tr><th>特性</th><th>快速排序</th><th>归并排序</th></tr></thead><tbody><tr><td>平均时间复杂度</td><td>O(n log n)</td><td>O(n log n)</td></tr><tr><td>最坏时间复杂度</td><td>O(n²)</td><td>O(n log n)</td></tr><tr><td>空间复杂度</td><td>O(log n) ~ O(n)</td><td>O(n) 或 O(log n)</td></tr><tr><td>稳定性</td><td>不稳定</td><td>稳定</td></tr><tr><td>原地排序</td><td>可以</td><td>可以，但实现复杂</td></tr><tr><td>对缓存友好性</td><td>好</td><td>一般</td></tr><tr><td>对已排序数据</td><td>性能差</td><td>性能稳定</td></tr><tr><td>并行性</td><td>一般</td><td>好</td></tr><tr><td>实现复杂度</td><td>较简单</td><td>较复杂</td></tr></tbody></table></div><h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><div class="tip cogs"><ul><li><p><strong>快速排序</strong>通常在实际应用中表现更好，因为它的缓存利用率高，并且不需要额外的大量内存。适合大多数一般情况的排序需求。</p></li><li><p><strong>归并排序</strong>的优势在于其稳定性和可预测的O(n log n)时间复杂度，适合对排序稳定性有要求的场景，或者处理链表排序。</p></li></ul></div><p>在选择排序算法时，应根据具体的应用场景、数据特征和性能要求进行选择。在许多标准库中，会结合两种算法的优点，例如Java的<code>Arrays.sort()</code>对于原始类型使用双轴快速排序，对于对象类型使用归并排序（Java 7及之前）或TimSort（Java 8及之后）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序与归并排序：两种高效排序算法的深度解析&quot;&gt;&lt;a href=&quot;#快速排序与归并排序：两种高效排序算法的深度解析&quot; class=&quot;headerlink&quot; title=&quot;快速排序与归并排序：两种高效排序算法的深度解析&quot;&gt;&lt;/a&gt;快速排序与归并排序：两种高效排序算</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于爬取贴吧的两种网页差异</title>
    <link href="https://nmcb666.vip/posts/cf38f81c.html"/>
    <id>https://nmcb666.vip/posts/cf38f81c.html</id>
    <published>2025-09-19T21:16:00.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度贴吧爬取时两种网页结构的差异"><a href="#百度贴吧爬取时两种网页结构的差异" class="headerlink" title="百度贴吧爬取时两种网页结构的差异"></a>百度贴吧爬取时两种网页结构的差异</h1><p>百度贴吧作为国内极具影响力的中文社区，其海量的用户生成内容（UGC）是进行市场调研、情感分析、热点追踪的宝贵数据资源。但在实际爬取过程中，很多开发者会遇到“明明XPath规则正确却爬不到数据”的问题，其核心原因在于百度贴吧存在两种差异化的前端渲染结构。</p><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h3 id="1-1-贴吧URL结构分析"><a href="#1-1-贴吧URL结构分析" class="headerlink" title="1.1 贴吧URL结构分析"></a>1.1 贴吧URL结构分析</h3><p>贴吧的帖子URL遵循固定格式，掌握后可批量构造爬取链接：</p><ul><li><p><strong>单页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]</code>（默认显示第一页）</p></li><li><p><strong>分页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]?pn=[页码]</code>（pn参数指定页码，如pn=2表示第二页）</p></li></ul><p>例如：帖子<code>https://tieba.baidu.com/p/789012345?pn=3</code>表示ID为789012345的帖子的第三页内容。</p><h2 id="二、两种网页结构的深度对比"><a href="#二、两种网页结构的深度对比" class="headerlink" title="二、两种网页结构的深度对比"></a>二、两种网页结构的深度对比</h2><p>通过Chrome开发者工具（F12）查看网页源码，我们发现两种结构的核心差异集中在<strong>帖子内容容器</strong>和<strong>发布时间节点</strong>，以下是具体对比：</p><h3 id="2-1-结构一：传统版（无clearfix后缀）"><a href="#2-1-结构一：传统版（无clearfix后缀）" class="headerlink" title="2.1 结构一：传统版（无clearfix后缀）"></a>2.1 结构一：传统版（无clearfix后缀）</h3><p>通过“检查”功能定位到帖子内容和发布时间节点，其HTML结构如下：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/2.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code></p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#39;)</code><br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//span[@class=&quot;tail-info&quot;]/text()&#39;)[-1] for i in create_time]</code>（取最后一个tail-info的文本）</p></li></ul><h3 id="2-2-结构二：新版（含clearfix后缀）"><a href="#2-2-结构二：新版（含clearfix后缀）" class="headerlink" title="2.2 结构二：新版（含clearfix后缀）"></a>2.2 结构二：新版（含clearfix后缀）</h3><p>其HTML结构调整了class属性和节点层级：</p><p><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/3.png" alt="code"><br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/4.png" alt="code"></p><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code>（注意两个空格）</p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail &quot;]&#39;)</code>（<br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#39;)[-1] for i in create_time]</code>取p_tail最后一个li的span文本）</p></li></ul><p><strong>关键提醒</strong>：XPath中class属性的匹配是<strong>精确匹配</strong>，空格和后缀的差异会导致解析失败。在编写规则时，必须完全复制网页源码中的class值。</p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 提取帖子评论数据第一种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#x27;</span>)</span><br><span class="line">create_time = [i.xpath(<span class="string">&#x27;.//span[@class=&quot;tail-info&quot;]/text()&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> create_time]</span><br><span class="line"><span class="comment"># 提取帖子评论数据第二种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail &quot;]&#x27;</span>)</span><br><span class="line">create_time_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> create_time:</span><br><span class="line">    time_elements = i.xpath(<span class="string">&#x27;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> time_elements:</span><br><span class="line">        create_time_list.append(time_elements[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        create_time_list.append(<span class="string">&#x27;未知&#x27;</span>)</span><br><span class="line">create_time = create_time_list</span><br></pre></td></tr></table></figure><h2 id="四、关于爬取贴吧列表"><a href="#四、关于爬取贴吧列表" class="headerlink" title="四、关于爬取贴吧列表"></a>四、关于爬取贴吧列表</h2><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h3><p>贴吧列表页面如下所示<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/5.png" alt="code"><br>现在我们想要获取列表页的贴子名称，帖子作者，帖子链接，帖子时间<br>原来的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">        title_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@title&#x27;</span>)</span><br><span class="line">        link_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@href&#x27;</span>)</span><br><span class="line">        creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot;]/@title&#x27;</span>)</span><br><span class="line">        create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>看上去似乎没有什么问题 ，但是运行代码的时候，发现爬取的帖子有些标题跟时间对不上这会导致一些问题。<br>所以这到底是为什么呢？<br>我们可以打开f12查看网页源代码，查看列表页面的html结构，通过观察可以发现，一些帖子的标题，链接，发帖人的html结构跟大部分还不一样。<br>例如普通的标题页面结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/6.png" alt="code"><br>但是某些帖子标题的html结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/7.png" alt="code"><br>可以发现少部分贴子的标题比普通的多了member_thread_title_frs 这一段文字 导致获取不到一些帖子标题，所以也就造成了之后的时间不一致的问题。</p><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><p>解决方法很简单只需要在多匹配那少部分的内容即可。<br>可以把原来的正则表达式替换为<code>//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title</code>。<br>这样就能匹配只要有threadlist_title pull_left j_th_tit 的内容了。<br>但是注意这里的作者名称，一个帖子会有两个作者名称。第一个是帖子作者，第二个是最后评论的人的名称。这里我们只需要获取第一个作者名称即可。<br>于是关于作者名称的正则表达式用or即可。<br>修改的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">title_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title&#x27;</span>)</span><br><span class="line">link_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@href&#x27;</span>)</span><br><span class="line"><span class="comment"># 修改后的作者匹配规则，只匹配指定的两种形式</span></span><br><span class="line">creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot; or @class=&quot;tb_icon_author no_icon_author&quot;]/@title&#x27;</span>)</span><br><span class="line">create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>这样修改之后就可以匹配到正确的完整的数据了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度贴吧爬取时两种网页结构的差异&quot;&gt;&lt;a href=&quot;#百度贴吧爬取时两种网页结构的差异&quot; class=&quot;headerlink&quot; title=&quot;百度贴吧爬取时两种网页结构的差异&quot;&gt;&lt;/a&gt;百度贴吧爬取时两种网页结构的差异&lt;/h1&gt;&lt;p&gt;百度贴吧作为国内极具影响力的</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://nmcb666.vip/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬取微博移动端评论</title>
    <link href="https://nmcb666.vip/posts/eb47d163.html"/>
    <id>https://nmcb666.vip/posts/eb47d163.html</id>
    <published>2025-09-19T16:58:21.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬取微博移动端评论完整教程（基础-常见问题）"><a href="#Python爬取微博移动端评论完整教程（基础-常见问题）" class="headerlink" title="Python爬取微博移动端评论完整教程（基础+常见问题）"></a>Python爬取微博移动端评论完整教程（基础+常见问题）</h1><p>在数据采集领域，微博作为国内主流的社交媒体平台，其评论数据蕴含着丰富的用户观点和舆论倾向。相较于PC端，微博移动端接口更简洁、反爬措施相对宽松，是获取评论数据的优选方案。本文将以<strong>Python</strong>为工具，从环境搭建到代码实现，手把手教你爬取微博移动端评论，并解答过程中可能遇到的常见问题。</p><hr><h2 id="一、基础教程：从零实现微博评论爬取"><a href="#一、基础教程：从零实现微博评论爬取" class="headerlink" title="一、基础教程：从零实现微博评论爬取"></a>一、基础教程：从零实现微博评论爬取</h2><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><p>首先需要搭建Python爬虫环境，核心依赖库如下：</p><ul><li><p><strong>requests</strong>：发送HTTP请求，获取接口数据</p></li><li><p><strong>json</strong>：解析接口返回的JSON数据（Python内置，无需安装）</p></li><li><p><strong>pandas</strong>：数据存储与导出（可选，用于生成Excel文件）</p></li><li><p><strong>time</strong>：设置请求间隔，避免被反爬（Python内置）</p></li></ul><p>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install requests pandas</span><br></pre></td></tr></table></figure><h3 id="1-2-核心原理：找到评论接口"><a href="#1-2-核心原理：找到评论接口" class="headerlink" title="1.2 核心原理：找到评论接口"></a>1.2 核心原理：找到评论接口</h3><p>微博移动端评论通过AJAX异步加载，我们需要先找到真实的评论接口。步骤如下：</p><ol><li><p>打开手机浏览器（或电脑浏览器切换到<strong>移动端模式</strong>），登录微博账号，找到目标微博（例如：<a href="https://m.weibo.cn/detail/4900000000000000">https://m.weibo.cn/detail/4900000000000000</a>）</p></li><li><p>按F12打开开发者工具，切换到<strong>Network</strong>标签，勾选<strong>XHR</strong>（筛选AJAX请求）</p></li><li><p>下拉页面加载评论，此时会看到名为<strong>comment</strong>的请求，点击该请求查看详情</p></li><li><p>在<strong>Request URL</strong>中可以看到评论接口地址，在<strong>Response</strong>中可以看到JSON格式的评论数据</p></li></ol><div class="note primary modern"><p>典型的微博评论接口格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://m.weibo.cn/comments/hotflow?id=微博ID&amp;mid=微博ID&amp;max_id=下一页标识&amp;max_id_type=0</span><br></pre></td></tr></table></figure></div><p>参数说明：</p><ul><li><p><strong>id/mid</strong>：目标微博的ID（从微博详情页URL中获取，例如URL末尾的数字串）</p></li><li><p><strong>max_id</strong>：分页标识，初始为0，后续页面的max_id从当前响应中获取</p></li><li><p><strong>max_id_type</strong>：固定为0即可</p></li></ul><h3 id="1-3-代码实现步骤"><a href="#1-3-代码实现步骤" class="headerlink" title="1.3 代码实现步骤"></a>1.3 代码实现步骤</h3><h4 id="步骤1：获取请求头（Headers）"><a href="#步骤1：获取请求头（Headers）" class="headerlink" title="步骤1：获取请求头（Headers）"></a>步骤1：获取请求头（Headers）</h4><p>为了模拟真实用户请求，需要在请求中添加Headers，核心参数包括<strong>User-Agent</strong>和<strong>Cookie</strong>：</p><ul><li><p><strong>User-Agent</strong>：标识浏览器类型，移动端UA示例：<code>Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1</code></p></li><li><p><strong>Cookie</strong>：包含登录状态信息，从浏览器开发者工具的Request Headers中复制（登录后才能获取更多评论）</p></li></ul><h4 id="步骤2：发送请求并解析数据"><a href="#步骤2：发送请求并解析数据" class="headerlink" title="步骤2：发送请求并解析数据"></a>步骤2：发送请求并解析数据</h4><p>编写代码发送GET请求，解析JSON响应中的评论内容（用户名、评论时间、评论内容等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置信息</span></span><br><span class="line">weibo_id = <span class="string">&quot;4900000000000000&quot;</span>  <span class="comment"># 目标微博ID</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;你的Cookie信息&quot;</span>  <span class="comment"># 替换为自己的Cookie</span></span><br><span class="line">&#125;</span><br><span class="line">comments = []  <span class="comment"># 存储评论数据</span></span><br><span class="line">max_id = <span class="number">0</span>  <span class="comment"># 初始分页标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 构建请求URL</span></span><br><span class="line">    url = <span class="string">f&quot;https://m.weibo.cn/comments/hotflow?id=<span class="subst">&#123;weibo_id&#125;</span>&amp;mid=<span class="subst">&#123;weibo_id&#125;</span>&amp;max_id=<span class="subst">&#123;max_id&#125;</span>&amp;max_id_type=0&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">        response.raise_for_status()  <span class="comment"># 若状态码不是200，抛出异常</span></span><br><span class="line">        data = json.loads(response.text)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取评论列表</span></span><br><span class="line">        comment_list = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;data&quot;</span>, [])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> comment_list:  <span class="comment"># 没有更多评论时退出循环</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已获取所有评论&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解析每条评论</span></span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> comment_list:</span><br><span class="line">            item = &#123;</span><br><span class="line">                <span class="string">&quot;用户名&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;screen_name&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;用户ID&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论时间&quot;</span>: comment.get(<span class="string">&quot;created_at&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论内容&quot;</span>: comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;点赞数&quot;</span>: comment.get(<span class="string">&quot;like_count&quot;</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="string">&quot;回复数&quot;</span>: comment.get(<span class="string">&quot;reply_count&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            comments.append(item)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;已获取<span class="subst">&#123;<span class="built_in">len</span>(comments)&#125;</span>条评论&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新下一页的max_id</span></span><br><span class="line">        max_id = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;max_id&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> max_id == <span class="number">0</span>:  <span class="comment"># 没有下一页时退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置请求间隔，避免被封IP</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;请求出错：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="步骤3：数据存储"><a href="#步骤3：数据存储" class="headerlink" title="步骤3：数据存储"></a>步骤3：数据存储</h4><p>将爬取到的评论数据导出为Excel文件，方便后续分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 转换为DataFrame并导出</span></span><br><span class="line">df = pd.DataFrame(comments)</span><br><span class="line">df.to_excel(<span class="string">&quot;微博评论.xlsx&quot;</span>, index=<span class="literal">False</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;评论数据已保存到微博评论.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="二、常见问题及解决方案"><a href="#二、常见问题及解决方案" class="headerlink" title="二、常见问题及解决方案"></a>二、常见问题及解决方案</h2><h3 id="2-1-问题1：请求返回403-401错误"><a href="#2-1-问题1：请求返回403-401错误" class="headerlink" title="2.1 问题1：请求返回403/401错误"></a>2.1 问题1：请求返回403/401错误</h3><p><strong>原因</strong>：Headers参数不完整或Cookie失效，服务器识别为爬虫请求。</p><p><strong>解决方案</strong>：</p><ul><li><p>检查Cookie是否正确，重新登录微博后复制最新的Cookie</p></li><li><p>补充Headers中的其他参数（如<strong>Referer</strong>：设置为目标微博详情页URL）</p></li><li><p>确保User-Agent是移动端格式，避免使用PC端UA</p></li></ul><h3 id="2-2-问题2：只能爬取前20条评论"><a href="#2-2-问题2：只能爬取前20条评论" class="headerlink" title="2.2 问题2：只能爬取前20条评论"></a>2.2 问题2：只能爬取前20条评论</h3><p><strong>原因</strong>：未正确处理分页参数max_id，或未登录导致只能获取公开评论。</p><p><strong>解决方案</strong>：</p><ul><li><p>确保登录状态（Cookie有效），登录后可获取更多评论</p></li><li><p>检查max_id是否正确从响应中提取，避免手动设置固定值</p></li><li><p>部分微博可能限制评论查看权限，属于正常情况</p></li></ul><h3 id="2-3-问题3：IP被封禁，无法发送请求"><a href="#2-3-问题3：IP被封禁，无法发送请求" class="headerlink" title="2.3 问题3：IP被封禁，无法发送请求"></a>2.3 问题3：IP被封禁，无法发送请求</h3><p><strong>原因</strong>：请求频率过高，触发微博反爬机制。</p><p><strong>解决方案</strong>：</p><ul><li><p>增加请求间隔时间（如time.sleep(3-5秒)），避免高频请求</p></li><li><p>使用代理IP池，轮换IP地址发送请求（推荐使用高匿代理）</p></li><li><p>暂停爬取1-2小时，IP封禁通常是临时的</p></li></ul><h3 id="2-4-问题4：评论内容含HTML标签"><a href="#2-4-问题4：评论内容含HTML标签" class="headerlink" title="2.4 问题4：评论内容含HTML标签"></a>2.4 问题4：评论内容含HTML标签</h3><p><strong>原因</strong>：接口返回的text字段包含HTML格式（如表情、话题链接等）。</p><p><strong>解决方案</strong>：使用<strong>BeautifulSoup</strong>清理HTML标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理评论内容中的HTML标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_html</span>(<span class="params">text</span>):</span><br><span class="line">    soup = BeautifulSoup(text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> soup.get_text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在解析评论时调用</span></span><br><span class="line"><span class="string">&quot;评论内容&quot;</span>: clean_html(comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>)),</span><br></pre></td></tr></table></figure><h3 id="2-5-问题5：响应数据格式异常"><a href="#2-5-问题5：响应数据格式异常" class="headerlink" title="2.5 问题5：响应数据格式异常"></a>2.5 问题5：响应数据格式异常</h3><p><strong>原因</strong>：接口参数变化或微博更新反爬策略。</p><p><strong>解决方案</strong>：</p><ul><li><p>重新通过浏览器开发者工具抓取最新的评论接口，确认参数是否变化</p></li><li><p>打印response.text查看原始响应，分析数据格式是否与预期一致</p></li><li><p>关注微博接口的官方变化（若有），及时调整代码</p></li></ul><h3 id="2-6-问题6：请求第一页之后的数据响应ok-0"><a href="#2-6-问题6：请求第一页之后的数据响应ok-0" class="headerlink" title="2.6 问题6：请求第一页之后的数据响应ok{0}"></a>2.6 问题6：请求第一页之后的数据响应ok{0}</h3><p><strong>原因</strong>：请求的Cookie已失效，需要重新登录获取Cookie。(因为微博需要登录才能查看更多评论)</p><p><strong>解决方案</strong>：</p><ul><li>登录微博账号，打开浏览器开发者工具，选择Network选项卡，点击刷新按钮。</li><li>在Network选项卡中，找到对应的请求，查看响应头，找到Cookie字段，复制Cookie值。</li><li>将Cookie值替换为配置文件中的Cookie字段。</li><li>重新运行代码，即可获取最新数据。</li></ul><hr><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ul><li><p><strong>合规性</strong>：爬取微博数据需遵守《微博服务使用协议》，不得用于商业用途或恶意攻击，建议仅用于个人学习研究</p></li><li><p><strong>登录状态</strong>：尽量使用小号登录，避免主号因爬虫行为被限制</p></li><li><p><strong>请求频率</strong>：保持低调，避免短时间内发送大量请求，友好对待服务器</p></li><li><p><strong>数据备份</strong>：定期保存爬取到的数据，防止程序异常导致数据丢失</p></li></ul><p>通过以上步骤，你可以成功爬取微博移动端评论数据。如果遇到其他问题，欢迎在评论区留言交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python爬取微博移动端评论完整教程（基础-常见问题）&quot;&gt;&lt;a href=&quot;#Python爬取微博移动端评论完整教程（基础-常见问题）&quot; class=&quot;headerlink&quot; title=&quot;Python爬取微博移动端评论完整教程（基础+常见问题）&quot;&gt;&lt;/a&gt;Py</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://nmcb666.vip/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于GitHub Pages加载静态文件失败</title>
    <link href="https://nmcb666.vip/posts/b1168866.html"/>
    <id>https://nmcb666.vip/posts/b1168866.html</id>
    <published>2025-09-17T23:50:28.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决Github-Pages不加载Vue框架项目静态文件问题"><a href="#解决Github-Pages不加载Vue框架项目静态文件问题" class="headerlink" title="解决Github Pages不加载Vue框架项目静态文件问题"></a>解决Github Pages不加载Vue框架项目静态文件问题</h1><p>在使用Vue框架开发项目并部署到Github Pages时，很多开发者都会遇到一个头疼的问题：页面能够正常访问，但项目中的JS、CSS等静态文件却无法加载，导致页面样式错乱、功能失效。其实这个问题的核心在于静态文件的路径配置不当，本文将详细介绍如何通过配置打包工具的路径以及Github Pages设置来解决这一问题，并分别以Vite和Webpack两种常用打包工具进行演示。</p><h2 id="一、问题原因分析"><a href="#一、问题原因分析" class="headerlink" title="一、问题原因分析"></a>一、问题原因分析</h2><p>Github Pages部署的项目，其访问路径通常是 <code>https://[用户名].github.io/[项目名]/</code>，而Vue项目默认的静态文件路径是基于根目录（<code>/</code>）的。当项目部署到Github Pages后，静态文件会被请求从根目录获取，而实际静态文件却在<code>/[项目名]/</code>目录下，这就导致了路径不匹配，静态文件加载失败。</p><h2 id="二、不同打包工具的配置方法"><a href="#二、不同打包工具的配置方法" class="headerlink" title="二、不同打包工具的配置方法"></a>二、不同打包工具的配置方法</h2><div class="note primary modern"><p>解决该问题的关键是修改打包工具的静态文件公共路径（publicPath），使其指向Github Pages的项目地址。</p></div><div class="tip success"><p>如果你不想打包，直接在根目录下有一个index.html静态网页文件。那么将里面js,css等静态文件的引用路径前面加上<code>/[项目名]/</code>即可。例如：/static/js/app.js —&gt; /[项目名]/static/js/app.js 如果成功则无需打包</p></div><p>下面分别介绍Vite和Webpack的配置步骤。</p><h3 id="2-1-Vite打包工具配置"><a href="#2-1-Vite打包工具配置" class="headerlink" title="2.1 Vite打包工具配置"></a>2.1 Vite打包工具配置</h3><p>Vite是目前Vue项目常用的构建工具，配置方式较为简洁，只需修改项目根目录下的<code>vite.config.js</code>文件。</p><ol><li><p><strong>找到vite.config.js文件</strong>：该文件位于Vue项目的根目录下，如果没有则手动创建。</p></li><li><p><strong>配置publicPath</strong>：在<code>defineConfig</code>对象中添加<code>base</code>属性（Vite中publicPath对应的是base），其值设置为你的Github Pages项目地址。格式为 <code>&#39;https://[用户名].github.io/[项目名]/&#39;</code>，例如如果用户名为<code>testuser</code>，项目名为<code>vue-demo</code>，则配置为 <code>base: &#39;https://testuser.github.io/vue-demo/&#39;</code>。</p></li><li><p><strong>设置打包输出目录</strong>：默认情况下Vite打包输出到<code>dist</code>目录，我们需要将其改为<code>docs</code>目录，方便后续Github Pages配置。在<code>defineConfig</code>中添加<code>build</code>选项，设置<code>outDir: &#39;docs&#39;</code>。</p></li></ol><p>配置完成后的<code>vite.config.js</code>文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;https://testuser.github.io/vue-demo/&#x27;</span>, <span class="comment">// 替换为你的项目地址</span></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">outDir</span>: <span class="string">&#x27;docs&#x27;</span> <span class="comment">// 打包输出到docs目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>base路径不唯一 可自行在浏览器控制台中查看请求路径  将请求路径调整为 https://&lt;你的名称&gt;.github.io/&lt;项目名称&gt;/静态文件路径。即可<br>配置完成后，执行<code>npm run build</code>命令进行打包，此时项目根目录下会生成<code>docs</code>文件夹，里面包含了打包后的静态文件。</p><h3 id="2-2-Webpack打包工具配置（Vue-CLI项目）"><a href="#2-2-Webpack打包工具配置（Vue-CLI项目）" class="headerlink" title="2.2 Webpack打包工具配置（Vue CLI项目）"></a>2.2 Webpack打包工具配置（Vue CLI项目）</h3><p>如果你的Vue项目是使用Vue CLI创建的，那么使用的打包工具是Webpack，需要修改<code>vue.config.js</code>文件。</p><ol><li><p><strong>找到vue.config.js文件</strong>：该文件位于Vue项目的根目录下，若不存在则手动创建。</p></li><li><p><strong>配置publicPath</strong>：在配置对象中添加<code>publicPath</code>属性，值设置为你的Github Pages项目地址，格式与Vite相同，即 <code>&#39;https://[用户名].github.io/[项目名]/&#39;</code>。</p></li><li><p><strong>设置打包输出目录</strong>：同样将打包输出目录改为<code>docs</code>，在配置对象中添加<code>outputDir: &#39;docs&#39;</code>。</p></li></ol><p>配置完成后的<code>vue.config.js</code>文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;https://testuser.github.io/vue-demo/&#x27;</span>, <span class="comment">// 替换为你的项目地址</span></span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&#x27;docs&#x27;</span> <span class="comment">// 打包输出到docs目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npm run build</code>命令打包，项目根目录会生成<code>docs</code>文件夹，包含打包后的静态资源。</p><h2 id="三、Github-Pages配置步骤"><a href="#三、Github-Pages配置步骤" class="headerlink" title="三、Github Pages配置步骤"></a>三、Github Pages配置步骤</h2><p>完成打包工具配置并生成<code>docs</code>文件夹后，需要在Github仓库中设置Github Pages的部署源。</p><ol><li><p><strong>推送代码到Github仓库</strong>：将包含<code>docs</code>文件夹的项目代码推送到Github仓库的<code>main</code>分支（或你使用的主分支）。</p></li><li><p><strong>进入仓库设置</strong>：打开你的Github项目仓库，点击右上角的<code>Settings</code>选项。</p></li><li><p><strong>找到Github Pages设置</strong>：在左侧导航栏中找到<code>Pages</code>选项并点击进入。</p></li><li><p><strong>设置部署源</strong>：在<code>Build and deployment</code>下的<code>Source</code>选项中，选择<code>Deploy from a branch</code>。然后在<code>Branch</code>选项中，选择<code>main</code>分支，并在后面的文件夹选择框中选择<code>/docs</code>，点击<code>Save</code>保存设置。</p></li></ol><p>设置完成后，Github Pages会自动部署你的项目，通常几分钟后即可通过<code>https://[用户名].github.io/[项目名]/</code>访问，此时JS、CSS等静态文件就能正常加载了。</p><h2 id="四、常见问题排查"><a href="#四、常见问题排查" class="headerlink" title="四、常见问题排查"></a>四、常见问题排查</h2><ul><li><p><strong>publicPath配置错误</strong>：确保publicPath（Vite中为base）的路径正确，末尾必须加上<code>/</code>，否则可能导致部分静态文件路径拼接错误。</p></li><li><p><strong>docs文件夹未推送</strong>：检查是否将打包生成的<code>docs</code>文件夹推送到了Github仓库，若未推送则需要执行<code>git add docs</code>、<code>git commit -m &quot;add docs&quot;</code>、<code>git push</code>命令。</p></li><li><p><strong>分支或文件夹选择错误</strong>：确认Github Pages设置中选择的分支是<code>main</code>（或你的项目主分支），文件夹是<code>/docs</code>。</p></li></ul><h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、<wavy>额外注意</wavy></h2><div class="tip warning faa-horizontal animated-hover"><p>github pages 默认是使用jekyll作为静态文件处理引擎，这个会默认删除静态文件名的下划线_导致静态文件无法加载。</p></div><p>解决方法：即在跟目录下创建一个名为.nojekyll的文件即可取消jekyll<br>关于jekyll的详细介绍可以参考：<a href="https://jekyllcn.com/docs/home/">https://jekyllcn.com/docs/home/</a></p><p>通过以上步骤，就能顺利解决Github Pages不加载Vue项目静态文件的问题。核心在于正确配置打包工具的publicPath路径，并将打包文件输出到docs目录，再配合Github Pages的部署源设置，即可实现项目的正常访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解决Github-Pages不加载Vue框架项目静态文件问题&quot;&gt;&lt;a href=&quot;#解决Github-Pages不加载Vue框架项目静态文件问题&quot; class=&quot;headerlink&quot; title=&quot;解决Github Pages不加载Vue框架项目静态文件问题&quot;&gt;</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://nmcb666.vip/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机与数学的那些事</title>
    <link href="https://nmcb666.vip/posts/f8b7ba6f.html"/>
    <id>https://nmcb666.vip/posts/f8b7ba6f.html</id>
    <published>2025-09-16T14:12:43.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学计算机一定要数学好吗？不同岗位需求大不同"><a href="#学计算机一定要数学好吗？不同岗位需求大不同" class="headerlink" title="学计算机一定要数学好吗？不同岗位需求大不同"></a>学计算机一定要数学好吗？不同岗位需求大不同</h1><p>“我数学不好，是不是学不了计算机？”这是很多想入行计算机领域的人都会问的问题。其实这个问题没有绝对的答案，核心在于你想从事计算机领域的哪个岗位。在我看来，<strong>普通开发岗对数学功底的要求并不高，而算法岗和人工智能岗则需要扎实且甚至高于计算机知识本身的数学基础</strong>。今天就来详细聊聊不同岗位对数学的真实需求，帮大家消除认知误区。</p><h2 id="一、普通开发岗：数学是“加分项”而非“必需品”"><a href="#一、普通开发岗：数学是“加分项”而非“必需品”" class="headerlink" title="一、普通开发岗：数学是“加分项”而非“必需品”"></a>一、普通开发岗：数学是“加分项”而非“必需品”</h2><p>普通开发岗涵盖的范围很广，比如前端开发、后端开发、移动端开发、全栈开发等，这些岗位的核心是“实现业务需求”，更看重的是编程能力、逻辑思维和业务理解能力，对数学的要求远没有大家想象中那么高。</p><p>以前端开发为例，日常工作主要是用HTML、CSS、JavaScript构建用户界面，实现页面交互效果。即使是用到React、Vue等框架，核心也是组件化思想和状态管理，涉及到的数学知识可能最多就是简单的布局计算（比如用Flex或Grid布局时的百分比、像素换算），连初中数学知识都能应对。后端开发虽然会接触到数据库、服务器等，但更多是掌握编程语言（如Java、Python、Go）、框架（如Spring、Django）和数据库优化技巧，数学知识的应用场景少之又少。</p><p>我身边有不少做普通开发的学长，大学时数学成绩并不突出，但凭借扎实的编程基础和不断积累的业务经验，照样能成为团队里的骨干。当然，这并不是说数学对普通开发岗毫无用处——如果懂一点离散数学，在理解数据结构（如树、图）时会更轻松；如果懂一点线性代数，在处理图形相关的开发任务时可能会更得心应手。但这些都属于“加分项”，而非“入门必备项”，不会成为阻碍你入行和发展的绊脚石。</p><h2 id="二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要"><a href="#二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要" class="headerlink" title="二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要"></a>二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要</h2><p>与普通开发岗不同，算法岗（如机器学习算法工程师、推荐算法工程师）和人工智能岗（如AI研究员、深度学习工程师）对数学的要求极高，数学知识是开展工作的核心基础，甚至在很多场景下比单纯的计算机知识更重要。</p><p>这些岗位的工作本质是“解决复杂问题”，需要通过数学模型来抽象现实问题，并设计高效的算法来求解。这就要求从业者必须掌握多门高等数学知识：</p><ul><li><p><strong>线性代数</strong>：是机器学习的基础，比如数据的表示（向量、矩阵）、特征变换（矩阵乘法、特征值分解）、降维算法（PCA）等，都离不开线性代数的知识。如果不懂矩阵运算，连最简单的神经网络前向传播都无法理解。</p></li><li><p><strong>概率论与数理统计</strong>：在处理不确定性问题时至关重要，比如贝叶斯分类器、概率模型（如隐马尔可夫模型）、模型评估指标（准确率、召回率、ROC曲线）等，都需要概率论和统计学的支撑。</p></li><li><p><strong>微积分</strong>：主要用于优化算法，比如机器学习中的梯度下降法，就是通过求导来找到函数的最小值点，从而更新模型参数。如果不懂导数、偏导数，就无法理解优化算法的原理，更谈不上调优模型。</p></li><li><p><strong>离散数学</strong>：在图算法、组合优化等领域应用广泛，比如最短路径算法（Dijkstra、Floyd）、图神经网络（GNN）等，都需要离散数学的知识作为铺垫。</p></li></ul><p>举个例子，如果你想做深度学习工程师，搭建一个神经网络模型可能用TensorFlow或PyTorch几行代码就能实现，但要想让模型达到更好的效果——比如调整网络结构、优化损失函数、解决过拟合问题，就必须深入理解模型背后的数学原理。如果数学基础薄弱，只能停留在“调参工程师”的层面，无法真正成为一名优秀的算法或AI工程师。很多顶尖的AI研究员，本身就是数学专业出身，可见数学在这个领域的重要性。</p><h2 id="三、总结：根据目标岗位，合理规划数学学习"><a href="#三、总结：根据目标岗位，合理规划数学学习" class="headerlink" title="三、总结：根据目标岗位，合理规划数学学习"></a>三、总结：根据目标岗位，合理规划数学学习</h2><p>回到最初的问题“学计算机一定要数学好吗？”，答案已经很清晰了：</p><div class="tip warning faa-horizontal animated"><p>如果你目标是普通开发岗，不用因为数学不好而焦虑，重点放在提升编程能力和逻辑思维上，数学可以作为后续提升的补充；如果你目标是算法岗或人工智能岗，那么一定要打好数学基础，把线性代数、概率论、微积分等核心知识学扎实，这比单纯掌握编程语言和框架更重要。</p></div><p>计算机领域博大精深，不同岗位的需求差异很大。关键是明确自己的职业方向，然后有针对性地学习。不要被“数学不好就不能学计算机”的误区吓住，也不要忽视算法和AI岗对数学的高要求。希望这篇文章能帮大家更清晰地认识计算机与数学的关系，祝大家在计算机的道路上走得更远！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学计算机一定要数学好吗？不同岗位需求大不同&quot;&gt;&lt;a href=&quot;#学计算机一定要数学好吗？不同岗位需求大不同&quot; class=&quot;headerlink&quot; title=&quot;学计算机一定要数学好吗？不同岗位需求大不同&quot;&gt;&lt;/a&gt;学计算机一定要数学好吗？不同岗位需求大不同&lt;/</summary>
      
    
    
    
    
    <category term="计算机杂谈" scheme="https://nmcb666.vip/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>jsdelivr不可用替代方案</title>
    <link href="https://nmcb666.vip/posts/6acc4ad2.html"/>
    <id>https://nmcb666.vip/posts/6acc4ad2.html</id>
    <published>2025-09-16T09:57:48.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客提速实战：cdn-jsdelivr-net不可用"><a href="#Hexo博客提速实战：cdn-jsdelivr-net不可用" class="headerlink" title="Hexo博客提速实战：cdn.jsdelivr.net不可用"></a>Hexo博客提速实战：cdn.jsdelivr.net不可用</h1><p>对于使用Hexo搭建个人博客的开发者和博主而言，网站加载速度直接影响用户体验与内容传播效果。不少用户在运营过程中会发现，博客打开缓慢、样式加载延迟甚至部分资源失效，排查后往往能定位到核心问题——默认依赖的<code>cdn.jsdelivr.net</code>在国内网络环境下表现不佳。本文将从问题根源出发，提供一套完整的CDN替换方案，帮助你快速解决Hexo博客速度难题。</p><h2 id="一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？"><a href="#一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？" class="headerlink" title="一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？"></a>一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？</h2><p>在分析解决方案前，我们先明确<code>cdn.jsdelivr.net</code>导致Hexo博客速度慢的核心原因，避免盲目优化：</p><h3 id="1-网络环境的天然限制"><a href="#1-网络环境的天然限制" class="headerlink" title="1. 网络环境的天然限制"></a>1. 网络环境的天然限制</h3><p><code>jsDelivr</code>作为全球通用的开源CDN服务，其核心节点主要分布在北美、欧洲等海外地区。国内用户访问时，数据需经过跨境网络链路传输，受国际带宽、路由跳转等因素影响，延迟通常高达100-800ms，部分地区甚至出现数据包丢失。</p><h3 id="2-资源加载的连锁反应"><a href="#2-资源加载的连锁反应" class="headerlink" title="2. 资源加载的连锁反应"></a>2. 资源加载的连锁反应</h3><p>Hexo主题（如Next、Butterfly、Matery）默认依赖<code>jsDelivr</code>加载大量关键资源，包括：</p><ul><li>样式文件：CSS框架（Bootstrap）、图标库（Font Awesome）</li><li>脚本文件：交互插件（jQuery）、代码高亮（Prism.js）、评论系统（Valine）</li><li>静态资源：字体文件、主题图片、第三方组件</li></ul><p>这些资源若加载延迟，会导致页面“白屏时间”延长、样式错乱，甚至触发浏览器的“资源加载超时”错误。</p><h3 id="3-国内镜像的优势"><a href="#3-国内镜像的优势" class="headerlink" title="3. 国内镜像的优势"></a>3. 国内镜像的优势</h3><p><code>cdn.jsdmirror.com</code>是专为国内用户搭建的<code>jsDelivr</code>镜像服务，具备三大核心优势：</p><ul><li><strong>节点覆盖广</strong>：在国内30+城市部署节点，用户访问时自动匹配最近节点，延迟可降至50ms以内</li><li><strong>同步速度快</strong>：实时同步<code>jsDelivr</code>的GitHub仓库与npm包资源，资源更新无延迟</li><li><strong>访问稳定性高</strong>：规避跨境网络波动，支持HTTPS加密访问，兼容所有主流浏览器</li></ul><h2 id="二、替换前的准备工作"><a href="#二、替换前的准备工作" class="headerlink" title="二、替换前的准备工作"></a>二、替换前的准备工作</h2><p>为确保替换过程顺利，避免操作失误导致博客异常，需提前完成以下准备：</p><h3 id="1-核心文件备份"><a href="#1-核心文件备份" class="headerlink" title="1. 核心文件备份"></a>1. 核心文件备份</h3><ul><li>备份Hexo根目录下的<code>_config.yml</code>（全局配置文件）</li><li>备份主题目录（如<code>themes/next</code>、<code>themes/butterfly</code>），建议压缩为ZIP文件存储</li><li>若使用Git管理博客，可先提交当前版本，便于后续回滚</li></ul><h3 id="2-资源依赖排查"><a href="#2-资源依赖排查" class="headerlink" title="2. 资源依赖排查"></a>2. 资源依赖排查</h3><p>通过浏览器开发者工具（F12）定位所有<code>jsDelivr</code>资源：</p><ol><li>打开博客页面，按F12打开“开发者工具”</li><li>切换至“Network”标签，刷新页面</li><li>在搜索框输入<code>cdn.jsdelivr.net</code>，筛选出所有依赖该CDN的资源</li><li>记录资源类型（CSS/JS/Font）、链接地址及所在文件，避免替换遗漏</li></ol><h3 id="3-本地环境确认"><a href="#3-本地环境确认" class="headerlink" title="3. 本地环境确认"></a>3. 本地环境确认</h3><p>确保本地已搭建完整的Hexo运行环境：</p><ul><li>检查Node.js版本（建议v14+）：<code>node -v</code></li><li>检查Hexo CLI版本（建议v6+）：<code>hexo -v</code></li><li>测试本地服务可用性：在根目录执行<code>hexo s</code>，确认<code>http://localhost:4000</code>可正常访问</li></ul><h2 id="三、分主题替换教程（覆盖主流主题）"><a href="#三、分主题替换教程（覆盖主流主题）" class="headerlink" title="三、分主题替换教程（覆盖主流主题）"></a>三、分主题替换教程（覆盖主流主题）</h2><p>不同Hexo主题的资源配置位置存在差异，以下针对3个最常用主题，提供 step-by-step 替换指南：</p><u>为了方便可以直接在编辑器中进行全局替换，将所有`cdn.jsdelivr.net`替换为`cdn.jsdmirror.com`</u><emp>如果生效，则无需下面的步骤</emp><h3 id="1-Next主题（v8-x-v9-x）"><a href="#1-Next主题（v8-x-v9-x）" class="headerlink" title="1. Next主题（v8.x - v9.x）"></a>1. Next主题（v8.x - v9.x）</h3><p>Next主题的CDN配置分散在<strong>主题配置文件</strong>和<strong>布局模板文件</strong>中，需分两步替换：</p><h4 id="步骤1：修改主题配置文件（themes-next-config-yml）"><a href="#步骤1：修改主题配置文件（themes-next-config-yml）" class="headerlink" title="步骤1：修改主题配置文件（themes/next/_config.yml）"></a>步骤1：修改主题配置文件（themes/next/_config.yml）</h4><p>用文本编辑器打开该文件，按<code>Ctrl+F</code>搜索<code>cdn.jsdelivr.net</code>，逐一替换以下资源：</p><ul><li><strong>字体图标（Font Awesome）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdmirror.com/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>代码高亮（Prism.js）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdmirror.com/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>评论系统（Valine）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdmirror.com/npm/valine@1.4.18/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="步骤2：修改布局模板中的硬编码资源"><a href="#步骤2：修改布局模板中的硬编码资源" class="headerlink" title="步骤2：修改布局模板中的硬编码资源"></a>步骤2：修改布局模板中的硬编码资源</h4><p>进入<code>themes/next/layout</code>目录，搜索所有文件中的<code>cdn.jsdelivr.net</code>：</p><ol><li>打开<code>_partials/head.swig</code>，替换CSS资源引用</li><li>打开<code>_partials/footer.swig</code>，替换JS资源引用</li><li>打开<code>_third-party/comments/valine.swig</code>（若使用Valine），确认评论组件CDN已替换</li></ol><h3 id="2-Butterfly主题（v4-x-v5-x）"><a href="#2-Butterfly主题（v4-x-v5-x）" class="headerlink" title="2. Butterfly主题（v4.x - v5.x）"></a>2. Butterfly主题（v4.x - v5.x）</h3><p>Butterfly主题的CDN配置高度集中，主要在<strong>主题配置文件</strong>中：</p><h4 id="步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）"><a href="#步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）" class="headerlink" title="步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）"></a>步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）</h4><p>找到<code>CDN</code>相关配置段，替换以下关键资源：</p><ul><li><strong>基础框架（jQuery + Bootstrap）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdmirror.com/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br></pre></td></tr></table></figure></li><li><strong>图标与高亮</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdelivr.net/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdmirror.com/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdmirror.com/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>第三方插件（如阅读进度、目录）</strong><br>继续向下搜索，替换<code>tocbot</code>、<code>nprogress</code>等插件的CDN链接，确保无遗漏。</li></ul><h4 id="步骤2：检查自定义页面资源"><a href="#步骤2：检查自定义页面资源" class="headerlink" title="步骤2：检查自定义页面资源"></a>步骤2：检查自定义页面资源</h4><p>若在<code>source</code>目录下创建了自定义页面（如<code>about.md</code>、<code>links.md</code>），需打开文件检查是否有内嵌的<code>jsDelivr</code>链接，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原链接 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 替换后 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="3-Matery主题（v1-x）"><a href="#3-Matery主题（v1-x）" class="headerlink" title="3. Matery主题（v1.x）"></a>3. Matery主题（v1.x）</h3><p>Matery主题的资源配置在<strong>主题配置文件</strong>和<strong>HTML模板</strong>中：</p><h4 id="步骤1：修改主题配置（themes-matery-config-yml）"><a href="#步骤1：修改主题配置（themes-matery-config-yml）" class="headerlink" title="步骤1：修改主题配置（themes/matery/_config.yml）"></a>步骤1：修改主题配置（themes/matery/_config.yml）</h4><p>替换<code>CDN</code>部分的资源：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdelivr.net/npm/layer@3.5.1/dist/layer.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdmirror.com/npm/layer@3.5.1/dist/layer.min.js</span></span><br></pre></td></tr></table></figure></p><h4 id="步骤2：修改HTML模板（themes-matery-layout-partial）"><a href="#步骤2：修改HTML模板（themes-matery-layout-partial）" class="headerlink" title="步骤2：修改HTML模板（themes/matery/layout/_partial）"></a>步骤2：修改HTML模板（themes/matery/layout/_partial）</h4><p>打开<code>head.html</code>和<code>footer.html</code>，替换模板中硬编码的CDN链接，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 替换后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="四、替换后的验证与测试"><a href="#四、替换后的验证与测试" class="headerlink" title="四、替换后的验证与测试"></a>四、替换后的验证与测试</h2><p>完成替换后，需通过多维度测试确保博客正常运行且速度提升：</p><h3 id="1-本地环境验证"><a href="#1-本地环境验证" class="headerlink" title="1. 本地环境验证"></a>1. 本地环境验证</h3><p>在Hexo根目录执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存（关键步骤，避免旧资源干扰）</span></span><br><span class="line">hexo s      <span class="comment"># 启动本地服务器</span></span><br></pre></td></tr></table></figure><br>打开浏览器访问<code>http://localhost:4000</code>，进行以下检查：</p><ul><li><strong>视觉检查</strong>：页面样式是否完整（无错位、无缺失图标）</li><li><strong>控制台检查</strong>：按F12打开“Console”标签，确认无“404 Not Found”或“Failed to load”错误</li><li><strong>网络检查</strong>：在“Network”标签中搜索<code>jsdmirror</code>，确认所有资源均从该CDN加载</li></ul><h3 id="2-线上部署与速度测试"><a href="#2-线上部署与速度测试" class="headerlink" title="2. 线上部署与速度测试"></a>2. 线上部署与速度测试</h3><p>若本地验证无问题，部署到线上（如GitHub Pages、Gitee Pages、Vercel）后，使用以下工具测试速度提升效果：</p><h4 id="（1）基础速度检测"><a href="#（1）基础速度检测" class="headerlink" title="（1）基础速度检测"></a>（1）基础速度检测</h4><ul><li><strong>17CE</strong>：检测国内多地区节点的访问延迟，对比替换前后数据</li><li><strong>Ping.pe</strong>：测试全球节点响应速度，确保海外用户访问不受影响</li></ul><h4 id="（2）性能评分工具"><a href="#（2）性能评分工具" class="headerlink" title="（2）性能评分工具"></a>（2）性能评分工具</h4><ul><li><strong>Google PageSpeed Insights</strong>：重点关注“首次内容绘制（FCP）”和“最大内容绘制（LCP）”指标，替换后通常可提升10-30分</li><li><strong>WebPageTest</strong>：生成详细的资源加载瀑布图，查看<code>jsdmirror</code>资源的加载时间（目标：单个资源加载时间&lt;100ms）</li></ul><h2 id="五、进阶优化与风险规避"><a href="#五、进阶优化与风险规避" class="headerlink" title="五、进阶优化与风险规避"></a>五、进阶优化与风险规避</h2><h3 id="1-资源加载优化补充"><a href="#1-资源加载优化补充" class="headerlink" title="1. 资源加载优化补充"></a>1. 资源加载优化补充</h3><p>替换CDN后，可结合以下措施进一步提升速度：</p><ul><li><strong>开启Gzip压缩</strong>：在GitHub Pages中可通过配置<code>_config.yml</code>启用，或在Vercel中直接开启</li><li><strong>图片优化</strong>：使用<code>hexo-image-compressor</code>插件压缩图片，或迁移至国内图床（如阿里云OSS、腾讯云COS）</li><li><strong>减少第三方插件</strong>：卸载无用的评论、统计插件，降低资源请求数量</li></ul><h3 id="2-CDN服务风险规避"><a href="#2-CDN服务风险规避" class="headerlink" title="2. CDN服务风险规避"></a>2. CDN服务风险规避</h3><p><code>cdn.jsdmirror.com</code>作为第三方镜像，若后续出现服务不稳定，可切换至其他国内<code>jsDelivr</code>镜像，常用备选：</p><ul><li><code>https://cdn.jsdelivr.fusesearch.net/</code></li><li><code>https://jsd.onmicrosoft.cn/</code></li><li><code>https://jsdelivr.b-cdn.net/</code></li></ul><p>切换时仅需替换“域名”，保持资源路径完全一致，无需修改其他配置。</p><h3 id="3-定期检查与更新"><a href="#3-定期检查与更新" class="headerlink" title="3. 定期检查与更新"></a>3. 定期检查与更新</h3><p>建议每3-6个月检查一次CDN资源：</p><ul><li>确认使用的npm包/GitHub仓库资源是否有更新，避免使用过时版本导致安全风险</li><li>测试当前CDN的响应速度，若出现延迟升高，及时切换至其他镜像</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过将Hexo博客的<code>cdn.jsdelivr.net</code>替换为<code>cdn.jsdmirror.com</code>，可有效解决国内网络环境下的资源加载慢问题，通常能带来30%-70%的加载速度提升。整个过程核心在于“精准定位资源位置+完整替换域名”，配合本地测试与线上验证，即可确保博客稳定运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo博客提速实战：cdn-jsdelivr-net不可用&quot;&gt;&lt;a href=&quot;#Hexo博客提速实战：cdn-jsdelivr-net不可用&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客提速实战：cdn.jsdelivr.net不可用&quot;&gt;</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://nmcb666.vip/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于Task定时任务的一些事</title>
    <link href="https://nmcb666.vip/posts/12ed125b.html"/>
    <id>https://nmcb666.vip/posts/12ed125b.html</id>
    <published>2025-09-15T15:13:27.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-定时任务（Task）使用教程：从入门到精通"><a href="#Spring-Boot-定时任务（Task）使用教程：从入门到精通" class="headerlink" title="Spring Boot 定时任务（Task）使用教程：从入门到精通"></a>Spring Boot 定时任务（Task）使用教程：从入门到精通</h1><p>在日常开发中，定时任务是一个非常常见的需求，比如定时发送短信、定时生成报表、定时清理缓存等。Spring Boot 内置了 <code>spring-boot-starter</code> 模块，其中就包含了对定时任务的支持，无需额外引入复杂的第三方框架（如 Quartz），就能快速实现定时任务功能。本文将从基础到进阶，详细讲解 Spring Boot 定时任务的使用方法。</p><h2 id="一、Spring-Boot-定时任务基础"><a href="#一、Spring-Boot-定时任务基础" class="headerlink" title="一、Spring Boot 定时任务基础"></a>一、Spring Boot 定时任务基础</h2><h3 id="1-1-什么是定时任务？"><a href="#1-1-什么是定时任务？" class="headerlink" title="1.1 什么是定时任务？"></a>1.1 什么是定时任务？</h3><p>定时任务是指在预定的时间点或按照固定的时间间隔自动执行的任务。在 Java 生态中，常见的定时任务实现方式有 <code>Timer</code>、<code>ScheduledExecutorService</code>、Quartz 等，而 Spring Boot 提供的 <code>@Scheduled</code> 注解则是对这些底层实现的封装，简化了开发流程。</p><h3 id="1-2-启用定时任务"><a href="#1-2-启用定时任务" class="headerlink" title="1.2 启用定时任务"></a>1.2 启用定时任务</h3><p>Spring Boot 中启用定时任务非常简单，只需两步：</p><ol><li><strong>添加依赖</strong>：Spring Boot 的 <code>spring-boot-starter</code> 已经包含了定时任务相关的依赖，无需额外引入。如果是 Maven 项目，<code>pom.xml</code> 中默认的 <code>spring-boot-starter</code> 即可满足需求：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>开启定时任务注解</strong>：在 Spring Boot 启动类上添加 <code>@EnableScheduling</code> 注解，用于启用定时任务的自动配置：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TaskDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、简单定时任务实现"><a href="#二、简单定时任务实现" class="headerlink" title="二、简单定时任务实现"></a>二、简单定时任务实现</h2><p>启用定时任务后，只需在需要定时执行的方法上添加 <code>@Scheduled</code> 注解，并指定任务的执行时机即可。<code>@Scheduled</code> 注解支持多种定时方式，下面介绍最常用的几种。</p><h3 id="2-1-固定延迟执行（fixedDelay）"><a href="#2-1-固定延迟执行（fixedDelay）" class="headerlink" title="2.1 固定延迟执行（fixedDelay）"></a>2.1 固定延迟执行（fixedDelay）</h3><p><code>fixedDelay</code> 表示上一次任务执行完成后，间隔固定时间再执行下一次任务。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 交给 Spring 管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次任务执行完成后，间隔 3 秒执行下一次</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;固定延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间为 <code>3000ms + 任务执行耗时（1000ms）</code>，即约 4 秒。</p><h3 id="2-2-固定频率执行（fixedRate）"><a href="#2-2-固定频率执行（fixedRate）" class="headerlink" title="2.2 固定频率执行（fixedRate）"></a>2.2 固定频率执行（fixedRate）</h3><p><code>fixedRate</code> 表示按照固定的频率执行任务，无论上一次任务是否执行完成。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每隔 3 秒执行一次，不管上一次任务是否完成</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间约为 3 秒（因为任务耗时 1 秒，小于频率间隔）。如果任务耗时超过频率间隔（如任务耗时 4 秒），则上一次任务执行完成后会立即执行下一次任务。</p><h3 id="2-3-初始延迟执行（initialDelay）"><a href="#2-3-初始延迟执行（initialDelay）" class="headerlink" title="2.3 初始延迟执行（initialDelay）"></a>2.3 初始延迟执行（initialDelay）</h3><p><code>initialDelay</code> 表示任务启动后，延迟指定时间再开始执行第一次任务，之后按照 <code>fixedDelay</code> 或 <code>fixedRate</code> 执行。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 启动后延迟 5 秒执行第一次任务，之后每隔 3 秒执行一次</span></span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 5000, fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：应用启动 5 秒后，第一次执行任务，之后每 3 秒执行一次。</p><h2 id="三、Cron-表达式：灵活的定时配置"><a href="#三、Cron-表达式：灵活的定时配置" class="headerlink" title="三、Cron 表达式：灵活的定时配置"></a>三、Cron 表达式：灵活的定时配置</h2><p>如果需要更灵活的定时规则（如每天凌晨 2 点执行、每周一上午 10 点执行等），<code>fixedDelay</code> 和 <code>fixedRate</code> 就无法满足需求了，此时需要使用 <strong>Cron 表达式</strong>。</p><h3 id="3-1-Cron-表达式格式"><a href="#3-1-Cron-表达式格式" class="headerlink" title="3.1 Cron 表达式格式"></a>3.1 Cron 表达式格式</h3><p>Cron 表达式是一个字符串，由 6 或 7 个字段组成，字段之间用空格分隔。Spring Boot 中的 Cron 表达式支持 6 个字段（不支持年份），格式如下：</p><div class="callout">秒 分 时 日 月 星期</div><p>每个字段的取值范围和允许的特殊字符如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>取值范围</th><th>特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日</td><td>1-31</td><td>, - * / ? L W C</td></tr><tr><td>月</td><td>1-12 或 JAN-DEC</td><td>, - * /</td></tr><tr><td>星期</td><td>1-7 或 SUN-SAT（1 表示星期日）</td><td>, - * / ? L C #</td></tr></tbody></table></div><h3 id="3-2-常用特殊字符说明"><a href="#3-2-常用特殊字符说明" class="headerlink" title="3.2 常用特殊字符说明"></a>3.2 常用特殊字符说明</h3><ul><li><p><strong>*</strong>：表示所有可能的值，例如“秒”字段为 <code>*</code>，表示每秒执行。</p></li><li><p><strong>?</strong>：用于“日”和“星期”字段，表示不指定具体值，避免两者冲突。例如每月 10 日执行，不管是星期几，“星期”字段就填 <code>?</code>。</p></li><li><p><strong>/</strong>：表示增量，例如“分”字段为 <code>0/5</code>，表示从 0 分开始，每 5 分钟执行一次。</p></li><li><p><strong>-</strong>：表示范围，例如“时”字段为 <code>9-17</code>，表示 9 点到 17 点之间执行。</p></li><li><p><strong>,</strong>：表示多个值，例如“星期”字段为 <code>1,3,5</code>，表示星期日、星期二、星期四执行。</p></li><li><p><strong>L</strong>：表示“最后”，例如“日”字段为 <code>L</code>，表示每月最后一天；“星期”字段为 <code>L</code>，表示星期六。</p></li><li><p><strong>#</strong>：用于“星期”字段，表示每月的第几个星期几，例如 <code>6#3</code> 表示每月第三个星期五（6 表示星期五）。</p></li></ul><h3 id="3-3-Cron-表达式示例"><a href="#3-3-Cron-表达式示例" class="headerlink" title="3.3 Cron 表达式示例"></a>3.3 Cron 表达式示例</h3><ul><li><p>每秒执行：<code>* * * * * ?</code></p></li><li><p>每 5 分钟执行：<code>0 */5 * * * ?</code></p></li><li><p>每天凌晨 2 点执行：<code>0 0 2 * * ?</code></p></li><li><p>每月 10 日上午 10 点执行：<code>0 0 10 10 * ?</code></p></li><li><p>每周一到周五下午 5 点执行：<code>0 0 17 ? * 2-6</code>（2 表示星期一，6 表示星期五）</p></li><li><p>每月最后一天晚上 11 点执行：<code>0 0 23 L * ?</code></p></li></ul><h3 id="3-4-在-Scheduled-中使用-Cron-表达式"><a href="#3-4-在-Scheduled-中使用-Cron-表达式" class="headerlink" title="3.4 在 @Scheduled 中使用 Cron 表达式"></a>3.4 在 @Scheduled 中使用 Cron 表达式</h3><p>只需将 <code>@Scheduled</code> 注解的 <code>cron</code> 属性设置为对应的表达式即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每天凌晨 2 点执行</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、定时任务参数外部化配置"><a href="#四、定时任务参数外部化配置" class="headerlink" title="四、定时任务参数外部化配置"></a>四、定时任务参数外部化配置</h2><p>在实际开发中，定时任务的执行规则可能需要根据环境动态调整（如开发环境和生产环境的执行频率不同）。此时，不建议将参数硬编码在 <code>@Scheduled</code> 注解中，而是通过 <code>application.properties</code> 或 <code>application.yml</code> 进行外部化配置。</p><h3 id="4-1-使用-properties-文件配置"><a href="#4-1-使用-properties-文件配置" class="headerlink" title="4.1 使用 properties 文件配置"></a>4.1 使用 properties 文件配置</h3><p>在 <code>application.properties</code> 中添加定时任务参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 定时任务参数配置</span></span><br><span class="line"><span class="attr">task.fixedRate</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">task.cron</span>=<span class="string">0 0 2 * * ?</span></span><br></pre></td></tr></table></figure><p>在代码中通过 <code>$&#123;&#125;</code> 引用配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 fixedRate</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRateString = &quot;$&#123;task.fixedRate&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalFixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 cron 表达式</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalCronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置 Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于数值类型的参数（如 <code>fixedRate</code>、<code>fixedDelay</code>），需要使用 <code>fixedRateString</code>、<code>fixedDelayString</code> 属性来引用字符串类型的配置值。</p><h2 id="五、定时任务的高级特性"><a href="#五、定时任务的高级特性" class="headerlink" title="五、定时任务的高级特性"></a>五、定时任务的高级特性</h2><h3 id="5-1-定时任务线程池配置"><a href="#5-1-定时任务线程池配置" class="headerlink" title="5.1 定时任务线程池配置"></a>5.1 定时任务线程池配置</h3><p>Spring Boot 定时任务默认使用单线程执行，如果多个任务同时触发，会出现任务排队的情况。为了提高任务执行效率，可以配置定时任务线程池。</p><p>通过实现 <code>SchedulingConfigurer</code> 接口来配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为 5</span></span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        scheduler.setPoolSize(<span class="number">5</span>);</span><br><span class="line">        scheduler.setThreadNamePrefix(<span class="string">&quot;scheduled-task-&quot;</span>); <span class="comment">// 线程名前缀</span></span><br><span class="line">        scheduler.initialize();</span><br><span class="line">        </span><br><span class="line">        taskRegistrar.setTaskScheduler(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，定时任务会通过线程池中的线程并行执行，避免单线程瓶颈。</p><h3 id="5-2-动态调整定时任务"><a href="#5-2-动态调整定时任务" class="headerlink" title="5.2 动态调整定时任务"></a>5.2 动态调整定时任务</h3><p>如果需要在应用运行过程中动态修改定时任务的执行规则（如修改 Cron 表达式），可以通过 <code>ScheduledTaskRegistrar</code> 和 <code>Trigger</code> 接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTaskConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中读取 Cron 表达式，支持动态刷新</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;task.dynamic.cron&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String cronExpression;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态注册定时任务</span></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">            () -&gt; System.out.println(<span class="string">&quot;动态定时任务执行时间：&quot;</span> + LocalDateTime.now()),</span><br><span class="line">            triggerContext -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每次执行前重新读取 Cron 表达式，实现动态调整</span></span><br><span class="line">                <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cronExpression);</span><br><span class="line">                <span class="keyword">return</span> trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供方法修改 cronExpression</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCronExpression</span><span class="params">(String cronExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cronExpression = cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>setCronExpression</code> 方法，可以在应用运行时修改任务的执行规则。如果结合配置中心（如 Nacos、Apollo），还能实现配置的动态推送。</p><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><ul><li><p><strong>任务执行时长</strong>：如果任务执行时长超过了定时频率，会导致任务堆积。建议通过线程池配置或优化任务逻辑来避免。</p></li><li><p><strong>异常处理</strong>：定时任务方法中如果抛出未捕获的异常，会导致任务终止。建议在方法内部添加 try-catch 块，或通过全局异常处理器捕获异常。</p></li><li><p><strong>分布式环境</strong>：Spring Boot 内置的定时任务不支持分布式锁，在分布式环境下可能出现多个节点同时执行任务的情况。此时需要结合分布式锁（如 Redis 分布式锁）来保证任务的唯一性。</p></li><li><p><strong>幂等性</strong>：即使使用了分布式锁，也建议保证任务的幂等性，避免因网络抖动等问题导致任务重复执行。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Spring Boot 定时任务通过 <code>@EnableScheduling</code> 和 <code>@Scheduled</code> 注解，极大地简化了定时任务的开发。本文从基础的固定延迟、固定频率任务，到灵活的 Cron 表达式，再到参数外部化和线程池配置，最后介绍了动态任务和注意事项，覆盖了定时任务的大部分使用场景。</p><p>在实际开发中，需要根据业务需求选择合适的定时方式，并注意异常处理、分布式环境下的任务唯一性等问题。希望本文能帮助你快速掌握 Spring Boot 定时任务的使用😊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Boot-定时任务（Task）使用教程：从入门到精通&quot;&gt;&lt;a href=&quot;#Spring-Boot-定时任务（Task）使用教程：从入门到精通&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 定时任务（Task）使用教程</summary>
      
    
    
    
    
    <category term="Spring Boot" scheme="https://nmcb666.vip/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>关于Spring Security的一些事</title>
    <link href="https://nmcb666.vip/posts/3f6c5c0b.html"/>
    <id>https://nmcb666.vip/posts/3f6c5c0b.html</id>
    <published>2025-09-14T13:54:10.000Z</published>
    <updated>2025-12-31T02:05:23.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security-使用教程：从入门到实战"><a href="#Spring-Security-使用教程：从入门到实战" class="headerlink" title="Spring Security 使用教程：从入门到实战"></a>Spring Security 使用教程：从入门到实战</h1><p>在Web应用开发中，安全永远是不可忽视的环节。Spring Security作为Spring生态中成熟的安全框架，提供了全面的认证（Authentication）和授权（Authorization）解决方案。本文将从基础到进阶，带你一步步掌握Spring Security的核心用法，构建安全可靠的Java Web应用。(对的，这是Spring Security的入门篇)</p><h2 id="一、Spring-Security-核心概念"><a href="#一、Spring-Security-核心概念" class="headerlink" title="一、Spring Security 核心概念"></a>一、Spring Security 核心概念</h2><p>在开始实战前，先理解几个核心概念，有助于后续学习：</p><ul><li><p><strong>认证（Authentication）</strong>：验证用户身份的过程，比如登录时校验用户名和密码是否正确。</p></li><li><p><strong>授权（Authorization）</strong>：在认证通过后，判断用户是否有权限执行某个操作（如访问特定接口、修改数据）。</p></li><li><p><strong>SecurityContext</strong>：存储当前认证用户的信息，通过<code>SecurityContextHolder</code>可以随时获取。</p></li><li><p><strong>UserDetails</strong>：封装用户信息的接口，包含用户名、密码、权限等核心字段。</p></li><li><p><strong>AuthenticationManager</strong>：认证的核心管理器，负责调度<code>AuthenticationProvider</code>完成认证。</p></li></ul><h2 id="二、环境搭建：快速集成Spring-Security"><a href="#二、环境搭建：快速集成Spring-Security" class="headerlink" title="二、环境搭建：快速集成Spring Security"></a>二、环境搭建：快速集成Spring Security</h2><p>本文基于<strong>Spring Boot 3.x</strong>进行演示，Spring Boot已为Spring Security提供了自动配置，集成过程非常简单。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><p>在<code>pom.xml</code>（Maven）或<code>build.gradle</code>（Gradle）中添加Spring Security依赖：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0-M2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="2-2-启动应用，体验默认安全配置"><a href="#2-2-启动应用，体验默认安全配置" class="headerlink" title="2.2 启动应用，体验默认安全配置"></a>2.2 启动应用，体验默认安全配置</h3><p>添加依赖后，直接启动Spring Boot应用，Spring Security会自动生效，默认做了以下安全配置：</p><ol><li><p>所有接口默认需要认证才能访问。</p></li><li><p>生成一个默认用户，用户名是<code>user</code>，密码会在控制台输出（格式如：<code>Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code>）。</p></li><li><p>提供一个默认的登录页面（访问任意接口会自动跳转）。</p></li></ol><p>测试：访问<code>http://localhost:8080/hello</code>（需先编写一个简单的Hello接口），会跳转至登录页，输入默认用户名和密码即可访问。</p><h2 id="三、自定义认证：从默认到数据库"><a href="#三、自定义认证：从默认到数据库" class="headerlink" title="三、自定义认证：从默认到数据库"></a>三、自定义认证：从默认到数据库</h2><p>默认配置仅用于测试，实际项目中需要对接数据库用户，下面实现自定义认证逻辑。</p><h3 id="3-1-编写配置类"><a href="#3-1-编写配置类" class="headerlink" title="3.1 编写配置类"></a>3.1 编写配置类</h3><p>创建<code>SecurityConfig</code>类，继承<code>WebSecurityConfigurerAdapter</code>（Spring Boot 3.x中已 deprecated，推荐使用函数式风格配置）：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入自定义的UserDetailsService（后续实现）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityConfig</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置密码加密器（Spring Security 5+要求必须指定密码加密方式）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置SecurityFilterChain（核心配置）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 关闭CSRF（测试环境可关闭，生产环境需开启）</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            <span class="comment">// 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                <span class="comment">// 放行登录接口、静态资源等</span></span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 其他所有接口需要认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置表单登录</span></span><br><span class="line">            .formLogin(form -&gt; form</span><br><span class="line">                <span class="comment">// 自定义登录页面路径（可选，默认是/spring-security-login）</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/custom-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录请求的接口路径（默认是/login）</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/do-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录成功后的跳转路径</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 登录失败后的跳转路径</span></span><br><span class="line">                .failureUrl(<span class="string">&quot;/custom-login?error=true&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置退出登录</span></span><br><span class="line">            .logout(logout -&gt; logout</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/custom-login?logout=true&quot;</span>)</span><br><span class="line">                .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 销毁session</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="3-2-实现UserDetailsService"><a href="#3-2-实现UserDetailsService" class="headerlink" title="3.2 实现UserDetailsService"></a>3.2 实现UserDetailsService</h3><p><code>UserDetailsService</code>负责从数据库加载用户信息，我们需要实现它来对接自己的用户表：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用户DAO（实际项目中替换为MyBatis或JPA的Repository）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomUserDetailsService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 从数据库查询用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据库用户转换为UserDetails对象（包含权限信息）</span></span><br><span class="line">        <span class="keyword">return</span> User.withUsername(user.getUsername())</span><br><span class="line">                .password(user.getPassword()) <span class="comment">// 数据库中存储的密码必须是加密后的</span></span><br><span class="line">                .roles(user.getRoles().split(<span class="string">&quot;,&quot;</span>)) <span class="comment">// 假设roles字段是逗号分隔的角色字符串</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="callout">注意：数据库中存储的密码必须是通过`BCryptPasswordEncoder`加密后的字符串，不能存储明文。可以通过`passwordEncoder.encode("123456")`生成加密密码。</div><h2 id="四、授权控制：基于角色和权限"><a href="#四、授权控制：基于角色和权限" class="headerlink" title="四、授权控制：基于角色和权限"></a>四、授权控制：基于角色和权限</h2><p>认证通过后，需要对不同用户授予不同权限，Spring Security支持多种授权方式。</p><h3 id="4-1-基于角色的URL授权"><a href="#4-1-基于角色的URL授权" class="headerlink" title="4.1 基于角色的URL授权"></a>4.1 基于角色的URL授权</h3><p>在<code>securityFilterChain</code>中通过<code>hasRole</code>或<code>hasAnyRole</code>配置URL的角色权限：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// 只有ADMIN角色可访问/admin下的接口</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>) <span class="comment">// ADMIN或USER角色可访问</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/public/**&quot;</span>).permitAll() <span class="comment">// 公开接口，无需认证</span></span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="4-2-基于注解的方法级授权"><a href="#4-2-基于注解的方法级授权" class="headerlink" title="4.2 基于注解的方法级授权"></a>4.2 基于注解的方法级授权</h3><p>在Controller方法上使用注解控制权限，需先开启全局方法安全：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span> <span class="comment">// 开启PreAuthorize注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在Controller方法上使用注解：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有ADMIN角色的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-manage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">manageUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户管理页面&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有DELETE权限的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;DELETE&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除用户：&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="五、进阶功能：记住我与JWT"><a href="#五、进阶功能：记住我与JWT" class="headerlink" title="五、进阶功能：记住我与JWT"></a>五、进阶功能：记住我与JWT</h2><p>除了基础的认证授权，Spring Security还支持“记住我”、JWT令牌等高级功能。</p><h3 id="5-1-实现“记住我”功能"><a href="#5-1-实现“记住我”功能" class="headerlink" title="5.1 实现“记住我”功能"></a>5.1 实现“记住我”功能</h3><p>只需在<code>securityFilterChain</code>中添加<code>rememberMe</code>配置：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.rememberMe(remember -&gt; remember</span><br><span class="line">    .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中的记住我参数名</span></span><br><span class="line">    .tokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>) <span class="comment">// 记住我有效期（7天）</span></span><br><span class="line">    .userDetailsService(userDetailsService) <span class="comment">// 加载用户信息</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在登录表单中添加一个名为<code>remember-me</code>的复选框即可。</p><h3 id="5-2-集成JWT实现无状态认证"><a href="#5-2-集成JWT实现无状态认证" class="headerlink" title="5.2 集成JWT实现无状态认证"></a>5.2 集成JWT实现无状态认证</h3><p>对于前后端分离项目，通常使用JWT（JSON Web Token）实现无状态认证，核心步骤如下：</p><ol><li><p><strong>引入JWT依赖</strong>：添加<code>jjwt-api</code>、<code>jjwt-impl</code>、<code>jjwt-jackson</code>依赖。</p></li><li><p><strong>编写JWT工具类</strong>：实现Token的生成、解析、验证逻辑。</p></li><li><p><strong>自定义JwtAuthenticationFilter</strong>：从请求头中获取Token，解析后完成认证。</p></li><li><p><strong>配置SecurityFilterChain</strong>：关闭session，添加JWT过滤器，放行登录接口等。</p></li></ol><p>由于JWT集成步骤较多，后续会单独写一篇实战文章，感兴趣的可以关注。</p><h2 id="六、常见问题与排查"><a href="#六、常见问题与排查" class="headerlink" title="六、常见问题与排查"></a>六、常见问题与排查</h2><ul><li><p><strong>密码加密失败</strong>：确保数据库中存储的是加密后的密码，且配置了正确的<code>PasswordEncoder</code>。</p></li><li><p><strong>接口授权不生效</strong>：检查URL匹配规则的顺序（具体规则要放在通用规则前面），以及角色/权限名称是否正确（<code>hasRole</code>会自动添加<code>ROLE_</code>前缀，<code>hasAuthority</code>需要完整名称）。</p></li><li><p><strong>CSRF问题</strong>：前后端分离项目中，若关闭CSRF，需确保请求头中没有携带CSRF Token；若开启，需在前端请求中添加Token。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本文介绍了Spring Security的核心概念、环境搭建、自定义认证、授权控制及进阶功能，涵盖了大部分实际项目中的常用场景。Spring Security功能强大且灵活，掌握它能有效提升应用的安全性。建议结合实际项目多动手实践，深入理解其核心原理（如过滤器链、认证流程等），以便应对更复杂的安全需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Security-使用教程：从入门到实战&quot;&gt;&lt;a href=&quot;#Spring-Security-使用教程：从入门到实战&quot; class=&quot;headerlink&quot; title=&quot;Spring Security 使用教程：从入门到实战&quot;&gt;&lt;/a&gt;Sprin</summary>
      
    
    
    
    
    <category term="Spring Boot" scheme="https://nmcb666.vip/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>计算机技术</title>
    <link href="https://nmcb666.vip/posts/b67a9f87.html"/>
    <id>https://nmcb666.vip/posts/b67a9f87.html</id>
    <published>2025-09-13T22:53:06.000Z</published>
    <updated>2025-12-31T02:05:23.122Z</updated>
    
    <content type="html"><![CDATA[<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg><h1 id="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"><a href="#从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互" class="headerlink" title="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"></a>从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互</h1><p>在十年前，打开一个大型文档需要等待几十秒、视频通话时频繁出现“马赛克”、手机多开几个APP就会闪退，这些场景对大多数人来说都司空见惯。而如今，我们早已习惯了“即点即开”的文档编辑、4K画质的实时视频会议、手机后台同时运行十几个应用仍流畅切换——这些“丝滑”体验的背后，并非只是“硬件变好了”这么简单，而是计算机技术在<strong>存储架构、网络传输、系统优化</strong>等多个维度协同进化的结果。今天，我们就从日常场景切入，聊聊那些“看不见却离不开”的技术进步。</p><h2 id="一、存储技术：从“机械等待”到“电子秒达”"><a href="#一、存储技术：从“机械等待”到“电子秒达”" class="headerlink" title="一、存储技术：从“机械等待”到“电子秒达”"></a>一、存储技术：从“机械等待”到“电子秒达”</h2><p>打开电脑时，系统启动速度的快慢，很大程度上取决于存储设备的性能。十年前主流的机械硬盘（HDD），就像一个“带转盘的档案柜”：读写数据时，需要先让磁盘高速旋转（通常是5400转/分钟或7200转/分钟），再让磁头移动到指定位置“查找”数据——这个过程虽然比早期的软盘快，但仍有明显的“等待时间”（平均寻道时间约8-12毫秒）。</p><p>而现在主流的固态硬盘（SSD），彻底抛弃了“机械结构”，改用<strong>NAND闪存芯片</strong>存储数据，就像把“档案柜”换成了“电子货架”：数据通过电信号直接读写，无需等待磁盘旋转或磁头移动，平均响应时间可以做到0.1毫秒以内——这意味着，从“点击开机”到“进入桌面”，时间从原来的1-2分钟压缩到了10-20秒，甚至更短。</p><p>更关键的是，SSD的进步还在持续：</p><ul><li><strong>NVMe协议</strong>的普及：相比早期SSD使用的SATA接口，NVMe直接通过PCIe总线与CPU通信，带宽提升了10倍以上，读写速度从“几百MB/s”跃升到“几GB/s”，打开4K视频文件、大型设计软件时几乎没有延迟。</li><li><strong>QLC闪存的成本下降</strong>：早期SSD因成本高，容量普遍在128GB-256GB；而现在1TB容量的QLC SSD价格已非常亲民，既能满足日常文件存储，也能装下多个大型游戏或专业软件。</li></ul><p>对普通用户来说，存储技术的进步不是“参数的胜利”，而是“打开文件不用等、编辑视频不卡顿”的实在体验。</p><h2 id="二、网络传输：从“断断续续”到“实时互动”"><a href="#二、网络传输：从“断断续续”到“实时互动”" class="headerlink" title="二、网络传输：从“断断续续”到“实时互动”"></a>二、网络传输：从“断断续续”到“实时互动”</h2><p>疫情期间，远程办公和在线学习成为常态，很多人都经历过“视频会议卡成PPT”“在线课堂声音延迟”的尴尬。这背后的核心问题，是早期网络传输在<strong>带宽、延迟、稳定性</strong>上的不足。而现在，这些问题的缓解，离不开两项关键技术的成熟：</p><h3 id="1-5G与Wi-Fi-6：解决“带宽不够用”的问题"><a href="#1-5G与Wi-Fi-6：解决“带宽不够用”的问题" class="headerlink" title="1. 5G与Wi-Fi 6：解决“带宽不够用”的问题"></a>1. 5G与Wi-Fi 6：解决“带宽不够用”的问题</h3><ul><li>5G网络的峰值速率可达10Gbps，是4G的10-100倍，即使在户外用手机开热点参加视频会议，也能支持4K画质的实时传输；</li><li>Wi-Fi 6（802.11ax）的单设备速率提升到9.6Gbps，同时支持更多设备连接（最多可同时连接100+设备）——这意味着，家里的电视、手机、电脑、智能音箱同时联网，也不会出现“抢网速”导致的卡顿。</li></ul><h3 id="2-边缘计算：降低“数据跑太远”的延迟"><a href="#2-边缘计算：降低“数据跑太远”的延迟" class="headerlink" title="2. 边缘计算：降低“数据跑太远”的延迟"></a>2. 边缘计算：降低“数据跑太远”的延迟</h3><p>传统的网络架构中，我们的视频通话数据需要先传到远方的“中心服务器”，再转发给对方，这个过程会产生几十甚至上百毫秒的延迟（即“网络时延”）。而边缘计算则把“服务器”搬到了离用户更近的地方（比如城市的基站、区域数据中心），数据传输距离缩短，时延可以降低到10毫秒以内——这也是为什么现在的“实时连麦”“云游戏”能做到“操作无延迟”的关键。</p><p>举个例子：以前玩云游戏，按下“射击”按钮后，需要等1-2秒才能看到画面反应；现在有了边缘计算和高速网络，延迟几乎可以忽略，体验和在本地玩游戏没什么区别。</p><h2 id="三、系统优化：从“资源浪费”到“智能调度”"><a href="#三、系统优化：从“资源浪费”到“智能调度”" class="headerlink" title="三、系统优化：从“资源浪费”到“智能调度”"></a>三、系统优化：从“资源浪费”到“智能调度”</h2><p>除了硬件和网络，操作系统的优化同样重要。早期的系统（比如Windows XP、安卓4.0）对硬件资源的调度能力较弱，比如：</p><ul><li>打开多个APP后，后台应用不会“主动释放内存”，导致可用内存越来越少，手机或电脑越来越卡；</li><li>CPU资源分配“一刀切”，不管是微信聊天还是视频渲染，都用同样的性能模式，既浪费电量，又无法满足高负载需求。</li></ul><p>而现在的操作系统（如Windows 11、安卓14），通过<strong>智能资源调度</strong>技术，让硬件性能“用在刀刃上”：</p><h3 id="1-内存管理：“动态回收”与“压缩优化”"><a href="#1-内存管理：“动态回收”与“压缩优化”" class="headerlink" title="1. 内存管理：“动态回收”与“压缩优化”"></a>1. 内存管理：“动态回收”与“压缩优化”</h3><ul><li>安卓系统的“墓碑机制”（Android 12后优化）：当APP进入后台时，系统会“冻结”其占用的内存，不再让它消耗资源；如果内存不足，会自动回收优先级低的后台APP内存，保证前台应用流畅运行。</li><li>Windows的“内存压缩”：当物理内存不足时，系统会将不常用的内存数据压缩（压缩率可达50%以上），而不是直接写入硬盘（虚拟内存），避免了因硬盘速度慢导致的卡顿。</li></ul><h3 id="2-CPU调度：“按需分配”与“能效平衡”"><a href="#2-CPU调度：“按需分配”与“能效平衡”" class="headerlink" title="2. CPU调度：“按需分配”与“能效平衡”"></a>2. CPU调度：“按需分配”与“能效平衡”</h3><ul><li>手机的“异构计算”：现在的手机CPU大多是“多核心架构”（比如4个小核+4个大核），系统会根据任务轻重分配核心：聊微信时用低功耗小核，省电量；玩游戏时调用高性能大核，保证帧率稳定。</li><li>Windows的“性能模式”：用户可以根据需求切换“节能模式”“平衡模式”“高性能模式”，比如外出办公时用节能模式延长续航，做视频剪辑时开高性能模式提升效率。</li></ul><h2 id="四、技术的终极目标：让“复杂”隐于“无形”"><a href="#四、技术的终极目标：让“复杂”隐于“无形”" class="headerlink" title="四、技术的终极目标：让“复杂”隐于“无形”"></a>四、技术的终极目标：让“复杂”隐于“无形”</h2><p>回顾计算机技术的发展，我们会发现一个规律：真正优秀的技术，从来不是让用户去“理解它”，而是让用户“感受不到它的存在”——就像我们不会在意SSD的闪存芯片如何工作，也不会关心Wi-Fi 6的协议细节，我们只需要“打开文件很快”“视频通话很流畅”。</p><p>未来，随着AI与计算机技术的融合（比如AI驱动的智能内存调度、AI优化的网络传输路径），我们的交互体验还会进一步升级：可能电脑会“预判”你要打开的文件，提前加载到内存；可能网络会“自动避开”拥堵路段，保证视频会议不卡顿。</p><p>技术的进步，最终是为了“让工具回归工具的本质”——让我们不再被“卡顿”“等待”困扰，而是更专注于内容创作、沟通协作，或者单纯地享受数字生活的乐趣。这，或许就是计算机技术最动人的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;object class=&quot;ghbdage&quot; style=&quot;margin-inline:5px&quot; title=&quot;&quot; standby=&quot;loading...&quot; data=&quot;https://img.shields.io/badge/Butterfly-Theme-orange?lo</summary>
      
    
    
    
    
    <category term="计算机杂谈" scheme="https://nmcb666.vip/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
