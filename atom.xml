<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2025-09-16T06:19:33.641Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机与数学的那些事</title>
    <link href="https://nmcb666.vip/posts/f8b7ba6f.html"/>
    <id>https://nmcb666.vip/posts/f8b7ba6f.html</id>
    <published>2025-09-16T14:12:43.000Z</published>
    <updated>2025-09-16T06:19:33.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学计算机一定要数学好吗？不同岗位需求大不同"><a href="#学计算机一定要数学好吗？不同岗位需求大不同" class="headerlink" title="学计算机一定要数学好吗？不同岗位需求大不同"></a>学计算机一定要数学好吗？不同岗位需求大不同</h1><p>“我数学不好，是不是学不了计算机？”这是很多想入行计算机领域的人都会问的问题。其实这个问题没有绝对的答案，核心在于你想从事计算机领域的哪个岗位。在我看来，<strong>普通开发岗对数学功底的要求并不高，而算法岗和人工智能岗则需要扎实且甚至高于计算机知识本身的数学基础</strong>。今天就来详细聊聊不同岗位对数学的真实需求，帮大家消除认知误区。</p><h2 id="一、普通开发岗：数学是“加分项”而非“必需品”"><a href="#一、普通开发岗：数学是“加分项”而非“必需品”" class="headerlink" title="一、普通开发岗：数学是“加分项”而非“必需品”"></a>一、普通开发岗：数学是“加分项”而非“必需品”</h2><p>普通开发岗涵盖的范围很广，比如前端开发、后端开发、移动端开发、全栈开发等，这些岗位的核心是“实现业务需求”，更看重的是编程能力、逻辑思维和业务理解能力，对数学的要求远没有大家想象中那么高。</p><p>以前端开发为例，日常工作主要是用HTML、CSS、JavaScript构建用户界面，实现页面交互效果。即使是用到React、Vue等框架，核心也是组件化思想和状态管理，涉及到的数学知识可能最多就是简单的布局计算（比如用Flex或Grid布局时的百分比、像素换算），连初中数学知识都能应对。后端开发虽然会接触到数据库、服务器等，但更多是掌握编程语言（如Java、Python、Go）、框架（如Spring、Django）和数据库优化技巧，数学知识的应用场景少之又少。</p><p>我身边有不少做普通开发的学长，大学时数学成绩并不突出，但凭借扎实的编程基础和不断积累的业务经验，照样能成为团队里的骨干。当然，这并不是说数学对普通开发岗毫无用处——如果懂一点离散数学，在理解数据结构（如树、图）时会更轻松；如果懂一点线性代数，在处理图形相关的开发任务时可能会更得心应手。但这些都属于“加分项”，而非“入门必备项”，不会成为阻碍你入行和发展的绊脚石。</p><h2 id="二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要"><a href="#二、算法岗-amp-人工智能岗：数学是“基石”，甚至比计算机知识更重要" class="headerlink" title="二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要"></a>二、算法岗&amp;人工智能岗：数学是“基石”，甚至比计算机知识更重要</h2><p>与普通开发岗不同，算法岗（如机器学习算法工程师、推荐算法工程师）和人工智能岗（如AI研究员、深度学习工程师）对数学的要求极高，数学知识是开展工作的核心基础，甚至在很多场景下比单纯的计算机知识更重要。</p><p>这些岗位的工作本质是“解决复杂问题”，需要通过数学模型来抽象现实问题，并设计高效的算法来求解。这就要求从业者必须掌握多门高等数学知识：</p><ul><li><p><strong>线性代数</strong>：是机器学习的基础，比如数据的表示（向量、矩阵）、特征变换（矩阵乘法、特征值分解）、降维算法（PCA）等，都离不开线性代数的知识。如果不懂矩阵运算，连最简单的神经网络前向传播都无法理解。</p></li><li><p><strong>概率论与数理统计</strong>：在处理不确定性问题时至关重要，比如贝叶斯分类器、概率模型（如隐马尔可夫模型）、模型评估指标（准确率、召回率、ROC曲线）等，都需要概率论和统计学的支撑。</p></li><li><p><strong>微积分</strong>：主要用于优化算法，比如机器学习中的梯度下降法，就是通过求导来找到函数的最小值点，从而更新模型参数。如果不懂导数、偏导数，就无法理解优化算法的原理，更谈不上调优模型。</p></li><li><p><strong>离散数学</strong>：在图算法、组合优化等领域应用广泛，比如最短路径算法（Dijkstra、Floyd）、图神经网络（GNN）等，都需要离散数学的知识作为铺垫。</p></li></ul><p>举个例子，如果你想做深度学习工程师，搭建一个神经网络模型可能用TensorFlow或PyTorch几行代码就能实现，但要想让模型达到更好的效果——比如调整网络结构、优化损失函数、解决过拟合问题，就必须深入理解模型背后的数学原理。如果数学基础薄弱，只能停留在“调参工程师”的层面，无法真正成为一名优秀的算法或AI工程师。很多顶尖的AI研究员，本身就是数学专业出身，可见数学在这个领域的重要性。</p><h2 id="三、总结：根据目标岗位，合理规划数学学习"><a href="#三、总结：根据目标岗位，合理规划数学学习" class="headerlink" title="三、总结：根据目标岗位，合理规划数学学习"></a>三、总结：根据目标岗位，合理规划数学学习</h2><p>回到最初的问题“学计算机一定要数学好吗？”，答案已经很清晰了：</p><div class="tip warning faa-horizontal animated"><p>如果你目标是普通开发岗，不用因为数学不好而焦虑，重点放在提升编程能力和逻辑思维上，数学可以作为后续提升的补充；如果你目标是算法岗或人工智能岗，那么一定要打好数学基础，把线性代数、概率论、微积分等核心知识学扎实，这比单纯掌握编程语言和框架更重要。</p></div><p>计算机领域博大精深，不同岗位的需求差异很大。关键是明确自己的职业方向，然后有针对性地学习。不要被“数学不好就不能学计算机”的误区吓住，也不要忽视算法和AI岗对数学的高要求。希望这篇文章能帮大家更清晰地认识计算机与数学的关系，祝大家在计算机的道路上走得更远！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学计算机一定要数学好吗？不同岗位需求大不同&quot;&gt;&lt;a href=&quot;#学计算机一定要数学好吗？不同岗位需求大不同&quot; class=&quot;headerlink&quot; title=&quot;学计算机一定要数学好吗？不同岗位需求大不同&quot;&gt;&lt;/a&gt;学计算机一定要数学好吗？不同岗位需求大不同&lt;/</summary>
      
    
    
    
    
    <category term="计算机杂谈" scheme="https://nmcb666.vip/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>jsdelivr不可用替代方案</title>
    <link href="https://nmcb666.vip/posts/6acc4ad2.html"/>
    <id>https://nmcb666.vip/posts/6acc4ad2.html</id>
    <published>2025-09-16T09:57:48.000Z</published>
    <updated>2025-09-16T06:19:33.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客提速实战：cdn-jsdelivr-net不可用"><a href="#Hexo博客提速实战：cdn-jsdelivr-net不可用" class="headerlink" title="Hexo博客提速实战：cdn.jsdelivr.net不可用"></a>Hexo博客提速实战：cdn.jsdelivr.net不可用</h1><p>对于使用Hexo搭建个人博客的开发者和博主而言，网站加载速度直接影响用户体验与内容传播效果。不少用户在运营过程中会发现，博客打开缓慢、样式加载延迟甚至部分资源失效，排查后往往能定位到核心问题——默认依赖的<code>cdn.jsdelivr.net</code>在国内网络环境下表现不佳。本文将从问题根源出发，提供一套完整的CDN替换方案，帮助你快速解决Hexo博客速度难题。</p><h2 id="一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？"><a href="#一、现象与根源：为什么cdn-jsdelivr-net会拖慢博客？" class="headerlink" title="一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？"></a>一、现象与根源：为什么cdn.jsdelivr.net会拖慢博客？</h2><p>在分析解决方案前，我们先明确<code>cdn.jsdelivr.net</code>导致Hexo博客速度慢的核心原因，避免盲目优化：</p><h3 id="1-网络环境的天然限制"><a href="#1-网络环境的天然限制" class="headerlink" title="1. 网络环境的天然限制"></a>1. 网络环境的天然限制</h3><p><code>jsDelivr</code>作为全球通用的开源CDN服务，其核心节点主要分布在北美、欧洲等海外地区。国内用户访问时，数据需经过跨境网络链路传输，受国际带宽、路由跳转等因素影响，延迟通常高达100-800ms，部分地区甚至出现数据包丢失。</p><h3 id="2-资源加载的连锁反应"><a href="#2-资源加载的连锁反应" class="headerlink" title="2. 资源加载的连锁反应"></a>2. 资源加载的连锁反应</h3><p>Hexo主题（如Next、Butterfly、Matery）默认依赖<code>jsDelivr</code>加载大量关键资源，包括：</p><ul><li>样式文件：CSS框架（Bootstrap）、图标库（Font Awesome）</li><li>脚本文件：交互插件（jQuery）、代码高亮（Prism.js）、评论系统（Valine）</li><li>静态资源：字体文件、主题图片、第三方组件</li></ul><p>这些资源若加载延迟，会导致页面“白屏时间”延长、样式错乱，甚至触发浏览器的“资源加载超时”错误。</p><h3 id="3-国内镜像的优势"><a href="#3-国内镜像的优势" class="headerlink" title="3. 国内镜像的优势"></a>3. 国内镜像的优势</h3><p><code>cdn.jsdmirror.com</code>是专为国内用户搭建的<code>jsDelivr</code>镜像服务，具备三大核心优势：</p><ul><li><strong>节点覆盖广</strong>：在国内30+城市部署节点，用户访问时自动匹配最近节点，延迟可降至50ms以内</li><li><strong>同步速度快</strong>：实时同步<code>jsDelivr</code>的GitHub仓库与npm包资源，资源更新无延迟</li><li><strong>访问稳定性高</strong>：规避跨境网络波动，支持HTTPS加密访问，兼容所有主流浏览器</li></ul><h2 id="二、替换前的准备工作"><a href="#二、替换前的准备工作" class="headerlink" title="二、替换前的准备工作"></a>二、替换前的准备工作</h2><p>为确保替换过程顺利，避免操作失误导致博客异常，需提前完成以下准备：</p><h3 id="1-核心文件备份"><a href="#1-核心文件备份" class="headerlink" title="1. 核心文件备份"></a>1. 核心文件备份</h3><ul><li>备份Hexo根目录下的<code>_config.yml</code>（全局配置文件）</li><li>备份主题目录（如<code>themes/next</code>、<code>themes/butterfly</code>），建议压缩为ZIP文件存储</li><li>若使用Git管理博客，可先提交当前版本，便于后续回滚</li></ul><h3 id="2-资源依赖排查"><a href="#2-资源依赖排查" class="headerlink" title="2. 资源依赖排查"></a>2. 资源依赖排查</h3><p>通过浏览器开发者工具（F12）定位所有<code>jsDelivr</code>资源：</p><ol><li>打开博客页面，按F12打开“开发者工具”</li><li>切换至“Network”标签，刷新页面</li><li>在搜索框输入<code>cdn.jsdelivr.net</code>，筛选出所有依赖该CDN的资源</li><li>记录资源类型（CSS/JS/Font）、链接地址及所在文件，避免替换遗漏</li></ol><h3 id="3-本地环境确认"><a href="#3-本地环境确认" class="headerlink" title="3. 本地环境确认"></a>3. 本地环境确认</h3><p>确保本地已搭建完整的Hexo运行环境：</p><ul><li>检查Node.js版本（建议v14+）：<code>node -v</code></li><li>检查Hexo CLI版本（建议v6+）：<code>hexo -v</code></li><li>测试本地服务可用性：在根目录执行<code>hexo s</code>，确认<code>http://localhost:4000</code>可正常访问</li></ul><h2 id="三、分主题替换教程（覆盖主流主题）"><a href="#三、分主题替换教程（覆盖主流主题）" class="headerlink" title="三、分主题替换教程（覆盖主流主题）"></a>三、分主题替换教程（覆盖主流主题）</h2><p>不同Hexo主题的资源配置位置存在差异，以下针对3个最常用主题，提供 step-by-step 替换指南：</p><u>为了方便可以直接在编辑器中进行全局替换，将所有`cdn.jsdelivr.net`替换为`cdn.jsdmirror.com`</u><emp>如果生效，则无需下面的步骤</emp><h3 id="1-Next主题（v8-x-v9-x）"><a href="#1-Next主题（v8-x-v9-x）" class="headerlink" title="1. Next主题（v8.x - v9.x）"></a>1. Next主题（v8.x - v9.x）</h3><p>Next主题的CDN配置分散在<strong>主题配置文件</strong>和<strong>布局模板文件</strong>中，需分两步替换：</p><h4 id="步骤1：修改主题配置文件（themes-next-config-yml）"><a href="#步骤1：修改主题配置文件（themes-next-config-yml）" class="headerlink" title="步骤1：修改主题配置文件（themes/next/_config.yml）"></a>步骤1：修改主题配置文件（themes/next/_config.yml）</h4><p>用文本编辑器打开该文件，按<code>Ctrl+F</code>搜索<code>cdn.jsdelivr.net</code>，逐一替换以下资源：</p><ul><li><strong>字体图标（Font Awesome）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdmirror.com/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>代码高亮（Prism.js）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">//cdn.jsdmirror.com/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>评论系统（Valine）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">//cdn.jsdmirror.com/npm/valine@1.4.18/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="步骤2：修改布局模板中的硬编码资源"><a href="#步骤2：修改布局模板中的硬编码资源" class="headerlink" title="步骤2：修改布局模板中的硬编码资源"></a>步骤2：修改布局模板中的硬编码资源</h4><p>进入<code>themes/next/layout</code>目录，搜索所有文件中的<code>cdn.jsdelivr.net</code>：</p><ol><li>打开<code>_partials/head.swig</code>，替换CSS资源引用</li><li>打开<code>_partials/footer.swig</code>，替换JS资源引用</li><li>打开<code>_third-party/comments/valine.swig</code>（若使用Valine），确认评论组件CDN已替换</li></ol><h3 id="2-Butterfly主题（v4-x-v5-x）"><a href="#2-Butterfly主题（v4-x-v5-x）" class="headerlink" title="2. Butterfly主题（v4.x - v5.x）"></a>2. Butterfly主题（v4.x - v5.x）</h3><p>Butterfly主题的CDN配置高度集中，主要在<strong>主题配置文件</strong>中：</p><h4 id="步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）"><a href="#步骤1：修改主题核心CDN配置（themes-butterfly-config-yml）" class="headerlink" title="步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）"></a>步骤1：修改主题核心CDN配置（themes/butterfly/_config.yml）</h4><p>找到<code>CDN</code>相关配置段，替换以下关键资源：</p><ul><li><strong>基础框架（jQuery + Bootstrap）</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.6.4/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="string">https://cdn.jsdmirror.com/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js</span></span><br></pre></td></tr></table></figure></li><li><strong>图标与高亮</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdelivr.net/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">iconify:</span> <span class="string">https://cdn.jsdmirror.com/npm/iconify-icon@1.0.7/dist/iconify-icon.min.js</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">https://cdn.jsdmirror.com/npm/highlight.js@11.8.0/styles/atom-one-dark.min.css</span></span><br></pre></td></tr></table></figure></li><li><strong>第三方插件（如阅读进度、目录）</strong><br>继续向下搜索，替换<code>tocbot</code>、<code>nprogress</code>等插件的CDN链接，确保无遗漏。</li></ul><h4 id="步骤2：检查自定义页面资源"><a href="#步骤2：检查自定义页面资源" class="headerlink" title="步骤2：检查自定义页面资源"></a>步骤2：检查自定义页面资源</h4><p>若在<code>source</code>目录下创建了自定义页面（如<code>about.md</code>、<code>links.md</code>），需打开文件检查是否有内嵌的<code>jsDelivr</code>链接，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原链接 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 替换后 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="3-Matery主题（v1-x）"><a href="#3-Matery主题（v1-x）" class="headerlink" title="3. Matery主题（v1.x）"></a>3. Matery主题（v1.x）</h3><p>Matery主题的资源配置在<strong>主题配置文件</strong>和<strong>HTML模板</strong>中：</p><h4 id="步骤1：修改主题配置（themes-matery-config-yml）"><a href="#步骤1：修改主题配置（themes-matery-config-yml）" class="headerlink" title="步骤1：修改主题配置（themes/matery/_config.yml）"></a>步骤1：修改主题配置（themes/matery/_config.yml）</h4><p>替换<code>CDN</code>部分的资源：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdelivr.net/npm/layer@3.5.1/dist/layer.min.js</span></span><br><span class="line"><span class="comment"># 替换后</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">layer:</span> <span class="string">https://cdn.jsdmirror.com/npm/layer@3.5.1/dist/layer.min.js</span></span><br></pre></td></tr></table></figure></p><h4 id="步骤2：修改HTML模板（themes-matery-layout-partial）"><a href="#步骤2：修改HTML模板（themes-matery-layout-partial）" class="headerlink" title="步骤2：修改HTML模板（themes/matery/layout/_partial）"></a>步骤2：修改HTML模板（themes/matery/layout/_partial）</h4><p>打开<code>head.html</code>和<code>footer.html</code>，替换模板中硬编码的CDN链接，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 替换后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdmirror.com/npm/mdui@0.4.3/dist/css/mdui.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="四、替换后的验证与测试"><a href="#四、替换后的验证与测试" class="headerlink" title="四、替换后的验证与测试"></a>四、替换后的验证与测试</h2><p>完成替换后，需通过多维度测试确保博客正常运行且速度提升：</p><h3 id="1-本地环境验证"><a href="#1-本地环境验证" class="headerlink" title="1. 本地环境验证"></a>1. 本地环境验证</h3><p>在Hexo根目录执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存（关键步骤，避免旧资源干扰）</span></span><br><span class="line">hexo s      <span class="comment"># 启动本地服务器</span></span><br></pre></td></tr></table></figure><br>打开浏览器访问<code>http://localhost:4000</code>，进行以下检查：</p><ul><li><strong>视觉检查</strong>：页面样式是否完整（无错位、无缺失图标）</li><li><strong>控制台检查</strong>：按F12打开“Console”标签，确认无“404 Not Found”或“Failed to load”错误</li><li><strong>网络检查</strong>：在“Network”标签中搜索<code>jsdmirror</code>，确认所有资源均从该CDN加载</li></ul><h3 id="2-线上部署与速度测试"><a href="#2-线上部署与速度测试" class="headerlink" title="2. 线上部署与速度测试"></a>2. 线上部署与速度测试</h3><p>若本地验证无问题，部署到线上（如GitHub Pages、Gitee Pages、Vercel）后，使用以下工具测试速度提升效果：</p><h4 id="（1）基础速度检测"><a href="#（1）基础速度检测" class="headerlink" title="（1）基础速度检测"></a>（1）基础速度检测</h4><ul><li><strong>17CE</strong>：检测国内多地区节点的访问延迟，对比替换前后数据</li><li><strong>Ping.pe</strong>：测试全球节点响应速度，确保海外用户访问不受影响</li></ul><h4 id="（2）性能评分工具"><a href="#（2）性能评分工具" class="headerlink" title="（2）性能评分工具"></a>（2）性能评分工具</h4><ul><li><strong>Google PageSpeed Insights</strong>：重点关注“首次内容绘制（FCP）”和“最大内容绘制（LCP）”指标，替换后通常可提升10-30分</li><li><strong>WebPageTest</strong>：生成详细的资源加载瀑布图，查看<code>jsdmirror</code>资源的加载时间（目标：单个资源加载时间&lt;100ms）</li></ul><h2 id="五、进阶优化与风险规避"><a href="#五、进阶优化与风险规避" class="headerlink" title="五、进阶优化与风险规避"></a>五、进阶优化与风险规避</h2><h3 id="1-资源加载优化补充"><a href="#1-资源加载优化补充" class="headerlink" title="1. 资源加载优化补充"></a>1. 资源加载优化补充</h3><p>替换CDN后，可结合以下措施进一步提升速度：</p><ul><li><strong>开启Gzip压缩</strong>：在GitHub Pages中可通过配置<code>_config.yml</code>启用，或在Vercel中直接开启</li><li><strong>图片优化</strong>：使用<code>hexo-image-compressor</code>插件压缩图片，或迁移至国内图床（如阿里云OSS、腾讯云COS）</li><li><strong>减少第三方插件</strong>：卸载无用的评论、统计插件，降低资源请求数量</li></ul><h3 id="2-CDN服务风险规避"><a href="#2-CDN服务风险规避" class="headerlink" title="2. CDN服务风险规避"></a>2. CDN服务风险规避</h3><p><code>cdn.jsdmirror.com</code>作为第三方镜像，若后续出现服务不稳定，可切换至其他国内<code>jsDelivr</code>镜像，常用备选：</p><ul><li><code>https://cdn.jsdelivr.fusesearch.net/</code></li><li><code>https://jsd.onmicrosoft.cn/</code></li><li><code>https://jsdelivr.b-cdn.net/</code></li></ul><p>切换时仅需替换“域名”，保持资源路径完全一致，无需修改其他配置。</p><h3 id="3-定期检查与更新"><a href="#3-定期检查与更新" class="headerlink" title="3. 定期检查与更新"></a>3. 定期检查与更新</h3><p>建议每3-6个月检查一次CDN资源：</p><ul><li>确认使用的npm包/GitHub仓库资源是否有更新，避免使用过时版本导致安全风险</li><li>测试当前CDN的响应速度，若出现延迟升高，及时切换至其他镜像</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过将Hexo博客的<code>cdn.jsdelivr.net</code>替换为<code>cdn.jsdmirror.com</code>，可有效解决国内网络环境下的资源加载慢问题，通常能带来30%-70%的加载速度提升。整个过程核心在于“精准定位资源位置+完整替换域名”，配合本地测试与线上验证，即可确保博客稳定运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo博客提速实战：cdn-jsdelivr-net不可用&quot;&gt;&lt;a href=&quot;#Hexo博客提速实战：cdn-jsdelivr-net不可用&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客提速实战：cdn.jsdelivr.net不可用&quot;&gt;</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://nmcb666.vip/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://nmcb666.vip/posts/3eeb.html"/>
    <id>https://nmcb666.vip/posts/3eeb.html</id>
    <published>2025-09-16T06:19:33.641Z</published>
    <updated>2025-09-16T06:19:33.641Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Task定时任务的一些事</title>
    <link href="https://nmcb666.vip/posts/12ed125b.html"/>
    <id>https://nmcb666.vip/posts/12ed125b.html</id>
    <published>2025-09-15T15:13:27.000Z</published>
    <updated>2025-09-16T06:19:33.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-定时任务（Task）使用教程：从入门到精通"><a href="#Spring-Boot-定时任务（Task）使用教程：从入门到精通" class="headerlink" title="Spring Boot 定时任务（Task）使用教程：从入门到精通"></a>Spring Boot 定时任务（Task）使用教程：从入门到精通</h1><p>在日常开发中，定时任务是一个非常常见的需求，比如定时发送短信、定时生成报表、定时清理缓存等。Spring Boot 内置了 <code>spring-boot-starter</code> 模块，其中就包含了对定时任务的支持，无需额外引入复杂的第三方框架（如 Quartz），就能快速实现定时任务功能。本文将从基础到进阶，详细讲解 Spring Boot 定时任务的使用方法。</p><h2 id="一、Spring-Boot-定时任务基础"><a href="#一、Spring-Boot-定时任务基础" class="headerlink" title="一、Spring Boot 定时任务基础"></a>一、Spring Boot 定时任务基础</h2><h3 id="1-1-什么是定时任务？"><a href="#1-1-什么是定时任务？" class="headerlink" title="1.1 什么是定时任务？"></a>1.1 什么是定时任务？</h3><p>定时任务是指在预定的时间点或按照固定的时间间隔自动执行的任务。在 Java 生态中，常见的定时任务实现方式有 <code>Timer</code>、<code>ScheduledExecutorService</code>、Quartz 等，而 Spring Boot 提供的 <code>@Scheduled</code> 注解则是对这些底层实现的封装，简化了开发流程。</p><h3 id="1-2-启用定时任务"><a href="#1-2-启用定时任务" class="headerlink" title="1.2 启用定时任务"></a>1.2 启用定时任务</h3><p>Spring Boot 中启用定时任务非常简单，只需两步：</p><ol><li><strong>添加依赖</strong>：Spring Boot 的 <code>spring-boot-starter</code> 已经包含了定时任务相关的依赖，无需额外引入。如果是 Maven 项目，<code>pom.xml</code> 中默认的 <code>spring-boot-starter</code> 即可满足需求：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>开启定时任务注解</strong>：在 Spring Boot 启动类上添加 <code>@EnableScheduling</code> 注解，用于启用定时任务的自动配置：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TaskDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、简单定时任务实现"><a href="#二、简单定时任务实现" class="headerlink" title="二、简单定时任务实现"></a>二、简单定时任务实现</h2><p>启用定时任务后，只需在需要定时执行的方法上添加 <code>@Scheduled</code> 注解，并指定任务的执行时机即可。<code>@Scheduled</code> 注解支持多种定时方式，下面介绍最常用的几种。</p><h3 id="2-1-固定延迟执行（fixedDelay）"><a href="#2-1-固定延迟执行（fixedDelay）" class="headerlink" title="2.1 固定延迟执行（fixedDelay）"></a>2.1 固定延迟执行（fixedDelay）</h3><p><code>fixedDelay</code> 表示上一次任务执行完成后，间隔固定时间再执行下一次任务。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 交给 Spring 管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次任务执行完成后，间隔 3 秒执行下一次</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;固定延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间为 <code>3000ms + 任务执行耗时（1000ms）</code>，即约 4 秒。</p><h3 id="2-2-固定频率执行（fixedRate）"><a href="#2-2-固定频率执行（fixedRate）" class="headerlink" title="2.2 固定频率执行（fixedRate）"></a>2.2 固定频率执行（fixedRate）</h3><p><code>fixedRate</code> 表示按照固定的频率执行任务，无论上一次任务是否执行完成。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每隔 3 秒执行一次，不管上一次任务是否完成</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：两次任务的间隔时间约为 3 秒（因为任务耗时 1 秒，小于频率间隔）。如果任务耗时超过频率间隔（如任务耗时 4 秒），则上一次任务执行完成后会立即执行下一次任务。</p><h3 id="2-3-初始延迟执行（initialDelay）"><a href="#2-3-初始延迟执行（initialDelay）" class="headerlink" title="2.3 初始延迟执行（initialDelay）"></a>2.3 初始延迟执行（initialDelay）</h3><p><code>initialDelay</code> 表示任务启动后，延迟指定时间再开始执行第一次任务，之后按照 <code>fixedDelay</code> 或 <code>fixedRate</code> 执行。单位为毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 启动后延迟 5 秒执行第一次任务，之后每隔 3 秒执行一次</span></span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 5000, fixedRate = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialDelayTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始延迟任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果示例：应用启动 5 秒后，第一次执行任务，之后每 3 秒执行一次。</p><h2 id="三、Cron-表达式：灵活的定时配置"><a href="#三、Cron-表达式：灵活的定时配置" class="headerlink" title="三、Cron 表达式：灵活的定时配置"></a>三、Cron 表达式：灵活的定时配置</h2><p>如果需要更灵活的定时规则（如每天凌晨 2 点执行、每周一上午 10 点执行等），<code>fixedDelay</code> 和 <code>fixedRate</code> 就无法满足需求了，此时需要使用 <strong>Cron 表达式</strong>。</p><h3 id="3-1-Cron-表达式格式"><a href="#3-1-Cron-表达式格式" class="headerlink" title="3.1 Cron 表达式格式"></a>3.1 Cron 表达式格式</h3><p>Cron 表达式是一个字符串，由 6 或 7 个字段组成，字段之间用空格分隔。Spring Boot 中的 Cron 表达式支持 6 个字段（不支持年份），格式如下：</p><div class="callout">秒 分 时 日 月 星期</div><p>每个字段的取值范围和允许的特殊字符如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>取值范围</th><th>特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日</td><td>1-31</td><td>, - * / ? L W C</td></tr><tr><td>月</td><td>1-12 或 JAN-DEC</td><td>, - * /</td></tr><tr><td>星期</td><td>1-7 或 SUN-SAT（1 表示星期日）</td><td>, - * / ? L C #</td></tr></tbody></table></div><h3 id="3-2-常用特殊字符说明"><a href="#3-2-常用特殊字符说明" class="headerlink" title="3.2 常用特殊字符说明"></a>3.2 常用特殊字符说明</h3><ul><li><p><strong>*</strong>：表示所有可能的值，例如“秒”字段为 <code>*</code>，表示每秒执行。</p></li><li><p><strong>?</strong>：用于“日”和“星期”字段，表示不指定具体值，避免两者冲突。例如每月 10 日执行，不管是星期几，“星期”字段就填 <code>?</code>。</p></li><li><p><strong>/</strong>：表示增量，例如“分”字段为 <code>0/5</code>，表示从 0 分开始，每 5 分钟执行一次。</p></li><li><p><strong>-</strong>：表示范围，例如“时”字段为 <code>9-17</code>，表示 9 点到 17 点之间执行。</p></li><li><p><strong>,</strong>：表示多个值，例如“星期”字段为 <code>1,3,5</code>，表示星期日、星期二、星期四执行。</p></li><li><p><strong>L</strong>：表示“最后”，例如“日”字段为 <code>L</code>，表示每月最后一天；“星期”字段为 <code>L</code>，表示星期六。</p></li><li><p><strong>#</strong>：用于“星期”字段，表示每月的第几个星期几，例如 <code>6#3</code> 表示每月第三个星期五（6 表示星期五）。</p></li></ul><h3 id="3-3-Cron-表达式示例"><a href="#3-3-Cron-表达式示例" class="headerlink" title="3.3 Cron 表达式示例"></a>3.3 Cron 表达式示例</h3><ul><li><p>每秒执行：<code>* * * * * ?</code></p></li><li><p>每 5 分钟执行：<code>0 */5 * * * ?</code></p></li><li><p>每天凌晨 2 点执行：<code>0 0 2 * * ?</code></p></li><li><p>每月 10 日上午 10 点执行：<code>0 0 10 10 * ?</code></p></li><li><p>每周一到周五下午 5 点执行：<code>0 0 17 ? * 2-6</code>（2 表示星期一，6 表示星期五）</p></li><li><p>每月最后一天晚上 11 点执行：<code>0 0 23 L * ?</code></p></li></ul><h3 id="3-4-在-Scheduled-中使用-Cron-表达式"><a href="#3-4-在-Scheduled-中使用-Cron-表达式" class="headerlink" title="3.4 在 @Scheduled 中使用 Cron 表达式"></a>3.4 在 @Scheduled 中使用 Cron 表达式</h3><p>只需将 <code>@Scheduled</code> 注解的 <code>cron</code> 属性设置为对应的表达式即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每天凌晨 2 点执行</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、定时任务参数外部化配置"><a href="#四、定时任务参数外部化配置" class="headerlink" title="四、定时任务参数外部化配置"></a>四、定时任务参数外部化配置</h2><p>在实际开发中，定时任务的执行规则可能需要根据环境动态调整（如开发环境和生产环境的执行频率不同）。此时，不建议将参数硬编码在 <code>@Scheduled</code> 注解中，而是通过 <code>application.properties</code> 或 <code>application.yml</code> 进行外部化配置。</p><h3 id="4-1-使用-properties-文件配置"><a href="#4-1-使用-properties-文件配置" class="headerlink" title="4.1 使用 properties 文件配置"></a>4.1 使用 properties 文件配置</h3><p>在 <code>application.properties</code> 中添加定时任务参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 定时任务参数配置</span></span><br><span class="line"><span class="attr">task.fixedRate</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">task.cron</span>=<span class="string">0 0 2 * * ?</span></span><br></pre></td></tr></table></figure><p>在代码中通过 <code>$&#123;&#125;</code> 引用配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 fixedRate</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRateString = &quot;$&#123;task.fixedRate&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalFixedRateTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置固定频率任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用外部配置的 cron 表达式</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">externalCronTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;外部配置 Cron 任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于数值类型的参数（如 <code>fixedRate</code>、<code>fixedDelay</code>），需要使用 <code>fixedRateString</code>、<code>fixedDelayString</code> 属性来引用字符串类型的配置值。</p><h2 id="五、定时任务的高级特性"><a href="#五、定时任务的高级特性" class="headerlink" title="五、定时任务的高级特性"></a>五、定时任务的高级特性</h2><h3 id="5-1-定时任务线程池配置"><a href="#5-1-定时任务线程池配置" class="headerlink" title="5.1 定时任务线程池配置"></a>5.1 定时任务线程池配置</h3><p>Spring Boot 定时任务默认使用单线程执行，如果多个任务同时触发，会出现任务排队的情况。为了提高任务执行效率，可以配置定时任务线程池。</p><p>通过实现 <code>SchedulingConfigurer</code> 接口来配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为 5</span></span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        scheduler.setPoolSize(<span class="number">5</span>);</span><br><span class="line">        scheduler.setThreadNamePrefix(<span class="string">&quot;scheduled-task-&quot;</span>); <span class="comment">// 线程名前缀</span></span><br><span class="line">        scheduler.initialize();</span><br><span class="line">        </span><br><span class="line">        taskRegistrar.setTaskScheduler(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，定时任务会通过线程池中的线程并行执行，避免单线程瓶颈。</p><h3 id="5-2-动态调整定时任务"><a href="#5-2-动态调整定时任务" class="headerlink" title="5.2 动态调整定时任务"></a>5.2 动态调整定时任务</h3><p>如果需要在应用运行过程中动态修改定时任务的执行规则（如修改 Cron 表达式），可以通过 <code>ScheduledTaskRegistrar</code> 和 <code>Trigger</code> 接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTaskConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中读取 Cron 表达式，支持动态刷新</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;task.dynamic.cron&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String cronExpression;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态注册定时任务</span></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">            () -&gt; System.out.println(<span class="string">&quot;动态定时任务执行时间：&quot;</span> + LocalDateTime.now()),</span><br><span class="line">            triggerContext -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每次执行前重新读取 Cron 表达式，实现动态调整</span></span><br><span class="line">                <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cronExpression);</span><br><span class="line">                <span class="keyword">return</span> trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供方法修改 cronExpression</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCronExpression</span><span class="params">(String cronExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cronExpression = cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>setCronExpression</code> 方法，可以在应用运行时修改任务的执行规则。如果结合配置中心（如 Nacos、Apollo），还能实现配置的动态推送。</p><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><ul><li><p><strong>任务执行时长</strong>：如果任务执行时长超过了定时频率，会导致任务堆积。建议通过线程池配置或优化任务逻辑来避免。</p></li><li><p><strong>异常处理</strong>：定时任务方法中如果抛出未捕获的异常，会导致任务终止。建议在方法内部添加 try-catch 块，或通过全局异常处理器捕获异常。</p></li><li><p><strong>分布式环境</strong>：Spring Boot 内置的定时任务不支持分布式锁，在分布式环境下可能出现多个节点同时执行任务的情况。此时需要结合分布式锁（如 Redis 分布式锁）来保证任务的唯一性。</p></li><li><p><strong>幂等性</strong>：即使使用了分布式锁，也建议保证任务的幂等性，避免因网络抖动等问题导致任务重复执行。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Spring Boot 定时任务通过 <code>@EnableScheduling</code> 和 <code>@Scheduled</code> 注解，极大地简化了定时任务的开发。本文从基础的固定延迟、固定频率任务，到灵活的 Cron 表达式，再到参数外部化和线程池配置，最后介绍了动态任务和注意事项，覆盖了定时任务的大部分使用场景。</p><p>在实际开发中，需要根据业务需求选择合适的定时方式，并注意异常处理、分布式环境下的任务唯一性等问题。希望本文能帮助你快速掌握 Spring Boot 定时任务的使用😊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Boot-定时任务（Task）使用教程：从入门到精通&quot;&gt;&lt;a href=&quot;#Spring-Boot-定时任务（Task）使用教程：从入门到精通&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 定时任务（Task）使用教程</summary>
      
    
    
    
    
    <category term="Spring Boot" scheme="https://nmcb666.vip/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>关于Spring Security的一些事</title>
    <link href="https://nmcb666.vip/posts/3f6c5c0b.html"/>
    <id>https://nmcb666.vip/posts/3f6c5c0b.html</id>
    <published>2025-09-14T13:54:10.000Z</published>
    <updated>2025-09-16T06:19:33.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security-使用教程：从入门到实战"><a href="#Spring-Security-使用教程：从入门到实战" class="headerlink" title="Spring Security 使用教程：从入门到实战"></a>Spring Security 使用教程：从入门到实战</h1><p>在Web应用开发中，安全永远是不可忽视的环节。Spring Security作为Spring生态中成熟的安全框架，提供了全面的认证（Authentication）和授权（Authorization）解决方案。本文将从基础到进阶，带你一步步掌握Spring Security的核心用法，构建安全可靠的Java Web应用。(对的，这是Spring Security的入门篇)</p><h2 id="一、Spring-Security-核心概念"><a href="#一、Spring-Security-核心概念" class="headerlink" title="一、Spring Security 核心概念"></a>一、Spring Security 核心概念</h2><p>在开始实战前，先理解几个核心概念，有助于后续学习：</p><ul><li><p><strong>认证（Authentication）</strong>：验证用户身份的过程，比如登录时校验用户名和密码是否正确。</p></li><li><p><strong>授权（Authorization）</strong>：在认证通过后，判断用户是否有权限执行某个操作（如访问特定接口、修改数据）。</p></li><li><p><strong>SecurityContext</strong>：存储当前认证用户的信息，通过<code>SecurityContextHolder</code>可以随时获取。</p></li><li><p><strong>UserDetails</strong>：封装用户信息的接口，包含用户名、密码、权限等核心字段。</p></li><li><p><strong>AuthenticationManager</strong>：认证的核心管理器，负责调度<code>AuthenticationProvider</code>完成认证。</p></li></ul><h2 id="二、环境搭建：快速集成Spring-Security"><a href="#二、环境搭建：快速集成Spring-Security" class="headerlink" title="二、环境搭建：快速集成Spring Security"></a>二、环境搭建：快速集成Spring Security</h2><p>本文基于<strong>Spring Boot 3.x</strong>进行演示，Spring Boot已为Spring Security提供了自动配置，集成过程非常简单。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><p>在<code>pom.xml</code>（Maven）或<code>build.gradle</code>（Gradle）中添加Spring Security依赖：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0-M2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="2-2-启动应用，体验默认安全配置"><a href="#2-2-启动应用，体验默认安全配置" class="headerlink" title="2.2 启动应用，体验默认安全配置"></a>2.2 启动应用，体验默认安全配置</h3><p>添加依赖后，直接启动Spring Boot应用，Spring Security会自动生效，默认做了以下安全配置：</p><ol><li><p>所有接口默认需要认证才能访问。</p></li><li><p>生成一个默认用户，用户名是<code>user</code>，密码会在控制台输出（格式如：<code>Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code>）。</p></li><li><p>提供一个默认的登录页面（访问任意接口会自动跳转）。</p></li></ol><p>测试：访问<code>http://localhost:8080/hello</code>（需先编写一个简单的Hello接口），会跳转至登录页，输入默认用户名和密码即可访问。</p><h2 id="三、自定义认证：从默认到数据库"><a href="#三、自定义认证：从默认到数据库" class="headerlink" title="三、自定义认证：从默认到数据库"></a>三、自定义认证：从默认到数据库</h2><p>默认配置仅用于测试，实际项目中需要对接数据库用户，下面实现自定义认证逻辑。</p><h3 id="3-1-编写配置类"><a href="#3-1-编写配置类" class="headerlink" title="3.1 编写配置类"></a>3.1 编写配置类</h3><p>创建<code>SecurityConfig</code>类，继承<code>WebSecurityConfigurerAdapter</code>（Spring Boot 3.x中已 deprecated，推荐使用函数式风格配置）：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入自定义的UserDetailsService（后续实现）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityConfig</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置密码加密器（Spring Security 5+要求必须指定密码加密方式）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置SecurityFilterChain（核心配置）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 关闭CSRF（测试环境可关闭，生产环境需开启）</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            <span class="comment">// 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                <span class="comment">// 放行登录接口、静态资源等</span></span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 其他所有接口需要认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置表单登录</span></span><br><span class="line">            .formLogin(form -&gt; form</span><br><span class="line">                <span class="comment">// 自定义登录页面路径（可选，默认是/spring-security-login）</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/custom-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录请求的接口路径（默认是/login）</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/do-login&quot;</span>)</span><br><span class="line">                <span class="comment">// 登录成功后的跳转路径</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 登录失败后的跳转路径</span></span><br><span class="line">                .failureUrl(<span class="string">&quot;/custom-login?error=true&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 配置退出登录</span></span><br><span class="line">            .logout(logout -&gt; logout</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/custom-login?logout=true&quot;</span>)</span><br><span class="line">                .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 销毁session</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="3-2-实现UserDetailsService"><a href="#3-2-实现UserDetailsService" class="headerlink" title="3.2 实现UserDetailsService"></a>3.2 实现UserDetailsService</h3><p><code>UserDetailsService</code>负责从数据库加载用户信息，我们需要实现它来对接自己的用户表：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用户DAO（实际项目中替换为MyBatis或JPA的Repository）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomUserDetailsService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 从数据库查询用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据库用户转换为UserDetails对象（包含权限信息）</span></span><br><span class="line">        <span class="keyword">return</span> User.withUsername(user.getUsername())</span><br><span class="line">                .password(user.getPassword()) <span class="comment">// 数据库中存储的密码必须是加密后的</span></span><br><span class="line">                .roles(user.getRoles().split(<span class="string">&quot;,&quot;</span>)) <span class="comment">// 假设roles字段是逗号分隔的角色字符串</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="callout">注意：数据库中存储的密码必须是通过`BCryptPasswordEncoder`加密后的字符串，不能存储明文。可以通过`passwordEncoder.encode("123456")`生成加密密码。</div><h2 id="四、授权控制：基于角色和权限"><a href="#四、授权控制：基于角色和权限" class="headerlink" title="四、授权控制：基于角色和权限"></a>四、授权控制：基于角色和权限</h2><p>认证通过后，需要对不同用户授予不同权限，Spring Security支持多种授权方式。</p><h3 id="4-1-基于角色的URL授权"><a href="#4-1-基于角色的URL授权" class="headerlink" title="4.1 基于角色的URL授权"></a>4.1 基于角色的URL授权</h3><p>在<code>securityFilterChain</code>中通过<code>hasRole</code>或<code>hasAnyRole</code>配置URL的角色权限：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// 只有ADMIN角色可访问/admin下的接口</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>) <span class="comment">// ADMIN或USER角色可访问</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/public/**&quot;</span>).permitAll() <span class="comment">// 公开接口，无需认证</span></span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="4-2-基于注解的方法级授权"><a href="#4-2-基于注解的方法级授权" class="headerlink" title="4.2 基于注解的方法级授权"></a>4.2 基于注解的方法级授权</h3><p>在Controller方法上使用注解控制权限，需先开启全局方法安全：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span> <span class="comment">// 开启PreAuthorize注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在Controller方法上使用注解：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有ADMIN角色的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-manage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">manageUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户管理页面&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有拥有DELETE权限的用户可访问</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;DELETE&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除用户：&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="五、进阶功能：记住我与JWT"><a href="#五、进阶功能：记住我与JWT" class="headerlink" title="五、进阶功能：记住我与JWT"></a>五、进阶功能：记住我与JWT</h2><p>除了基础的认证授权，Spring Security还支持“记住我”、JWT令牌等高级功能。</p><h3 id="5-1-实现“记住我”功能"><a href="#5-1-实现“记住我”功能" class="headerlink" title="5.1 实现“记住我”功能"></a>5.1 实现“记住我”功能</h3><p>只需在<code>securityFilterChain</code>中添加<code>rememberMe</code>配置：</p><details class="folding-tag" green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.rememberMe(remember -&gt; remember</span><br><span class="line">    .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中的记住我参数名</span></span><br><span class="line">    .tokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>) <span class="comment">// 记住我有效期（7天）</span></span><br><span class="line">    .userDetailsService(userDetailsService) <span class="comment">// 加载用户信息</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><p>然后在登录表单中添加一个名为<code>remember-me</code>的复选框即可。</p><h3 id="5-2-集成JWT实现无状态认证"><a href="#5-2-集成JWT实现无状态认证" class="headerlink" title="5.2 集成JWT实现无状态认证"></a>5.2 集成JWT实现无状态认证</h3><p>对于前后端分离项目，通常使用JWT（JSON Web Token）实现无状态认证，核心步骤如下：</p><ol><li><p><strong>引入JWT依赖</strong>：添加<code>jjwt-api</code>、<code>jjwt-impl</code>、<code>jjwt-jackson</code>依赖。</p></li><li><p><strong>编写JWT工具类</strong>：实现Token的生成、解析、验证逻辑。</p></li><li><p><strong>自定义JwtAuthenticationFilter</strong>：从请求头中获取Token，解析后完成认证。</p></li><li><p><strong>配置SecurityFilterChain</strong>：关闭session，添加JWT过滤器，放行登录接口等。</p></li></ol><p>由于JWT集成步骤较多，后续会单独写一篇实战文章，感兴趣的可以关注。</p><h2 id="六、常见问题与排查"><a href="#六、常见问题与排查" class="headerlink" title="六、常见问题与排查"></a>六、常见问题与排查</h2><ul><li><p><strong>密码加密失败</strong>：确保数据库中存储的是加密后的密码，且配置了正确的<code>PasswordEncoder</code>。</p></li><li><p><strong>接口授权不生效</strong>：检查URL匹配规则的顺序（具体规则要放在通用规则前面），以及角色/权限名称是否正确（<code>hasRole</code>会自动添加<code>ROLE_</code>前缀，<code>hasAuthority</code>需要完整名称）。</p></li><li><p><strong>CSRF问题</strong>：前后端分离项目中，若关闭CSRF，需确保请求头中没有携带CSRF Token；若开启，需在前端请求中添加Token。</p></li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本文介绍了Spring Security的核心概念、环境搭建、自定义认证、授权控制及进阶功能，涵盖了大部分实际项目中的常用场景。Spring Security功能强大且灵活，掌握它能有效提升应用的安全性。建议结合实际项目多动手实践，深入理解其核心原理（如过滤器链、认证流程等），以便应对更复杂的安全需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Security-使用教程：从入门到实战&quot;&gt;&lt;a href=&quot;#Spring-Security-使用教程：从入门到实战&quot; class=&quot;headerlink&quot; title=&quot;Spring Security 使用教程：从入门到实战&quot;&gt;&lt;/a&gt;Sprin</summary>
      
    
    
    
    
    <category term="Spring Boot" scheme="https://nmcb666.vip/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>计算机技术</title>
    <link href="https://nmcb666.vip/posts/b67a9f87.html"/>
    <id>https://nmcb666.vip/posts/b67a9f87.html</id>
    <published>2025-09-13T22:53:06.000Z</published>
    <updated>2025-09-16T06:19:33.641Z</updated>
    
    <content type="html"><![CDATA[<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg><h1 id="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"><a href="#从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互" class="headerlink" title="从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互"></a>从“卡顿”到“丝滑”：现代计算机技术如何重塑我们的日常交互</h1><p>在十年前，打开一个大型文档需要等待几十秒、视频通话时频繁出现“马赛克”、手机多开几个APP就会闪退，这些场景对大多数人来说都司空见惯。而如今，我们早已习惯了“即点即开”的文档编辑、4K画质的实时视频会议、手机后台同时运行十几个应用仍流畅切换——这些“丝滑”体验的背后，并非只是“硬件变好了”这么简单，而是计算机技术在<strong>存储架构、网络传输、系统优化</strong>等多个维度协同进化的结果。今天，我们就从日常场景切入，聊聊那些“看不见却离不开”的技术进步。</p><h2 id="一、存储技术：从“机械等待”到“电子秒达”"><a href="#一、存储技术：从“机械等待”到“电子秒达”" class="headerlink" title="一、存储技术：从“机械等待”到“电子秒达”"></a>一、存储技术：从“机械等待”到“电子秒达”</h2><p>打开电脑时，系统启动速度的快慢，很大程度上取决于存储设备的性能。十年前主流的机械硬盘（HDD），就像一个“带转盘的档案柜”：读写数据时，需要先让磁盘高速旋转（通常是5400转/分钟或7200转/分钟），再让磁头移动到指定位置“查找”数据——这个过程虽然比早期的软盘快，但仍有明显的“等待时间”（平均寻道时间约8-12毫秒）。</p><p>而现在主流的固态硬盘（SSD），彻底抛弃了“机械结构”，改用<strong>NAND闪存芯片</strong>存储数据，就像把“档案柜”换成了“电子货架”：数据通过电信号直接读写，无需等待磁盘旋转或磁头移动，平均响应时间可以做到0.1毫秒以内——这意味着，从“点击开机”到“进入桌面”，时间从原来的1-2分钟压缩到了10-20秒，甚至更短。</p><p>更关键的是，SSD的进步还在持续：</p><ul><li><strong>NVMe协议</strong>的普及：相比早期SSD使用的SATA接口，NVMe直接通过PCIe总线与CPU通信，带宽提升了10倍以上，读写速度从“几百MB/s”跃升到“几GB/s”，打开4K视频文件、大型设计软件时几乎没有延迟。</li><li><strong>QLC闪存的成本下降</strong>：早期SSD因成本高，容量普遍在128GB-256GB；而现在1TB容量的QLC SSD价格已非常亲民，既能满足日常文件存储，也能装下多个大型游戏或专业软件。</li></ul><p>对普通用户来说，存储技术的进步不是“参数的胜利”，而是“打开文件不用等、编辑视频不卡顿”的实在体验。</p><h2 id="二、网络传输：从“断断续续”到“实时互动”"><a href="#二、网络传输：从“断断续续”到“实时互动”" class="headerlink" title="二、网络传输：从“断断续续”到“实时互动”"></a>二、网络传输：从“断断续续”到“实时互动”</h2><p>疫情期间，远程办公和在线学习成为常态，很多人都经历过“视频会议卡成PPT”“在线课堂声音延迟”的尴尬。这背后的核心问题，是早期网络传输在<strong>带宽、延迟、稳定性</strong>上的不足。而现在，这些问题的缓解，离不开两项关键技术的成熟：</p><h3 id="1-5G与Wi-Fi-6：解决“带宽不够用”的问题"><a href="#1-5G与Wi-Fi-6：解决“带宽不够用”的问题" class="headerlink" title="1. 5G与Wi-Fi 6：解决“带宽不够用”的问题"></a>1. 5G与Wi-Fi 6：解决“带宽不够用”的问题</h3><ul><li>5G网络的峰值速率可达10Gbps，是4G的10-100倍，即使在户外用手机开热点参加视频会议，也能支持4K画质的实时传输；</li><li>Wi-Fi 6（802.11ax）的单设备速率提升到9.6Gbps，同时支持更多设备连接（最多可同时连接100+设备）——这意味着，家里的电视、手机、电脑、智能音箱同时联网，也不会出现“抢网速”导致的卡顿。</li></ul><h3 id="2-边缘计算：降低“数据跑太远”的延迟"><a href="#2-边缘计算：降低“数据跑太远”的延迟" class="headerlink" title="2. 边缘计算：降低“数据跑太远”的延迟"></a>2. 边缘计算：降低“数据跑太远”的延迟</h3><p>传统的网络架构中，我们的视频通话数据需要先传到远方的“中心服务器”，再转发给对方，这个过程会产生几十甚至上百毫秒的延迟（即“网络时延”）。而边缘计算则把“服务器”搬到了离用户更近的地方（比如城市的基站、区域数据中心），数据传输距离缩短，时延可以降低到10毫秒以内——这也是为什么现在的“实时连麦”“云游戏”能做到“操作无延迟”的关键。</p><p>举个例子：以前玩云游戏，按下“射击”按钮后，需要等1-2秒才能看到画面反应；现在有了边缘计算和高速网络，延迟几乎可以忽略，体验和在本地玩游戏没什么区别。</p><h2 id="三、系统优化：从“资源浪费”到“智能调度”"><a href="#三、系统优化：从“资源浪费”到“智能调度”" class="headerlink" title="三、系统优化：从“资源浪费”到“智能调度”"></a>三、系统优化：从“资源浪费”到“智能调度”</h2><p>除了硬件和网络，操作系统的优化同样重要。早期的系统（比如Windows XP、安卓4.0）对硬件资源的调度能力较弱，比如：</p><ul><li>打开多个APP后，后台应用不会“主动释放内存”，导致可用内存越来越少，手机或电脑越来越卡；</li><li>CPU资源分配“一刀切”，不管是微信聊天还是视频渲染，都用同样的性能模式，既浪费电量，又无法满足高负载需求。</li></ul><p>而现在的操作系统（如Windows 11、安卓14），通过<strong>智能资源调度</strong>技术，让硬件性能“用在刀刃上”：</p><h3 id="1-内存管理：“动态回收”与“压缩优化”"><a href="#1-内存管理：“动态回收”与“压缩优化”" class="headerlink" title="1. 内存管理：“动态回收”与“压缩优化”"></a>1. 内存管理：“动态回收”与“压缩优化”</h3><ul><li>安卓系统的“墓碑机制”（Android 12后优化）：当APP进入后台时，系统会“冻结”其占用的内存，不再让它消耗资源；如果内存不足，会自动回收优先级低的后台APP内存，保证前台应用流畅运行。</li><li>Windows的“内存压缩”：当物理内存不足时，系统会将不常用的内存数据压缩（压缩率可达50%以上），而不是直接写入硬盘（虚拟内存），避免了因硬盘速度慢导致的卡顿。</li></ul><h3 id="2-CPU调度：“按需分配”与“能效平衡”"><a href="#2-CPU调度：“按需分配”与“能效平衡”" class="headerlink" title="2. CPU调度：“按需分配”与“能效平衡”"></a>2. CPU调度：“按需分配”与“能效平衡”</h3><ul><li>手机的“异构计算”：现在的手机CPU大多是“多核心架构”（比如4个小核+4个大核），系统会根据任务轻重分配核心：聊微信时用低功耗小核，省电量；玩游戏时调用高性能大核，保证帧率稳定。</li><li>Windows的“性能模式”：用户可以根据需求切换“节能模式”“平衡模式”“高性能模式”，比如外出办公时用节能模式延长续航，做视频剪辑时开高性能模式提升效率。</li></ul><h2 id="四、技术的终极目标：让“复杂”隐于“无形”"><a href="#四、技术的终极目标：让“复杂”隐于“无形”" class="headerlink" title="四、技术的终极目标：让“复杂”隐于“无形”"></a>四、技术的终极目标：让“复杂”隐于“无形”</h2><p>回顾计算机技术的发展，我们会发现一个规律：真正优秀的技术，从来不是让用户去“理解它”，而是让用户“感受不到它的存在”——就像我们不会在意SSD的闪存芯片如何工作，也不会关心Wi-Fi 6的协议细节，我们只需要“打开文件很快”“视频通话很流畅”。</p><p>未来，随着AI与计算机技术的融合（比如AI驱动的智能内存调度、AI优化的网络传输路径），我们的交互体验还会进一步升级：可能电脑会“预判”你要打开的文件，提前加载到内存；可能网络会“自动避开”拥堵路段，保证视频会议不卡顿。</p><p>技术的进步，最终是为了“让工具回归工具的本质”——让我们不再被“卡顿”“等待”困扰，而是更专注于内容创作、沟通协作，或者单纯地享受数字生活的乐趣。这，或许就是计算机技术最动人的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;object class=&quot;ghbdage&quot; style=&quot;margin-inline:5px&quot; title=&quot;&quot; standby=&quot;loading...&quot; data=&quot;https://img.shields.io/badge/Butterfly-Theme-orange?lo</summary>
      
    
    
    
    
    <category term="计算机杂谈" scheme="https://nmcb666.vip/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
