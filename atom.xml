<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2026-01-24T07:56:35.359Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAP中的一致性</title>
    <link href="https://nmcb666.vip/posts/5bb35c22.html"/>
    <id>https://nmcb666.vip/posts/5bb35c22.html</id>
    <published>2026-01-24T14:37:48.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<p>关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）</p><h2 id="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"><a href="#首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？" class="headerlink" title="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"></a>首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？</h2><p>这是一个非常经典且容易混淆的问题，因为“一致性”（Consistency）这个词在计算机科学的不同领域里，虽然名字一样，但含义却大相径庭。</p><p>这三个概念分别对应了：<strong>单机数据库理论（ACID）</strong>、<strong>分布式系统理论（CAP）</strong> 和 <strong>工程实践（分布式事务）</strong>。</p><p>我们可以用一句话概括它们的区别：</p><ul><li><strong>ACID 的一致性</strong>：关乎<strong>数据的“正确性”</strong>（符合业务约束）。</li><li><strong>CAP 的一致性</strong>：关乎<strong>数据的“新旧”</strong>（多副本同步）。</li><li><strong>分布式事务的一致性</strong>：关乎<strong>跨系统的“协调”</strong>（让多个独立系统的数据最终对齐）。</li></ul><hr><h3 id="1-事务的一致性-ACID-中的-C"><a href="#1-事务的一致性-ACID-中的-C" class="headerlink" title="1. 事务的一致性 (ACID 中的 C)"></a>1. 事务的一致性 (ACID 中的 C)</h3><p>这里的背景通常指<strong>单机数据库</strong>（如 MySQL）的本地事务。</p><ul><li><strong>定义</strong>：指事务执行前后，数据库必须从一个<strong>合法状态</strong>变换到另一个<strong>合法状态</strong>。</li><li><strong>核心关注点</strong>：<strong>业务逻辑与约束 (Business Logic &amp; Constraints)</strong>。</li><li><strong>详细解释</strong>：<br>“合法状态”是指数据必须符合预定义的规则。这些规则包括：<ul><li><strong>数据库约束</strong>：主键唯一、外键约束、字段类型、Check约束（例如余额不能小于0）。</li><li><strong>业务逻辑</strong>：例如 A 转账给 B 100元，那么 A 减去 100，B 加上 100，总金额必须不变。如果代码写错了，A 减了 100，B 却只加了 50，虽然数据库没崩溃（原子性满足），但<strong>一致性</strong>被破坏了，因为数据不再符合“总额守恒”的业务规则。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证数据不违背现实世界的业务规则。</strong></li></ul><hr><h3 id="2-分布式系统的一致性-CAP-中的-C"><a href="#2-分布式系统的一致性-CAP-中的-C" class="headerlink" title="2. 分布式系统的一致性 (CAP 中的 C)"></a>2. 分布式系统的一致性 (CAP 中的 C)</h3><p>这里的背景是指<strong>多副本的数据存储系统</strong>（如 Redis Cluster, Cassandra, ZooKeeper, HDFS）。</p><ul><li><strong>定义</strong>：在 CAP 理论中，C 代表 <strong>Linearizability (线性一致性)</strong> 或 <strong>Strong Consistency (强一致性)</strong>。意思是：<strong>所有的节点在同一时间看到的数据是完全相同的</strong>。</li><li><strong>核心关注点</strong>：<strong>多节点间的数据同步 (Synchronization &amp; Timing)</strong>。</li><li><strong>详细解释</strong>：<br>在分布式系统中，为了容灾，数据通常会有多个副本（Replica）。<ul><li>当你向节点 A 写入一个新值 <code>x = 1</code>。</li><li>紧接着向节点 B 读取 <code>x</code>。</li><li><strong>一致性</strong>要求：你必须读到 <code>1</code>。如果你读到了旧值 <code>0</code>，那么这个系统就不满足 CAP 中的 C。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证你读到的永远是最新写入的数据（就像只有一个副本一样）。</strong></li></ul><hr><h3 id="3-分布式事务中的一致性"><a href="#3-分布式事务中的一致性" class="headerlink" title="3. 分布式事务中的一致性"></a>3. 分布式事务中的一致性</h3><p>这里的背景是指<strong>微服务架构</strong>或<strong>跨数据库</strong>的操作（如 订单服务 + 库存服务 + 支付服务）。</p><ul><li><strong>定义</strong>：指在跨越多个独立服务或数据库的操作中，确保所有相关的数据最终能够达成一种<strong>逻辑上的对齐</strong>。它可以理解为事务的原子性，<strong>要么全部成功，要么全部失败</strong>。</li><li><strong>核心关注点</strong>：<strong>跨系统的原子性与最终状态 (Global Outcome)</strong>。</li><li><strong>详细解释</strong>：<br>由于分布式系统很难同时满足 CAP（通常为了可用性 A，必须牺牲强一致性 C），所以在分布式事务中，我们通常讨论两种一致性：<ol><li><strong>强一致性（刚性事务）</strong>：如 XA 协议、2PC（两阶段提交）。要求所有服务同时提交，立刻看到结果。这很像 ACID，但在分布式环境下性能极差。</li><li><strong>最终一致性（柔性事务，BASE理论）</strong>：如 TCC、Saga、消息队列。允许中间有一段时间数据是不一致的（例如订单已创建，但库存还没扣减完），但保证经过一段时间后，所有数据都会变对。</li></ol></li><li><strong>一句话总结</strong>：<strong>它保证多个独立系统的数据，虽然可能有延迟，但最终会“账目”对齐，不会出现“订单成功了但没扣库存”的烂账。</strong></li></ul><hr><h3 id="三者对比总结表"><a href="#三者对比总结表" class="headerlink" title="三者对比总结表"></a>三者对比总结表</h3><p>为了更清晰地理解，我们可以通过下表对比：</p><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">ACID 的一致性 (事务)</th><th style="text-align:left">CAP 的一致性 (分布式系统)</th><th style="text-align:left">分布式事务的一致性</th></tr></thead><tbody><tr><td style="text-align:left"><strong>侧重点</strong></td><td style="text-align:left"><strong>数据的正确性</strong> (逻辑约束)</td><td style="text-align:left"><strong>数据的可见性</strong> (时间同步)</td><td style="text-align:left"><strong>全局操作的协同</strong> (多方对齐)</td></tr><tr><td style="text-align:left"><strong>场景</strong></td><td style="text-align:left">单机数据库 (Oracle, MySQL)</td><td style="text-align:left">分布式存储 (Redis, ZK, NoSQL)</td><td style="text-align:left">微服务、跨库业务</td></tr><tr><td style="text-align:left"><strong>反例</strong></td><td style="text-align:left">转账后总金额变少了 (违反守恒)</td><td style="text-align:left">刚写完主库，读从库还是旧数据</td><td style="text-align:left">订单库显示“已支付”，库存库显示“未扣减”</td></tr><tr><td style="text-align:left"><strong>依赖对象</strong></td><td style="text-align:left">依赖数据库引擎的约束检查</td><td style="text-align:left">依赖共识算法 (Raft, Paxos) 或同步复制</td><td style="text-align:left">依赖协调器、MQ 或 补偿代码</td></tr><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left">“这笔数据合乎逻辑吗？”</td><td style="text-align:left">“我现在读到的是最新的吗？”</td><td style="text-align:left">“这几个系统的数据最后能对上吗？”</td></tr></tbody></table></div><h3 id="举个通俗的例子"><a href="#举个通俗的例子" class="headerlink" title="举个通俗的例子"></a>举个通俗的例子</h3><p>假设你要去买一杯奶茶：</p><ol><li><p><strong>ACID 一致性</strong>：你付了 20 元，店员必须给你一杯 20 元的奶茶。如果店员只给你一杯 10 元的水，或者没收钱就给你奶茶，这就违背了<strong>交易规则</strong>（ACID 破坏）。</p></li><li><p><strong>CAP 一致性</strong>：这家奶茶店有 3 个店员（副本）。店长（主节点）刚刚更新了菜单，把“珍珠奶茶”涨价到 25 元。你问店员 A，他说 25 元；你立刻问店员 B，如果店员 B 还说 20 元，那就是<strong>同步</strong>没做好（CAP 的 C 破坏）。</p></li><li><p><strong>分布式事务一致性</strong>：你在手机 App 上点单。</p><ul><li>你的支付宝扣了钱（支付服务）。</li><li>奶茶店的打印机出了小票（订单服务）。</li><li>如果支付宝扣了钱，但奶茶店没收到单子；或者奶茶店出了单子，支付宝没扣钱，这就是<strong>跨系统</strong>的不一致。分布式事务就是要保证：要么没扣钱也没单子，要么扣了钱也有单子（哪怕中间有几秒延迟）。</li></ul></li></ol><h2 id="线性一致性跟顺序一致性"><a href="#线性一致性跟顺序一致性" class="headerlink" title="线性一致性跟顺序一致性"></a>线性一致性跟顺序一致性</h2><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p><p>•    条件 I：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</p><p>•    条件 II：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>线性一致性的定义，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件 I 和条件 II 之外，还要同时满足一个条件：</p><p>•    条件 III：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>•    它们都试图让系统“表现得像只有一个副本”一样。</p><p>•    它们都保证了程序执行顺序不会被打乱。体现在条件 II 对于进程内各个操作的排序保持上。</p><p>•    线性一致性考虑了时间先后顺序，而顺序一致性没有。</p><p>•    满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</p><p>•    线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</p><p>•    在顺序一致性中，我们有可能读到旧版本的数据。</p><p>具体可以参考这篇博客 <a href="https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA">https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA</a></p><h2 id="最终一致性又是什么？"><a href="#最终一致性又是什么？" class="headerlink" title="最终一致性又是什么？"></a>最终一致性又是什么？</h2><p>其实最终一致性就不满足CAP理论的C,而是对于AP系统的扩充。</p><p><strong>最终一致性（Eventual Consistency）是 CAP 理论中选择了 AP（可用性 + 分区容错性）策略后，为了弥补缺失的 C（强一致性）而不得不采用的一种“妥协”方案。</strong></p><p>或者更简单点说：<strong>最终一致性是 AP 系统的核心特征。</strong></p><p>我们可以从以下几个层面来剖析这段关系：</p><h3 id="1-CAP-的必然性与“二选一”"><a href="#1-CAP-的必然性与“二选一”" class="headerlink" title="1. CAP 的必然性与“二选一”"></a>1. CAP 的必然性与“二选一”</h3><p>CAP 理论告诉我们，在分布式系统中，<strong>P（分区容错性）是不可避免的</strong>（网线总会断，节点总会挂）。所以我们只能在 C（强一致性/线性一致性）和 A（可用性）之间做选择：</p><ul><li><strong>选择 CP（放弃 A）</strong>：为了保证数据绝对一致，当网络出问题时，我宁愿报错拒绝服务，也不让你读到旧数据。<ul><li><em>结果</em>：这是<strong>强一致性</strong>系统（如 Zookeeper, HBase）。</li></ul></li><li><strong>选择 AP（放弃 C）</strong>：为了保证服务永远可用，哪怕网络出问题了，我也让你读，虽然读到的可能是旧数据。<ul><li><em>结果</em>：这就是<strong>最终一致性</strong>发挥作用的地方（如 DNS, Eureka, Cassandra）。</li></ul></li></ul><h3 id="2-最终一致性在-CAP-图谱中的位置"><a href="#2-最终一致性在-CAP-图谱中的位置" class="headerlink" title="2. 最终一致性在 CAP 图谱中的位置"></a>2. 最终一致性在 CAP 图谱中的位置</h3><p>如果把 CAP 画成一个三角形：</p><ul><li><strong>CAP 中的 C (Consistency)</strong>：指的是<strong>线性一致性</strong>（强一致性）。如果你追求 CAP 的 C，你就必须保证写完立刻能读到。</li><li><strong>最终一致性</strong>：它是<strong>弱一致性</strong>的一种特例。<strong>它不属于 CAP 的 C</strong>。相反，它是当我们<strong>抛弃了 CAP 的 C</strong> 之后，退而求其次追求的目标。</li></ul><blockquote><p><strong>关系公式</strong>：<br><strong>CAP (AP 模式)</strong> = <strong>Availability</strong> (高可用) + <strong>Partition Tolerance</strong> (分区容错) + <strong>Eventual Consistency</strong> (最终一致性)</p></blockquote><h3 id="3-为什么-AP-系统必然导致最终一致性？"><a href="#3-为什么-AP-系统必然导致最终一致性？" class="headerlink" title="3. 为什么 AP 系统必然导致最终一致性？"></a>3. 为什么 AP 系统必然导致最终一致性？</h3><p>让我们推演一下：</p><ol><li><strong>前提 (P)</strong>：系统有两个节点 Node A 和 Node B，它们之间的网络断了。</li><li><strong>抉择 (A)</strong>：我们选择了高可用（Availability），所以当用户向 Node A 写入 <code>x=1</code> 时，Node A 必须接受并返回成功，不能报错。</li><li><strong>后果</strong>：此时，Node A 的数据是 <code>x=1</code>，而 Node B 因为网络断了，数据还是 <code>x=0</code>。</li><li><strong>现状</strong>：此时系统已经<strong>不一致</strong>了（违反了 CAP 的 C）。</li><li><strong>补救 (最终一致性)</strong>：我们不能让 Node B 永远是 <code>0</code>。系统承诺：当网络恢复后，Node A 会后台把 <code>x=1</code> 同步给 Node B。经过一段时间（不确定多久），Node B 最终也会变成 <code>1</code>。</li></ol><p><strong>结论</strong>：因为选择了 A（允许在断网时继续写），必然导致数据暂时不一致。而“最终一致性”就是对这种暂时不一致的<strong>容忍</strong>和对未来的<strong>承诺</strong>。</p><h3 id="4-延伸：BASE-理论"><a href="#4-延伸：BASE-理论" class="headerlink" title="4. 延伸：BASE 理论"></a>4. 延伸：BASE 理论</h3><p>讲到最终一致性与 CAP 的关系，就不得不提 <strong>BASE 理论</strong>。它是对 CAP 中 AP 策略的工程化延伸。：</p><ul><li><strong>BA (Basically Available)</strong>：基本可用（允许响应时间慢一点，或者部分降级）。</li><li><strong>S (Soft state)</strong>：软状态（允许系统存在中间状态，即允许数据同步有延迟）。</li><li><strong>E (Eventual consistency)</strong>：最终一致性（数据最终会变对）。</li></ul><h3 id="5-总结表"><a href="#5-总结表" class="headerlink" title="5. 总结表"></a>5. 总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">CAP 的 C (强一致性)</th><th style="text-align:left">最终一致性 (弱一致性的一种)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CAP 选择</strong></td><td style="text-align:left"><strong>CP</strong> (放弃可用性)</td><td style="text-align:left"><strong>AP</strong> (放弃强一致性)</td></tr><tr><td style="text-align:left"><strong>核心逻辑</strong></td><td style="text-align:left">写操作完成后，所有节点<strong>立刻</strong>可见。</td><td style="text-align:left">写操作完成后，数据<strong>异步</strong>复制，经过一段时间才可见。</td></tr><tr><td style="text-align:left"><strong>用户体验</strong></td><td style="text-align:left">“要么读到最新的，要么系统告诉我报错/超时。”</td><td style="text-align:left">“我可能读到旧的，但系统保证随时能用。”</td></tr><tr><td style="text-align:left"><strong>典型场景</strong></td><td style="text-align:left">银行余额、库存扣减、分布式锁 (Etcd/ZK)</td><td style="text-align:left">社交网络点赞、DNS解析、电商商品浏览量</td></tr><tr><td style="text-align:left"><strong>关系</strong></td><td style="text-align:left"><strong>它是 CAP 定义的一致性标准</strong></td><td style="text-align:left"><strong>它是放弃 CAP 的 C 之后的替代方案</strong></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）&lt;/p&gt;
&lt;h2 id=&quot;首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？&quot;&gt;&lt;a href=&quot;#首先我们要知道什么是CAP的一致性，他跟</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法（四）递归</title>
    <link href="https://nmcb666.vip/posts/38e6282b.html"/>
    <id>https://nmcb666.vip/posts/38e6282b.html</id>
    <published>2026-01-20T15:24:25.000Z</published>
    <updated>2026-01-24T07:56:35.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归相关的题目"><a href="#递归相关的题目" class="headerlink" title="递归相关的题目"></a>递归相关的题目</h1><h2 id="找一个字符串的不重复的子序列"><a href="#找一个字符串的不重复的子序列" class="headerlink" title="找一个字符串的不重复的子序列"></a>找一个字符串的不重复的子序列</h2><p>递归的思路：每次按要这个位置的字符和不要这个位置的字符两种情况去递归，当i = s.length()时，保存当前的子序列。用hashSet去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String[] generatePermutation(String str) &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">f2(s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">char</span>[s.length], <span class="number">0</span>, set);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> set.size();</span><br><span class="line">String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[m];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String cur : set) &#123;</span><br><span class="line">ans[i++] = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// i是当前要处理的字符的索引,path是当前已经保存的路径，size是path的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">char</span>[] path, <span class="type">int</span> size, HashSet&lt;String&gt; set)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">set.add(String.valueOf(path, <span class="number">0</span>, size));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path[size] = s[i];</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size + <span class="number">1</span>, set);</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size, set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找一个数组中的所有子数组，顺序可以任意"><a href="#找一个数组中的所有子数组，顺序可以任意" class="headerlink" title="找一个数组中的所有子数组，顺序可以任意"></a>找一个数组中的所有子数组，顺序可以任意</h2><p>思路：先将数组排序，然后每次对同一个数讨论，要0个，要1个… 还需要知道对于这个数来说下一个跟自己不同的数的位置，然后调用递归从下个不同的数开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    findSubsetsWithDup(<span class="number">0</span>,nums,<span class="number">0</span>,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findSubsetsWithDup</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span> size,<span class="type">int</span>[] path,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">            temp.add(path[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找出下一个跟自己不同的数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; nums[j] == nums[i])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要0个</span></span><br><span class="line">        findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        <span class="comment">// 依次要多个</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++)&#123;</span><br><span class="line">            path[size++] = nums[i];</span><br><span class="line">            findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。"><a href="#给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。" class="headerlink" title="给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。"></a>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</h2><p>思路： 每次拿一个数跟当前下标的第一个数交换，然后递归调用将下标+1，递归完成后再交换回来。终止条件就算下标==nums.length</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    findPermute(nums,<span class="number">0</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPermute</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            temp.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            findPermute(nums,i+<span class="number">1</span>,ans);</span><br><span class="line">            <span class="comment">// 交换回来</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：如果有重复数字，则需要去重</p><p>思路： 每次递归的时候维护一个set这个set记录哪些数来到过我这个下标，如果发现一个数已经来到过，则不进行交换，也不递归跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">cur.add(num);</span><br><span class="line">&#125;</span><br><span class="line">ans.add(cur);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="comment">// nums[j]没有来到过i位置，才会去尝试</span></span><br><span class="line"><span class="keyword">if</span> (!set.contains(nums[j])) &#123;</span><br><span class="line">set.add(nums[j]);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">f(nums, i + <span class="number">1</span>, ans);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>思路：维护一个路径数组path[],path的第几个数的值表示第几行的皇后放在第几列，每次循环每一行的列去判断是否合法，如果合法则递归调用下一行，并且size++.终止条件是size == n 即找到合法的一个解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    findSolveNQueens(<span class="number">0</span>,n,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findSolveNQueens</span><span class="params">(<span class="type">int</span> size,<span class="type">int</span> n,<span class="type">int</span>[] path,List&lt;List&lt;String&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(size == n)&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span>path[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span> ;j&lt;pos;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> pos+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次尝试</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 尝试第i列</span></span><br><span class="line">            <span class="keyword">if</span>(isvalid(i,path,size))&#123;</span><br><span class="line">                <span class="comment">// 合法</span></span><br><span class="line">                path[size] = i;</span><br><span class="line">                findSolveNQueens(size+<span class="number">1</span>,n,path,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isvalid</span> <span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] path,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k&lt; size; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==path[k])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Math.abs(size-k) == Math.abs(i-path[k]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拓展： 利用位运算去判断当前位置是否合法。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-21%20162737.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalNQueens2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n = 5</span></span><br><span class="line"><span class="comment">// 1 &lt;&lt; 5 = 0...100000 - 1</span></span><br><span class="line"><span class="comment">// limit  = 0...011111; </span></span><br><span class="line"><span class="comment">// n = 7</span></span><br><span class="line"><span class="comment">// limit  = 0...01111111; </span></span><br><span class="line"><span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> f2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// limit : 当前是几皇后问题</span></span><br><span class="line"><span class="comment">// 之前皇后的列影响：col</span></span><br><span class="line"><span class="comment">// 之前皇后的右上 -&gt; 左下对角线影响：left</span></span><br><span class="line"><span class="comment">// 之前皇后的左上 -&gt; 右下对角线影响：right</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> col, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (col == limit) &#123;</span><br><span class="line"><span class="comment">// 所有皇后放完了！</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总限制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ban</span> <span class="operator">=</span> col | left | right;</span><br><span class="line"><span class="comment">// ~ban : 1可放皇后，0不能放</span></span><br><span class="line"><span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> limit &amp; (~ban);</span><br><span class="line"><span class="comment">// 放置皇后的尝试！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 一共有多少有效的方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (candidate != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 提取出最右侧的1</span></span><br><span class="line"><span class="comment">// 0 0 1 1 1 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 1 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 1 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line">place = candidate &amp; (-candidate);</span><br><span class="line">candidate ^= place;</span><br><span class="line">ans += f2(limit, col | place, (left | place) &gt;&gt; <span class="number">1</span>, (right | place) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归相关的题目&quot;&gt;&lt;a href=&quot;#递归相关的题目&quot; class=&quot;headerlink&quot; title=&quot;递归相关的题目&quot;&gt;&lt;/a&gt;递归相关的题目&lt;/h1&gt;&lt;h2 id=&quot;找一个字符串的不重复的子序列&quot;&gt;&lt;a href=&quot;#找一个字符串的不重复的子序列&quot; cla</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（四）二叉树</title>
    <link href="https://nmcb666.vip/posts/44956a51.html"/>
    <id>https://nmcb666.vip/posts/44956a51.html</id>
    <published>2026-01-19T21:48:58.000Z</published>
    <updated>2026-01-24T07:56:35.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树相关的题目"><a href="#二叉树相关的题目" class="headerlink" title="二叉树相关的题目"></a>二叉树相关的题目</h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>思路：利用队列进行层序遍历，类似与BFS。</p><p>这里举一个锯齿形层序遍历的例子（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">l = r = <span class="number">0</span>;</span><br><span class="line">queue[r++] = root;</span><br><span class="line"><span class="comment">// false 代表从左往右</span></span><br><span class="line"><span class="comment">// true 代表从右往左</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// reverse == false, 左 -&gt; 右， l....r-1, 收集size个</span></span><br><span class="line"><span class="comment">// reverse == true,  右 -&gt; 左， r-1....l, 收集size个</span></span><br><span class="line"><span class="comment">// 左 -&gt; 右, i = i + 1</span></span><br><span class="line"><span class="comment">// 右 -&gt; 左, i = i - 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reverse ? r - <span class="number">1</span> : l, j = reverse ? -<span class="number">1</span> : <span class="number">1</span>, k = <span class="number">0</span>; k &lt; size; i += j, k++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[i];</span><br><span class="line">list.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line"><span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">queue[r++] = cur.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">queue[r++] = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.add(list);</span><br><span class="line">reverse = !reverse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h2><p>思路：利用队列进行层序遍历，并同步记录当前层节点的索引，将索引保存在数组中，最后计算每一层开始与结束的索引的差值，并返回最大值。想象为完全二叉树，对于节点i，其左子节点为2i，右子节点为2i+1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">3001</span>];</span><br><span class="line">    Long[] idQueue = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">3001</span>];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[r] = root;</span><br><span class="line">    idQueue[r++] = <span class="number">1L</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//每次遍历完成后，l 到 r-1，就是当前层所有节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r-l;</span><br><span class="line">        ans = Math.max(ans,(<span class="type">int</span>)(idQueue[r-<span class="number">1</span>]-idQueue[l]+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue[l];</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idQueue[l++];</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue[r] = node.left;</span><br><span class="line">                idQueue[r++] = id*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue[r] =node.right;</span><br><span class="line">                idQueue[r++] = id*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大深度跟最小深度"><a href="#最大深度跟最小深度" class="headerlink" title="最大深度跟最小深度"></a>最大深度跟最小深度</h2><p>思路：利用递归进行求解，对于每个节点，求左右子树的最大深度，并返回较大的值。（最小深度同理，但要处理根节点为空的情况，因为为空子问题返回0高度，但题目说的最小深度必须到叶节点，所以会干扰最小深度的计算，所以必须子节点不为空才能进行递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right ==<span class="literal">null</span> &amp;&amp; root.left ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lMin</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rMin</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lMin = minDepth(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        rMin = minDepth(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(lMin,rMin)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据中序遍历和前序遍历构建二叉树"><a href="#根据中序遍历和前序遍历构建二叉树" class="headerlink" title="根据中序遍历和前序遍历构建二叉树"></a>根据中序遍历和前序遍历构建二叉树</h2><p>思路：</p><p>确定根节点：<br>前序遍历的第一个元素一定是整个树的根节点。</p><p>划分左右子树：<br>根据根节点在中序遍历中的位置，可以将中序遍历序列划分为左子树和右子树的中序遍历序列。<br>左子树的中序遍历序列位于根节点的左边，右子树的中序遍历序列位于根节点的右边。</p><p>递归构建：<br>根据左子树和右子树的中序遍历序列长度，可以在前序遍历序列中划分出对应的左子树和右子树的前序遍历序列。<br>递归地对左右子树进行上述操作，直到遍历序列为空，返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(preorder,<span class="number">0</span>,len-<span class="number">1</span>,inorder,<span class="number">0</span>,len-<span class="number">1</span>,map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] pre ,<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span>[] in,<span class="type">int</span> l2,<span class="type">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1&gt;r1 || l2 &gt; r2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == r1)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[l1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[l1]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span>map.get(pre[l1]);</span><br><span class="line">    <span class="comment">// 划分左右子树 递归求解</span></span><br><span class="line">    head.left = build(pre,l1+<span class="number">1</span>,k-l2+l1,in,l2,k-<span class="number">1</span>,map);</span><br><span class="line">    head.right = build(pre,k-l2+l1+<span class="number">1</span>,r1,in,k+<span class="number">1</span>,r2,map);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>思路： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line"><span class="comment">// 遇到空，或者p，或者q，直接返回</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"><span class="keyword">if</span> (l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 左树也搜到，右树也搜到，返回root</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="literal">null</span> &amp;&amp; r == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 都没搜到返回空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l和r一个为空，一个不为空</span></span><br><span class="line"><span class="comment">// 返回不空的那个</span></span><br><span class="line"><span class="keyword">return</span> l != <span class="literal">null</span> ? l : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>思路：每个点必须大于左树的最大值，小于右树最小值。递归验证即可。但注意把最大值设为Long.MIN_VALUE，最小值设为Long.MAX_VALUE（为了不对结果造成干扰）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        max = Long.MIN_VALUE;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lok</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">    <span class="type">long</span> <span class="variable">lmax</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lmin</span> <span class="operator">=</span> min;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">rok</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">    <span class="type">long</span> <span class="variable">rmax</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">long</span> <span class="variable">rmin</span> <span class="operator">=</span> min;</span><br><span class="line">    max = Math.max(Math.max(lmax,rmax),root.val);</span><br><span class="line">    min = Math.min(Math.min(lmin,rmin),root.val);</span><br><span class="line">    <span class="keyword">return</span> lok &amp;&amp; rok &amp;&amp; root.val &gt; lmax &amp;&amp; root.val&lt; rmin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树相关的题目&quot;&gt;&lt;a href=&quot;#二叉树相关的题目&quot; class=&quot;headerlink&quot; title=&quot;二叉树相关的题目&quot;&gt;&lt;/a&gt;二叉树相关的题目&lt;/h1&gt;&lt;h2 id=&quot;层序遍历&quot;&gt;&lt;a href=&quot;#层序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DDD领域事件的最佳实践</title>
    <link href="https://nmcb666.vip/posts/8f3b837f.html"/>
    <id>https://nmcb666.vip/posts/8f3b837f.html</id>
    <published>2026-01-16T23:59:31.000Z</published>
    <updated>2026-01-24T07:56:35.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考"><a href="#DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考" class="headerlink" title="DDD 实战：关于领域事件（Domain Events）的设计抉择与工程落地思考"></a>DDD 实战：关于领域事件（Domain Events）的设计抉择与工程落地思考</h1><p>在领域驱动设计（DDD）的战术落地过程中，<strong>领域事件（Domain Event）</strong> 是连接各个子域、聚合以及限界上下文的“胶水”。它不仅解耦了复杂的业务逻辑，更是实现“最终一致性”架构的关键手段。</p><p>本文基于实际开发经验，总结领域事件的建模、生成、发布及可靠性投递的最佳实践，并探讨不同方案背后的权衡。</p><hr><h2 id="一、-什么是领域事件？"><a href="#一、-什么是领域事件？" class="headerlink" title="一、 什么是领域事件？"></a>一、 什么是领域事件？</h2><p>简单来说，领域事件是<strong>聚合内已发生的业务事实</strong>。</p><ul><li><strong>业务事实</strong>：意味着它是过去式。比如“用户已注册”、“订单已支付”。</li><li><strong>命名规范</strong>：推荐使用 <code>动词过去式</code>（如 <code>OrderPaid</code>, <code>AccountActivated</code>）。</li><li><strong>价值</strong>：<ol><li><strong>解耦</strong>：核心业务逻辑不需要知道谁在关注它。</li><li><strong>副作用处理</strong>：触发通知、大数据分析、报表生成等非核心逻辑。</li><li><strong>数据一致性</strong>：跨聚合、跨服务的状态同步。</li></ol></li></ul><hr><h2 id="二、-建模：胖消息-vs-瘦消息"><a href="#二、-建模：胖消息-vs-瘦消息" class="headerlink" title="二、 建模：胖消息 vs 瘦消息"></a>二、 建模：胖消息 vs 瘦消息</h2><p>领域事件通常被建模为<strong>不可变的值对象（Value Object）</strong>。但在设计消息体（Payload）时，我们面临一个经典抉择：</p><h3 id="1-瘦消息（Id-Only）"><a href="#1-瘦消息（Id-Only）" class="headerlink" title="1. 瘦消息（Id-Only）"></a>1. 瘦消息（Id-Only）</h3><p>消息体仅包含最基础的元数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MobileChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;entityId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eventId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uuid-001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eventTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1654156165&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>优点</strong>：消息极小，传输快。</li><li><strong>缺点</strong>：消费者（Subscriber）必须拿着 <code>entityId</code> 反查聚合根信息，导致<strong>读放大</strong>。</li></ul><h3 id="2-胖消息（Event-Enrichment-事件增强）"><a href="#2-胖消息（Event-Enrichment-事件增强）" class="headerlink" title="2. 胖消息（Event Enrichment / 事件增强）"></a>2. 胖消息（Event Enrichment / 事件增强）</h3><p>消息体包含消费者所需的业务数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MobileChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;beforeMobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13800000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;afterMobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18100000000&quot;</span> <span class="comment">// 增强字段</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>优点</strong>：消费者完全自治，无需反查，降低源端系统压力。</li><li><strong>缺点</strong>：消息体较大；可能包含消费者不应关心的敏感数据；存在数据时效性问题（如果消费者处理慢，消息里的数据可能是旧的）。</li></ul><blockquote><p><strong>💡 思考与建议</strong>：<br>在微服务架构下，为了减少跨服务调用带来的耦合与延迟，<strong>推荐适度的“事件增强”</strong>。即：包含消费者处理业务所必须的核心字段，而不是把整个聚合根都塞进去。</p></blockquote><hr><h2 id="三、-生成：如何优雅地创建事件？"><a href="#三、-生成：如何优雅地创建事件？" class="headerlink" title="三、 生成：如何优雅地创建事件？"></a>三、 生成：如何优雅地创建事件？</h2><p>在代码层面，何处创建、何处发布事件，直接影响代码的整洁度（Clean Code）。我们对比四种常见方案：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方案</th><th style="text-align:left">描述</th><th style="text-align:left">评价</th><th style="text-align:left">建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. Service层创建</strong></td><td style="text-align:left">业务执行完后，手动 <code>new Event()</code> 并发布</td><td style="text-align:left"><strong>简单粗暴</strong>。适合贫血模型，但容易导致Service层逻辑膨胀，容易遗漏。</td><td style="text-align:left">⭐️⭐️</td></tr><tr><td style="text-align:left"><strong>2. 聚合根依赖Infra</strong></td><td style="text-align:left">聚合根注入 <code>Publisher</code>，内部直接发布</td><td style="text-align:left"><strong>反模式</strong>。聚合根不应依赖基础设施，破坏了POJO的纯净性，且导致单一职责问题。</td><td style="text-align:left">🚫</td></tr><tr><td style="text-align:left"><strong>3. 聚合根返回事件</strong></td><td style="text-align:left">方法签名改为 <code>List&lt;Event&gt; doSomething()</code></td><td style="text-align:left"><strong>侵入性强</strong>。强行改变了业务方法签名，调用方处理繁琐。</td><td style="text-align:left">⭐️</td></tr><tr><td style="text-align:left"><strong>4. 聚合根暂存 + 抽取</strong></td><td style="text-align:left">聚合根内部 <code>List</code> 暂存，Repo保存时抽取</td><td style="text-align:left"><strong>最佳实践</strong>。保证了聚合根的纯净，同时利用基础设施层自动化处理发布，业务无感知。</td><td style="text-align:left">⭐️⭐️⭐️⭐️</td></tr></tbody></table></div><h3 id="推荐方案代码示例"><a href="#推荐方案代码示例" class="headerlink" title="推荐方案代码示例"></a>推荐方案代码示例</h3><p><strong>抽象聚合根基类：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAggregateRoot</span> &#123;</span><br><span class="line">    <span class="comment">// 暂存事件，不持久化到业务表</span></span><br><span class="line">    <span class="meta">@Transient</span> </span><br><span class="line">    <span class="keyword">private</span> List&lt;DomainEvent&gt; domainEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerEvent</span><span class="params">(DomainEvent event)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domainEvents.add(event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供给基础设施层调用</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;DomainEvent&gt; <span class="title function_">pollEvents</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;DomainEvent&gt; events = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.domainEvents);</span><br><span class="line">        <span class="built_in">this</span>.domainEvents.clear();</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>业务聚合根：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractAggregateRoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMobile</span><span class="params">(String newMobile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mobile = newMobile;</span><br><span class="line">        <span class="comment">// 仅仅是注册，不涉及IO操作</span></span><br><span class="line">        registerEvent(<span class="keyword">new</span> <span class="title class_">MobileChangedEvent</span>(<span class="built_in">this</span>.id, newMobile));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="四、-可靠投递：分布式事务的噩梦"><a href="#四、-可靠投递：分布式事务的噩梦" class="headerlink" title="四、 可靠投递：分布式事务的噩梦"></a>四、 可靠投递：分布式事务的噩梦</h2><p>最核心的工程难题在于：<strong>Database保存</strong> 与 <strong>MQ消息发送</strong> 是两个独立的操作。<br>如果 DB 提交了，但 MQ 挂了（或者反过来），就会导致数据不一致。</p><p>为了解决这个问题，我们必须引入<strong>本地消息表（Transactional Outbox Pattern）</strong>。</p><h3 id="1-核心机制"><a href="#1-核心机制" class="headerlink" title="1. 核心机制"></a>1. 核心机制</h3><p>利用关系型数据库的本地事务（ACID），将“业务数据保存”和“事件数据保存”放在同一个事务中提交。</p><ul><li><strong>Step 1</strong>: 开启事务。</li><li><strong>Step 2</strong>: Update 业务表。</li><li><strong>Step 3</strong>: Insert into <code>t_event</code> (状态：PENDING)。</li><li><strong>Step 4</strong>: 提交事务。</li></ul><p>此时，业务操作和事件记录要么同时成功，要么同时失败。</p><h3 id="2-发送与补偿策略"><a href="#2-发送与补偿策略" class="headerlink" title="2. 发送与补偿策略"></a>2. 发送与补偿策略</h3><p>保存到 <code>t_event</code> 后，如何发到 MQ？</p><ul><li><strong>方案 A：应用直接发 + 轮询补偿（适合中小规模）</strong><ul><li>应用在事务提交后，直接异步发送 MQ。发送成功则更新 <code>t_event</code> 为 <code>PUBLISHED</code>。</li><li>后台启动定时任务（Worker），扫描 <code>t_event</code> 中超过 1 分钟仍为 <code>PENDING</code> 的记录，进行重试。</li><li><em>缺点</em>：增加了数据库查询压力。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EventJdbcRepository eventJdbcRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span> <span class="params">(Command cmd)</span> &#123;</span><br><span class="line">        <span class="type">AggregateRoot</span> <span class="variable">root</span> <span class="operator">=</span> repository.load(bizId);</span><br><span class="line">        entity.doBusiness(cmd.getValue());</span><br><span class="line">        repository.save(root);</span><br><span class="line">        <span class="comment">// 发布领域事件</span></span><br><span class="line">        List&lt;DomainEvent&gt; domainEvents = entity.getDomainEvents();</span><br><span class="line">        publisher.publish(domainEvents);</span><br><span class="line">        <span class="comment">// 通过事件的EntityId更新EventStore中事件的状态为已发布</span></span><br><span class="line">        List&lt;String&gt; eventIds = domainEvents.stream()</span><br><span class="line">        .map(e-&gt;e.getEventId())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">     eventJdbcRepository.publishSuccess(eventIds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 1.扫描数据库超时未发布成功的领域事件</span></span><br><span class="line">    <span class="comment">// TODO 2.发布领域事件到消息中间件</span></span><br><span class="line">    <span class="comment">// TODO 3.修改数据库领域事件发布状态为已发布</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>方案 B：事务日志拖尾 / CDC（适合大规模）</strong><ul><li>应用只管写库，不发消息。</li><li>利用 <strong>Canal / Debezium</strong> 监听数据库的 Binlog。</li><li>CDC 组件解析 Binlog 中的 <code>t_event</code> 插入记录，自动投递到 MQ。</li><li><em>优点</em>：应用层完全解耦，性能极高。</li></ul></li></ul><hr><h2 id="五、-订阅：归属于哪一层？"><a href="#五、-订阅：归属于哪一层？" class="headerlink" title="五、 订阅：归属于哪一层？"></a>五、 订阅：归属于哪一层？</h2><p>在 DDD 的分层架构中，事件订阅者（Subscriber/Listener）应该放在哪里？</p><p><strong>结论：用户接口层（User Interface / Adapters Layer）。</strong></p><ul><li><strong>理由</strong>：订阅 MQ 消息本质上和 Controller 接收 HTTP 请求是一样的。它们都是外部世界的输入（Input）。</li><li><strong>流程</strong>：<ol><li>Subscriber 接收 JSON 消息。</li><li>反序列化为 DTO。</li><li><strong>调用 Application Service</strong> 执行具体的业务命令。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 领域事件订阅者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DomainEventSubscriber</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> ApplicationService applicationService;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@KafkaListener(topics = &quot;domain_event_topic&quot;,groupId = &quot;local_consumer_group_id&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span> <span class="params">(String event)</span> &#123;</span><br><span class="line">            <span class="comment">// 解析得到领域事件</span></span><br><span class="line">            <span class="type">DomainEvent</span> <span class="variable">domainEvent</span> <span class="operator">=</span> JSON.parse(event,DomainEvent.class);</span><br><span class="line">            <span class="comment">// 拼装Command</span></span><br><span class="line">            <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="built_in">this</span>.toCommand(domainEvent);</span><br><span class="line">            <span class="comment">// 应用层执行领域模型状态变更</span></span><br><span class="line">            applicationService.handleCommand(command);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="幂等性（Idempotency）"><a href="#幂等性（Idempotency）" class="headerlink" title="幂等性（Idempotency）"></a>幂等性（Idempotency）</h3><p>由于网络抖动或重试机制，消费者必然会收到重复消息。<strong>必须</strong>利用 <code>event_id</code> 建立唯一索引或去重表，确保同一业务逻辑不执行两次。</p><hr><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>领域事件的设计不仅仅是技术实现，更是一种将<strong>业务流程显性化</strong>的手段。</p><ol><li><strong>设计上</strong>：优先选择 <strong>“聚合根暂存 + 基础设施抽取”</strong> 的生成模式，保持领域纯净。</li><li><strong>数据上</strong>：权衡消息大小，推荐使用 <strong>增强型事件</strong> 减少下游依赖。</li><li><strong>架构上</strong>：必须正视分布式一致性问题，<strong>本地消息表</strong> 是实现可靠投递的基石。</li></ol><p>DDD 的路途虽远，但只要处理好领域事件，系统的解耦与演进就会变得从容许多。</p><p>最后有关于领域事件跟事件回溯以及CQRS的结合可以看专门的文章。 CQRS与DDD: <a href="https://juejin.cn/post/7510057969265115146">https://juejin.cn/post/7510057969265115146</a> , 领域事件与事件回溯：<a href="https://juejin.cn/post/7510120678847184906">https://juejin.cn/post/7510120678847184906</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考&quot;&gt;&lt;a href=&quot;#DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考&quot; class=&quot;headerlink&quot; title=&quot;DDD 实战：关于领域事</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（三) 链表</title>
    <link href="https://nmcb666.vip/posts/73873447.html"/>
    <id>https://nmcb666.vip/posts/73873447.html</id>
    <published>2026-01-16T16:06:09.000Z</published>
    <updated>2026-01-24T07:56:35.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表相关的题目"><a href="#链表相关的题目" class="headerlink" title="链表相关的题目"></a>链表相关的题目</h1><p>这里用来记录链表相关的题目以及思路</p><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>思路：每k个翻转一次，可以单独进行反转，但注意上一组的尾节点和下一组的头节点要连接起来，所以需要记录上一组尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> teamEnd(start, k);</span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一组很特殊因为牵扯到换头的问题</span></span><br><span class="line">head = end;</span><br><span class="line">reverse(start, end);</span><br><span class="line"><span class="comment">// 翻转之后start变成了上一组的结尾节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">lastTeamEnd</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="keyword">while</span> (lastTeamEnd.next != <span class="literal">null</span>) &#123;</span><br><span class="line">start = lastTeamEnd.next;</span><br><span class="line">end = teamEnd(start, k);</span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">reverse(start, end);</span><br><span class="line">lastTeamEnd.next = end; <span class="comment">// 上一组结尾节点要连接下一组头节点</span></span><br><span class="line">lastTeamEnd = start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前组的开始节点是s，往下数k个找到当前组的结束节点返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">teamEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; s != <span class="literal">null</span>) &#123;</span><br><span class="line">s = s.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s -&gt; a -&gt; b -&gt; c -&gt; e -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment">// 上面的链表通过如下的reverse方法调整成 : e -&gt; c -&gt; b -&gt; a -&gt; s -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode s, ListNode e)</span> &#123;</span><br><span class="line">e = e.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = s, next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line">next = cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">s.next = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>思路：将每个节点复制一份，并把复制的节点放在原节点后面，比如1-&gt;2-&gt;3-&gt;4-&gt;5，复制之后变成1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;4-&gt;4’-&gt;5-&gt;5’，然后遍历链表，将复制的节点的random指针指向原节点的random指针指向的节点的下一个节点。最后将链表拆分，返回新链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span>head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将链表复制串联</span></span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">Node</span>(pre.val);</span><br><span class="line">        pre.next.next = next;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将random进行复制</span></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next.next;</span><br><span class="line">        pre.next.random = pre.random == <span class="literal">null</span> ? <span class="literal">null</span> : pre.random.next;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离两个链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newPre</span> <span class="operator">=</span> newHead;</span><br><span class="line">    pre =head;</span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next.next;</span><br><span class="line">        newPre.next = next == <span class="literal">null</span> ? <span class="literal">null</span> : next.next ;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        pre =next;</span><br><span class="line">        newPre = newPre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h2><p>思路：利用快慢指针，找到中点，然后翻转后半部分链表，比较前后两个链表是否相等。最后恢复链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//利用快慢指针找到中点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">man</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">kuai</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (kuai.next != <span class="literal">null</span> &amp;&amp; kuai.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        man = man.next;</span><br><span class="line">        kuai = kuai.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> reverseList(man);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isPal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reversePre</span> <span class="operator">=</span>reverseHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(reversePre!=<span class="literal">null</span> &amp;&amp; pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.val!=reversePre.val)&#123;</span><br><span class="line">            isPal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reversePre = reversePre.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表还原</span></span><br><span class="line">    reverseList(reverseHead);</span><br><span class="line">    <span class="keyword">return</span> isPal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next =head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre =head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表是否存在环-并求环的入口节点"><a href="#链表是否存在环-并求环的入口节点" class="headerlink" title="链表是否存在环 并求环的入口节点"></a>链表是否存在环 并求环的入口节点</h2><p>思路：利用快慢指针，快指针每次移动两步，慢指针每次移动一步，如果快慢指针相遇，则说明链表有环，否则没有环。相遇的时候，快指针回到头节点，慢指针继续移动，但是慢指针和快指针每次都移动一步，再次相遇的时候就是环的入口节点。 a+(nb+c) = 2(a+c)  a = nb - c  所以慢指针再走a步，就能到达入口节点。此时快指针也走a步，慢指针和快指针相遇的节点就是入口节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span>head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>要求：时间复杂度nlog(n),空间复杂度O(1)，且稳定<br>思路：利用非递归版本的归并排序，并且merge是合并两个有序链表。<br>代码很复杂，看看就好<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n*logn)，额外空间复杂度O(1)，有稳定性</span></span><br><span class="line"><span class="comment">// 注意为了额外空间复杂度O(1)，所以不能使用递归</span></span><br><span class="line"><span class="comment">// 因为mergeSort递归需要O(log n)的额外空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">n++;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l1...r1 每组的左部分</span></span><br><span class="line"><span class="comment">// l2...r2 每组的右部分</span></span><br><span class="line"><span class="comment">// next 下一组的开头</span></span><br><span class="line"><span class="comment">// lastTeamEnd 上一组的结尾</span></span><br><span class="line">ListNode l1, r1, l2, r2, next, lastTeamEnd;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 第一组很特殊，因为要决定整个链表的头，所以单独处理</span></span><br><span class="line">l1 = head;</span><br><span class="line">r1 = findEnd(l1, step);</span><br><span class="line">l2 = r1.next;</span><br><span class="line">r2 = findEnd(l2, step);</span><br><span class="line">next = r2.next;</span><br><span class="line">r1.next = <span class="literal">null</span>;</span><br><span class="line">r2.next = <span class="literal">null</span>;</span><br><span class="line">merge(l1, r1, l2, r2);</span><br><span class="line">head = start;</span><br><span class="line">lastTeamEnd = end;</span><br><span class="line"><span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">l1 = next;</span><br><span class="line">r1 = findEnd(l1, step);</span><br><span class="line">l2 = r1.next;</span><br><span class="line"><span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">lastTeamEnd.next = l1;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">r2 = findEnd(l2, step);</span><br><span class="line">next = r2.next;</span><br><span class="line">r1.next = <span class="literal">null</span>;</span><br><span class="line">r2.next = <span class="literal">null</span>;</span><br><span class="line">merge(l1, r1, l2, r2);</span><br><span class="line">lastTeamEnd.next = start;</span><br><span class="line">lastTeamEnd = end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括s在内，往下数k个节点返回</span></span><br><span class="line"><span class="comment">// 如果不够，返回最后一个数到的非空节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (s.next != <span class="literal">null</span> &amp;&amp; --k != <span class="number">0</span>) &#123;</span><br><span class="line">s = s.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l1...r1 -&gt; null : 有序的左部分</span></span><br><span class="line"><span class="comment">// l2...r2 -&gt; null : 有序的右部分</span></span><br><span class="line"><span class="comment">// 整体merge在一起，保证有序</span></span><br><span class="line"><span class="comment">// 并且把全局变量start设置为整体的头，全局变量end设置为整体的尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode r1, ListNode l2, ListNode r2)</span> &#123;</span><br><span class="line">ListNode pre;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">start = l1;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = l2;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">pre.next = l1;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre.next = l2;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">pre.next = l1;</span><br><span class="line">end = r1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre.next = l2;</span><br><span class="line">end = r2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h2><p>思路：利用双向链表和HashMap，双向链表负责维护最久未使用的顺序（最久未使用放到头节点，只要使用就放到尾节点）（实现三个功能 1.加入节点(直接放入尾部)，2.将已经有的节点放入尾部，3.删除头节点），HashMap实现快速查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Listnode</span>&#123;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            Listnode last;</span><br><span class="line">            Listnode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Listnode</span><span class="params">(<span class="type">int</span> val,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.val =val;</span><br><span class="line">                <span class="built_in">this</span>.key =key;</span><br><span class="line">                last =<span class="literal">null</span>;</span><br><span class="line">                next =<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">doubleList</span>&#123;</span><br><span class="line">            Listnode head;</span><br><span class="line">            Listnode tail;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">doubleList</span><span class="params">()</span>&#123;</span><br><span class="line">                head =<span class="literal">null</span>;</span><br><span class="line">                tail =<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Listnode node)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">                    head = node;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tail.next = node;</span><br><span class="line">                    node.last = tail;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNode2Tail</span><span class="params">(Listnode node)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (tail == node) &#123;  <span class="comment">/// 如果是最后一个节点，则不需要移动</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">                    head = node.next;</span><br><span class="line">                    head.last =<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    node.last.next = node.next;</span><br><span class="line">                    node.next.last = node.last;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tail.next = node;</span><br><span class="line">                node.last = tail;</span><br><span class="line">                node.next = <span class="literal">null</span>;</span><br><span class="line">                tail =node;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Listnode <span class="title function_">delHead</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">h</span> <span class="operator">=</span>head;</span><br><span class="line">                <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">                    head = <span class="literal">null</span>;</span><br><span class="line">                    tail =<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Listnode</span> <span class="variable">next</span> <span class="operator">=</span>head.next;</span><br><span class="line">                    head.next = <span class="literal">null</span>;</span><br><span class="line">                    head = next;</span><br><span class="line">                    head.last = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer,Listnode&gt; myMap;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">MaxCap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> doubleList myList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cap = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.MaxCap = capacity;</span><br><span class="line">            myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Listnode&gt;();</span><br><span class="line">            myList = <span class="keyword">new</span> <span class="title class_">doubleList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(key))&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> myMap.get(key);</span><br><span class="line">                myList.moveNode2Tail(node);</span><br><span class="line">                <span class="keyword">return</span> node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(key))&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> myMap.get(key);</span><br><span class="line">                node.val = value;</span><br><span class="line">                myList.moveNode2Tail(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cap == MaxCap)&#123;</span><br><span class="line">                    myMap.remove(myList.delHead().key);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    cap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Listnode</span>(value,key);</span><br><span class="line">                myMap.put(key,node);</span><br><span class="line">                myList.addNode(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表相关的题目&quot;&gt;&lt;a href=&quot;#链表相关的题目&quot; class=&quot;headerlink&quot; title=&quot;链表相关的题目&quot;&gt;&lt;/a&gt;链表相关的题目&lt;/h1&gt;&lt;p&gt;这里用来记录链表相关的题目以及思路&lt;/p&gt;
&lt;h2 id=&quot;相交链表&quot;&gt;&lt;a href=&quot;#相交链表</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务相关的总结</title>
    <link href="https://nmcb666.vip/posts/fee9ca7b.html"/>
    <id>https://nmcb666.vip/posts/fee9ca7b.html</id>
    <published>2026-01-15T14:13:30.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="TC-如何知道哪些RM属于同一个全局事务？"><a href="#TC-如何知道哪些RM属于同一个全局事务？" class="headerlink" title="TC 如何知道哪些RM属于同一个全局事务？"></a>TC 如何知道哪些RM属于同一个全局事务？</h3><p>以Seate框架为例，在TM向TC发送全局事务开始时，TC会生成对应的全局事务ID（XID），并发送给TM。TM 将 XID 放入当前线程的 ThreadLocal 中，后续的 RM (资源管理器) 分支事务通过解析该 XID 来注册分支。如果涉及RPC调用，每次调用时会在请求头部传递这个XID，让RM知道这个XID,RM向TC发送分支事务开始时,就会携带这个XID,从而告诉TC这个RM属于哪一个全局事务。</p><p>在多线程中，由于每个线程的XID是线程私有的，所以无法确定哪些RM属于同一个全局事务。这时全局事务会失效。解决方案可以是在开启新线程时，将XID传递给新线程，新线程的XID会继承父线程的XID。这样子线程的XID就会和父线程的XID一致，从而可以确定哪些RM属于同一个全局事务。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-15%20142842.png" alt="流程图片"/></div><span class="image-caption">流程图片</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h2&gt;&lt;h3 id=&quot;TC-如何知道哪些RM属于同一个全局事务？&quot;&gt;&lt;a href=&quot;#TC-如何知道哪些RM属于同一个全局事务</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>DDD与MVC的统一</title>
    <link href="https://nmcb666.vip/posts/f4b47790.html"/>
    <id>https://nmcb666.vip/posts/f4b47790.html</id>
    <published>2026-01-11T18:50:35.000Z</published>
    <updated>2026-01-24T07:56:35.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC到DDD：从架构分层到业务建模的思考"><a href="#MVC到DDD：从架构分层到业务建模的思考" class="headerlink" title="MVC到DDD：从架构分层到业务建模的思考"></a>MVC到DDD：从架构分层到业务建模的思考</h1><p>在后端开发学习和实践过程中，我们总会被各种架构模式和设计思想围绕——MVC、Service+DAO分层、DDD四层架构（DDD并非与四层架构绑定 DDD是思想，四层架构是代码落地的一个架构）……这些概念之间到底是替代关系还是互补关系？为什么简单业务用Service+DAO就够，复杂业务却要引入DDD？结合近期的学习思考，我想梳理清楚这些架构之间的核心关联，帮自己（也希望帮到同样困惑的同学）建立清晰的认知。</p><h2 id="一、起点：MVC的核心价值——解决“代码放哪”的基础问题"><a href="#一、起点：MVC的核心价值——解决“代码放哪”的基础问题" class="headerlink" title="一、起点：MVC的核心价值——解决“代码放哪”的基础问题"></a>一、起点：MVC的核心价值——解决“代码放哪”的基础问题</h2><p>最早接触后端开发时，MVC是绕不开的入门架构。它的核心思想非常简单：将软件分为三个核心层级，实现“展示与逻辑”的初步解耦。</p><ul><li><p><strong>Controller（控制器）</strong>：接收用户请求、协调后续处理、返回响应，相当于系统的“入口/出口”，不承载核心业务逻辑；</p></li><li><p><strong>Model（模型）</strong>：封装数据和核心业务逻辑，是系统的“大脑”，负责数据的增删改查和业务规则校验；</p></li><li><p><strong>View（视图）</strong>：展示数据，与用户直接交互（前后端分离场景下，前端页面即View层，后端不再关注）。</p></li></ul><p>MVC的价值在于给出了“代码该放哪”的明确答案，解决了早期开发中“业务逻辑与页面展示混在一起”的混乱问题。但它的局限性也很明显：Model层是一个“大黑盒”，没有明确的内部划分标准——当业务简单时，一个Service+Mapper就能撑起Model层；但当业务复杂（比如电商订单履约、金融风控）时，直接把所有逻辑堆在Service里，很快就会导致代码臃肿、逻辑混乱、难以维护。</p><h2 id="二、演进：Service-DAO分层——MVC-Model层的简易拆分"><a href="#二、演进：Service-DAO分层——MVC-Model层的简易拆分" class="headerlink" title="二、演进：Service+DAO分层——MVC Model层的简易拆分"></a>二、演进：Service+DAO分层——MVC Model层的简易拆分</h2><p>为了弥补MVC Model层的模糊性，在Spring生态实践中，我们自然演化出了“Controller+Service+DAO（Mapper）”的三层落地方案。这本质上是对MVC的Model层做了第一次“粗粒度拆分”，让职责更清晰：</p><ul><li><p><strong>Controller层</strong>：完全对应MVC的Controller层，负责请求接收、参数简单校验、调用Service层；</p></li><li><p><strong>Service层</strong>：对应MVC Model层的“业务逻辑核心”，实现订单支付、库存扣减等核心业务规则；</p></li><li><p><strong>DAO（Mapper）层</strong>：对应MVC Model层的“数据访问部分”，仅负责与数据库交互，不包含任何业务逻辑。</p></li></ul><p>这种拆分方案简单直观、开发效率高，非常适合简单CRUD场景（比如小型管理后台、个人工具）。但它的问题在复杂业务场景下会暴露无遗：Service层很容易变成“万能层”——既要处理跨实体的业务逻辑（比如支付需要协调订单、库存、支付三个模块），又要兼顾事务控制、数据组装等辅助逻辑，最终导致Service层代码臃肿、逻辑缠绕，后续迭代和维护成本极高。</p><h2 id="三、进阶：DDD四层架构——MVC-Model层的精细化升级"><a href="#三、进阶：DDD四层架构——MVC-Model层的精细化升级" class="headerlink" title="三、进阶：DDD四层架构——MVC Model层的精细化升级"></a>三、进阶：DDD四层架构——MVC Model层的精细化升级</h2><p>当业务复杂度上升到一定程度，DDD（领域驱动设计）就成了更优的选择。很多人会误以为DDD是“替代MVC”的架构，其实不然——DDD本质上是一套“业务建模方法论”，它在MVC的大框架下，对Model层做了更精细的拆分，让复杂业务逻辑更清晰、更贴合业务本身。</p><p>DDD提出的四层架构（用户层/接口层、应用层、领域层、基础设施层），与MVC、Service+DAO分层的对应关系非常清晰，核心结论先抛出来：<strong>DDD的用户层对应MVC的Controller层，后三层共同构成MVC的Model层；DDD与MVC完全兼容，只是对Model层的拆分更彻底</strong>。</p><h3 id="1-DDD四层架构的核心职责与对应关系"><a href="#1-DDD四层架构的核心职责与对应关系" class="headerlink" title="1. DDD四层架构的核心职责与对应关系"></a>1. DDD四层架构的核心职责与对应关系</h3><div class="table-container"><table><thead><tr><th>DDD四层架构</th><th>核心职责</th><th>对应MVC分层</th><th>对应Service+DAO分层</th><th>Spring实践落地</th></tr></thead><tbody><tr><td>用户层（接口层）</td><td>接收外部请求（HTTP/RPC/消息）、返回响应、参数非业务校验、权限拦截</td><td>Controller层</td><td>Controller层</td><td>@RestController、ControllerAdvice、RPC接口</td></tr><tr><td>应用层</td><td>协调领域层执行、处理事务、组装返回数据，无核心业务逻辑</td><td>Model层</td><td>Service层的“协调部分”</td><td>XXXApplicationService（应用服务）</td></tr><tr><td>领域层</td><td>封装核心业务规则、聚合根/实体/值对象、跨实体业务逻辑，系统核心</td><td>Model层（核心）</td><td>Service层的“核心业务部分”</td><td>聚合根（Entity）、XXXDomainService（领域服务）</td></tr><tr><td>基础设施层</td><td>封装技术细节（数据库、缓存、第三方接口），为上层提供技术支撑</td><td>Model层</td><td>DAO（Mapper）层</td><td>Repository、Mapper、RedisTemplate、Feign客户端</td></tr></tbody></table></div><h3 id="2-关键演进：从Service层到“应用服务-领域服务”"><a href="#2-关键演进：从Service层到“应用服务-领域服务”" class="headerlink" title="2. 关键演进：从Service层到“应用服务+领域服务”"></a>2. 关键演进：从Service层到“应用服务+领域服务”</h3><p>DDD对Service+DAO分层的核心优化，就是把传统“厚Service”拆成了“薄应用服务”和“厚领域服务”，让业务逻辑的归属更明确：</p><ul><li><p><strong>领域服务</strong>：只负责核心业务逻辑，比如“订单支付”需要校验订单状态、扣减库存、更新支付状态等跨实体逻辑，都放在领域服务；</p></li><li><p><strong>应用服务</strong>：不碰核心业务，只做“协调工作”——比如开启事务、调用领域服务、把领域层的结果组装成前端需要的格式。</p></li></ul><p>同时，DDD还强调“业务驱动建模”：先梳理业务领域的规则（比如“未支付订单24小时自动取消”），再把这些规则封装到实体类中（比如Order实体的canPay()、markAsPaid()方法），而不是像传统Service+DAO那样，把所有业务逻辑都写在Service的if-else里。这种方式让代码更贴合业务，后续迭代时也更容易理解和修改。</p><h2 id="四、核心认知：所有架构的本质都是“解耦”，只是粒度不同"><a href="#四、核心认知：所有架构的本质都是“解耦”，只是粒度不同" class="headerlink" title="四、核心认知：所有架构的本质都是“解耦”，只是粒度不同"></a>四、核心认知：所有架构的本质都是“解耦”，只是粒度不同</h2><p>梳理完从MVC到Service+DAO，再到DDD的演进脉络，会发现一个核心规律：<strong>所有架构分层的最终目标都是“解耦”，只是针对不同业务复杂度，选择了不同的拆分粒度</strong>。</p><ul><li><p>MVC：解决“展示与逻辑”的解耦，给出最基础的分层框架；</p></li><li><p>Service+DAO：解决MVC Model层的内部解耦，让数据访问和业务逻辑分离，适配简单业务；</p></li><li><p>DDD：解决复杂业务下Model层的深度解耦，让核心业务逻辑、协调逻辑、技术细节彻底分离，适配复杂业务。</p></li></ul><p>很多人会误以为“DDD比MVC高级”“用了DDD就不能用MVC”，这其实是误区。DDD和MVC不是对立关系，而是互补关系——MVC提供了整体的架构骨架，DDD则是对这个骨架中“Model层”的精细化设计指南。</p><h2 id="五、实践建议：根据业务复杂度选择合适的架构"><a href="#五、实践建议：根据业务复杂度选择合适的架构" class="headerlink" title="五、实践建议：根据业务复杂度选择合适的架构"></a>五、实践建议：根据业务复杂度选择合适的架构</h2><p>架构没有“最优解”，只有“最合适”。结合自己的实践经验，给出几点选择建议：</p><ol><li><p><strong>简单CRUD场景（小型管理后台、个人工具）</strong>：直接用“Controller+Service+DAO”，开发效率高、维护成本低，没必要过度设计；</p></li><li><p><strong>中等复杂度场景（常规业务系统）</strong>：可以借鉴DDD的思想，在Service层内部做简单拆分（比如把核心业务逻辑抽成单独的方法或类），避免Service层臃肿；</p></li><li><p><strong>高复杂度场景（电商、金融、供应链）</strong>：推荐使用DDD四层架构，通过领域建模让复杂业务逻辑更清晰，为长期迭代打下基础；</p></li><li><p><strong>渐进式改造</strong>：不用一开始就全盘重构为DDD，可以从“拆分Service层”开始，先把核心业务逻辑抽成领域服务，再逐步完善应用层和基础设施层，降低改造风险。</p></li></ol><h2 id="六、DDD跟四层架构什么关系？"><a href="#六、DDD跟四层架构什么关系？" class="headerlink" title="六、DDD跟四层架构什么关系？"></a>六、DDD跟四层架构什么关系？</h2><p>DDD（领域驱动设计）本身不强制规定 “四层架构”。DDD 的核心在于战略设计（限界上下文、领域模型）和战术设计（实体、值对象、聚合根、领域服务、仓储等），而 “四层架构” 确实是为了让这些战术设计模式在代码层面更好落地而总结出的一套经典工程实践。</p><p>在实际落地 DDD 时，代码架构的选择确实非常重要。虽然 DDD 是一种思想，不强求特定目录结构，但业界已经沉淀出两套最主流的架构模式：</p><ol><li><strong>经典的四层架构（Layered Architecture）</strong> —— 最容易理解，适合起步。</li><li><strong>整洁/六边形架构（Clean / Hexagonal Architecture）</strong> —— 依赖倒置更彻底，现代微服务主流。</li></ol><p>此外，国内 Java 圈（特别是阿里系）还常用 <strong>COLA 架构</strong>。</p><p>下面详细拆解这几种架构的代码目录结构和核心要点。</p><hr><h3 id="方案一：经典的四层架构-Standard-4-Layer"><a href="#方案一：经典的四层架构-Standard-4-Layer" class="headerlink" title="方案一：经典的四层架构 (Standard 4-Layer)"></a>方案一：经典的四层架构 (Standard 4-Layer)</h3><p>这是最符合上文所提出观点的理解的结构，结构清晰，适合从三层架构转型过来的团队。</p><h4 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h4><p><strong>依赖倒置（DIP）</strong>：虽然物理上是四层，但在逻辑上，<strong>领域层（Domain）必须是独立的</strong>。</p><ul><li><strong>错误的做法</strong>：Domain 层 <code>import</code> Infrastructure 层的代码。</li><li><strong>正确的做法</strong>：Domain 层定义接口（Repository Interface），Infrastructure 层去实现它。</li></ul><h4 id="目录结构示例"><a href="#目录结构示例" class="headerlink" title="目录结构示例"></a>目录结构示例</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.company.project</span><br><span class="line">├── interfaces (用户接口层 / Web)</span><br><span class="line">│   ├── controller       // 处理 HTTP 请求</span><br><span class="line">│   └── dto              // 数据传输对象 (Request/Response)</span><br><span class="line">├── application (应用层)</span><br><span class="line">│   ├── service          // 应用服务 (流程编排)</span><br><span class="line">│   └── assembler        // DTO 与 Entity 的转换器</span><br><span class="line">├── domain (领域层 - 核心)</span><br><span class="line">│   ├── model            // 聚合根、实体、值对象</span><br><span class="line">│   │   ├── aggregate    // 聚合</span><br><span class="line">│   │   └── entity       // 实体</span><br><span class="line">│   ├── service          // 领域服务 (跨实体逻辑)</span><br><span class="line">│   └── repository       // 仓储接口 (注意：这里只放接口！)</span><br><span class="line">└── infrastructure (基础设施层)</span><br><span class="line">    ├── repository       // 仓储实现 (Impl，这里依赖 JPA/MyBatis)</span><br><span class="line">    ├── entity           // PO (Persistent Object，对应数据库表)</span><br><span class="line">    └── util             // 通用工具</span><br></pre></td></tr></table></figure><hr><h3 id="方案二：整洁架构-六边形架构-Clean-Hexagonal"><a href="#方案二：整洁架构-六边形架构-Clean-Hexagonal" class="headerlink" title="方案二：整洁架构 / 六边形架构 (Clean / Hexagonal)"></a>方案二：整洁架构 / 六边形架构 (Clean / Hexagonal)</h3><p>这是目前 DDD 社区<strong>最推荐</strong>的架构，特别是在微服务场景下。它不再强调“上下层”，而是强调“<strong>内外</strong>”。</p><ul><li><strong>内核（Inner）</strong>：Domain + Application。这是雷打不动的业务核心。</li><li><strong>外壳（Outer）</strong>：Web、Database、Redis、MQ。这些都是“插件”。</li></ul><h4 id="核心原则-1"><a href="#核心原则-1" class="headerlink" title="核心原则"></a>核心原则</h4><p><strong>依赖只能由外向内</strong>。外壳（Web、DB）依赖内核（Domain），内核谁也不依赖。</p><h4 id="目录结构示例-1"><a href="#目录结构示例-1" class="headerlink" title="目录结构示例"></a>目录结构示例</h4><p>这种架构通常会把文件夹分为 <code>adapter</code>（适配器/外壳）和 <code>core</code>（内核）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com.company.project</span><br><span class="line">├── adapter (适配器层 - 对应“六边形”的端口)</span><br><span class="line">│   ├── inbound (输入端 / 驱动端)</span><br><span class="line">│   │   └── web          // RestController</span><br><span class="line">│   └── outbound (输出端 / 被驱动端)</span><br><span class="line">│       ├── persistence  // 数据库实现 (Repository Impl)</span><br><span class="line">│       └── thirdparty   // 第三方调用 (如调用支付接口)</span><br><span class="line">├── application (应用层 - 业务流程)</span><br><span class="line">│   ├── service          // 应用服务</span><br><span class="line">│   └── port             // 端口定义 (如果是严格六边形，接口定义在这里)</span><br><span class="line">└── domain (领域层 - 业务核心)</span><br><span class="line">    ├── model            // 实体、聚合根</span><br><span class="line">    ├── service          // 领域服务</span><br><span class="line">    └── repository       // 仓储接口 (定义数据该怎么存，但不关心存哪里)</span><br></pre></td></tr></table></figure><p><strong>区别点</strong>：<br>你会发现 <code>Controller</code> 和 <code>RepositoryImpl</code> 变成了兄弟关系，都属于 <code>Adapter</code>（外围设施），而 <code>Domain</code> 被层层保护在最里面。</p><hr><h3 id="方案三：COLA-架构-Clean-Object-Oriented-and-Layered-Architecture"><a href="#方案三：COLA-架构-Clean-Object-Oriented-and-Layered-Architecture" class="headerlink" title="方案三：COLA 架构 (Clean Object-Oriented and Layered Architecture)"></a>方案三：COLA 架构 (Clean Object-Oriented and Layered Architecture)</h3><p>如果你是 Java 开发者，特别是在国内大厂环境，阿里开源的 <strong>COLA 架构</strong> 是一个非常流行的 DDD 落地模板。它结合了四层架构和整洁架构的优点。</p><p>它的特点是把<strong>对外暴露的接口（API）</strong>单独抽离成一个模块，方便微服务之间调用。</p><h4 id="Maven-模块结构"><a href="#Maven-模块结构" class="headerlink" title="Maven 模块结构"></a>Maven 模块结构</h4><p>COLA 通常是多 Module 的 Maven 项目：</p><ol><li><strong><code>start</code> (启动层)</strong><ul><li>Spring Boot 启动类，各种配置。</li></ul></li><li><strong><code>adapter</code> (适配层)</strong><ul><li>Controller (Web), Consumer (MQ)。</li></ul></li><li><strong><code>client</code> (API 层 / SDK)</strong><ul><li><strong>重点</strong>：这里放 DTO 和 API 接口定义。外部系统只需要依赖这个 jar 包。</li></ul></li><li><strong><code>app</code> (应用层)</strong><ul><li>Application Service, Command Handler。</li></ul></li><li><strong><code>domain</code> (领域层)</strong><ul><li>Entity, ValueObject, DomainService, Repository Interface。</li><li><strong>最纯净的一层，不依赖 Spring，只依赖 JDK。</strong></li></ul></li><li><strong><code>infrastructure</code> (基础设施层)</strong><ul><li>MyBatis Mapper, Repository Impl, Redis Util。</li></ul></li></ol><hr><h3 id="总结：我该怎么选？"><a href="#总结：我该怎么选？" class="headerlink" title="总结：我该怎么选？"></a>总结：我该怎么选？</h3><ol><li><p><strong>如果你是初学者，或者项目规模不大</strong>：<br>推荐 <strong>方案一（经典的四层架构）</strong>。</p><ul><li>理由：最符合直觉，文件夹分层清晰，从 MVC 迁移过来认知负担最小。</li><li><em>注意点：一定要坚持“领域层定义接口，基础层实现接口”，不要让领域层依赖 MyBatis。</em></li></ul></li><li><p><strong>如果你在做微服务，或者业务逻辑极度复杂</strong>：<br>推荐 <strong>方案二（整洁/六边形架构）</strong>。</p><ul><li>理由：能够完美隔离技术实现的变动（比如从 MySQL 换到 MongoDB，核心业务代码一行都不用改）。</li></ul></li><li><p><strong>如果你的团队用 Java 且由于规范要求</strong>：<br>推荐 <strong>方案三（COLA）</strong>。</p><ul><li>理由：国内资料多，规范约束性强，适合团队协作。</li></ul></li></ol><h3 id="关键点（无论选哪个架构）"><a href="#关键点（无论选哪个架构）" class="headerlink" title="关键点（无论选哪个架构）"></a>关键点（无论选哪个架构）</h3><p>不管你选哪个文件结构，DDD 落地的<strong>生死线</strong>只有一条：</p><blockquote><p><strong>Domain 层（领域层）必须是“纯净”的。</strong></p></blockquote><ul><li>它可以引用 <code>java.util.List</code>。</li><li>它<strong>绝对不能</strong>引用 <code>javax.sql.DataSource</code>、<code>org.springframework.xxx</code>、<code>com.github.pagehelper</code>。</li><li>它只谈业务（账号、金额、冻结），不谈技术（表、JSON、HTTP）。</li></ul><p>只要守住了这条线，你的架构就是合格的 DDD 架构。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>从MVC到Service+DAO，再到DDD，不是架构的“替代”，而是架构的“演进”。它们的核心都是通过分层实现解耦，只是针对不同的业务复杂度，选择了不同的拆分粒度。</p><p>对于开发者而言，不用盲目追求“高大上”的架构，而应该理解每种架构的核心价值和适用场景：简单业务用简单架构，复杂业务用精细架构。同时，要抓住架构设计的本质——让代码结构清晰、职责明确，便于维护和迭代。这才是我们学习各种架构思想的最终目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC到DDD：从架构分层到业务建模的思考&quot;&gt;&lt;a href=&quot;#MVC到DDD：从架构分层到业务建模的思考&quot; class=&quot;headerlink&quot; title=&quot;MVC到DDD：从架构分层到业务建模的思考&quot;&gt;&lt;/a&gt;MVC到DDD：从架构分层到业务建模的思考&lt;/</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络问题总结</title>
    <link href="https://nmcb666.vip/posts/a3a5550f.html"/>
    <id>https://nmcb666.vip/posts/a3a5550f.html</id>
    <published>2026-01-08T15:32:51.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习过程中的疑惑"><a href="#学习过程中的疑惑" class="headerlink" title="学习过程中的疑惑"></a>学习过程中的疑惑</h2><h3 id="通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-那我应该得到谁的mac地址呢"><a href="#通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-那我应该得到谁的mac地址呢" class="headerlink" title="通过ARP协议我们可以知道目的ip的mac地址  那要是这个ip不在我的局域网里面 那我应该得到谁的mac地址呢"></a>通过ARP协议我们可以知道目的ip的mac地址  那要是这个ip不在我的局域网里面 那我应该得到谁的mac地址呢</h3><p>这是一个非常经典且关键的网络问题。</p><p>简单直接的回答是：<strong>你会得到你所在局域网的“网关”（Gateway）的 MAC 地址。</strong></p><h4 id="详细原理解析"><a href="#详细原理解析" class="headerlink" title="详细原理解析"></a>详细原理解析</h4><p>当你的电脑（主机 A）想要发送数据包给一个 IP 地址（主机 B）时，它会经历以下逻辑判断流程：</p><ol><li><p><strong>判断目标 IP 是否在同一个局域网（子网）内：</strong></p><ul><li>电脑会查看自己的子网掩码（Subnet Mask）。</li><li>如果 <code>目标IP</code> 和 <code>本机IP</code> 在同一个网段内，电脑认为它可以直接通信。</li><li><strong>如果不在同一个网段内</strong>，电脑认为“我够不着它”，必须找一个“中介”来帮忙转发。</li></ul></li><li><p><strong>寻找“中介”（网关）：</strong></p><ul><li>这个“中介”就是你配置的<strong>默认网关（Default Gateway）</strong>。通常这是你路由器（Router）的内网 IP 地址（例如 <code>192.168.1.1</code> 或 <code>192.168.0.1</code>）。</li><li>电脑会把数据包发给网关，由网关负责把数据包投递到外网。</li></ul></li><li><p><strong>ARP 解析的对象发生变化：</strong></p><ul><li>既然数据包要发给网关，那么在数据链路层（二层），目标 MAC 地址就必须是网关的 MAC 地址。</li><li>因此，你的电脑会发起一个 <strong>ARP 请求</strong>，但是请求的目标 IP 不再是“目的 IP”，而是 <strong>“网关的 IP”</strong>。</li></ul></li><li><p><strong>获取 MAC 地址：</strong></p><ul><li>网关（路由器）收到 ARP 请求后，回复它的 MAC 地址。</li><li>你的电脑将数据包封装，<strong>目标 IP 仍然是远方的 IP，但目标 MAC 地址变成了网关的 MAC 地址</strong>。</li></ul></li></ol><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假设你的网络环境如下：</p><ul><li><strong>你的电脑 IP：</strong> <code>192.168.1.100</code></li><li><strong>你的网关 IP：</strong> <code>192.168.1.1</code> （MAC: <code>AA:AA:AA:AA:AA:AA</code>）</li><li><strong>你想访问的百度服务器 IP：</strong> <code>110.242.68.4</code> （这显然不在你的局域网）</li></ul><p><strong>发生的过程：</strong></p><ol><li>你要 ping <code>110.242.68.4</code>。</li><li>你的电脑计算一下，发现 <code>110.242.68.4</code> 不在 <code>192.168.1.x</code> 这个圈子里。</li><li>你的电脑决定：“我要把这个包交给网关 <code>192.168.1.1</code> 处理。”</li><li>你的电脑发出 ARP 请求：“谁是 <code>192.168.1.1</code>？请告诉我你的 MAC 地址。”</li><li>路由器回复：“我是 <code>192.168.1.1</code>，我的 MAC 是 <code>AA:AA:AA:AA:AA:AA</code>。”</li><li>你的电脑发送数据包：<ul><li><strong>源 IP：</strong> <code>192.168.1.100</code></li><li><strong>目的 IP：</strong> <code>110.242.68.4</code> （IP 头不变）</li><li><strong>源 MAC：</strong> <code>你的电脑 MAC</code></li><li><strong>目的 MAC：</strong> <code>AA:AA:AA:AA:AA:AA</code> （变成了网关的 MAC）</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>同网段通信：</strong> ARP 解析 <strong>目标 IP</strong> 的 MAC。</li><li><strong>跨网段通信：</strong> ARP 解析 <strong>网关 IP</strong> 的 MAC。</li></ul><p>这就是为什么当你访问互联网上任何网站时，你电脑的 ARP 缓存表中，主要变动的其实是网关的记录，而不是互联网上无数服务器的 MAC 地址（你也无法直接获取互联网服务器的 MAC 地址，因为路由器会隔离广播域）。</p><h3 id="封装好网络包后如何送达目标IP？"><a href="#封装好网络包后如何送达目标IP？" class="headerlink" title="封装好网络包后如何送达目标IP？"></a>封装好网络包后如何送达目标IP？</h3><p>在网络通信中，“封装好网络包后如何送达目标IP”是最核心的基础问题之一。这个过程涉及链路层、网络层的协同工作，以及交换机、路由器等设备的核心机制。本文将结合此前的讨论，以技术思考的视角，完整梳理从网络包封装完成到最终送达目标IP的全流程，拆解其中的关键逻辑与设备分工。</p><h4 id="一、核心前提：网络包的“两层身份”与核心寻址要素"><a href="#一、核心前提：网络包的“两层身份”与核心寻址要素" class="headerlink" title="一、核心前提：网络包的“两层身份”与核心寻址要素"></a>一、核心前提：网络包的“两层身份”与核心寻址要素</h4><p>当我们在主机上完成网络包封装后（通常是TCP/UDP头部+IP头部+数据的封装），这个包要在物理网络中传输，必须具备“两层身份标识”，对应网络分层模型的不同职责：</p><ul><li><p><strong>网络层身份</strong>：即源IP地址（发送方主机IP）和目标IP地址（最终接收方IP），核心作用是“跨网段导航”，确定数据包的最终目的地，全程不变。</p></li><li><p><strong>链路层身份</strong>：即源MAC地址（当前发送设备网卡MAC）和目标MAC地址（当前链路下一跳设备MAC），核心作用是“局域网内定位”，每经过一跳链路都会更新，仅在当前链路有效。</p></li></ul><p>核心结论：IP地址负责“找最终目的地在哪”，MAC地址负责“找当前链路上下一跳是谁”，两者协同完成全路径传输。</p><h4 id="二、发送前的关键决策：目标IP是否在同一局域网？"><a href="#二、发送前的关键决策：目标IP是否在同一局域网？" class="headerlink" title="二、发送前的关键决策：目标IP是否在同一局域网？"></a>二、发送前的关键决策：目标IP是否在同一局域网？</h4><p>封装完成后，主机的TCP/IP协议栈首先会进行一个核心判断——目标IP是否与本机在同一局域网（通过子网掩码计算网段）。这个判断直接决定了后续的发送逻辑：是直接发送给目标主机，还是先发送给网关（路由器）。</p><h4 id="三、同一局域网场景：直接发送至目标主机"><a href="#三、同一局域网场景：直接发送至目标主机" class="headerlink" title="三、同一局域网场景：直接发送至目标主机"></a>三、同一局域网场景：直接发送至目标主机</h4><p>当目标IP在同一网段时，主机需要直接与目标主机通信，核心问题是“如何获取目标IP对应的MAC地址”，这就需要ARP协议的参与。</p><h5 id="3-1-步骤1：查询ARP缓存表"><a href="#3-1-步骤1：查询ARP缓存表" class="headerlink" title="3.1 步骤1：查询ARP缓存表"></a>3.1 步骤1：查询ARP缓存表</h5><p>主机本地会维护一个ARP缓存表，存储“IP地址-MAC地址”的映射关系。协议栈会先查询该表：</p><ul><li><p>若存在目标IP对应的MAC地址：直接进入链路层封装，将目标MAC填入以太网帧头，源MAC填入本机网卡MAC，然后将帧发送至交换机。</p></li><li><p>若不存在目标IP对应的MAC地址：触发ARP广播流程。</p></li></ul><h5 id="3-2-步骤2：ARP广播获取目标MAC"><a href="#3-2-步骤2：ARP广播获取目标MAC" class="headerlink" title="3.2 步骤2：ARP广播获取目标MAC"></a>3.2 步骤2：ARP广播获取目标MAC</h5><p>主机发送ARP请求包（链路层目标MAC为广播地址FF:FF:FF:FF:FF:FF），该广播包会被交换机泛洪至局域网内所有设备：</p><ul><li><p>非目标设备收到后，发现目标IP不是自己，直接丢弃；</p></li><li><p>目标设备收到后，识别出目标IP是自己，回复ARP响应包，包含自身MAC地址；</p></li><li><p>主机收到ARP响应后，将“目标IP-目标MAC”映射存入ARP缓存表，后续通信可直接使用。</p></li></ul><h5 id="3-3-步骤3：交换机的转发逻辑"><a href="#3-3-步骤3：交换机的转发逻辑" class="headerlink" title="3.3 步骤3：交换机的转发逻辑"></a>3.3 步骤3：交换机的转发逻辑</h5><p>主机将封装好的以太网帧发送至交换机后，交换机会通过自身的MAC地址表（记录“MAC地址-端口”映射）进行转发：</p><ul><li><p>若MAC地址表存在目标MAC对应的端口：直接将帧从该端口转发（单播），仅目标设备能接收；</p></li><li><p>若MAC地址表不存在目标MAC对应的端口：交换机执行“泛洪”，将帧从除接收端口外的所有端口转发，直到目标设备接收后，交换机通过源MAC学习，将目标MAC与对应端口的映射存入MAC地址表，后续通信直接单播。</p></li></ul><p>核心要点：交换机仅识别MAC地址，不关心IP地址；ARP广播仅在当前局域网内传播，不会跨网段。</p><h4 id="四、跨局域网场景：通过网关转发至目标IP"><a href="#四、跨局域网场景：通过网关转发至目标IP" class="headerlink" title="四、跨局域网场景：通过网关转发至目标IP"></a>四、跨局域网场景：通过网关转发至目标IP</h4><p>当目标IP不在同一网段时，主机无法直接与目标主机通信，必须通过网关（路由器）转发——网关是连接本地局域网与外部网络的“桥梁”，同时属于两个网络（本地局域网和外网），拥有两个IP和两个MAC（局域网侧IP/MAC、外网侧IP/MAC）。</p><h5 id="4-1-步骤1：获取网关的IP和MAC地址"><a href="#4-1-步骤1：获取网关的IP和MAC地址" class="headerlink" title="4.1 步骤1：获取网关的IP和MAC地址"></a>4.1 步骤1：获取网关的IP和MAC地址</h5><ul><li><p>网关IP的获取：主机通过DHCP自动获取（常见）或手动配置，存储在本地网络设置中；</p></li><li><p>网关MAC的获取：与同一局域网获取目标MAC逻辑一致，通过查询ARP缓存表或发送ARP广播获取网关IP对应的MAC地址。</p></li></ul><h5 id="4-2-步骤2：发送至网关"><a href="#4-2-步骤2：发送至网关" class="headerlink" title="4.2 步骤2：发送至网关"></a>4.2 步骤2：发送至网关</h5><p>主机将以太网帧的目标MAC填入网关的局域网侧MAC，源MAC填入本机MAC，发送至交换机，由交换机转发至网关。</p><h5 id="4-3-步骤3：网关的转发逻辑（跨网段核心）"><a href="#4-3-步骤3：网关的转发逻辑（跨网段核心）" class="headerlink" title="4.3 步骤3：网关的转发逻辑（跨网段核心）"></a>4.3 步骤3：网关的转发逻辑（跨网段核心）</h5><p>网关（路由器）收到帧后，会执行“剥帧-路由-重新封装”的核心流程：</p><ol><li><p>剥帧：路由器工作在网络层，会剥离链路层以太网帧头（MAC地址信息失效），查看IP头部的目标IP；</p></li><li><p>路由决策：查询自身路由表，确定目标IP对应的“下一跳网关”（可能是运营商路由器、骨干网路由器等）；</p></li><li><p>重新封装：通过ARP获取下一跳网关的MAC地址，将新的以太网帧头封装（源MAC为网关的外网侧MAC，目标MAC为下一跳网关的MAC），发送至下一跳；</p></li><li><p>重复转发：数据包在互联网中经过多个路由器接力转发，每一跳都重复“剥帧-路由-重新封装”，直到到达目标IP所在的局域网网关。</p></li></ol><h5 id="4-4-步骤4：NAT地址转换（家庭-企业网络必备）"><a href="#4-4-步骤4：NAT地址转换（家庭-企业网络必备）" class="headerlink" title="4.4 步骤4：NAT地址转换（家庭/企业网络必备）"></a>4.4 步骤4：NAT地址转换（家庭/企业网络必备）</h5><p>家庭/企业内网使用私有IP（如192.168.x.x），无法直接在互联网中路由。因此，网关在转发时会触发NAT（网络地址转换）：</p><ul><li><p>出口转换：将数据包的源IP从私有IP改为网关的公网IP，同时记录“私有IP:端口-公网IP:端口”的映射关系（NAT表）；</p></li><li><p>入口转换：当目标IP的响应包返回至网关时，网关通过NAT表反向查询，将目标IP改为对应的内网私有IP，目标MAC改为该主机的MAC，转发至目标主机。</p></li></ul><p>核心要点：NAT仅发生在本地网关的出口处，是私有IP访问互联网的必要条件；源IP在NAT转换后，在互联网传输过程中保持不变，直到到达目标局域网。</p><h5 id="4-5-步骤5：目标局域网内的最后一跳"><a href="#4-5-步骤5：目标局域网内的最后一跳" class="headerlink" title="4.5 步骤5：目标局域网内的最后一跳"></a>4.5 步骤5：目标局域网内的最后一跳</h5><p>当数据包到达目标IP所在的局域网网关后，网关会再次执行“剥帧-路由”，发现目标IP在当前局域网内，通过ARP获取目标主机的MAC地址，重新封装帧后发送至目标主机，完成全链路传输。</p><h4 id="五、关键设备分工总结"><a href="#五、关键设备分工总结" class="headerlink" title="五、关键设备分工总结"></a>五、关键设备分工总结</h4><div class="table-container"><table><thead><tr><th>设备</th><th>工作层级</th><th>核心职责</th><th>关键特性</th></tr></thead><tbody><tr><td>主机</td><td>网络层+链路层</td><td>封装网络包、ARP查询/广播、判断目标IP网段</td><td>维护ARP缓存表，不直接跨网段转发</td></tr><tr><td>交换机</td><td>链路层</td><td>根据MAC地址表转发帧、泛洪未知MAC帧、学习源MAC</td><td>不识别IP地址，不隔离广播域（二层交换机）</td></tr><tr><td>路由器（网关）</td><td>网络层+链路层</td><td>路由决策、跨网段转发、NAT转换、隔离广播域</td><td>丢弃广播包，同时属于多个网络，维护路由表</td></tr></tbody></table></div><h4 id="六、全流程核心总结（思维导图式）"><a href="#六、全流程核心总结（思维导图式）" class="headerlink" title="六、全流程核心总结（思维导图式）"></a>六、全流程核心总结（思维导图式）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">封装完成网络包</span><br><span class="line">├─ 决策：目标IP是否在同一局域网？</span><br><span class="line">│  ├─ 是：</span><br><span class="line">│  │  ├─ 查询ARP缓存表 → 有目标MAC？</span><br><span class="line">│  │  │  ├─ 是：封装帧（目标MAC=目标主机MAC）→ 交换机转发 → 目标主机</span><br><span class="line">│  │  │  └─ 否：ARP广播获取目标MAC → 存入缓存 → 封装转发</span><br><span class="line">│  └─ 否：</span><br><span class="line">│     ├─ 获取网关IP（DHCP/手动配置）</span><br><span class="line">│     ├─ 获取网关MAC（ARP查询/广播）</span><br><span class="line">│     ├─ 封装帧（目标MAC=网关MAC）→ 交换机转发 → 网关</span><br><span class="line">│     ├─ 网关NAT：源IP从私有IP改为公网IP</span><br><span class="line">│     ├─ 网关路由决策 → 转发至下一跳（互联网多路由器接力）</span><br><span class="line">│     ├─ 到达目标局域网网关 → 剥帧路由 → 获取目标主机MAC</span><br><span class="line">│     └─ 转发至目标主机</span><br><span class="line">└─ 核心不变量：目标IP全程不变；核心变量：MAC地址每跳更新</span><br></pre></td></tr></table></figure><h4 id="七、关键疑问解答（补充思考）"><a href="#七、关键疑问解答（补充思考）" class="headerlink" title="七、关键疑问解答（补充思考）"></a>七、关键疑问解答（补充思考）</h4><ul><li><p>Q：如果指定的MAC地址不在局域网内怎么办？<br>A：主机发送前会通过ARP验证，若ARP广播无响应，会判定“目标不可达”，直接报错，数据包不会发送。</p></li><li><p>Q：交换机有ARP吗？知道IP对应MAC吗？<br>A：二层交换机无ARP，不识别IP，仅通过MAC地址转发；三层交换机集成路由功能，才会有ARP表。</p></li><li><p>Q：ARP是广播，如何隔离广播域？<br>A：路由器会丢弃广播包，不跨网段转发，因此广播域被路由器隔离，仅在当前局域网内传播。</p></li></ul><h4 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h4><p>网络包从封装完成到送达目标IP的过程，本质是“IP地址导航+MAC地址定位”的协同过程，涉及ARP寻址、交换机泛洪/转发、路由器路由/NAT等核心机制。理解这一过程的关键，是分清网络层与链路层的职责边界，以及各设备的分工逻辑——IP负责“找终点”，MAC负责“找下一跳”，交换机管“局域网内搬运”，路由器管“跨网段导航+隔离广播”，最终实现数据包的精准传输。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习过程中的疑惑&quot;&gt;&lt;a href=&quot;#学习过程中的疑惑&quot; class=&quot;headerlink&quot; title=&quot;学习过程中的疑惑&quot;&gt;&lt;/a&gt;学习过程中的疑惑&lt;/h2&gt;&lt;h3 id=&quot;通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（二）</title>
    <link href="https://nmcb666.vip/posts/d323df1a.html"/>
    <id>https://nmcb666.vip/posts/d323df1a.html</id>
    <published>2026-01-05T18:03:11.000Z</published>
    <updated>2026-01-24T07:56:35.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法总结（二）"><a href="#算法总结（二）" class="headerlink" title="算法总结（二）"></a>算法总结（二）</h1><h2 id="异或运算的骚操作"><a href="#异或运算的骚操作" class="headerlink" title="异或运算的骚操作"></a>异或运算的骚操作</h2><h3 id="异或解释"><a href="#异或解释" class="headerlink" title="异或解释"></a>异或解释</h3><ol><li>异或运算，相同的值异或为0，不同的值异或为1</li><li>也可以理解为无进位的加法</li><li>异或运算满足交换律，结合律</li><li>一个数组中所有数的异或和 跟 某些数异或的结果 相当于 减去某些数的异或和</li></ol><h3 id="使用异或进行交换两个数"><a href="#使用异或进行交换两个数" class="headerlink" title="使用异或进行交换两个数"></a>使用异或进行交换两个数</h3><ol><li>a = a^b</li><li>b = a^b (此时相当于a^b^b = a , 就让b等于a)</li><li>a = a^b (此时相当于a^b^a = b , 就让a等于b)</li></ol><p><em>局限性：注意这个交换不能对同一个地址的两个变量进行操作。因为第一步就会把他们都变为0</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">2323</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><h3 id="使用异或不用判断语句去判断两个数的大小"><a href="#使用异或不用判断语句去判断两个数的大小" class="headerlink" title="使用异或不用判断语句去判断两个数的大小"></a>使用异或不用判断语句去判断两个数的大小</h3><p>大体思路就是根据a-b的符号，来判断a和b的大小。<br>但是这样有溢出的风险（a-b会溢出）<br>优化思路：</p><ol><li>获取a和b的符号</li><li>获取c=a-b的符号</li><li>综合判断</li><li>如果a,b符号相同，则不可能溢出，直接根据c的符号来判断大小</li><li>如果a,b符号不同，则a-b可能会溢出，判断a的符号 如果a是非负的，就可以直接返回a更大</li><li>除了以上两种情况，其余情况都返回b</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 必须保证n一定是0或者1</span></span><br><span class="line"><span class="comment">// 0变1，1变0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非负数返回1</span></span><br><span class="line"><span class="comment">// 负数返回0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> flip(n &gt;&gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有溢出风险的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line"><span class="comment">// c非负，returnA -&gt; 1</span></span><br><span class="line"><span class="comment">// c非负，returnB -&gt; 0</span></span><br><span class="line"><span class="comment">// c负数，returnA -&gt; 0</span></span><br><span class="line"><span class="comment">// c负数，returnB -&gt; 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> sign(c);</span><br><span class="line"><span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line"><span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有任何问题的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="comment">// c可能是溢出的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line"><span class="comment">// a的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sa</span> <span class="operator">=</span> sign(a);</span><br><span class="line"><span class="comment">// b的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> sign(b);</span><br><span class="line"><span class="comment">// c的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sc</span> <span class="operator">=</span> sign(c);</span><br><span class="line"><span class="comment">// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">diffAB</span> <span class="operator">=</span> sa ^ sb;</span><br><span class="line"><span class="comment">// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sameAB</span> <span class="operator">=</span> flip(diffAB);</span><br><span class="line"><span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> diffAB * sa + sameAB * sc;</span><br><span class="line"><span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line"><span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异或去返回出现了奇数次的数（其余数都出现了偶数次）"><a href="#使用异或去返回出现了奇数次的数（其余数都出现了偶数次）" class="headerlink" title="使用异或去返回出现了奇数次的数（其余数都出现了偶数次）"></a>使用异或去返回出现了奇数次的数（其余数都出现了偶数次）</h3><p>思路很简单，就是把所有的数异或一遍，最后剩下的数就是出现了奇数次的数。<br>因为异或满足交换律。凡是出现偶数次的数，异或结果都为0，最后结果就是奇数次的数^0 = 奇数次的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">eor ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）"><a href="#使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）" class="headerlink" title="使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）"></a>使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）</h3><p>思路：(假设那两个数为a和b)</p><ol><li>先将数组中所有数异或一遍，得到一个数xor1=a^b</li><li>找到xor1最右边的1，即xor1 &amp; (-xor1) (解释：xor1 &amp; (-xor1)可以获取xor1最右边的1。并且这个1就是a跟b肯定不一样的数位（当然不只这一个，但是只需要这一个我们就可以区分它们了）)</li><li>将数组中所有数分为两组，一组是xor1最右边的1为1的数，一组是xor1最右边的1为0的数 （a,b肯定在不同的组中）</li><li>对其中一组数异或，得到XOR2  (XOR可能是a也有可能是b) （每组还是满足除了a,b之外所有数出现次数都是偶数）</li><li>讲XOR2与XOR1异或，得到另一个数 （XOR2^XOR1=a^b^b=a (假设XOR是b)）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="comment">// nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次</span></span><br><span class="line">eor1 ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eor1 : a ^ b</span></span><br><span class="line"><span class="comment">// Brian Kernighan算法</span></span><br><span class="line"><span class="comment">// 提取出二进制里最右侧的1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor1 &amp; (-eor1);</span><br><span class="line"><span class="type">int</span> <span class="variable">eor2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> ((num &amp; rightOne) == <span class="number">0</span>) &#123;</span><br><span class="line">eor2 ^= num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; eor2, eor1 ^ eor2 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他位运算的骚操作"><a href="#其他位运算的骚操作" class="headerlink" title="其他位运算的骚操作"></a>其他位运算的骚操作</h2><h3 id="判断一个数是不是2的幂"><a href="#判断一个数是不是2的幂" class="headerlink" title="判断一个数是不是2的幂"></a>判断一个数是不是2的幂</h3><p>原理： 如果是2的幂，那么二进制数只有一位为1，其他为0 。这时候我们用a&amp;-a 拿到到的数，就是a最右边的1。然后判断a是不是等于a&amp;-a 等于的话，那么a就是2的幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; <span class="number">0</span> &amp;&amp; a==(a&amp;-a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是不是三的幂"><a href="#判断一个数是不是三的幂" class="headerlink" title="判断一个数是不是三的幂"></a>判断一个数是不是三的幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子</span></span><br><span class="line"><span class="comment">// 1162261467是int型范围内，最大的3的幂，它是3的19次方</span></span><br><span class="line"><span class="comment">// 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么</span></span><br><span class="line"><span class="comment">// 1162261467 % n == 0</span></span><br><span class="line"><span class="comment">// 反之如果1162261467 % n != 0 说明n一定含有其他因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回大于等于n的最小的2某次方"><a href="#返回大于等于n的最小的2某次方" class="headerlink" title="返回大于等于n的最小的2某次方"></a>返回大于等于n的最小的2某次方</h3><p>先对n-1 然后把n最左边的1一直让右边全变为1.最后的答案就是n+1 (00111111 -&gt; 01000000)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">near2power</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="此区间内所有数字-amp-的结果-连续"><a href="#此区间内所有数字-amp-的结果-连续" class="headerlink" title="此区间内所有数字 &amp; 的结果(连续)"></a>此区间内所有数字 &amp; 的结果(连续)</h3><p>形如 0111001000 如果此时还存在一个比自己还小的数，那么我最右边的1肯定会被与运算变成0.直到最小的数都大于我，我的最右侧的1才能保留下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">right -= right &amp; -right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计一个数的二进制中1的个数"><a href="#统计一个数的二进制中1的个数" class="headerlink" title="统计一个数的二进制中1的个数"></a>统计一个数的二进制中1的个数</h3><p>具体思路参考 【算法讲解031【必备】位运算的骚操作】<a href="https://www.bilibili.com/video/BV1ch4y1Q7vd?vd_source=c6cdeb45f015e4ab4447a6c61482633a">https://www.bilibili.com/video/BV1ch4y1Q7vd?vd_source=c6cdeb45f015e4ab4447a6c61482633a</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cntOnes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算实现加减乘除操作"><a href="#位运算实现加减乘除操作" class="headerlink" title="位运算实现加减乘除操作"></a>位运算实现加减乘除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == MIN &amp;&amp; b == MIN) &#123;</span><br><span class="line"><span class="comment">// a和b都是整数最小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != MIN &amp;&amp; b != MIN) &#123;</span><br><span class="line"><span class="comment">// a和b都不是整数最小，那么正常去除</span></span><br><span class="line"><span class="keyword">return</span> div(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == MIN) &#123;</span><br><span class="line"><span class="comment">// a不是整数最小，b是整数最小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了</span></span><br><span class="line"><span class="keyword">if</span> (b == neg(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是整数最小，b不是整数最小，b也不是-1</span></span><br><span class="line">a = add(a, b &gt; <span class="number">0</span> ? b : neg(b));</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> div(a, b);</span><br><span class="line"><span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> b &gt; <span class="number">0</span> ? neg(<span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> add(ans, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须保证a和b都不是整数最小值，返回a除以b的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a &lt; <span class="number">0</span> ? neg(a) : a;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> b &lt; <span class="number">0</span> ? neg(b) : b;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &gt;= <span class="number">0</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">x = minus(x, y &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a &lt; <span class="number">0</span> ^ b &lt; <span class="number">0</span> ? neg(ans) : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ans : a和b无进位相加的结果</span></span><br><span class="line">ans = a ^ b;</span><br><span class="line"><span class="comment">// b : a和b相加时的进位信息</span></span><br><span class="line">b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">a = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(a, neg(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种乘法后面有大用处，尤其是求(a的b次方 % m)的结果，也叫龟速乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 考察b当前最右的状态！</span></span><br><span class="line">ans = add(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">b &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法总结（二）&quot;&gt;&lt;a href=&quot;#算法总结（二）&quot; class=&quot;headerlink&quot; title=&quot;算法总结（二）&quot;&gt;&lt;/a&gt;算法总结（二）&lt;/h1&gt;&lt;h2 id=&quot;异或运算的骚操作&quot;&gt;&lt;a href=&quot;#异或运算的骚操作&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（一）</title>
    <link href="https://nmcb666.vip/posts/e33533c2.html"/>
    <id>https://nmcb666.vip/posts/e33533c2.html</id>
    <published>2026-01-02T15:26:44.000Z</published>
    <updated>2026-01-24T07:56:35.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法总结（一）"><a href="#算法总结（一）" class="headerlink" title="算法总结（一）"></a>算法总结（一）</h1><h2 id="归并分治"><a href="#归并分治" class="headerlink" title="归并分治"></a>归并分治</h2><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ol><li>左边结果+右边结果+跨越两边的结果是否等于最终结果</li><li>对于两边排序之后对于统计跨越两边的结果是否有帮助</li></ol><h3 id="注意与总结"><a href="#注意与总结" class="headerlink" title="注意与总结"></a>注意与总结</h3><ol><li>主要思想跟归并排序一样 只不过是在merge的时候进行一些额外统计操作（统计跨越两边的结果）</li><li>如果只是单纯的比大小（比如 小和，逆序对）可以直接在merge的时候进行比较<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小和 直接在合并的时候进行比较统计</span></span><br><span class="line">        <span class="keyword">while</span>(a &lt;=m &amp;&amp; b&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]&lt;nums[b])&#123;</span><br><span class="line">                help[i++] = nums[a];</span><br><span class="line">                sum+= (nums[a]*(r-b+<span class="number">1</span>));</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                help[i++] = nums[b++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>如果不只是比大小 而是比较乘以二倍的结果，那么就需要在merge的时候 添加额外的统计操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当左边的数大于右边的两倍时进行统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ll=l,rr=m+<span class="number">1</span>;ll&lt;=m;ll++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(rr&lt;=r &amp;&amp; (<span class="type">long</span>)nums[ll]&gt;((<span class="type">long</span>)nums[rr]&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                rr++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="两种partition-普通-荷兰国旗"><a href="#两种partition-普通-荷兰国旗" class="headerlink" title="两种partition (普通+荷兰国旗)"></a>两种partition (普通+荷兰国旗)</h3><ol><li>普通partition 一次只能确定一个数的位置</li></ol><p>核心思想：初始化索引i a xi<br>1.1 遍历数组，如果当前数小于等于x，则交换i和a数 i++ a++<br>1.2 如果大于x，则i++ a不动<br>1.3 如果遇到nums[a] == x,用xi记录他的位置<br>1.4 遍历结束后，交换xi和a-1的位置，让x放到对应的位置。<br>1.5 返回a-1（x应该在的位置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个区号 小于等于   大于</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= x)&#123;</span><br><span class="line">                swap(nums,a,i);</span><br><span class="line">                <span class="keyword">if</span>(nums[a] == x)&#123;</span><br><span class="line">                    xi = a;</span><br><span class="line">                &#125;</span><br><span class="line">                a++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,xi,a-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>荷兰国旗partition 一次可以确定多个相同的数的位置</li></ol><p>核心思路：初始化索引i a(小于区间) b（大于区间）<br>1.1 遍历数组，如果当前数小于x，则交换i和a数 i++ a++<br>1.2 如果大于x，则i不动 b—<br>1.3 如果等于x，则i++<br>1.4 遍历结束后，a-1（小于区间的末尾） b+1（大于区间的开头） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first,last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个区间 小于  大于   等于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=l;</span><br><span class="line">    <span class="type">int</span> b=r;</span><br><span class="line">    <span class="type">int</span> i=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; x)&#123;</span><br><span class="line">            swap(nums,a++,i++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x)&#123;</span><br><span class="line">            swap(nums,i,b--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first = a;</span><br><span class="line">    last = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-快速选择"><a href="#扩展-快速选择" class="headerlink" title="扩展 快速选择"></a>扩展 快速选择</h3><p>快速选择：给定一个数组，返回第k小的数</p><ol><li>快速排序的思想，partition之后，如果在当前区间内的排名大于指定的排名，则递归quickselect(l,left-1,k)</li><li>快速排序的思想，partition之后，如果在当前区间内的排名小于指定的排名，则递归quickselect(right+1,r,k-rightNow)  (rightNow指定的数在当前区间内的最靠右的排名)</li><li>快速排序的思想，partition之后，如果在当前区间内的排名等于指定的排名，则返回用于partition的数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">partitor</span> <span class="operator">=</span> nums[l+ (<span class="type">int</span>)(Math.random()*(r-l+<span class="number">1</span>))];</span><br><span class="line">    <span class="comment">//荷兰国旗</span></span><br><span class="line">    partition2(nums,l,r,partitor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftNow</span> <span class="operator">=</span> left -l +<span class="number">1</span>; <span class="comment">//当前区间内partitor靠左的排名（可能存在多个partitor）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightNow</span> <span class="operator">=</span> right -l+<span class="number">1</span>; <span class="comment">//当前区间内partitor靠右的排名</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;leftNow)&#123; <span class="comment">//要找的位置在左边 再去左边找</span></span><br><span class="line">        <span class="keyword">return</span> quick(nums,l,left-<span class="number">1</span>,pos);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;rightNow)&#123; <span class="comment">//要找的位置在右边 再去右边找</span></span><br><span class="line">        <span class="keyword">return</span> quick(nums,right+<span class="number">1</span>,r,pos-rightNow);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//要找的位置在中间 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nums[pos+l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序本身没什么好说的，就是利用堆这个数据结构进行排序。这里重点说一下heapify 跟 heapInsert</p><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>将节点下移到合适的位置，直接贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// i位置的数，变小了，又想维持大根堆结构</span></span><br><span class="line"><span class="comment">// 向下调整大根堆</span></span><br><span class="line"><span class="comment">// 当前堆的大小为size</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; size) &#123;</span><br><span class="line"><span class="comment">// 有左孩子，l</span></span><br><span class="line"><span class="comment">// 右孩子，l+1</span></span><br><span class="line"><span class="comment">// 评选，最强的孩子，是哪个下标的孩子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> l + <span class="number">1</span> &lt; size &amp;&amp; arr[l + <span class="number">1</span>] &gt; arr[l] ? l + <span class="number">1</span> : l;</span><br><span class="line"><span class="comment">// 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁</span></span><br><span class="line">best = arr[best] &gt; arr[i] ? best : i;</span><br><span class="line"><span class="keyword">if</span> (best == i) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, best, i);</span><br><span class="line">i = best;</span><br><span class="line">l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也有递归的版本也很简单，这里不详细说了。</p><p>此外使用heapify可以自底向上的构建堆 时间复杂度为O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapify(arr, i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="heapInsert"><a href="#heapInsert" class="headerlink" title="heapInsert"></a>heapInsert</h3><p>将节点上移到合适位置，直接贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// i位置的数，变大了，又想维持小根堆结构</span></span><br><span class="line"><span class="comment">// 向上调整小根堆</span></span><br><span class="line"><span class="comment">// 当前堆的大小为size</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">i = (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外使用heapInsert可以自上到下的构建堆 时间复杂度为O(n*logn) (不如上面的方法)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">heapInsert(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用堆结构去解决一些其他问题"><a href="#利用堆结构去解决一些其他问题" class="headerlink" title="利用堆结构去解决一些其他问题"></a>利用堆结构去解决一些其他问题</h3><h4 id="1-合并k个有序链表"><a href="#1-合并k个有序链表" class="headerlink" title="1. 合并k个有序链表"></a>1. 合并k个有序链表</h4><ol><li>创建一个最小堆，将k个链表的头节点加入堆中</li><li>弹出最小的节点，并加入到结果链表中</li><li>弹出的节点的next节点加入堆中</li><li>重复2-3，直到堆为空</li><li>返回结果链表</li></ol><p>复杂度 O(n*logk)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode listNode : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.add(listNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span>h;</span><br><span class="line">    <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        heap.add(pre.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">        pre.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            heap.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-线段最多重合问题"><a href="#2-线段最多重合问题" class="headerlink" title="2. 线段最多重合问题"></a>2. 线段最多重合问题</h4><p> 线段最多重合问题，就是给定很多线段，求线段最多重合的次数 </p><ol><li>将所有线段按开始的点进行排序</li><li>依次开始遍历线段</li><li>弹出堆中的最小点，如果最小点小于当前线段的开始点，则说明在当前线段开始时，这里面的线段已经结束不会重合。弹出堆中的最小点</li><li>循环3步直到堆里面的元素不小于当前线段的开始点。</li><li>将当前线段的结束点加入最小堆中</li><li>当前最小堆的size就是以这个线段开始为重合开始区间的重合的次数，用这个跟记录的最大次数进行比较，更新最大次数</li><li>循环2-6，直到所有线段都遍历结束</li><li>返回最大次数</li></ol><p>时间复杂度  O(n*logn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 堆的清空</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段一共有n条，line[0...n-1][2] : line[i][0] line[i][1], 左闭右闭</span></span><br><span class="line"><span class="comment">// 所有线段，根据开始位置排序，结束位置无所谓</span></span><br><span class="line"><span class="comment">// 比较器的用法</span></span><br><span class="line"><span class="comment">// line [0...n) 排序 : 所有小数组，开始位置谁小谁在前</span></span><br><span class="line">Arrays.sort(line, <span class="number">0</span>, n, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// i : line[i][0] line[i][1]</span></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; heap[<span class="number">0</span>] &lt;= line[i][<span class="number">0</span>]) &#123;</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line">add(line[i][<span class="number">1</span>]);</span><br><span class="line">ans = Math.max(ans, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-累加和减半最小操作次数"><a href="#3-累加和减半最小操作次数" class="headerlink" title="3.累加和减半最小操作次数"></a>3.累加和减半最小操作次数</h4><p>给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择任意一个数并将它减小到恰好一半。（注意，在后续操作中你可以对减半过的数继续执行操作）<br>请你返回将 nums 数组和至少减少一半的最少操作数。</p><p>思路： 其实就是贪心算法，每次把最大的数减到一半，直到和减少到一半。其中找最大的数就可以用大根堆来实现。</p><ol><li>创建一个大根堆，将数组中的数放入大根堆中。</li><li>取出最大的数，除以2 ，操作数++，并判断和是否减少到一半。如果和减少到一半，则返回当前操作数。</li><li>循环第二步。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">halveArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">PriorityQueue&lt;Double&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">heap.add((<span class="type">double</span>) num);</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum，整体累加和，-&gt; 要减少的目标！</span></span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">minus</span> <span class="operator">=</span> <span class="number">0</span>, cur; minus &lt; sum; ans++, minus += cur) &#123;</span><br><span class="line">cur = heap.poll() / <span class="number">2</span>;</span><br><span class="line">heap.add(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化思路：可以自己实现大根堆，并且不用Double类型，用long类型将所有数乘以2的20次方，相当于小数部分可以保留20位，可以精确到小数点后20位。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>原理很简单 不细说 主要说说感悟</p><p>为什么要逆序遍历 Array：</p><ol><li>排序的稳定性：<br>在基数排序的实现中，逆序访问原数组 arr 的目的是为了保证排序的稳定性。稳定性是指排序算法在处理相等元素时能够保持它们在原数组中的相对顺序不变。<br>在循环中，我们逆序遍历原数组 arr。这样做的好处是，当存在相等的元素时，先出现的元素会先放入对应的位置，而后出现的相等元素会放在它们之后的位置。这样可以保证相等元素的相对顺序不变，从而保证了排序的稳定性。<br>如果我们采用顺序访问 arr 的方式，那么在处理相等元素时，后出现的相等元素可能会先放入对应的位置，从而打破了它们在原数组中的相对顺序，导致排序不稳定。<br>因此，为了确保排序的稳定性，我们需要在逆序遍历原数组 arr 的情况下进行元素的放置操作。</li><li>自己的理解：<br>2.1 基数排序，是基于数字的每一位（从低位到高位）进行排序，每一位的排序 基于 上一位（较低位）排好的基础上<br>2.2 先将所有元素按照低位排序，再保持低位位序不变的情况下去排高位的位序（能让已经排好的低位的位序变化的原因只能受高位数值的影响）<br>2.3 如果是顺序排序，那么低位顺序的改变不仅仅受到高位数值的影响，也受到错位的影响<br>2.4 错位的影响：有数组：arr【 11 , 12 , 13 , 14 , 15】<br>低位序已经排好，如果按照高位顺序遍历，会导致数组变成 【15 , 14 , 13 , 12 , 11】<br>使得原先在 15 之前的 11 排在了 15 之后<br>这种错位的影响是 顺序遍历 和 使用词频统计方法往Help中放元素(逆序) 相互作用决定的</li></ol><h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/blog1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法总结（一）&quot;&gt;&lt;a href=&quot;#算法总结（一）&quot; class=&quot;headerlink&quot; title=&quot;算法总结（一）&quot;&gt;&lt;/a&gt;算法总结（一）&lt;/h1&gt;&lt;h2 id=&quot;归并分治&quot;&gt;&lt;a href=&quot;#归并分治&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>feign的三种异常处理关系</title>
    <link href="https://nmcb666.vip/posts/20b8d2ff.html"/>
    <id>https://nmcb666.vip/posts/20b8d2ff.html</id>
    <published>2025-12-31T10:00:37.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"><a href="#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘" class="headerlink" title="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"></a>Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘</h1><p>在微服务架构中，Feign作为声明式HTTP客户端，是服务间调用的核心组件。而异常处理是保障微服务稳定性的关键环节——当Feign调用下游服务抛出异常时，我们常通过 <code>ErrorDecoder</code>、容错组件的 <code>Fallback</code>（如Sentinel/Hystrix）、Spring全局异常捕获器（<code>@RestControllerAdvice</code>）三种方式处理异常。但三者并存时，执行顺序如何？优先级背后的原理是什么？特殊场景下又会出现哪些变化？本文将结合实践拆解这一核心问题。</p><h2 id="一、核心结论：三者的优先执行顺序"><a href="#一、核心结论：三者的优先执行顺序" class="headerlink" title="一、核心结论：三者的优先执行顺序"></a>一、核心结论：三者的优先执行顺序</h2><p>当Feign调用发生异常（非2xx HTTP状态码、超时、网络异常等）时，三者的执行优先级从高到低依次为：</p><p><strong>ErrorDecoder（Feign原生） → Fallback（容错组件） → 全局异常捕获器（Spring MVC）</strong></p><p>完整执行链路可概括为：</p><blockquote><p>Feign调用触发异常 → ResponseInterceptor（OpenFeign 12.0+ 可选预处理） → ErrorDecoder（异常解码/转换） → 容错组件拦截异常 → Fallback（异常兜底，返回正常数据） → （Fallback失效时）全局异常捕获器 → （均未处理时）向上抛出原始异常</p></blockquote><p>其中，前两者属于Feign调用链路的“前置处理”，全局异常捕获器属于“后置兜底”，且Fallback默认会阻断异常向上传播，使全局异常捕获器无法触发。</p><h2 id="二、优先级原理：层级与职责边界决定执行顺序"><a href="#二、优先级原理：层级与职责边界决定执行顺序" class="headerlink" title="二、优先级原理：层级与职责边界决定执行顺序"></a>二、优先级原理：层级与职责边界决定执行顺序</h2><p>三者优先级的本质的是执行层级和职责边界的差异，不同层级对应不同的异常处理目标，形成了“层层拦截、各司其职”的链路。</p><h3 id="1-第一优先级：ErrorDecoder（Feign原生扩展点）"><a href="#1-第一优先级：ErrorDecoder（Feign原生扩展点）" class="headerlink" title="1. 第一优先级：ErrorDecoder（Feign原生扩展点）"></a>1. 第一优先级：ErrorDecoder（Feign原生扩展点）</h3><p><code>ErrorDecoder</code> 是Feign原生提供的异常解码扩展点，属于「Feign调用响应处理层级」，是异常进入业务链路前的“第一道关口”。</p><p>其核心职责是：拦截Feign调用返回的非2xx异常响应，将Feign默认抛出的 <code>FeignException</code>（包含杂乱的HTTP响应信息）转换为标准化的自定义业务异常，同时可解析异常响应体、提取下游服务异常详情，为后续处理提供统一的异常格式。</p><p>优先级最高的原因的是：它直接嵌入Feign的响应处理流程，在异常被传递给业务层或容错组件前，就完成了解码和转换。后续的Fallback和全局异常捕获器，处理的都是经过它转换后的异常（或未自定义时的默认异常）。</p><h3 id="2-第二优先级：Fallback（容错组件能力）"><a href="#2-第二优先级：Fallback（容错组件能力）" class="headerlink" title="2. 第二优先级：Fallback（容错组件能力）"></a>2. 第二优先级：Fallback（容错组件能力）</h3><p><code>Fallback</code> 是Sentinel、Hystrix、Resilience4j等容错组件提供的兜底能力，属于「微服务容错防护层级」，是异常传播的“第二道关口”。</p><p>其核心职责是：通过AOP或代理模式，拦截Feign调用/业务方法抛出的异常（已被ErrorDecoder处理），将“异常结果”转换为“合法的业务返回数据”，消化异常以防止服务雪崩，同时避免业务层手动try-catch。</p><p>优先级高于全局异常捕获器的原因的是：它在异常产生点附近直接拦截，且处理后返回正常数据——异常被完全“消化”，不再向上传播，导致全局异常捕获器失去触发前提（全局异常捕获器仅处理未被拦截的传播异常）。</p><h3 id="3-第三优先级：全局异常捕获器（Spring-MVC层级）"><a href="#3-第三优先级：全局异常捕获器（Spring-MVC层级）" class="headerlink" title="3. 第三优先级：全局异常捕获器（Spring MVC层级）"></a>3. 第三优先级：全局异常捕获器（Spring MVC层级）</h3><p>全局异常捕获器（基于 <code>@RestControllerAdvice</code> + <code>@ExceptionHandler</code>）是Spring MVC提供的全局能力，属于「应用层异常兜底层级」，是异常处理的“最后一道关口”。</p><p>其核心职责是：捕获所有向上传播到Controller层及以上的未处理异常，统一返回标准化错误响应，避免裸异常暴露给前端。</p><p>优先级最低的原因的是：它的执行依赖“异常未被前置逻辑处理且成功传播”，而Fallback通常会提前消化异常，只有在Fallback失效时，它才会补位生效。</p><h2 id="三、实战验证：直观感受执行顺序"><a href="#三、实战验证：直观感受执行顺序" class="headerlink" title="三、实战验证：直观感受执行顺序"></a>三、实战验证：直观感受执行顺序</h2><p>我们以「OpenFeign 12.0+ + Sentinel + Spring Boot」为例，通过代码验证三者的执行顺序，同时覆盖正常场景与特殊场景。</p><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>依赖核心组件：OpenFeign（12.0+）、Spring Cloud Alibaba Sentinel、Spring Web。</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><h4 id="（1）自定义ErrorDecoder（第一优先级）"><a href="#（1）自定义ErrorDecoder（第一优先级）" class="headerlink" title="（1）自定义ErrorDecoder（第一优先级）"></a>（1）自定义ErrorDecoder（第一优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【1. 执行 ErrorDecoder】：解码Feign异常，状态码=&quot;</span> + response.status());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorBody</span> <span class="operator">=</span> Util.toString(response.body().asReader(Util.UTF_8));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;服务调用异常（ErrorDecoder转换）：&quot;</span> + errorBody);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义业务异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）配置Fallback（第二优先级）"><a href="#（2）配置Fallback（第二优先级）" class="headerlink" title="（2）配置Fallback（第二优先级）"></a>（2）配置Fallback（第二优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Feign接口</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-service&quot;, fallback = ProviderFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/provider/getData&quot;)</span></span><br><span class="line">    String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback兜底类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id + <span class="string">&quot;（服务调用异常）&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）全局异常捕获器（第三优先级）"><a href="#（3）全局异常捕获器（第三优先级）" class="headerlink" title="（3）全局异常捕获器（第三优先级）"></a>（3）全局异常捕获器（第三优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleAllException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【3. 执行全局异常捕获器】：捕获异常：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;全局兜底：&quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）业务调用层"><a href="#（4）业务调用层" class="headerlink" title="（4）业务调用层"></a>（4）业务调用层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProviderClient providerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getData&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providerClient.getData(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-场景测试结果"><a href="#3-场景测试结果" class="headerlink" title="3. 场景测试结果"></a>3. 场景测试结果</h3><h4 id="（1）正常场景：三者并存，Fallback正常触发"><a href="#（1）正常场景：三者并存，Fallback正常触发" class="headerlink" title="（1）正常场景：三者并存，Fallback正常触发"></a>（1）正常场景：三者并存，Fallback正常触发</h4><p>当下游服务抛出异常时，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br></pre></td></tr></table></figure><p>接口返回：<code>兜底数据：id=123（服务调用异常）</code>，全局异常捕获器未触发（被Fallback阻断）。</p><h4 id="（2）特殊场景：Fallback自身抛出异常"><a href="#（2）特殊场景：Fallback自身抛出异常" class="headerlink" title="（2）特殊场景：Fallback自身抛出异常"></a>（2）特殊场景：Fallback自身抛出异常</h4><p>修改Fallback逻辑，故意抛出空指针异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nullStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        nullStr.length(); <span class="comment">// 空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：null</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：null</code>，Fallback异常向上传播，触发全局异常捕获器。</p><h4 id="（3）特殊场景：Fallback未触发（配置失效）"><a href="#（3）特殊场景：Fallback未触发（配置失效）" class="headerlink" title="（3）特殊场景：Fallback未触发（配置失效）"></a>（3）特殊场景：Fallback未触发（配置失效）</h4><p>若未开启Sentinel与Feign的整合（未配置 <code>feign.sentinel.enabled=true</code>），Fallback配置失效，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：服务调用异常（ErrorDecoder转换）：xxx</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：服务调用异常（ErrorDecoder转换）：xxx</code>，Fallback未触发，异常传播至全局捕获器。</p><h2 id="四、实践建议：三者协同的最佳姿势"><a href="#四、实践建议：三者协同的最佳姿势" class="headerlink" title="四、实践建议：三者协同的最佳姿势"></a>四、实践建议：三者协同的最佳姿势</h2><p>三者并非互斥关系，而是互补关系，合理搭配可实现“异常标准化+容错兜底+最终补位”的三层防护体系，提升微服务稳定性。</p><h3 id="1-分工明确，各司其职"><a href="#1-分工明确，各司其职" class="headerlink" title="1. 分工明确，各司其职"></a>1. 分工明确，各司其职</h3><ul><li><p><strong>ErrorDecoder</strong>：专注“异常标准化”，统一转换Feign原生异常为业务异常，解析异常详情，不做兜底逻辑；</p></li><li><p><strong>Fallback</strong>：专注“容错兜底”，针对核心服务调用，返回预设兜底数据（如缓存数据、默认值），防止服务雪崩；</p></li><li><p><strong>全局异常捕获器</strong>：专注“最终补位”，捕获所有漏网异常（Fallback异常、配置错误导致的异常），统一返回前端友好响应。</p></li></ul><h3 id="2-规避常见坑点"><a href="#2-规避常见坑点" class="headerlink" title="2. 规避常见坑点"></a>2. 规避常见坑点</h3><ul><li><p>Fallback方法签名必须与原方法一致（参数、返回值类型匹配），否则配置失效，异常直接传播；</p></li><li><p>Hystrix会忽略 <code>HystrixBadRequestException</code> 及 <code>ignoreExceptions</code> 配置的异常，这类异常不触发Fallback，需通过全局捕获器处理；</p></li><li><p>ErrorDecoder中避免抛出非业务异常，建议统一转换为自定义异常，便于Fallback和全局捕获器识别。</p></li></ul><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><ul><li>异常多层包装（含 Error 类型）会阻断 Spring 自动穿透。当异常链中存在 AssertionError 等 Error 类型异常时（如 Sentinel 整合 Feign 场景，在fallback函数中抛出RuntimeException异常会被Sentinel自动包装为AssertionError 继承 Error分支，然后又被Spring MVC DispatcherServlet自动抛出为NestedServletException异常），Spring 的 @ExceptionHandler 自动穿透功能仅支持 Exception 分支，无法穿透 Error 类型异常，导致自定义异常（CommonException）无法被精准捕获，最终被 Exception 兜底处理器捕获（或者被NestedServletException异常捕获器捕获）；</li><li><p>解决方案：手动解析完整的 Throwable 链（包含 Error 和 Exception），通过循环遍历 cause 链主动提取目标自定义异常，再手动分发到对应异常处理器；</p></li><li><p>下面是spring对于异常处理的源码。可以看见如果遇到非Exception的Throwable。它会自动抛出NestedServletException</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用处理器方法（Controller方法、Feign调用、Service方法等都在这一步执行）</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 捕获Exception类型异常，直接赋值给dispatchException，不包装</span></span><br><span class="line">    dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    <span class="comment">// 捕获Throwable类型（非Exception，如Error、AssertionError等），包装为NestedServletException</span></span><br><span class="line">    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-组件选择建议"><a href="#4-组件选择建议" class="headerlink" title="4. 组件选择建议"></a>4. 组件选择建议</h3><p>Hystrix已进入维护模式，推荐使用 <strong>Resilience4j</strong>（轻量、Spring官方推荐）或 <strong>Sentinel</strong>（阿里生态，支持流量控制、熔断降级等丰富特性）作为Fallback载体；OpenFeign 12.0+ 建议搭配 <code>ResponseInterceptor</code> 做响应日志预处理，与ErrorDecoder协同提升异常排查效率。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Feign异常处理的三重机制，本质是不同层级的“异常拦截-处理”链路：ErrorDecoder负责“入口标准化”，Fallback负责“中间容错”，全局异常捕获器负责“最终补位”。优先级的核心逻辑是“先处理异常、再消化异常、最后补位异常”。</p><p>在实际开发中，三者协同使用，既能保证异常处理的规范性和灵活性，又能提升微服务的高可用性，避免因单一异常处理机制失效导致的服务不稳定问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘&quot;&gt;&lt;a href=&quot;#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://nmcb666.vip/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>微服务之间的全局异常捕获</title>
    <link href="https://nmcb666.vip/posts/df97f9d4.html"/>
    <id>https://nmcb666.vip/posts/df97f9d4.html</id>
    <published>2025-12-24T02:09:18.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<p>在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是500，错误信息固定为INTERNAL_SERVER_ERROR，全局异常捕获器形同虚设，尤其在微服务间通过OpenFeign调用API时，该问题更为突出。本文将围绕这一问题，从原因分析、解决方案到特殊场景适配，逐步拆解实战过程中的思考与踩坑。</p><h2 id="一、问题现象：单体架构异常捕获在微服务中失效"><a href="#一、问题现象：单体架构异常捕获在微服务中失效" class="headerlink" title="一、问题现象：单体架构异常捕获在微服务中失效"></a>一、问题现象：单体架构异常捕获在微服务中失效</h2><p>在单体应用中，我们通常会编写如下全局异常捕获器，针对不同业务异常返回自定义状态码和信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(e.getCode(), e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在微服务架构中，当服务A通过OpenFeign调用服务B，服务B抛出BusinessException并被自身全局异常捕获器处理，返回400状态码和自定义信息时，服务A接收到的响应却依然是500 INTERNAL_SERVER_ERROR，无法获取服务B返回的真实异常信息，导致异常排查困难，也无法根据真实异常类型做后续业务处理。</p><h2 id="二、根源分析：OpenFeign对非2XX响应的默认处理机制"><a href="#二、根源分析：OpenFeign对非2XX响应的默认处理机制" class="headerlink" title="二、根源分析：OpenFeign对非2XX响应的默认处理机制"></a>二、根源分析：OpenFeign对非2XX响应的默认处理机制</h2><p>问题的核心在于微服务间的调用方式——OpenFeign的异常处理逻辑。当被调用方（服务B）抛出异常后，其自身的全局异常捕获器会正常工作，返回自定义的非2XX状态码（如400、502）和错误信息。但调用方（服务A）通过OpenFeign调用时，OpenFeign有一个默认规则：<strong>对所有非2XX的HTTP响应，都会自动抛出FeignException异常</strong>。</p><p>这就导致服务A无法直接获取服务B返回的自定义异常信息，只能捕获到OpenFeign封装的FeignException，而该异常默认对应500 INTERNAL_SERVER_ERROR状态码，最终呈现出“所有异常都返回500”的现象。本质上是OpenFeign的默认异常转换，覆盖了被调用方的自定义异常响应。</p><h2 id="三、解决方案一：自定义ErrorDecoder处理状态码异常"><a href="#三、解决方案一：自定义ErrorDecoder处理状态码异常" class="headerlink" title="三、解决方案一：自定义ErrorDecoder处理状态码异常"></a>三、解决方案一：自定义ErrorDecoder处理状态码异常</h2><p>要解决上述问题，我们可以通过自定义ErrorDecoder接口实现，覆写decode方法，对不同状态码的响应进行差异化处理，还原被调用方的真实异常信息，甚至返回自定义异常类型。</p><h3 id="3-1-自定义ErrorDecoder实现"><a href="#3-1-自定义ErrorDecoder实现" class="headerlink" title="3.1 自定义ErrorDecoder实现"></a>3.1 自定义ErrorDecoder实现</h3><p>注意：decode方法的核心是<strong>返回FeignException，而非直接抛出异常</strong>，OpenFeign会对该返回值做进一步处理并传递给调用方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultErrorDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeignException</span>.InternalServerError(methodKey, response, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据响应状态码自定义异常</span></span><br><span class="line">        <span class="keyword">switch</span> (response.status()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                <span class="comment">// 解析响应体，封装自定义业务异常信息</span></span><br><span class="line">                <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">                <span class="keyword">return</span> FeignException.badRequest(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>)</span><br><span class="line">                        .reason(errorResponse.getMsg());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                <span class="keyword">return</span> FeignException.serviceUnavailable(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 其他状态码可按需扩展</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 默认使用OpenFeign原生解码器</span></span><br><span class="line">                <span class="keyword">return</span> defaultErrorDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-配置FeignConfig注册Bean"><a href="#3-2-配置FeignConfig注册Bean" class="headerlink" title="3.2 配置FeignConfig注册Bean"></a>3.2 配置FeignConfig注册Bean</h3><p>将自定义的CustomErrorDecoder配置为Spring Bean，纳入Feign的配置体系中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ErrorDecoder <span class="title function_">errorDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomErrorDecoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，当服务A通过OpenFeign调用服务B时，若服务B返回非2XX状态码，CustomErrorDecoder会解析响应体，返回对应状态码的FeignException，并携带真实错误信息，服务A即可通过捕获FeignException获取详细异常内容，再结合自身全局异常捕获器做进一步处理。</p><h2 id="四、特殊场景：基于业务状态码的响应处理"><a href="#四、特殊场景：基于业务状态码的响应处理" class="headerlink" title="四、特殊场景：基于业务状态码的响应处理"></a>四、特殊场景：基于业务状态码的响应处理</h2><p>上述方案适用于HTTP状态码区分异常的场景，但在实际项目开发中，很多团队会采用“统一HTTP状态码”的设计：所有接口均返回200 OK，异常信息通过响应体中的自定义业务状态码（如code字段）、msg字段区分，data字段存储业务数据，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">10001</span><span class="punctuation">,</span> <span class="comment">// 10001代表业务异常，200代表成功</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;参数校验失败&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种场景下，ErrorDecoder将完全失效——因为ErrorDecoder仅拦截HTTP状态码为4XX、5XX的响应，而当前所有请求的HTTP状态码都是200，无法触发自定义解码逻辑。此时需要寻找新的解决方案。</p><h2 id="五、解决方案二：CustomResponseInterceptor（版本限制）"><a href="#五、解决方案二：CustomResponseInterceptor（版本限制）" class="headerlink" title="五、解决方案二：CustomResponseInterceptor（版本限制）"></a>五、解决方案二：CustomResponseInterceptor（版本限制）</h2><p>针对HTTP 200响应中嵌入业务状态码的场景，可通过自定义ResponseInterceptor接口实现，覆写intercept方法，在响应返回后解析业务状态码，判断是否存在异常并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResponseInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ResponseInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intercept</span><span class="params">(Response response, Chain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析响应体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">            <span class="comment">// 根据业务状态码判断是否抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (errorResponse.getCode() != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorResponse.getCode(), errorResponse.getMsg());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(<span class="string">&quot;响应解析异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.proceed(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要在FeignConfig中配置该拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ResponseInterceptor <span class="title function_">responseInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomResponseInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该方案存在明显局限性：<strong>ResponseInterceptor接口仅在OpenFeign 12.0+版本中提供</strong>，对于一些基于低版本OpenFeign（如Spring Cloud Netflix早期版本）的老项目，无法使用该方案，兼容性较差。</p><h2 id="六、尝试方案：AOP拦截Feign调用（失效原因分析）"><a href="#六、尝试方案：AOP拦截Feign调用（失效原因分析）" class="headerlink" title="六、尝试方案：AOP拦截Feign调用（失效原因分析）"></a>六、尝试方案：AOP拦截Feign调用（失效原因分析）</h2><p>针对低版本OpenFeign无法使用ResponseInterceptor的问题，我尝试通过AOP切面，在Feign客户端调用API后，对响应结果进行解析，根据业务状态码抛出对应异常。但实际测试发现，AOP切面完全不生效，无法拦截Feign客户端的方法调用。</p><p>查阅资料后，明确了失效的核心原因：</p><ol><li><p><strong>Feign客户端的创建机制</strong>：Feign客户端是通过动态代理生成的，而非Spring容器管理的普通Bean，其代理逻辑由Feign自身控制。</p></li><li><p><strong>Spring AOP的拦截限制</strong>：Spring AOP默认采用JDK动态代理，仅能拦截Spring容器管理的Bean的方法调用，无法直接拦截Feign生成的动态代理对象。</p></li><li><p><strong>代理优先级问题</strong>：Feign动态代理的优先级高于Spring AOP代理，导致AOP切面无法切入Feign客户端的方法执行流程。</p></li></ol><p>即便尝试切换为CGLIB代理，也无法有效拦截Feign客户端的调用，该方案最终宣告失败。</p><h2 id="七、现状与思考：待解决的痛点"><a href="#七、现状与思考：待解决的痛点" class="headerlink" title="七、现状与思考：待解决的痛点"></a>七、现状与思考：待解决的痛点</h2><p>综合以上实践，目前针对微服务间异常捕获的解决方案存在明显的场景局限性：</p><ul><li><p>基于ErrorDecoder的方案：适用于HTTP状态码区分异常的场景，兼容性好，无版本限制，是目前最成熟的方案。</p></li><li><p>基于ResponseInterceptor的方案：适用于HTTP 200+业务状态码的场景，但仅支持OpenFeign 12.0+版本，老项目无法适配。</p></li><li><p>AOP方案：理论上可适配所有版本，但因Feign动态代理机制限制，无法生效，暂无可行的优化方向。</p></li></ul><p>对于“低版本OpenFeign + HTTP 200 + 业务状态码”的组合场景，目前仍没有优雅且兼容的解决方案。可以考虑在调用api的方法中，去接受api返回的响应结果，根据业务状态码判断是否抛出异常，但这种方案侵入性强，违背了面向切面编程的思想。</p><p>在此也欢迎各位同行分享实践经验，探讨更优的解决方案，共同完善微服务异常处理体系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>微服务间的异常捕获相比单体架构更复杂，核心难点在于OpenFeign的代理机制和响应处理逻辑。在实际开发中，建议优先采用“HTTP状态码+自定义响应体”的方式设计接口，通过CustomErrorDecoder实现异常透传，兼顾兼容性和优雅性；若因业务需求必须使用统一HTTP 200状态码，则需评估升级OpenFeign版本的可行性，或权衡侵入性方案的取舍。后续将持续关注OpenFeign的版本更新和社区实践，寻找更完善的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://nmcb666.vip/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus的分页查询原理</title>
    <link href="https://nmcb666.vip/posts/3ecdcd9c.html"/>
    <id>https://nmcb666.vip/posts/3ecdcd9c.html</id>
    <published>2025-12-11T22:27:30.000Z</published>
    <updated>2026-01-24T07:56:35.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus分页查询底层原理"><a href="#MyBatis-Plus分页查询底层原理" class="headerlink" title="MyBatis-Plus分页查询底层原理"></a>MyBatis-Plus分页查询底层原理</h1><h3 id="一、分页查询的核心痛点与-MP-的解决方案"><a href="#一、分页查询的核心痛点与-MP-的解决方案" class="headerlink" title="一、分页查询的核心痛点与 MP 的解决方案"></a>一、分页查询的核心痛点与 MP 的解决方案</h3><p>在传统 MyBatis 开发中，分页实现往往需要手动拼接<code>LIMIT</code>语句（MySQL）或<code>ROWNUM</code>（Oracle），不仅繁琐且易出错，还存在两个核心问题：</p><ol><li><p><strong>SQL 侵入性强</strong>：业务 SQL 与分页语法耦合，切换数据库时需批量修改；</p></li><li><p><strong>总条数统计冗余</strong>：需手动编写 count 查询，且需处理复杂查询（如多表关联、分组统计）的 count 适配。</p></li></ol><p>MyBatis-Plus（以下简称 MP）的分页插件通过<strong>拦截器机制</strong>+<strong>数据库方言适配</strong>，实现了 “无侵入式分页”，其核心设计思路是：<strong>在 SQL 执行前动态改写 SQL，自动添加分页语法和 count 查询，同时封装分页结果</strong>。</p><h3 id="二、MP-分页的核心组件与依赖关系"><a href="#二、MP-分页的核心组件与依赖关系" class="headerlink" title="二、MP 分页的核心组件与依赖关系"></a>二、MP 分页的核心组件与依赖关系</h3><p>MP 分页功能的实现依赖 3 个核心组件，它们的协作流程决定了分页的底层逻辑：</p><div class="table-container"><table><thead><tr><th>组件名称</th><th>作用说明</th></tr></thead><tbody><tr><td><code>PaginationInnerInterceptor</code></td><td>核心拦截器，负责拦截 SQL 执行、改写 SQL、统计总条数（MP 3.4.0 + 推荐使用）</td></tr><tr><td><code>Page</code></td><td>分页参数载体，封装页码、每页条数、总条数、分页结果集等信息</td></tr><tr><td><code>Dialect</code></td><td>数据库方言接口，适配不同数据库的分页语法（如 MySQL 的 LIMIT、PostgreSQL 的 OFFSET）</td></tr></tbody></table></div><p><strong>依赖关系</strong>：<code>Page</code>传递分页参数 → <code>PaginationInnerInterceptor</code>拦截 SQL → 调用<code>Dialect</code>生成适配 SQL → 执行查询并封装结果。</p><h3 id="三、底层核心流程：从-SQL-拦截到结果返回"><a href="#三、底层核心流程：从-SQL-拦截到结果返回" class="headerlink" title="三、底层核心流程：从 SQL 拦截到结果返回"></a>三、底层核心流程：从 SQL 拦截到结果返回</h3><h4 id="1-拦截器触发条件"><a href="#1-拦截器触发条件" class="headerlink" title="1. 拦截器触发条件"></a>1. 拦截器触发条件</h4><p>MP 的分页插件本质是 MyBatis 的<code>Interceptor</code>接口实现类，通过<code>@Intercepts</code>注解指定拦截<code>StatementHandler</code>的<code>prepare</code>方法（SQL 预处理阶段）和<code>query</code>方法（结果查询阶段）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;),</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaginationInnerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InnerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 核心逻辑实现</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>mapper.selectPage(page, queryWrapper)</code>时，MyBatis 的插件链会触发该拦截器。</p><h4 id="2-SQL-动态改写原理"><a href="#2-SQL-动态改写原理" class="headerlink" title="2. SQL 动态改写原理"></a>2. SQL 动态改写原理</h4><p>这是分页功能的核心步骤，MP 会根据数据库方言，将原始查询 SQL 改写成 “分页查询 SQL” 和 “总条数查询 SQL”：</p><h5 id="（1）原始-SQL-示例（MySQL）"><a href="#（1）原始-SQL-示例（MySQL）" class="headerlink" title="（1）原始 SQL 示例（MySQL）"></a>（1）原始 SQL 示例（MySQL）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM user WHERE age &gt; 18</span><br></pre></td></tr></table></figure><h5 id="（2）分页-SQL-改写（添加-LIMIT）"><a href="#（2）分页-SQL-改写（添加-LIMIT）" class="headerlink" title="（2）分页 SQL 改写（添加 LIMIT）"></a>（2）分页 SQL 改写（添加 LIMIT）</h5><p>MP 通过<code>BoundSql</code>解析原始 SQL，拼接分页语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM user WHERE age &gt; 18 LIMIT 0, 10  -- 第1页，每页10条</span><br></pre></td></tr></table></figure><p><strong>关键逻辑</strong>：在<code>prepare</code>方法中，通过<code>Dialect.buildPaginationSql</code>生成适配 SQL，不同数据库的方言实现不同：</p><ul><li><p>MySQL：<code>LIMIT offset, size</code></p></li><li><p>Oracle：<code>SELECT * FROM (SELECT t.*, ROWNUM rn FROM (...) t WHERE ROWNUM  ?) WHERE rn &gt; ?</code></p></li><li><p>PostgreSQL：<code>OFFSET ? LIMIT ?</code></p></li></ul><h5 id="（3）总条数-SQL-自动生成"><a href="#（3）总条数-SQL-自动生成" class="headerlink" title="（3）总条数 SQL 自动生成"></a>（3）总条数 SQL 自动生成</h5><p>MP 会自动剥离原始 SQL 的<code>SELECT</code>字段和<code>ORDER BY</code>（避免 count 统计错误），生成 count 查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(1) FROM user WHERE age &gt; 18</span><br></pre></td></tr></table></figure><p><strong>优化点</strong>：</p><ul><li><p>若原始 SQL 含<code>GROUP BY</code>，count 会改为<code>COUNT(DISTINCT 分组字段)</code>；</p></li><li><p>可通过<code>page.setSearchCount(false)</code>关闭总条数统计（适用于无需总页数的场景）。</p></li></ul><h4 id="3-分页参数传递与结果封装"><a href="#3-分页参数传递与结果封装" class="headerlink" title="3. 分页参数传递与结果封装"></a>3. 分页参数传递与结果封装</h4><ul><li><p><strong>参数传递</strong>：<code>Page</code>对象中的<code>current</code>（当前页）和<code>size</code>（每页条数）会被转换为<code>offset = (current - 1) * size</code>，作为分页参数注入改写后的 SQL；</p></li><li><p><strong>结果封装</strong>：执行分页 SQL 后，查询结果会被设置到<code>page.getRecords()</code>；执行 countSQL 后，总条数会设置到<code>page.setTotal(total)</code>，并自动计算<code>pages = (total + size - 1) / size</code>（总页数）。</p></li></ul><h3 id="四、物理分页-vs-逻辑分页：MP-为何选择物理分页？"><a href="#四、物理分页-vs-逻辑分页：MP-为何选择物理分页？" class="headerlink" title="四、物理分页 vs 逻辑分页：MP 为何选择物理分页？"></a>四、物理分页 vs 逻辑分页：MP 为何选择物理分页？</h3><p>很多人会疑惑：MP 为何采用 “物理分页”（依赖数据库 SQL 语法）而非 “逻辑分页”（查询全量数据后内存截取）？</p><div class="table-container"><table><thead><tr><th>对比维度</th><th>物理分页（MP 实现）</th><th>逻辑分页（内存截取）</th></tr></thead><tbody><tr><td>性能</td><td>只查询当前页数据，数据库压力小</td><td>查询全量数据，大数据量下内存溢出</td></tr><tr><td>适用场景</td><td>大数据量、跨库兼容</td><td>小数据量、本地测试</td></tr><tr><td>依赖</td><td>数据库方言支持</td><td>无依赖，纯 Java 逻辑</td></tr></tbody></table></div><p>MP 选择物理分页的核心原因是<strong>性能优化</strong>—— 对于百万级数据，逻辑分页会导致全表扫描，而物理分页通过数据库的索引优化，仅返回当前页数据，大幅降低 IO 开销。</p><h3 id="五、源码关键片段解析（MP-3-5-3-版本）"><a href="#五、源码关键片段解析（MP-3-5-3-版本）" class="headerlink" title="五、源码关键片段解析（MP 3.5.3 版本）"></a>五、源码关键片段解析（MP 3.5.3 版本）</h3><h4 id="1-分页-SQL-改写核心代码"><a href="#1-分页-SQL-改写核心代码" class="headerlink" title="1. 分页 SQL 改写核心代码"></a>1. 分页 SQL 改写核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaginationInnerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrepare</span><span class="params">(StatementHandler sh, Connection conn, Integer transactionTimeout)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 获取原始BoundSql（封装SQL和参数）</span></span><br><span class="line"></span><br><span class="line">   <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> sh.getBoundSql();</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 判断是否需要分页（是否包含Page参数）</span></span><br><span class="line"></span><br><span class="line">   <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> getPage(sh);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; page.isNeedPagination()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 获取数据库方言（根据Connection自动识别）</span></span><br><span class="line"></span><br><span class="line">       <span class="type">Dialect</span> <span class="variable">dialect</span> <span class="operator">=</span> getDialect(conn);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 改写分页SQL</span></span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">paginationSql</span> <span class="operator">=</span> dialect.buildPaginationSql(sql, page.getOffset(), page.getSize());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 替换原始SQL</span></span><br><span class="line"></span><br><span class="line">      ReflectUtil.setFieldValue(boundSql, <span class="string">&quot;sql&quot;</span>, paginationSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-总条数统计核心代码"><a href="#2-总条数统计核心代码" class="headerlink" title="2. 总条数统计核心代码"></a>2. 总条数统计核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaginationInnerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(Connection conn, String sql, List Class</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   // <span class="number">1.</span> 生成count SQL</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   String countSql = DialectBuilder.buildCountSql(sql)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 执行count查询</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> SqlHelper.executeQuery(conn, countSql, paramList, rs -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> rs.getLong(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、常见问题与底层原理关联分析"><a href="#六、常见问题与底层原理关联分析" class="headerlink" title="六、常见问题与底层原理关联分析"></a>六、常见问题与底层原理关联分析</h3><h4 id="1-分页失效？——-拦截器未注册"><a href="#1-分页失效？——-拦截器未注册" class="headerlink" title="1. 分页失效？—— 拦截器未注册"></a>1. 分页失效？—— 拦截器未注册</h4><p>若分页 SQL 未添加 LIMIT，大概率是分页插件未注入 Spring 容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确配置（Spring Boot）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 添加分页拦截器，并指定数据库类型</span></span><br><span class="line"></span><br><span class="line">       interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：未注册拦截器时，SQL 不会被改写，自然无法实现分页。</p><h4 id="2-总条数统计错误？——-SQL-解析异常"><a href="#2-总条数统计错误？——-SQL-解析异常" class="headerlink" title="2. 总条数统计错误？—— SQL 解析异常"></a>2. 总条数统计错误？—— SQL 解析异常</h4><p>若 count 结果与实际不符，可能是原始 SQL 含复杂语法（如<code>UNION</code>、<code>子查询</code>），导致 MP 的 SQL 解析失败。此时可手动指定 countSQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.setCountSql(&quot;SELECT COUNT(1) FROM (原始复杂SQL) t&quot;);</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：MP 的自动 countSQL 生成依赖 SQL 解析器，复杂语法可能导致解析偏差，手动指定可绕过解析逻辑。</p><h4 id="3-跨库分页兼容问题？——-方言未适配"><a href="#3-跨库分页兼容问题？——-方言未适配" class="headerlink" title="3. 跨库分页兼容问题？—— 方言未适配"></a>3. 跨库分页兼容问题？—— 方言未适配</h4><p>切换数据库后分页失效，需确保<code>DbType</code>与实际数据库一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 适配PostgreSQL</span><br><span class="line"></span><br><span class="line">interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.POSTGRE\_SQL));</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：不同数据库的分页语法差异，方言是连接 SQL 改写与数据库的桥梁。</p><h3 id="七、总结与思考"><a href="#七、总结与思考" class="headerlink" title="七、总结与思考"></a>七、总结与思考</h3><p>MyBatis-Plus 的分页功能之所以强大，核心在于 **“无侵入式设计” 和 “数据库方言适配”**：</p><ol><li><p>基于 MyBatis 拦截器机制，无需修改业务 SQL，实现分页逻辑与业务逻辑解耦；</p></li><li><p>通过方言接口封装不同数据库的分页语法，解决跨库兼容问题；</p></li><li><p>自动生成 countSQL，减少重复编码，同时支持灵活配置（关闭统计、手动指定 countSQL）。</p></li></ol><p>从底层原理来看，MP 的分页插件本质是 “SQL 解析与改写的自动化工具”，其设计思路值得借鉴：<strong>将通用逻辑（分页）抽离为插件，通过拦截器嵌入框架流程，既不破坏原有架构，又能提升开发效率</strong>。</p><p>在实际开发中，需注意：</p><ul><li><p>复杂 SQL 场景下，建议手动验证分页 SQL 和 countSQL 的正确性；</p></li><li><p>大数据量分页（如千万级数据），可结合<code>PageHelper</code>的 “合理化分页” 或 MP 的<code>page.setReasonable(true)</code>避免页码越界；</p></li><li><p>无需总条数时，关闭<code>searchCount</code>可提升查询性能。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis-Plus分页查询底层原理&quot;&gt;&lt;a href=&quot;#MyBatis-Plus分页查询底层原理&quot; class=&quot;headerlink&quot; title=&quot;MyBatis-Plus分页查询底层原理&quot;&gt;&lt;/a&gt;MyBatis-Plus分页查询底层原理&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="MyBatis-Plus" scheme="https://nmcb666.vip/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>bitMap实现签到功能</title>
    <link href="https://nmcb666.vip/posts/61e739c3.html"/>
    <id>https://nmcb666.vip/posts/61e739c3.html</id>
    <published>2025-12-07T17:44:51.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，用户签到是一个非常常见的功能需求，比如APP的每日签到领积分、连续签到奖励等。面对海量用户的签到数据，如果使用传统的关系型数据库存储，不仅会占用大量的存储空间，而且在统计签到情况时效率也会比较低下。那么，有没有更高效、更节省空间的方案呢？答案是肯定的，那就是利用Redis中的Bitmap（位图）来实现用户签到功能。本文就来详细探讨一下如何使用Redis Bitmap结合Java实现用户签到，并分析其优势和注意事项。</p><h2 id="一、为什么选择Redis-Bitmap实现用户签到？"><a href="#一、为什么选择Redis-Bitmap实现用户签到？" class="headerlink" title="一、为什么选择Redis Bitmap实现用户签到？"></a>一、为什么选择Redis Bitmap实现用户签到？</h2><p>在介绍具体实现之前，我们先来思考一下为什么Redis Bitmap适合用来实现用户签到。首先，我们来回顾一下Bitmap的基本概念：Bitmap是一种基于位的数据结构，它使用一个位（bit）来表示一个元素的状态，0表示不存在或未发生，1表示存在或已发生。在用户签到场景中，我们可以用一个位来表示用户某一天是否签到，这样就能够极大地节省存储空间。</p><p>假设我们有1000万用户，每个用户每年签到数据需要365个 bit 来存储，那么一年的签到数据总存储空间为：1000万 <em> 365 bit = 10000000 </em> 365 / 8 / 1024 / 1024 ≈ 430MB。如果使用传统的数据库表，每个签到记录至少需要存储用户ID、签到日期等字段，假设每条记录占用20字节，那么1000万用户一年的签到数据存储空间为：1000万 <em> 365 </em> 20 byte = 10000000 <em> 365 </em> 20 / 1024 / 1024 / 1024 ≈ 6.8GB。通过对比可以明显看出，Bitmap在存储空间上具有巨大的优势。</p><p>除此之外，Redis Bitmap还提供了丰富的位操作命令，比如<code>SETBIT</code>（设置某一位的值）、<code>GETBIT</code>（获取某一位的值）、<code>BITCOUNT</code>（统计值为1的位的个数）、<code>BITOP</code>（位运算）等，这些命令能够高效地满足签到功能中的签到标记、签到查询、连续签到统计等需求，操作效率非常高。</p><h2 id="二、Redis-Bitmap实现用户签到的具体方案"><a href="#二、Redis-Bitmap实现用户签到的具体方案" class="headerlink" title="二、Redis Bitmap实现用户签到的具体方案"></a>二、Redis Bitmap实现用户签到的具体方案</h2><h3 id="2-1-键的设计"><a href="#2-1-键的设计" class="headerlink" title="2.1 键的设计"></a>2.1 键的设计</h3><p>要使用Bitmap实现用户签到，首先需要设计合理的键名。为了方便区分不同用户、不同年份和月份的签到数据，我们可以采用这样的键名格式：<code>user:checkin:uid:year:month</code>。其中，<code>uid</code>是用户的唯一标识，<code>year</code>是年份，<code>month</code>是月份。这样设计的好处是，每个用户每个月的签到数据都存储在一个独立的Bitmap中，既方便管理，又能避免单个Bitmap过大导致的性能问题。</p><h3 id="2-2-签到标记（SETBIT命令）"><a href="#2-2-签到标记（SETBIT命令）" class="headerlink" title="2.2 签到标记（SETBIT命令）"></a>2.2 签到标记（SETBIT命令）</h3><p>当用户进行签到操作时，我们需要将对应日期的位设置为1。具体步骤如下：</p><ol><li><p>获取当前日期，并计算出该日期在当月是第几天（假设为day，取值范围1-31）。</p></li><li><p>由于Bitmap的位是从0开始计数的，所以需要将day减1得到对应的位索引（index = day - 1）。</p></li><li><p>使用Redis的<code>SETBIT</code>命令，将键<code>user:checkin:uid:year:month</code>对应index位置的位设置为1。</p></li></ol><p><code>SETBIT</code>命令的语法为：<code>SETBIT key offset value</code>，其中offset是位索引，value是要设置的值（0或1）。该命令的返回值是该位在设置前的值。</p><h3 id="2-3-签到查询（GETBIT命令）"><a href="#2-3-签到查询（GETBIT命令）" class="headerlink" title="2.3 签到查询（GETBIT命令）"></a>2.3 签到查询（GETBIT命令）</h3><p>当需要查询用户某一天是否签到时，可以使用<code>GETBIT</code>命令。具体步骤如下：</p><ol><li><p>获取要查询的日期，并计算出该日期在当月是第几天（day）。</p></li><li><p>计算位索引index = day - 1。</p></li><li><p>使用<code>GETBIT</code>命令，获取键<code>user:checkin:uid:year:month</code>对应index位置的位值。如果返回1，表示用户当天已签到；如果返回0，表示用户当天未签到。</p></li></ol><p><code>GETBIT</code>命令的语法为：<code>GETBIT key offset</code>。</p><h3 id="2-4-签到统计（BITCOUNT命令）"><a href="#2-4-签到统计（BITCOUNT命令）" class="headerlink" title="2.4 签到统计（BITCOUNT命令）"></a>2.4 签到统计（BITCOUNT命令）</h3><p>在签到功能中，经常需要统计用户在某个时间段内的签到天数，比如当月签到天数、近7天签到天数等。这时候可以使用<code>BITCOUNT</code>命令，该命令用于统计Bitmap中值为1的位的个数。</p><p><code>BITCOUNT</code>命令的语法为：<code>BITCOUNT key [start end]</code>，其中start和end是字节的索引（注意不是位的索引），用于指定统计的范围。如果不指定start和end，则统计整个Bitmap。</p><p>例如，要统计用户当月的签到天数，直接使用<code>BITCOUNT user:checkin:uid:year:month</code>即可。如果要统计用户近7天的签到天数，需要先确定这7天对应的位索引范围，然后将位索引转换为字节索引（字节索引 = 位索引 / 8），再使用<code>BITCOUNT</code>命令进行统计。</p><h3 id="2-5-连续签到统计"><a href="#2-5-连续签到统计" class="headerlink" title="2.5 连续签到统计"></a>2.5 连续签到统计</h3><p>连续签到统计是签到功能中的一个难点，比如统计用户当前的连续签到天数。实现思路如下：</p><ol><li><p>从当前日期开始，依次向前查询每天的签到状态（使用<code>GETBIT</code>命令）。</p></li><li><p>如果查询到某一天未签到，则停止查询，连续签到天数为已查询到的签到天数。</p></li><li><p>如果查询到本月第一天都已签到，则继续查询上一个月的签到数据，直到查询到未签到的日期为止。</p></li></ol><p>在实现过程中，需要注意跨月份的情况，需要分别处理不同月份的Bitmap。</p><h2 id="三、Java代码实现"><a href="#三、Java代码实现" class="headerlink" title="三、Java代码实现"></a>三、Java代码实现</h2><p>接下来，我们通过Java代码来具体实现Redis Bitmap用户签到功能。首先，我们需要引入Redis的Java客户端依赖，这里以Jedis为例。</p><h3 id="3-1-依赖引入（Maven）"><a href="#3-1-依赖引入（Maven）" class="headerlink" title="3.1 依赖引入（Maven）"></a>3.1 依赖引入（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-签到工具类实现"><a href="#3-2-签到工具类实现" class="headerlink" title="3.2 签到工具类实现"></a>3.2 签到工具类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckinUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;user:checkin:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">YEAR_MONTH_FORMATTER</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckinUtil</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户签到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 签到日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签到前的状态（0：未签到，1：已签到）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">checkin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> dayOfMonth - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.setbit(key, offset, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户某一天是否签到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 查询日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：已签到，false：未签到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isCheckin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> dayOfMonth - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.getbit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计用户当月签到天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当月任意一天</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签到天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">countMonthCheckin</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCheckinKey(uid, date);</span><br><span class="line">        <span class="keyword">return</span> jedis.bitcount(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计用户当前连续签到天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连续签到天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countContinuousCheckin</span><span class="params">(Long uid)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">currentDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">continuousDays</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">tempDate</span> <span class="operator">=</span> currentDate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">isCheckin</span> <span class="operator">=</span> isCheckin(uid, tempDate);</span><br><span class="line">            <span class="keyword">if</span> (isCheckin) &#123;</span><br><span class="line">                continuousDays++;</span><br><span class="line">                tempDate = tempDate.minusDays(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 避免无限循环，当查询到一年前仍未断签时，停止查询</span></span><br><span class="line">                <span class="keyword">if</span> (tempDate.isBefore(currentDate.minusYears(<span class="number">1</span>))) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> continuousDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取签到Redis键名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getCheckinKey</span><span class="params">(Long uid, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">yearMonth</span> <span class="operator">=</span> date.format(YEAR_MONTH_FORMATTER);</span><br><span class="line">        <span class="keyword">return</span> REDIS_KEY_PREFIX + uid + <span class="string">&quot;:&quot;</span> + yearMonth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul><li><p><strong>Bitmap的大小限制</strong>：Redis中单个BitMap的偏移量最大为 2^32-1。在设计键名时，按用户每月拆分Bitmap，可以有效控制单个Bitmap的大小，避免因Bitmap过大导致报错。</p></li><li><p><strong>日期处理的准确性</strong>：在计算位索引时，一定要注意日期的准确性，特别是跨月份和闰年的情况。使用Java 8的<code>LocalDate</code>类可以方便、准确地处理日期相关操作。</p></li><li><p><strong>Redis连接管理</strong>：在实际项目中，不能每次操作都创建新的Jedis连接，应该使用连接池来管理Redis连接，以提高性能和避免资源泄露。（这个无需担心，实际开发大多采用spring-data-redis进行操作 会自行管理）</p></li><li><p><strong>数据持久化</strong>：Redis支持RDB和AOF两种持久化方式，为了防止签到数据丢失，需要合理配置Redis的持久化策略。</p></li><li><p><strong>过期策略</strong>：对于一些过期的签到数据（比如几年前的签到数据），如果业务上不再需要，可以设置键的过期时间，让Redis自动清理这些数据，节省存储空间。</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>使用Redis Bitmap实现用户签到功能，具有存储空间小、操作效率高、命令丰富等优点，非常适合处理海量用户的签到数据。通过合理的键名设计和Java代码实现，我们可以轻松地完成签到标记、签到查询、签到统计等功能。同时，在实际应用中，还需要注意Bitmap的大小限制、日期处理、Redis连接管理等问题，以确保系统的稳定性和性能。</p><p>总的来说，Redis Bitmap是实现用户签到功能的一种优秀方案，值得在项目中推广和应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发中，用户签到是一个非常常见的功能需求，比如APP的每日签到领积分、连续签到奖励等。面对海量用户的签到数据，如果使用传统的关系型数据库存储，不仅会占用大量的存储空间，而且在统计签到情况时效率也会比较低下。那么，有没有更高效、更节省空间的方案呢？答案是肯定的，那就是利</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>利用Redis Sorted Set实现Java滚动分页查询</title>
    <link href="https://nmcb666.vip/posts/7be5306f.html"/>
    <id>https://nmcb666.vip/posts/7be5306f.html</id>
    <published>2025-12-06T19:13:16.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，分页查询是一个非常常见的需求。传统的基于数据库的Limit Offset分页方式虽然简单，但在数据量较大或数据实时变动（如插入新数据）的场景下，会出现<strong>重复数据</strong>或<strong>数据遗漏</strong>的问题。本文将探讨如何利用Redis的Sorted Set（有序集合）数据结构来实现高效、准确的滚动分页查询，并结合具体Java代码进行详细解析。</p><h2 id="一、传统分页的痛点：为什么需要滚动分页？"><a href="#一、传统分页的痛点：为什么需要滚动分页？" class="headerlink" title="一、传统分页的痛点：为什么需要滚动分页？"></a>一、传统分页的痛点：为什么需要滚动分页？</h2><p>我们先回顾一下传统的Limit Offset分页。假设我们有一张博客表，要查询第2页数据（每页2条），SQL通常是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> blog <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> LIMIT <span class="number">2</span> <span class="keyword">OFFSET</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这种方式的问题在于：如果在查询第1页后、第2页前，有一条新的博客插入（create_time比第1页的部分数据更新），那么第2页的结果就会包含原本第1页的最后一条数据，导致重复查询。如下图所示：</p><ul><li><p>初始数据：[A(时间10), B(时间9), C(时间8), D(时间7)]</p></li><li><p>第1页（LIMIT 2 OFFSET 0）：[A, B]</p></li><li><p>插入新数据E(时间11)，数据变为：[E(11), A(10), B(9), C(8), D(7)]</p></li><li><p>第2页（LIMIT 2 OFFSET 2）：[B, C] → B重复出现</p></li></ul><p>滚动分页（也叫游标分页）则通过<strong>上一页的最后一个标记（如时间戳）</strong>来定位下一页的起始位置，避免了Offset带来的问题。而Redis的Sorted Set恰好能完美支持这种场景。</p><h2 id="二、Redis-Sorted-Set的特性：为什么适合滚动分页？"><a href="#二、Redis-Sorted-Set的特性：为什么适合滚动分页？" class="headerlink" title="二、Redis Sorted Set的特性：为什么适合滚动分页？"></a>二、Redis Sorted Set的特性：为什么适合滚动分页？</h2><p>Redis的Sorted Set（有序集合）是一种特殊的数据结构，它为每个元素分配一个<strong>分数（Score）</strong>，并按照分数对元素进行排序。其核心特性包括：</p><ol><li><p><strong>有序性</strong>：元素天然按照Score升序或降序排列，无需额外排序操作。</p></li><li><p><strong>范围查询</strong>：支持通过Score范围（如0到maxScore）查询元素，这是实现滚动分页的关键。</p></li><li><p><strong>高效性</strong>：无论是插入、查询还是删除操作，时间复杂度均为O(logN)，适合大数据量场景。</p></li></ol><p>在滚动分页场景中，我们可以将<strong>业务数据的唯一标识（如博客ID）</strong>作为Sorted Set的元素（Value），将<strong>排序字段（如创建时间戳）</strong>作为元素的分数（Score）。这样，通过Score范围就能快速定位下一页数据。</p><h2 id="三、滚动分页的实现思路与代码解析"><a href="#三、滚动分页的实现思路与代码解析" class="headerlink" title="三、滚动分页的实现思路与代码解析"></a>三、滚动分页的实现思路与代码解析</h2><p>下面结合提供的Java代码，详细拆解利用Redis Sorted Set实现滚动分页的完整流程。本文以“查询关注的博客动态”为例进行说明。</p><h3 id="3-1-核心流程概览"><a href="#3-1-核心流程概览" class="headerlink" title="3.1 核心流程概览"></a>3.1 核心流程概览</h3><p>滚动分页的核心是通过“上一页的最小时间戳（minTime）”和“偏移量（offset）”来定位下一页数据，具体流程如下：</p><ol><li><p>定义Redis的Sorted Set键：以用户ID为维度，存储该用户关注的博客ID集合（如<code>feed:1001</code>表示用户1001的关注动态）。</p></li><li><p>查询上一页数据：通过<code>reverseRangeByScoreWithScores</code>方法，查询Score在0到max（上一页的minTime）之间的元素，同时指定偏移量和每页数量。</p></li><li><p>处理查询结果：提取博客ID、计算当前页的最小时间戳和偏移量，用于下一页查询。</p></li><li><p>封装并返回结果：将博客详情、minTime、offset返回给前端，作为下一页请求的参数。</p></li></ol><h3 id="3-2-代码逐行解析"><a href="#3-2-代码逐行解析" class="headerlink" title="3.2 代码逐行解析"></a>3.2 代码逐行解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;feed:&quot;</span> + userId; <span class="comment">// Redis键：feed:用户ID</span></span><br><span class="line">    <span class="comment">// 2. 从Redis查询blogId列表</span></span><br><span class="line">    <span class="comment">// reverseRangeByScoreWithScores：倒序查询Score在[0, max]之间的元素</span></span><br><span class="line">    <span class="comment">// 参数说明：key, 最小Score, 最大Score, 偏移量, 每页数量</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; result = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3. 处理空结果</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;无新数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 提取博客ID、计算当前页的minTime和offset</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 初始化为当前时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 初始偏移量为1</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result.size());</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : result) &#123;</span><br><span class="line">        <span class="comment">// 提取博客ID</span></span><br><span class="line">        ids.add(Long.valueOf(Objects.requireNonNull(tuple.getValue())));</span><br><span class="line">        <span class="comment">// 提取Score（即博客创建时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> Objects.requireNonNull(tuple.getScore()).longValue();</span><br><span class="line">        <span class="comment">// 处理相同时间戳的情况：若时间等于当前minTime，偏移量+1；否则更新minTime和偏移量</span></span><br><span class="line">        <span class="keyword">if</span>(time == minTime) &#123;</span><br><span class="line">            offset1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            offset1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 查询博客详情（批量查询避免N+1问题，此处为简化示例）</span></span><br><span class="line">    List&lt;Blog&gt; blogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ids.size());</span><br><span class="line">    ids.forEach(id -&gt; &#123;</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id); <span class="comment">// 从数据库查询博客详情</span></span><br><span class="line">        setBlogIsLiked(blog); <span class="comment">// 处理博客点赞状态</span></span><br><span class="line">        queryUser(blog); <span class="comment">// 填充博客作者信息</span></span><br><span class="line">        blogs.add(blog);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 6. 封装滚动分页结果</span></span><br><span class="line">    ScrollResult&lt;Blog&gt; scrollResult = <span class="keyword">new</span> <span class="title class_">ScrollResult</span>&lt;&gt;();</span><br><span class="line">    scrollResult.setList(blogs); <span class="comment">// 当前页博客列表</span></span><br><span class="line">    scrollResult.setMinTime(minTime); <span class="comment">// 当前页最小时间戳（下一页的max参数）</span></span><br><span class="line">    scrollResult.setOffset(offset1); <span class="comment">// 当前页最小时间戳对应的偏移量</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-关键细节说明"><a href="#3-3-关键细节说明" class="headerlink" title="3.3 关键细节说明"></a>3.3 关键细节说明</h3><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**为什么用reverseRangeByScoreWithScores？**因为我们通常需要按时间倒序展示数据（最新的在前），该方法会按照Score从大到小返回元素，正好符合需求。</p></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**max和offset参数的作用？**- `max`：上一页返回的minTime，代表下一页数据的Score不能超过这个值（即时间不能晚于这个值）。- `offset`：当存在多个Score相同的元素时，用于跳过前N个元素，避免重复。</p></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">**如何处理相同时间戳的数据？**如果多条博客的创建时间戳相同（Score相同），下一页查询时需要通过offset跳过这些重复的元素。例如，当前页有3条数据的Score都是1620000000，那么minTime=1620000000，offset=3，下一页查询时会从第4个Score=1620000000的元素开始。</p></div><h2 id="四、滚动分页的优势与注意事项"><a href="#四、滚动分页的优势与注意事项" class="headerlink" title="四、滚动分页的优势与注意事项"></a>四、滚动分页的优势与注意事项</h2><h3 id="4-1-优势"><a href="#4-1-优势" class="headerlink" title="4.1 优势"></a>4.1 优势</h3><ul><li><p><strong>无重复无遗漏</strong>：基于时间戳定位，即使中间插入新数据，也不会影响下一页的查询结果。</p></li><li><p><strong>高性能</strong>：Redis的Sorted Set查询效率高，尤其适合大数据量场景，避免了数据库Limit Offset的全表扫描问题。</p></li><li><p><strong>实时性好</strong>：数据插入Redis后可立即查询，无需等待数据库同步。</p></li></ul><h3 id="4-2-注意事项"><a href="#4-2-注意事项" class="headerlink" title="4.2 注意事项"></a>4.2 注意事项</h3><ul><li><p><strong>Score的唯一性问题</strong>：如果排序字段（如时间戳）存在大量重复，需要通过offset来处理，否则可能出现数据漏查。</p></li><li><p><strong>Redis数据一致性</strong>：需要保证业务数据（如博客）与Redis中的Sorted Set同步。例如，博客删除时，要及时从Redis中移除对应的元素。</p></li><li><p><strong>分页参数的传递</strong>：前端需要将上一页返回的minTime和offset作为下一页请求的参数，因此需要在接口设计中明确这两个参数。</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>相比传统的Limit Offset分页，基于Redis Sorted Set的滚动分页在实时性、准确性和高性能方面都有明显优势，尤其适合动态数据（如关注动态、消息流）的分页场景。其核心是利用Sorted Set的Score有序性和范围查询能力，通过“上一页的最小时间戳+偏移量”来定位下一页数据，从根本上解决了传统分页的重复和遗漏问题。</p><p>在实际开发中，我们还可以根据业务需求优化细节，例如结合Redis的过期策略清理历史数据、使用管道（Pipeline）减少Redis交互次数等，进一步提升系统性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发中，分页查询是一个非常常见的需求。传统的基于数据库的Limit Offset分页方式虽然简单，但在数据量较大或数据实时变动（如插入新数据）的场景下，会出现&lt;strong&gt;重复数据&lt;/strong&gt;或&lt;strong&gt;数据遗漏&lt;/strong&gt;的问题。本文将探讨如何利</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Stream多消费者组模式：原理、ACK机制与在Java中的实践</title>
    <link href="https://nmcb666.vip/posts/da8941bc.html"/>
    <id>https://nmcb666.vip/posts/da8941bc.html</id>
    <published>2025-12-03T18:42:18.000Z</published>
    <updated>2026-01-24T07:56:35.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-Stream多消费者组模式：原理、ACK机制与Java实践"><a href="#Redis-Stream多消费者组模式：原理、ACK机制与Java实践" class="headerlink" title="Redis Stream多消费者组模式：原理、ACK机制与Java实践"></a>Redis Stream多消费者组模式：原理、ACK机制与Java实践</h1><p>在分布式系统中，消息队列是解耦服务、削峰填谷的核心组件。Redis作为高性能的内存数据库，从5.0版本开始引入Stream数据结构，原生支持消息队列功能。相较于Redis以往的Pub/Sub（无持久化）、List（简单队列），Stream提供了<strong>持久化、多消费者组、ACK确认、消息回溯</strong>等企业级特性，尤其在多消费者组场景下，能灵活实现消息的分发与处理。本文将深入剖析Stream多消费者组的实现原理，重点解读ACK确认机制与Pending List的作用，并结合Java代码演示实际运用场景。</p><h1 id="一、Redis-Stream核心概念与多消费者组模型"><a href="#一、Redis-Stream核心概念与多消费者组模型" class="headerlink" title="一、Redis Stream核心概念与多消费者组模型"></a>一、Redis Stream核心概念与多消费者组模型</h1><p>在理解多消费者组之前，我们先明确Stream的几个基础概念：</p><ul><li><p><strong>Stream</strong>：消息的载体，类似日志文件的结构，每条消息有唯一的ID（格式为“时间戳-序列号”，如1690000000000-0），消息内容以键值对存储。</p></li><li><p><strong>消费者组（Consumer Group）</strong>：一组消费者的集合，同一个Stream可以创建多个消费者组。<strong>不同消费者组之间是独立的</strong>，即同一条消息会被每个消费者组消费一次；而同一个消费者组内的消费者则竞争消费消息，确保一条消息只被组内一个消费者处理。</p></li><li><p><strong>消费者（Consumer）</strong>：隶属于某个消费者组，实际处理消息的个体。</p></li><li><p><strong>Pending List（PENDING列表）</strong>：消费者从组内获取消息后，若未发送ACK确认，消息会被放入该消费者的Pending List中，标记为“已读取但未确认”。</p></li></ul><p>多消费者组的核心模型如下图所示（概念示意）：</p><blockquote><p>Stream（消息队列） → 消费者组A（Consumer1、Consumer2） → 各自Pending List</p><pre><code>  └→ 消费者组B（Consumer3、Consumer4） → 各自Pending List</code></pre></blockquote><p>例如，一个订单Stream可以创建“支付组”和“物流组”，支付组处理订单支付状态，物流组处理订单发货，两者独立消费同一条订单消息，互不干扰。</p><h1 id="二、关键机制：ACK确认与Pending-List深度解析"><a href="#二、关键机制：ACK确认与Pending-List深度解析" class="headerlink" title="二、关键机制：ACK确认与Pending List深度解析"></a>二、关键机制：ACK确认与Pending List深度解析</h1><p>Stream的可靠性依赖于<strong>ACK确认机制</strong>，而Pending List则是ACK机制的核心载体。这两者共同确保消息“至少被消费一次”（At-Least-Once），避免消息丢失。</p><h2 id="2-1-ACK确认机制流程"><a href="#2-1-ACK确认机制流程" class="headerlink" title="2.1 ACK确认机制流程"></a>2.1 ACK确认机制流程</h2><p>当消费者从组内获取消息后，消息并不会立即从Stream中删除，而是需要消费者处理完成后主动发送ACK命令（<code>XACK</code>），Redis才会将消息从该消费者的Pending List中移除，标记为“已处理”。具体流程如下：</p><ol><li><p>消费者通过<code>XREADGROUP</code>命令从组内读取消息（如<code>XREADGROUP GROUP group1 consumer1 COUNT 1 STREAMS stream1 &gt;</code>，其中“&gt;”表示读取组内未被消费过的消息）。</p></li><li><p>Redis将消息标记为“已分配给consumer1”，并加入consumer1的Pending List。</p></li><li><p>消费者处理消息（如业务逻辑计算、数据库写入等）。</p></li><li><p>处理成功后，消费者发送<code>XACK stream1 group1 msgId</code>命令确认消息。</p></li><li><p>Redis收到ACK后，从consumer1的Pending List中删除该消息。</p></li></ol><h2 id="2-2-Pending-List的作用与核心操作"><a href="#2-2-Pending-List的作用与核心操作" class="headerlink" title="2.2 Pending List的作用与核心操作"></a>2.2 Pending List的作用与核心操作</h2><p>Pending List（简称PENDING）是每个消费者组内消费者独有的“未确认消息列表”，它解决了“消息已读取但处理失败”的问题。当消费者处理消息异常（如服务宕机、业务报错）时，消息会一直留在Pending List中，直到被重新处理并ACK。</p><div class="tip warning faa-horizontal animated-hover"><p><strong>核心特性</strong>：Pending List中的消息会记录三个关键信息——消息ID、消费者ID、未确认时长（idle time），方便后续进行消息重试或死信处理。</p></div><p>操作Pending List的常用命令：</p><ul><li><p><code>XPENDING</code>：查看消费者组或消费者的Pending消息统计，如<code>XPENDING stream1 group1</code>可查看group1的Pending总数、最小/最大idle time等。</p></li><li><p><code>XPENDING stream1 group1 - + 10 consumer1</code>：查看consumer1的前10条Pending消息（“-”表示最小ID，“+”表示最大ID）。</p></li><li><p><code>XCLAIM</code>：将Pending List中的消息“认领”给其他消费者处理，适用于消费者宕机后的消息转移，如<code>XCLAIM stream1 group1 consumer2 60000 1690000000000-0</code>（60000表示idle time超过60秒的消息）。</p></li></ul><h1 id="三、Java中的实践：从队列消费与Pending-List重试"><a href="#三、Java中的实践：从队列消费与Pending-List重试" class="headerlink" title="三、Java中的实践：从队列消费与Pending List重试"></a>三、Java中的实践：从队列消费与Pending List重试</h1><p>下面我们通过Java代码演示Stream的核心用法：<strong>先消费Stream中的新消息，若处理异常则将消息留在Pending List，下次消费前先处理Pending List中的消息</strong>。我们使用Spring Data Redis作为客户端（需引入依赖：<code>spring-boot-starter-data-redis</code>）。</p><h2 id="3-1-初始化Stream与消费者组"><a href="#3-1-初始化Stream与消费者组" class="headerlink" title="3.1 初始化Stream与消费者组"></a>3.1 初始化Stream与消费者组</h2><p>首先需要创建Stream并初始化消费者组（可在项目启动时执行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.Consumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ObjectRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ReadOffset;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.StreamInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_stream&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;order_group&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamInitializer</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initStreamAndGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.execute((RedisConnection connection) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 检查Stream是否存在，不存在则创建（可选，XADD会自动创建）</span></span><br><span class="line">            StreamInfo.<span class="type">XInfoStream</span> <span class="variable">info</span> <span class="operator">=</span> connection.streamCommands().xInfoStream(STREAM_KEY.getBytes());</span><br><span class="line">            <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Stream不存在，创建Stream：&quot;</span> + STREAM_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查消费者组是否存在，不存在则创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.streamCommands().xInfoGroup(STREAM_KEY.getBytes(), GROUP_NAME.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者组已存在：&quot;</span> + GROUP_NAME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// MKSTREAM选项：若Stream不存在则创建</span></span><br><span class="line">                connection.streamCommands().xGroupCreate(</span><br><span class="line">                        STREAM_KEY.getBytes(),</span><br><span class="line">                        GROUP_NAME.getBytes(),</span><br><span class="line">                        ReadOffset.latest(),</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                );</span><br><span class="line">                System.out.println(<span class="string">&quot;创建消费者组：&quot;</span> + GROUP_NAME);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-消息生产者"><a href="#3-2-消息生产者" class="headerlink" title="3.2 消息生产者"></a>3.2 消息生产者</h2><p>模拟发送订单消息到Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.stream.ObjectRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamProducer</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送订单消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOrderMessage</span><span class="params">(OrderMessage message)</span> &#123;</span><br><span class="line">        <span class="comment">// ObjectRecord会自动将对象序列化为Hash（需配置RedisTemplate的序列化方式）</span></span><br><span class="line">        ObjectRecord&lt;String, OrderMessage&gt; record = ObjectRecord.create(STREAM_KEY, message);</span><br><span class="line">        <span class="comment">// XADD命令：添加消息到Stream</span></span><br><span class="line">        redisTemplate.opsForStream().add(record);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单消息实体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderMessage</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String orderId;</span><br><span class="line">        <span class="keyword">private</span> String userId;</span><br><span class="line">        <span class="keyword">private</span> Double amount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getter、setter、toString</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-消息消费者：优先处理Pending-List"><a href="#3-3-消息消费者：优先处理Pending-List" class="headerlink" title="3.3 消息消费者：优先处理Pending List"></a>3.3 消息消费者：优先处理Pending List</h2><p>核心逻辑：消费者启动后，<strong>先处理Pending List中的消息</strong>，处理完后再持续消费Stream中的未被消费的消息；若处理消息异常，不发送ACK，消息留在Pending List下次重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SAVE_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动时执行 持续监听消息队列</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SAVE_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderTask</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从消息队列里面读取消息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order &gt;</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">if</span>(read == <span class="literal">null</span> || read.isEmpty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取消息 并且将消息转化为订单</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = read.getFirst();</span><br><span class="line">                    Map&lt;Object, Object&gt; orderMap = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(orderMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    voucherOrderSaveHandler(voucherOrder);</span><br><span class="line">                    <span class="comment">//确认消息 发送ack</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>);</span><br><span class="line">                    <span class="comment">//遇到异常应先处理pending list中的消息  确保每个消息都被处理一次</span></span><br><span class="line">                    handPendingMessagesList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handPendingMessagesList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从pending队列里面获取待处理的消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; read = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">if</span>(read == <span class="literal">null</span> || read.isEmpty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取消息 并且将消息转化为订单</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = read.getFirst();</span><br><span class="line">                Map&lt;Object, Object&gt; orderMap = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(orderMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                voucherOrderSaveHandler(voucherOrder);</span><br><span class="line">                <span class="comment">//确认消息 发送ack</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pending-list订单异常&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结与注意事项"><a href="#四、总结与注意事项" class="headerlink" title="四、总结与注意事项"></a>四、总结与注意事项</h1><p>Redis Stream的多消费者组模式通过ACK机制和Pending List，实现了消息的可靠消费，尤其适合中小型分布式系统的轻量级消息队列场景。但在使用时需注意以下几点：</p><ul><li><p><strong>消息持久化</strong>：Stream消息默认持久化到Redis的RDB/AOF中，需确保Redis的持久化配置合理，避免宕机丢失消息。</p></li><li><p><strong>Pending List积压</strong>：需定期监控Pending List的消息量，若积压过多，需排查消费者是否异常，并通过<code>XCLAIM</code>转移消息或设置死信机制（如超过重试次数后转移到其他Stream）。</p></li><li><p><strong>消费者弹性</strong>：同一个消费者组内可动态增减消费者，实现负载均衡，但需避免消费者ID重复。</p></li><li><p><strong>性能考量</strong>：Redis单线程处理命令，高并发场景下需评估Stream的消息生产速率，避免Redis成为瓶颈（可结合分片或集群扩展）。</p></li></ul><p>总之，Redis Stream以其轻量、高效、可靠的特性，为分布式系统提供了一种灵活的消息队列解决方案，尤其在多消费者组和消息重试场景下，展现了独特的优势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-Stream多消费者组模式：原理、ACK机制与Java实践&quot;&gt;&lt;a href=&quot;#Redis-Stream多消费者组模式：原理、ACK机制与Java实践&quot; class=&quot;headerlink&quot; title=&quot;Redis Stream多消费者组模式：原理</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java中Redisson锁对于可重试的实现</title>
    <link href="https://nmcb666.vip/posts/3a74c7b3.html"/>
    <id>https://nmcb666.vip/posts/3a74c7b3.html</id>
    <published>2025-12-02T08:40:27.000Z</published>
    <updated>2026-01-24T07:56:35.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中Redisson锁对于可重试的实现方式"><a href="#Java中Redisson锁对于可重试的实现方式" class="headerlink" title="Java中Redisson锁对于可重试的实现方式"></a>Java中Redisson锁对于可重试的实现方式</h1><p>在分布式系统中，分布式锁是解决并发问题的关键工具，而Redisson作为基于Redis的Java客户端，其提供的分布式锁因其高效、可靠的特性被广泛应用。在实际业务场景中，由于网络抖动、Redis服务短暂不可用等原因，锁的获取可能会出现暂时性失败，此时<strong>可重试机制</strong>就显得尤为重要。本文将深入探讨Redisson锁可重试的实现方式，从核心思路到具体代码，再到注意事项，为大家梳理这一实用特性的来龙去脉。</p><h2 id="一、为什么需要Redisson锁的可重试机制？"><a href="#一、为什么需要Redisson锁的可重试机制？" class="headerlink" title="一、为什么需要Redisson锁的可重试机制？"></a>一、为什么需要Redisson锁的可重试机制？</h2><p>在分布式环境下，获取Redisson锁失败并不总是意味着“锁被占用”，还可能是由以下暂时性因素导致：</p><ul><li><p><strong>网络波动</strong>：客户端与Redis服务器之间的网络连接出现短暂不稳定，导致锁请求超时。</p></li><li><p><strong>Redis服务负载过高</strong>：Redis在高并发场景下处理请求的速度变慢，使得锁获取操作未能在预期时间内完成。</p></li><li><p><strong>锁竞争激烈</strong>：多个客户端同时竞争同一把锁，当前客户端第一次请求时锁正被占用，但短时间内锁就会被释放。</p></li></ul><p>如果此时直接返回失败，可能会导致业务流程中断，影响系统的可用性和用户体验。而可重试机制能够让客户端在一定条件下重复尝试获取锁，从而规避上述暂时性问题，提高锁获取的成功率。</p><h2 id="二、Redisson锁可重试实现的核心思路"><a href="#二、Redisson锁可重试实现的核心思路" class="headerlink" title="二、Redisson锁可重试实现的核心思路"></a>二、Redisson锁可重试实现的核心思路</h2><p>Redisson锁的可重试并非简单循环+固定等待，而是基于<strong>“Redis发布订阅的等待-唤醒机制”</strong>实现，核心是避免无意义的轮询，减少资源消耗。其本质是结合<code>tryLock</code>的阻塞等待逻辑与Redis的消息通知，具体拆解为以下步骤：</p><ol><li><p><strong>初始尝试获取锁</strong>：客户端通过<code>SET NX</code>命令尝试获取锁，若成功则返回锁实例，同时记录锁的租期(如果还需要实现可重入则需要用Hash结构去记录锁的持有者以及锁的数量，这里默认不支持可重入)。</p></li><li><p><strong>失败则订阅锁释放通知</strong>：若锁已被占用，客户端不会立即重试，而是通过Redis的<code>SUBSCRIBE</code>命令订阅该锁的释放通知频道（如<code>redisson_lock__channel:&#123;lockKey&#125;</code>）。</p></li><li><p><strong>阻塞等待通知或超时</strong>：客户端进入阻塞状态，等待两个触发条件之一：① 收到锁释放的<code>PUBLISH</code>通知；② 达到预设的最大等待时间（<code>waitTime</code>）。</p></li><li><p><strong>唤醒后重试或终止</strong>：若收到释放通知，客户端立即唤醒并重新尝试获取锁；若等待超时，则终止重试并返回失败。</p></li></ol><div class="tip warning faa-horizontal animated"><p>关键在于“精准唤醒”而非“盲目重试”：通过Redis的发布订阅机制，只有当锁真正释放时才触发重试，既减少了Redis的请求压力，又能保证重试的及时性。</p></div><h2 id="三、Redisson锁可重试的底层实现与手动封装"><a href="#三、Redisson锁可重试的底层实现与手动封装" class="headerlink" title="三、Redisson锁可重试的底层实现与手动封装"></a>三、Redisson锁可重试的底层实现与手动封装</h2><p>Redisson的原生<code>tryLock(waitTime, leaseTime, TimeUnit)</code>方法已内置“等待-唤醒”的可重试逻辑，其底层通过<code>RedissonLock#tryAcquireAsync</code>实现异步获取+通知订阅。我们无需重复开发核心机制，只需基于原生方法封装业务级的重试策略（如总超时控制、多轮等待等），以下是具体实现。</p><h3 id="方式一：基于原生tryLock的多轮等待封装"><a href="#方式一：基于原生tryLock的多轮等待封装" class="headerlink" title="方式一：基于原生tryLock的多轮等待封装"></a>方式一：基于原生tryLock的多轮等待封装</h3><p>Redisson原生<code>tryLock(waitTime, ...)</code>已实现“等待通知+单次重试”，若需支持多轮等待（如总等待时间较长时），可封装多轮<code>tryLock</code>调用，每轮利用原生的等待-唤醒机制，避免固定休眠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLockRetryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="comment">// 总最大等待时间（毫秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TOTAL_MAX_WAIT_MS</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">// 每轮等待时间（利用原生tryLock的等待-唤醒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PER_ROUND_WAIT_MS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedissonLockRetryDemo</span><span class="params">(RedissonClient redissonClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于原生tryLock等待-唤醒的多轮重试封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁租期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁实例，若获取失败则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RLock <span class="title function_">tryLockWithRetry</span><span class="params">(String lockKey, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(TOTAL_MAX_WAIT_MS);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (remainingWaitMs.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每轮调用原生tryLock，利用其等待-唤醒机制</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock(remainingWaitMs.get(), leaseTime, unit);</span><br><span class="line">                <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">usedWaitMs</span> <span class="operator">=</span> System.currentTimeMillis() - startTimestamp;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取锁成功，累计等待时间：&quot;</span> + usedWaitMs + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> lock;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新剩余等待时间（避免总等待超时）</span></span><br><span class="line">                remainingWaitMs.addAndGet(-PER_ROUND_WAIT_MS);</span><br><span class="line">                System.out.println(<span class="string">&quot;本轮等待超时，剩余等待时间：&quot;</span> + remainingWaitMs.get() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="string">&quot;获取锁过程被中断&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总等待时间已耗尽，获取锁失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<strong><code>tryLock</code></strong> <strong>核心是复用Redisson原生的等待逻辑</strong>：每轮调用<code>tryLock(remainingWaitMs, ...)</code>时，客户端会订阅锁释放通知并阻塞，直到收到通知（立即重试）或本轮等待超时。通过<code>remainingWaitMs</code>控制总等待时间，既保证了“精准唤醒”，又实现了业务级的多轮重试控制。</p><h3 id="方式二：理解Redisson原生等待-唤醒的底层逻辑"><a href="#方式二：理解Redisson原生等待-唤醒的底层逻辑" class="headerlink" title="方式二：理解Redisson原生等待-唤醒的底层逻辑"></a>方式二：理解Redisson原生等待-唤醒的底层逻辑</h3><p>为更深入理解“等待-唤醒”机制，以下简要分析RedissonLock的底层实现流程（基于Redisson 3.x版本），帮助我们更合理地使用可重试功能：</p><h4 id="1-锁获取失败后的订阅逻辑"><a href="#1-锁获取失败后的订阅逻辑" class="headerlink" title="1. 锁获取失败后的订阅逻辑"></a>1. 锁获取失败后的订阅逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RedissonLock#tryAcquireAsync简化逻辑</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 尝试获取锁</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; acquiredFuture = tryLockInnerAsync(waitTime, leaseTime, unit);</span><br><span class="line">    <span class="keyword">return</span> acquiredFuture.thenCompose(acquired -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 获取失败，订阅锁释放通知</span></span><br><span class="line">        <span class="keyword">return</span> subscribeToLockRelease(waitTime, unit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅锁释放频道</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">subscribeToLockRelease</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="type">RTopic</span> <span class="variable">topic</span> <span class="operator">=</span> redisson.getTopic(getChannelName()); <span class="comment">// 频道名：redisson_lock__channel:&#123;lockKey&#125;</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 订阅消息，收到通知后完成future</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">listenerId</span> <span class="operator">=</span> topic.addListener(String.class, (channel, message) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.equals(getLockName())) &#123; <span class="comment">// 验证是当前锁的释放通知</span></span><br><span class="line">            topic.removeListener(listenerId);</span><br><span class="line">            future.complete(<span class="literal">true</span>); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3. 同时设置超时任务，避免无限等待</span></span><br><span class="line">    scheduleTimeout(future, waitTime, unit, listenerId, topic);</span><br><span class="line">    <span class="keyword">return</span> future.thenCompose(ignored -&gt; &#123;</span><br><span class="line">        <span class="comment">// 4. 被唤醒后重新尝试获取锁</span></span><br><span class="line">        <span class="keyword">return</span> tryAcquireAsync(waitTime - usedTime, leaseTime, unit);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-锁释放时的通知逻辑"><a href="#2-锁释放时的通知逻辑" class="headerlink" title="2. 锁释放时的通知逻辑"></a>2. 锁释放时的通知逻辑</h4><p>当持有锁的客户端释放锁时，会通过<code>PUBLISH</code>命令向对应频道发送通知，唤醒所有订阅的等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RedissonLock#unlockAsync简化逻辑</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 释放锁（删除Redis中的锁键）</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; releaseFuture = unlockInnerAsync();</span><br><span class="line">    <span class="keyword">return</span> releaseFuture.thenAccept(released -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (released) &#123;</span><br><span class="line">            <span class="comment">// 2. 发布锁释放通知</span></span><br><span class="line">            <span class="type">RTopic</span> <span class="variable">topic</span> <span class="operator">=</span> redisson.getTopic(getChannelName());</span><br><span class="line">            topic.publish(getLockName()); <span class="comment">// 发送当前锁的标识</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-核心优势总结"><a href="#3-核心优势总结" class="headerlink" title="3. 核心优势总结"></a>3. 核心优势总结</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// 原生tryLock的核心价值</span><br><span class="line">1. 无轮询：等待期间线程阻塞，不消耗CPU资源</span><br><span class="line">2. 精准唤醒：仅当锁释放时才触发重试，响应及时</span><br><span class="line">3. 自动超时：避免因通知丢失导致的无限等待</span><br><span class="line">4. 异步非阻塞：底层基于Netty实现异步操作，性能高效</span><br></pre></td></tr></table></figure><p>基于上述底层逻辑，我们在使用Redisson锁可重试功能时，需重点关注以下参数设计：</p><ul><li><p><code>waitTime</code>：单轮最大等待时间（非固定等待），建议设为业务可接受的单次阻塞时长，如1秒；</p></li><li><p><code>totalWaitTime</code>：业务级总等待时间，通过多轮<code>tryLock</code>累加控制，避免整体超时；</p></li><li><p><code>leaseTime</code>：锁租期，需大于业务执行时间，建议结合<code>lockWatchdogTimeout</code>（看门狗机制）自动续期，避免锁提前释放。</p></li></ul><h2 id="四、Redisson锁可重试实现的注意事项"><a href="#四、Redisson锁可重试实现的注意事项" class="headerlink" title="四、Redisson锁可重试实现的注意事项"></a>四、Redisson锁可重试实现的注意事项</h2><p>在实现Redisson锁的可重试机制时，需要注意以下几点，以确保系统的稳定性和正确性：</p><h3 id="1-合理设置重试参数"><a href="#1-合理设置重试参数" class="headerlink" title="1. 合理设置重试参数"></a>1. 合理设置重试参数</h3><p>重试次数和等待时间需要根据业务场景进行调整：</p><ul><li><p>若业务对响应时间敏感，应减少重试次数和等待时间；</p></li><li><p>若锁竞争激烈或网络不稳定，可适当增加重试次数，并采用指数退避等策略延长等待时间。</p></li></ul><h3 id="2-避免死锁风险"><a href="#2-避免死锁风险" class="headerlink" title="2. 避免死锁风险"></a>2. 避免死锁风险</h3><p>Redisson锁本身具有自动过期机制（<code>leaseTime</code>），可以避免死锁，但在重试过程中仍需注意：</p><ul><li><p>确保每次获取锁后都有对应的释放操作（建议使用<code>try-finally</code>块）；</p></li><li><p>不要在重试过程中持有其他资源，以免重试失败时导致资源泄漏。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 正确的锁释放方式</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> tryLockWithRetry(<span class="string">&quot;testLock&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-考虑Redis集群的一致性"><a href="#3-考虑Redis集群的一致性" class="headerlink" title="3. 考虑Redis集群的一致性"></a>3. 考虑Redis集群的一致性</h3><p>在Redis集群环境下，Redisson锁的实现基于Redis的<code>SET NX</code>命令，若采用主从复制架构，主节点宕机可能导致锁信息未同步到从节点，从而出现“锁丢失”问题。此时可考虑使用Redisson的<code>RedissonRedLock</code>（红锁），它通过在多个独立的Redis节点上获取锁，提高锁的可靠性，但会增加性能开销，需根据业务场景权衡。</p><h3 id="4-监控重试-metrics"><a href="#4-监控重试-metrics" class="headerlink" title="4. 监控重试 metrics"></a>4. 监控重试 metrics</h3><p>在生产环境中，建议对锁的重试情况进行监控，记录重试次数、成功率、失败原因等metrics，以便及时发现问题并调整重试策略。例如，使用Prometheus + Grafana监控重试相关指标。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Redisson锁的可重试机制是应对分布式环境中暂时性问题的有效手段，通过“循环尝试 + 条件判断 + 等待策略”的核心思路，结合手动实现或Spring Retry框架，能够灵活满足不同业务场景的需求。在实际应用中，需合理设置重试参数、避免死锁风险、考虑Redis集群一致性，并加强监控，以确保可重试机制的高效与可靠。</p><p>希望本文的思考能够为大家在使用Redisson锁时提供一些帮助，若有不同的见解或更好的实现方式，欢迎在评论区交流讨论！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中Redisson锁对于可重试的实现方式&quot;&gt;&lt;a href=&quot;#Java中Redisson锁对于可重试的实现方式&quot; class=&quot;headerlink&quot; title=&quot;Java中Redisson锁对于可重试的实现方式&quot;&gt;&lt;/a&gt;Java中Redisson锁</summary>
      
    
    
    
    
    <category term="redis" scheme="https://nmcb666.vip/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>windows11安装docker</title>
    <link href="https://nmcb666.vip/posts/fd5326b3.html"/>
    <id>https://nmcb666.vip/posts/fd5326b3.html</id>
    <published>2025-09-28T14:13:48.000Z</published>
    <updated>2026-01-24T07:56:35.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-11下安装Docker并修改安装位置至非C盘教程"><a href="#Windows-11下安装Docker并修改安装位置至非C盘教程" class="headerlink" title="Windows 11下安装Docker并修改安装位置至非C盘教程"></a>Windows 11下安装Docker并修改安装位置至非C盘教程</h1><h1 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a>一、安装前准备</h1><h2 id="1-1-检查系统要求"><a href="#1-1-检查系统要求" class="headerlink" title="1.1 检查系统要求"></a>1.1 检查系统要求</h2><p>在安装Docker前，需确保Windows 11系统满足以下条件：</p><ul><li><p>系统版本：Windows 11 64位专业版、企业版或教育版（家庭版需通过WSL 2支持）。</p></li><li><p>硬件要求：支持硬件虚拟化技术（VT-x/AMD-V），并在BIOS/UEFI中启用。</p></li><li><p>WSL 2要求：已安装并启用Windows Subsystem for Linux 2，且内核版本更新至最新。</p></li><li><p>存储空间：非C盘预留至少20GB空闲空间（用于Docker安装及镜像存储）。</p></li></ul><h2 id="1-2-启用必要功能"><a href="#1-2-启用必要功能" class="headerlink" title="1.2 启用必要功能"></a>1.2 启用必要功能</h2><p>打开“控制面板”→“程序”→“程序和功能”→“启用或关闭Windows功能”，勾选以下选项并点击“确定”，等待系统配置完成后重启电脑：</p><ul><li><p>Hyper-V（全部组件）</p></li><li><p>容器</p></li><li><p>Windows虚拟机监控程序平台</p></li></ul><p>若为Windows 11家庭版，需先安装WSL 2：以管理员身份打开PowerShell，输入命令 <code>wsl --install</code>，重启电脑后完成WSL 2安装。</p><h1 id="二、下载Docker安装程序"><a href="#二、下载Docker安装程序" class="headerlink" title="二、下载Docker安装程序"></a>二、下载Docker安装程序</h1><p>访问Docker官方网站（<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>），点击“Download for Windows”下载最新版Docker Desktop安装包（.exe文件），保存至非C盘的临时文件夹（如D:\Temp）。</p><h1 id="三、修改安装位置（已有安装程序时）"><a href="#三、修改安装位置（已有安装程序时）" class="headerlink" title="三、修改安装位置（已有安装程序时）"></a>三、修改安装位置（已有安装程序时）</h1><h2 id="3-1-解压安装程序（可选）"><a href="#3-1-解压安装程序（可选）" class="headerlink" title="3.1 解压安装程序（可选）"></a>3.1 解压安装程序（可选）</h2><p>若已下载Docker安装包，可通过以下方式查看安装文件结构（非必需步骤）：</p><ol><li><p>以管理员身份打开PowerShell，切换至安装包所在目录，例如：<code>cd D:\Temp</code>。</p></li><li><p>输入命令解压安装包：<code>Docker Desktop Installer.exe extract --destination D:\DockerTemp</code>，将安装文件提取至D:\DockerTemp文件夹。</p></li></ol><h2 id="3-2-通过命令行指定安装路径"><a href="#3-2-通过命令行指定安装路径" class="headerlink" title="3.2 通过命令行指定安装路径"></a>3.2 通过命令行指定安装路径</h2><p>这是修改Docker安装位置的核心步骤，需通过命令行参数指定非C盘安装目录：</p><ol><li><p>以<strong>管理员身份</strong>打开PowerShell，切换至Docker安装包所在目录（如D:\Temp）。</p></li><li><p>输入以下命令，将安装位置指定为非C盘路径（以D:\Docker为例）：<br><code>.\Docker Desktop Installer.exe install --installation-dir=D:\Docker --windows-containers=false --wsl2=true</code></p></li><li><p>命令参数说明：</p><pre><code> `--installation-dir=D:\Docker`：指定Docker主程序安装目录（非C盘路径）。</code></pre></li><li><p><code>--windows-containers=false</code>：默认启用Linux容器（如需Windows容器可改为true）。</p></li><li><p><code>--wsl2=true</code>：强制使用WSL 2作为容器运行时（推荐）。</p></li><li><p>执行命令后，等待安装进度完成，期间可能会提示重启电脑，点击“确定”即可。</p></li></ol><div class="tip warning faa-horizontal animated-hover"><p>若之前已安装过Docker并默认在C盘，需先卸载旧版本：打开“设置”→“应用”→“应用和功能”，找到“Docker Desktop”，点击“卸载”，并删除残留文件后再执行上述命令。</p></div><h1 id="四、验证安装结果"><a href="#四、验证安装结果" class="headerlink" title="四、验证安装结果"></a>四、验证安装结果</h1><h2 id="4-1-启动Docker-Desktop"><a href="#4-1-启动Docker-Desktop" class="headerlink" title="4.1 启动Docker Desktop"></a>4.1 启动Docker Desktop</h2><p>安装完成后，在开始菜单中找到“Docker Desktop”并启动，首次启动可能需要几分钟时间（初始化WSL 2环境）。启动成功后，任务栏右下角会显示Docker图标（蓝色鲸鱼图标）。</p><h2 id="4-2-检查安装路径"><a href="#4-2-检查安装路径" class="headerlink" title="4.2 检查安装路径"></a>4.2 检查安装路径</h2><p>打开文件资源管理器，导航至之前指定的安装目录（如D:\Docker），可看到Docker的主程序文件及相关组件，确认安装位置正确。</p><h2 id="4-3-测试Docker功能"><a href="#4-3-测试Docker功能" class="headerlink" title="4.3 测试Docker功能"></a>4.3 测试Docker功能</h2><p>以管理员身份打开PowerShell，输入以下命令测试Docker是否正常工作：</p><ol><li><p>查看Docker版本：<code>docker --version</code>，若输出类似“Docker version 26.1.4, build 5650f9b”则说明版本查询正常。</p></li><li><p>运行Hello World镜像：<code>docker run hello-world</code>，若输出“Hello from Docker!”等信息，说明Docker已成功拉取并运行镜像，功能正常。</p></li></ol><h1 id="五、后续配置（可选）"><a href="#五、后续配置（可选）" class="headerlink" title="五、后续配置（可选）"></a>五、后续配置（可选）</h1><h2 id="5-1-修改镜像存储位置"><a href="#5-1-修改镜像存储位置" class="headerlink" title="5.1 修改镜像存储位置"></a>5.1 修改镜像存储位置</h2><p>默认情况下，Docker镜像存储在WSL 2分发版的虚拟磁盘中（通常位于C盘），可通过以下步骤迁移至非C盘：</p><ol><li><p>关闭Docker Desktop：右键任务栏Docker图标，点击“Quit Docker Desktop”。</p></li><li><p>导出WSL 2分发版：在PowerShell中输入<code>wsl --export docker-desktop-data D:\Docker\wsl\data\docker-desktop-data.tar</code>。</p></li><li><p>注销现有分发版：<code>wsl --unregister docker-desktop-data</code>。</p></li><li><p>重新导入分发版至非C盘：<code>wsl --import docker-desktop-data D:\Docker\wsl\data D:\Docker\wsl\data\docker-desktop-data.tar --version 2</code>。</p></li><li><p>重启Docker Desktop，镜像存储位置即迁移至D:\Docker\wsl\data。</p></li></ol><h2 id="5-2-配置国内镜像源"><a href="#5-2-配置国内镜像源" class="headerlink" title="5.2 配置国内镜像源"></a>5.2 配置国内镜像源</h2><p>为加快镜像拉取速度，可配置国内镜像源：打开Docker Desktop，点击“Settings”→“Docker Engine”，在JSON配置中添加镜像源，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.1ms.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker-0.unsee.tech&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>点击“Apply &amp; Restart”保存配置并重启Docker。</p><h1 id="六、常见问题解决"><a href="#六、常见问题解决" class="headerlink" title="六、常见问题解决"></a>六、常见问题解决</h1><ul><li><p><strong>问题1：安装时提示“Hyper-V未启用”</strong>：重新检查“启用或关闭Windows功能”中Hyper-V组件是否全部勾选，若已勾选仍报错，可能是BIOS中虚拟化未启用，需重启电脑进入BIOS开启VT-x/AMD-V。</p></li><li><p><strong>问题2：Docker启动卡在“Starting…”</strong>：关闭Docker后，在PowerShell中输入<code>wsl --shutdown</code>关闭WSL 2，再重新启动Docker。</p></li><li><p><strong>问题3：命令行输入docker命令提示“command not found”</strong>：检查系统环境变量PATH中是否包含Docker安装目录（如D:\Docker\resources\bin），若未包含需手动添加后重启PowerShell。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-11下安装Docker并修改安装位置至非C盘教程&quot;&gt;&lt;a href=&quot;#Windows-11下安装Docker并修改安装位置至非C盘教程&quot; class=&quot;headerlink&quot; title=&quot;Windows 11下安装Docker并修改安装位置至非</summary>
      
    
    
    
    
    <category term="docker" scheme="https://nmcb666.vip/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>关于爬取贴吧的两种网页差异</title>
    <link href="https://nmcb666.vip/posts/cf38f81c.html"/>
    <id>https://nmcb666.vip/posts/cf38f81c.html</id>
    <published>2025-09-19T21:16:00.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度贴吧爬取时两种网页结构的差异"><a href="#百度贴吧爬取时两种网页结构的差异" class="headerlink" title="百度贴吧爬取时两种网页结构的差异"></a>百度贴吧爬取时两种网页结构的差异</h1><p>百度贴吧作为国内极具影响力的中文社区，其海量的用户生成内容（UGC）是进行市场调研、情感分析、热点追踪的宝贵数据资源。但在实际爬取过程中，很多开发者会遇到“明明XPath规则正确却爬不到数据”的问题，其核心原因在于百度贴吧存在两种差异化的前端渲染结构。</p><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h3 id="1-1-贴吧URL结构分析"><a href="#1-1-贴吧URL结构分析" class="headerlink" title="1.1 贴吧URL结构分析"></a>1.1 贴吧URL结构分析</h3><p>贴吧的帖子URL遵循固定格式，掌握后可批量构造爬取链接：</p><ul><li><p><strong>单页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]</code>（默认显示第一页）</p></li><li><p><strong>分页帖子URL</strong>：<code>https://tieba.baidu.com/p/[帖子ID]?pn=[页码]</code>（pn参数指定页码，如pn=2表示第二页）</p></li></ul><p>例如：帖子<code>https://tieba.baidu.com/p/789012345?pn=3</code>表示ID为789012345的帖子的第三页内容。</p><h2 id="二、两种网页结构的深度对比"><a href="#二、两种网页结构的深度对比" class="headerlink" title="二、两种网页结构的深度对比"></a>二、两种网页结构的深度对比</h2><p>通过Chrome开发者工具（F12）查看网页源码，我们发现两种结构的核心差异集中在<strong>帖子内容容器</strong>和<strong>发布时间节点</strong>，以下是具体对比：</p><h3 id="2-1-结构一：传统版（无clearfix后缀）"><a href="#2-1-结构一：传统版（无clearfix后缀）" class="headerlink" title="2.1 结构一：传统版（无clearfix后缀）"></a>2.1 结构一：传统版（无clearfix后缀）</h3><p>通过“检查”功能定位到帖子内容和发布时间节点，其HTML结构如下：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/2.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code></p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#39;)</code><br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//span[@class=&quot;tail-info&quot;]/text()&#39;)[-1] for i in create_time]</code>（取最后一个tail-info的文本）</p></li></ul><h3 id="2-2-结构二：新版（含clearfix后缀）"><a href="#2-2-结构二：新版（含clearfix后缀）" class="headerlink" title="2.2 结构二：新版（含clearfix后缀）"></a>2.2 结构二：新版（含clearfix后缀）</h3><p>其HTML结构调整了class属性和节点层级：</p><p><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/3.png" alt="code"><br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/4.png" alt="code"></p><p>对应的XPath解析规则：</p><ul><li><p>回复内容：<code>content_list = html.xpath(&#39;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#39;)</code><br>之后再循环获取评论内容：<code>content_list = [&#39;&#39;.join(i.xpath(&#39;.//text()&#39;)) for i in content_list]</code>（注意两个空格）</p></li><li><p>发布时间：<code>create_time = html.xpath(&#39;//div/div[@class=&quot;core_reply_tail &quot;]&#39;)</code>（<br>之后再循环获取里面的时间：<code>create_time = [i.xpath(&#39;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#39;)[-1] for i in create_time]</code>取p_tail最后一个li的span文本）</p></li></ul><p><strong>关键提醒</strong>：XPath中class属性的匹配是<strong>精确匹配</strong>，空格和后缀的差异会导致解析失败。在编写规则时，必须完全复制网页源码中的class值。</p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 提取帖子评论数据第一种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content &quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail clearfix&quot;]&#x27;</span>)</span><br><span class="line">create_time = [i.xpath(<span class="string">&#x27;.//span[@class=&quot;tail-info&quot;]/text()&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> create_time]</span><br><span class="line"><span class="comment"># 提取帖子评论数据第二种</span></span><br><span class="line">data_fields = html.xpath(<span class="string">&#x27;//*[@id=&quot;j_p_postlist&quot;]/div/@data-field&#x27;</span>)</span><br><span class="line">author_list = html.xpath(<span class="string">&#x27;//div[@id=&quot;j_p_postlist&quot;]/div/div[@class=&quot;d_author&quot;]/ul/li[@class=&quot;d_name&quot;]/a/text()&#x27;</span>)</span><br><span class="line">content_list = html.xpath(<span class="string">&#x27;//cc/div[@class=&quot;d_post_content j_d_post_content  clearfix&quot;]&#x27;</span>)</span><br><span class="line">content_list = [<span class="string">&#x27;&#x27;</span>.join(i.xpath(<span class="string">&#x27;.//text()&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content_list]</span><br><span class="line">create_time = html.xpath(<span class="string">&#x27;//div/div[@class=&quot;core_reply_tail &quot;]&#x27;</span>)</span><br><span class="line">create_time_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> create_time:</span><br><span class="line">    time_elements = i.xpath(<span class="string">&#x27;.//ul[@class=&quot;p_tail&quot;]/li[last()]/span/text()&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> time_elements:</span><br><span class="line">        create_time_list.append(time_elements[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        create_time_list.append(<span class="string">&#x27;未知&#x27;</span>)</span><br><span class="line">create_time = create_time_list</span><br></pre></td></tr></table></figure><h2 id="四、关于爬取贴吧列表"><a href="#四、关于爬取贴吧列表" class="headerlink" title="四、关于爬取贴吧列表"></a>四、关于爬取贴吧列表</h2><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h3><p>贴吧列表页面如下所示<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/5.png" alt="code"><br>现在我们想要获取列表页的贴子名称，帖子作者，帖子链接，帖子时间<br>原来的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">        title_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@title&#x27;</span>)</span><br><span class="line">        link_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_title pull_left j_th_tit &quot;]/a[1]/@href&#x27;</span>)</span><br><span class="line">        creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot;]/@title&#x27;</span>)</span><br><span class="line">        create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>看上去似乎没有什么问题 ，但是运行代码的时候，发现爬取的帖子有些标题跟时间对不上这会导致一些问题。<br>所以这到底是为什么呢？<br>我们可以打开f12查看网页源代码，查看列表页面的html结构，通过观察可以发现，一些帖子的标题，链接，发帖人的html结构跟大部分还不一样。<br>例如普通的标题页面结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/6.png" alt="code"><br>但是某些帖子标题的html结构如下：<br><img src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/7.png" alt="code"><br>可以发现少部分贴子的标题比普通的多了member_thread_title_frs 这一段文字 导致获取不到一些帖子标题，所以也就造成了之后的时间不一致的问题。</p><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><p>解决方法很简单只需要在多匹配那少部分的内容即可。<br>可以把原来的正则表达式替换为<code>//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title</code>。<br>这样就能匹配只要有threadlist_title pull_left j_th_tit 的内容了。<br>但是注意这里的作者名称，一个帖子会有两个作者名称。第一个是帖子作者，第二个是最后评论的人的名称。这里我们只需要获取第一个作者名称即可。<br>于是关于作者名称的正则表达式用or即可。<br>修改的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取标题、链接、发帖人和时间</span></span><br><span class="line">title_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@title&#x27;</span>)</span><br><span class="line">link_list = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;threadlist_title&quot;) and contains(@class,&quot;j_th_tit&quot;)]/a[1]/@href&#x27;</span>)</span><br><span class="line"><span class="comment"># 修改后的作者匹配规则，只匹配指定的两种形式</span></span><br><span class="line">creator_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;tb_icon_author &quot; or @class=&quot;tb_icon_author no_icon_author&quot;]/@title&#x27;</span>)</span><br><span class="line">create_time_list = html.xpath(<span class="string">&#x27;//div[@class=&quot;threadlist_author pull_right&quot;]/span[@class=&quot;pull-right is_show_create_time&quot;]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><br>这样修改之后就可以匹配到正确的完整的数据了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度贴吧爬取时两种网页结构的差异&quot;&gt;&lt;a href=&quot;#百度贴吧爬取时两种网页结构的差异&quot; class=&quot;headerlink&quot; title=&quot;百度贴吧爬取时两种网页结构的差异&quot;&gt;&lt;/a&gt;百度贴吧爬取时两种网页结构的差异&lt;/h1&gt;&lt;p&gt;百度贴吧作为国内极具影响力的</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://nmcb666.vip/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬取微博移动端评论</title>
    <link href="https://nmcb666.vip/posts/eb47d163.html"/>
    <id>https://nmcb666.vip/posts/eb47d163.html</id>
    <published>2025-09-19T16:58:21.000Z</published>
    <updated>2026-01-24T07:56:35.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬取微博移动端评论完整教程（基础-常见问题）"><a href="#Python爬取微博移动端评论完整教程（基础-常见问题）" class="headerlink" title="Python爬取微博移动端评论完整教程（基础+常见问题）"></a>Python爬取微博移动端评论完整教程（基础+常见问题）</h1><p>在数据采集领域，微博作为国内主流的社交媒体平台，其评论数据蕴含着丰富的用户观点和舆论倾向。相较于PC端，微博移动端接口更简洁、反爬措施相对宽松，是获取评论数据的优选方案。本文将以<strong>Python</strong>为工具，从环境搭建到代码实现，手把手教你爬取微博移动端评论，并解答过程中可能遇到的常见问题。</p><hr><h2 id="一、基础教程：从零实现微博评论爬取"><a href="#一、基础教程：从零实现微博评论爬取" class="headerlink" title="一、基础教程：从零实现微博评论爬取"></a>一、基础教程：从零实现微博评论爬取</h2><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><p>首先需要搭建Python爬虫环境，核心依赖库如下：</p><ul><li><p><strong>requests</strong>：发送HTTP请求，获取接口数据</p></li><li><p><strong>json</strong>：解析接口返回的JSON数据（Python内置，无需安装）</p></li><li><p><strong>pandas</strong>：数据存储与导出（可选，用于生成Excel文件）</p></li><li><p><strong>time</strong>：设置请求间隔，避免被反爬（Python内置）</p></li></ul><p>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install requests pandas</span><br></pre></td></tr></table></figure><h3 id="1-2-核心原理：找到评论接口"><a href="#1-2-核心原理：找到评论接口" class="headerlink" title="1.2 核心原理：找到评论接口"></a>1.2 核心原理：找到评论接口</h3><p>微博移动端评论通过AJAX异步加载，我们需要先找到真实的评论接口。步骤如下：</p><ol><li><p>打开手机浏览器（或电脑浏览器切换到<strong>移动端模式</strong>），登录微博账号，找到目标微博（例如：<a href="https://m.weibo.cn/detail/4900000000000000">https://m.weibo.cn/detail/4900000000000000</a>）</p></li><li><p>按F12打开开发者工具，切换到<strong>Network</strong>标签，勾选<strong>XHR</strong>（筛选AJAX请求）</p></li><li><p>下拉页面加载评论，此时会看到名为<strong>comment</strong>的请求，点击该请求查看详情</p></li><li><p>在<strong>Request URL</strong>中可以看到评论接口地址，在<strong>Response</strong>中可以看到JSON格式的评论数据</p></li></ol><div class="note primary modern"><p>典型的微博评论接口格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://m.weibo.cn/comments/hotflow?id=微博ID&amp;mid=微博ID&amp;max_id=下一页标识&amp;max_id_type=0</span><br></pre></td></tr></table></figure></div><p>参数说明：</p><ul><li><p><strong>id/mid</strong>：目标微博的ID（从微博详情页URL中获取，例如URL末尾的数字串）</p></li><li><p><strong>max_id</strong>：分页标识，初始为0，后续页面的max_id从当前响应中获取</p></li><li><p><strong>max_id_type</strong>：固定为0即可</p></li></ul><h3 id="1-3-代码实现步骤"><a href="#1-3-代码实现步骤" class="headerlink" title="1.3 代码实现步骤"></a>1.3 代码实现步骤</h3><h4 id="步骤1：获取请求头（Headers）"><a href="#步骤1：获取请求头（Headers）" class="headerlink" title="步骤1：获取请求头（Headers）"></a>步骤1：获取请求头（Headers）</h4><p>为了模拟真实用户请求，需要在请求中添加Headers，核心参数包括<strong>User-Agent</strong>和<strong>Cookie</strong>：</p><ul><li><p><strong>User-Agent</strong>：标识浏览器类型，移动端UA示例：<code>Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1</code></p></li><li><p><strong>Cookie</strong>：包含登录状态信息，从浏览器开发者工具的Request Headers中复制（登录后才能获取更多评论）</p></li></ul><h4 id="步骤2：发送请求并解析数据"><a href="#步骤2：发送请求并解析数据" class="headerlink" title="步骤2：发送请求并解析数据"></a>步骤2：发送请求并解析数据</h4><p>编写代码发送GET请求，解析JSON响应中的评论内容（用户名、评论时间、评论内容等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置信息</span></span><br><span class="line">weibo_id = <span class="string">&quot;4900000000000000&quot;</span>  <span class="comment"># 目标微博ID</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;你的Cookie信息&quot;</span>  <span class="comment"># 替换为自己的Cookie</span></span><br><span class="line">&#125;</span><br><span class="line">comments = []  <span class="comment"># 存储评论数据</span></span><br><span class="line">max_id = <span class="number">0</span>  <span class="comment"># 初始分页标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 构建请求URL</span></span><br><span class="line">    url = <span class="string">f&quot;https://m.weibo.cn/comments/hotflow?id=<span class="subst">&#123;weibo_id&#125;</span>&amp;mid=<span class="subst">&#123;weibo_id&#125;</span>&amp;max_id=<span class="subst">&#123;max_id&#125;</span>&amp;max_id_type=0&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">        response.raise_for_status()  <span class="comment"># 若状态码不是200，抛出异常</span></span><br><span class="line">        data = json.loads(response.text)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取评论列表</span></span><br><span class="line">        comment_list = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;data&quot;</span>, [])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> comment_list:  <span class="comment"># 没有更多评论时退出循环</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已获取所有评论&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解析每条评论</span></span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> comment_list:</span><br><span class="line">            item = &#123;</span><br><span class="line">                <span class="string">&quot;用户名&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;screen_name&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;用户ID&quot;</span>: comment.get(<span class="string">&quot;user&quot;</span>, &#123;&#125;).get(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论时间&quot;</span>: comment.get(<span class="string">&quot;created_at&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;评论内容&quot;</span>: comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;点赞数&quot;</span>: comment.get(<span class="string">&quot;like_count&quot;</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="string">&quot;回复数&quot;</span>: comment.get(<span class="string">&quot;reply_count&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            comments.append(item)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;已获取<span class="subst">&#123;<span class="built_in">len</span>(comments)&#125;</span>条评论&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新下一页的max_id</span></span><br><span class="line">        max_id = data.get(<span class="string">&quot;data&quot;</span>, &#123;&#125;).get(<span class="string">&quot;max_id&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> max_id == <span class="number">0</span>:  <span class="comment"># 没有下一页时退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置请求间隔，避免被封IP</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;请求出错：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="步骤3：数据存储"><a href="#步骤3：数据存储" class="headerlink" title="步骤3：数据存储"></a>步骤3：数据存储</h4><p>将爬取到的评论数据导出为Excel文件，方便后续分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 转换为DataFrame并导出</span></span><br><span class="line">df = pd.DataFrame(comments)</span><br><span class="line">df.to_excel(<span class="string">&quot;微博评论.xlsx&quot;</span>, index=<span class="literal">False</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;评论数据已保存到微博评论.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="二、常见问题及解决方案"><a href="#二、常见问题及解决方案" class="headerlink" title="二、常见问题及解决方案"></a>二、常见问题及解决方案</h2><h3 id="2-1-问题1：请求返回403-401错误"><a href="#2-1-问题1：请求返回403-401错误" class="headerlink" title="2.1 问题1：请求返回403/401错误"></a>2.1 问题1：请求返回403/401错误</h3><p><strong>原因</strong>：Headers参数不完整或Cookie失效，服务器识别为爬虫请求。</p><p><strong>解决方案</strong>：</p><ul><li><p>检查Cookie是否正确，重新登录微博后复制最新的Cookie</p></li><li><p>补充Headers中的其他参数（如<strong>Referer</strong>：设置为目标微博详情页URL）</p></li><li><p>确保User-Agent是移动端格式，避免使用PC端UA</p></li></ul><h3 id="2-2-问题2：只能爬取前20条评论"><a href="#2-2-问题2：只能爬取前20条评论" class="headerlink" title="2.2 问题2：只能爬取前20条评论"></a>2.2 问题2：只能爬取前20条评论</h3><p><strong>原因</strong>：未正确处理分页参数max_id，或未登录导致只能获取公开评论。</p><p><strong>解决方案</strong>：</p><ul><li><p>确保登录状态（Cookie有效），登录后可获取更多评论</p></li><li><p>检查max_id是否正确从响应中提取，避免手动设置固定值</p></li><li><p>部分微博可能限制评论查看权限，属于正常情况</p></li></ul><h3 id="2-3-问题3：IP被封禁，无法发送请求"><a href="#2-3-问题3：IP被封禁，无法发送请求" class="headerlink" title="2.3 问题3：IP被封禁，无法发送请求"></a>2.3 问题3：IP被封禁，无法发送请求</h3><p><strong>原因</strong>：请求频率过高，触发微博反爬机制。</p><p><strong>解决方案</strong>：</p><ul><li><p>增加请求间隔时间（如time.sleep(3-5秒)），避免高频请求</p></li><li><p>使用代理IP池，轮换IP地址发送请求（推荐使用高匿代理）</p></li><li><p>暂停爬取1-2小时，IP封禁通常是临时的</p></li></ul><h3 id="2-4-问题4：评论内容含HTML标签"><a href="#2-4-问题4：评论内容含HTML标签" class="headerlink" title="2.4 问题4：评论内容含HTML标签"></a>2.4 问题4：评论内容含HTML标签</h3><p><strong>原因</strong>：接口返回的text字段包含HTML格式（如表情、话题链接等）。</p><p><strong>解决方案</strong>：使用<strong>BeautifulSoup</strong>清理HTML标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理评论内容中的HTML标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_html</span>(<span class="params">text</span>):</span><br><span class="line">    soup = BeautifulSoup(text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> soup.get_text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在解析评论时调用</span></span><br><span class="line"><span class="string">&quot;评论内容&quot;</span>: clean_html(comment.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>)),</span><br></pre></td></tr></table></figure><h3 id="2-5-问题5：响应数据格式异常"><a href="#2-5-问题5：响应数据格式异常" class="headerlink" title="2.5 问题5：响应数据格式异常"></a>2.5 问题5：响应数据格式异常</h3><p><strong>原因</strong>：接口参数变化或微博更新反爬策略。</p><p><strong>解决方案</strong>：</p><ul><li><p>重新通过浏览器开发者工具抓取最新的评论接口，确认参数是否变化</p></li><li><p>打印response.text查看原始响应，分析数据格式是否与预期一致</p></li><li><p>关注微博接口的官方变化（若有），及时调整代码</p></li></ul><h3 id="2-6-问题6：请求第一页之后的数据响应ok-0"><a href="#2-6-问题6：请求第一页之后的数据响应ok-0" class="headerlink" title="2.6 问题6：请求第一页之后的数据响应ok{0}"></a>2.6 问题6：请求第一页之后的数据响应ok{0}</h3><p><strong>原因</strong>：请求的Cookie已失效，需要重新登录获取Cookie。(因为微博需要登录才能查看更多评论)</p><p><strong>解决方案</strong>：</p><ul><li>登录微博账号，打开浏览器开发者工具，选择Network选项卡，点击刷新按钮。</li><li>在Network选项卡中，找到对应的请求，查看响应头，找到Cookie字段，复制Cookie值。</li><li>将Cookie值替换为配置文件中的Cookie字段。</li><li>重新运行代码，即可获取最新数据。</li></ul><hr><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ul><li><p><strong>合规性</strong>：爬取微博数据需遵守《微博服务使用协议》，不得用于商业用途或恶意攻击，建议仅用于个人学习研究</p></li><li><p><strong>登录状态</strong>：尽量使用小号登录，避免主号因爬虫行为被限制</p></li><li><p><strong>请求频率</strong>：保持低调，避免短时间内发送大量请求，友好对待服务器</p></li><li><p><strong>数据备份</strong>：定期保存爬取到的数据，防止程序异常导致数据丢失</p></li></ul><p>通过以上步骤，你可以成功爬取微博移动端评论数据。如果遇到其他问题，欢迎在评论区留言交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python爬取微博移动端评论完整教程（基础-常见问题）&quot;&gt;&lt;a href=&quot;#Python爬取微博移动端评论完整教程（基础-常见问题）&quot; class=&quot;headerlink&quot; title=&quot;Python爬取微博移动端评论完整教程（基础+常见问题）&quot;&gt;&lt;/a&gt;Py</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://nmcb666.vip/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
