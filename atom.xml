<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2026-01-28T18:22:02.283Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java实现基于raft算法的kv存储系统</title>
    <link href="https://nmcb666.vip/posts/6eb88918.html"/>
    <id>https://nmcb666.vip/posts/6eb88918.html</id>
    <published>2026-01-29T02:02:09.000Z</published>
    <updated>2026-01-28T18:22:02.283Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇偏raft实现的博客。内容按照Raft协议的生命周期（选主、日志复制、安全性、一致性读）进行了论述，同时着重突出了我在<strong>并发模型优化</strong>（CompletableFuture）和<strong>一致性细节</strong>（幽灵复现解决、线性一致性读）上的实现思路。</p><hr><h1 id="Java手写Raft篇：核心流程与并发模型优化实战"><a href="#Java手写Raft篇：核心流程与并发模型优化实战" class="headerlink" title="Java手写Raft篇：核心流程与并发模型优化实战"></a>Java手写Raft篇：核心流程与并发模型优化实战</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Raft 算法作为分布式一致性协议的标准解法，以其清晰的模块化设计著称。本文将基于我亲手实现的 Java 版本 Raft KV 存储系统，深入剖析其中的核心机制。从选主逻辑、日志复制的细节，到解决“幽灵复现”问题的 No-Op 日志，再到利用 <code>CompletableFuture</code> 对并发模型的重构，以此记录从 0 到 1 构建高可用系统的思考过程。</p><hr><h2 id="一、-选举机制-Leader-Election"><a href="#一、-选举机制-Leader-Election" class="headerlink" title="一、 选举机制 (Leader Election)"></a>一、 选举机制 (Leader Election)</h2><p>选主是集群启动或 Leader 宕机后的首要任务。在此阶段，不仅要保证票数过半，更要严格校验节点资格。</p><h3 id="1-状态流转与拉票"><a href="#1-状态流转与拉票" class="headerlink" title="1. 状态流转与拉票"></a>1. 状态流转与拉票</h3><p>当 Follower 的心跳倒计时结束（在一定范围内随机时间，避免同时存在多个候选人导致效率下降）仍未收到 Leader 消息时，将触发选举流程（对应逻辑点 7）：</p><ul><li><strong>自增任期</strong>：将 <code>term + 1</code>，并将状态流转为 Candidate。</li><li><strong>给自己投票</strong>：先投自己一票，避免 split vote。</li><li><strong>广播请求</strong>：向所有节点发起拉票请求，请求中必须携带 <code>lastLogTerm</code> 和 <code>lastLogIndex</code>，以便其他节点校验“日志是否足够新”。</li></ul><h3 id="2-投票方逻辑与并发控制"><a href="#2-投票方逻辑与并发控制" class="headerlink" title="2. 投票方逻辑与并发控制"></a>2. 投票方逻辑与并发控制</h3><p>节点收到投票请求时的处理逻辑非常关键（对应逻辑点 1）：</p><ul><li><strong>Term 更新</strong>：如果请求中的 Term 大于自身，需将之前的投票记录（votedFor）置空，防止因持有旧锁导致无法投票。</li><li><strong>加锁防重</strong>：整个投票判断过程需要上锁，避免高并发下的重复投票。</li><li><strong>资格校验</strong>：只有当请求者的 Term &gt;= 自身 Term，且日志比自己新（Log Completeness），且自己在本任期未投过票时，才予以投票。</li><li><strong>收尾</strong>：更新本地 Term 和投票信息，释放锁。</li></ul><h3 id="3-异步并发模型的优化（亮点）"><a href="#3-异步并发模型的优化（亮点）" class="headerlink" title="3. 异步并发模型的优化（亮点）"></a>3. 异步并发模型的优化（亮点）</h3><p>在实现拉票请求时，我对并发模型进行了重构（对应逻辑点 8）：</p><ul><li><strong>旧方案</strong>：<code>线程池 + Future + CountDownLatch</code>。<code>Future.get()</code> 会阻塞调用线程，且 CountDownLatch 代码冗余。</li><li><strong>新方案</strong>：<code>CompletableFuture + 线程池</code>。<ul><li>使用 <code>List&lt;CompletableFuture&lt;&gt;&gt;</code> 保存所有 RPC 请求。</li><li>利用 <code>CompletableFuture.allOf(...)</code> 实现多线程的非阻塞同步。</li><li>配合 <code>AtomicInteger</code> 记录获胜票数，线程安全且代码更优雅。</li></ul></li></ul><hr><h2 id="二、-日志复制与心跳-Log-Replication-amp-Heartbeat"><a href="#二、-日志复制与心跳-Log-Replication-amp-Heartbeat" class="headerlink" title="二、 日志复制与心跳 (Log Replication &amp; Heartbeat)"></a>二、 日志复制与心跳 (Log Replication &amp; Heartbeat)</h2><p>Leader 确立后，进入正常的日志同步阶段。</p><h3 id="1-心跳与日志同步的合并"><a href="#1-心跳与日志同步的合并" class="headerlink" title="1. 心跳与日志同步的合并"></a>1. 心跳与日志同步的合并</h3><p>为了简化逻辑，我将“同步日志”与“发送心跳”合并处理（对应逻辑点 4）：</p><ul><li>Leader 周期性遍历所有 Follower。</li><li><strong>判断同步需求</strong>：检查 <code>Leader.lastIndex &gt;= Follower.nextIndex</code>。<ul><li>如果满足，说明有新日志，发送从 <code>nextIndex</code> 开始的日志条目。</li><li>如果不满足，说明日志已经同步，仅发送空的心跳包保活。</li></ul></li></ul><h3 id="2-批量发送与回溯"><a href="#2-批量发送与回溯" class="headerlink" title="2. 批量发送与回溯"></a>2. 批量发送与回溯</h3><ul><li><strong>批量优化</strong>：发送日志时，会把从 <code>nextIndex</code> 到 Leader <code>lastIndex</code> 的所有日志打包发送（对应逻辑点 6）。Follower 匹配成功后可批量写入，极大提升同步吞吐。</li><li><strong>失败回溯</strong>：发送请求会携带 <code>prevLogTerm</code> 和 <code>prevLogIndex</code>（对应逻辑点 5）。如果 Follower 返回失败（日志不匹配或 Leader Term 过旧）：<ul><li>Leader 将该 Follower 的 <code>nextIndex</code> 减一。</li><li>下次心跳时重试前一条日志，直到找到匹配点（MatchIndex）。</li></ul></li></ul><h3 id="3-Follower-的处理逻辑"><a href="#3-Follower-的处理逻辑" class="headerlink" title="3. Follower 的处理逻辑"></a>3. Follower 的处理逻辑</h3><p>Follower 在接收端的处理也做了细致的锁管理（对应逻辑点 2、3）：</p><ul><li><strong>日志写入</strong>：收到日志后严格校验匹配性。匹配成功则<strong>加锁</strong>写入本地日志。</li><li><strong>心跳处理</strong>：收到心跳时，若 Leader Term 小于自己，则拒绝并告知对方退位。若 Term 合法，重置选举超时，转为 Follower（因为自己之前可能是候选人，或者分区之后又合区的老leader）。</li><li><strong>异步应用 (Async Apply)</strong>：<ul><li>心跳包中包含 Leader 的 <code>commitIndex</code>。</li><li>Follower 取 <code>min(leaderCommit, lastLogIndex)</code> 作为本地提交点。</li><li><strong>优化点</strong>：写入本地日志后，或者更新 commitIndex 后，采用<strong>异步方式</strong>将日志应用（Apply）到状态机，避免阻塞 IO 线程，提升效率。</li></ul></li></ul><hr><h2 id="三、-CommitIndex-的计算与安全性"><a href="#三、-CommitIndex-的计算与安全性" class="headerlink" title="三、 CommitIndex 的计算与安全性"></a>三、 CommitIndex 的计算与安全性</h2><p>如何确定一条日志可以被安全提交？</p><h3 id="1-基于中位数的-CommitIndex-计算"><a href="#1-基于中位数的-CommitIndex-计算" class="headerlink" title="1. 基于中位数的 CommitIndex 计算"></a>1. 基于中位数的 CommitIndex 计算</h3><p>不再简单依赖单次 RPC 的成功率，而是基于全局视图：</p><ul><li>在每次心跳/日志发送完成（<code>CompletableFuture.allOf</code> 结束）后，统计所有节点的 <code>matchIndex</code>。</li><li><strong>求中位数</strong>：通过排序或统计算法，找出超过半数节点都拥有的最大索引值。</li><li><strong>任期检查</strong>：Raft 规定只能提交当前任期的日志。因此，计算出的索引对应的日志 term 必须等于 <code>currentTerm</code> 才能更新 <code>commitIndex</code>。</li></ul><h3 id="2-解决“幽灵复现”：No-Op-Log"><a href="#2-解决“幽灵复现”：No-Op-Log" class="headerlink" title="2. 解决“幽灵复现”：No-Op Log"></a>2. 解决“幽灵复现”：No-Op Log</h3><p>针对“只能提交当前任期日志”导致旧日志可能无法及时提交的问题（如果允许提交可能会导致同一个位置的日志重复提交），采用了<strong>插入空日志</strong>策略（对应逻辑点 10）：</p><ul><li>新 Leader 上任后，立即append一条空日志（No-Op Log）。</li><li>一旦这条当前任期的空日志被提交，根据日志连续性原则，之前所有未提交的旧日志也会被间接提交。</li><li>初始化：新 Leader 将所有 Follower 的 <code>nextIndex</code> 初始化为 <code>lastIndex + 1</code>，利用后续的心跳回溯机制自动对其。</li></ul><hr><h2 id="四、-线性一致性读-Linearizable-Read"><a href="#四、-线性一致性读-Linearizable-Read" class="headerlink" title="四、 线性一致性读 (Linearizable Read)"></a>四、 线性一致性读 (Linearizable Read)</h2><p>为了防止读取到旧数据（Stale Read），实现了 Follower Read 和 Leader Read（对应逻辑点 12）。</p><ul><li><strong>Leader Read</strong>：Leader 收到读请求后，不能直接返回。需先广播一轮心跳（同样使用 <code>CompletableFuture</code> 机制），确认自己仍持有过半数选票（未发生脑裂）。确认成功后，等待状态机应用到 <code>commitIndex</code> 后返回结果。</li><li><strong>Follower Read</strong>：<ol><li>Follower 收到读请求，向 Leader 发送 <code>ReadIndex</code> RPC。</li><li>Leader 收到后，执行上述“确认领导权”流程，返回当前的 <code>commitIndex</code>。</li><li>Follower 拿到 <code>commitIndex</code> 后，等待本地 <code>appliedIndex &gt;= commitIndex</code>，再将数据返回给客户端。</li></ol></li></ul><hr><h2 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇偏raft实现的博客。内容按照Raft协议的生命周期（选主、日志复制、安全性、一致性读）进行了论述，同时着重突出了我在&lt;strong&gt;并发模型优化&lt;/strong&gt;（CompletableFuture）和&lt;strong&gt;一致性细节&lt;/strong&gt;（幽灵复现解决、线</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（九） 二分</title>
    <link href="https://nmcb666.vip/posts/14894eda.html"/>
    <id>https://nmcb666.vip/posts/14894eda.html</id>
    <published>2026-01-28T16:23:15.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="狒狒吃香蕉"><a href="#狒狒吃香蕉" class="headerlink" title="狒狒吃香蕉"></a>狒狒吃香蕉</h2><p>思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计答案，右侧二分寻找更大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : piles) &#123;</span><br><span class="line">        r = Math.max(r,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(fMinEatingSpeed(piles,mid) &lt;= h)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">fMinEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles,<span class="type">int</span> speed)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">        cnt += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割数组最大值"><a href="#分割数组最大值" class="headerlink" title="分割数组最大值"></a>分割数组最大值</h2><p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。</p><p>返回分割后最小的和的最大值。</p><p>子数组 是数组中连续的部份。</p><p>思路： 对答案进行二分，答案范围为[0,sum(nums)]。f函数为当最小值为limit的时候，我需要的最小划分数。如果这个最小划分数&lt;=k,则记录答案，并且去左侧二分，寻找更小的答案。反之，则去右侧二分，不记录答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0,sum]二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = sum, m, need; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// 中点m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 必须让数组每一部分的累加和 &lt;= m，请问划分成几个部分才够!</span></span><br><span class="line">need = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (need &lt;= k) &#123;</span><br><span class="line"><span class="comment">// 达标</span></span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须让数组arr每一部分的累加和 &lt;= limit，请问划分成几个部分才够!</span></span><br><span class="line"><span class="comment">// 返回需要的部分数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">parts</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &gt; limit) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum + num &gt; limit) &#123;</span><br><span class="line">parts++;</span><br><span class="line">sum = num;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出第k小的数对距离"><a href="#找出第k小的数对距离" class="headerlink" title="找出第k小的数对距离"></a>找出第k小的数对距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0, 最大-最小]，不停二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>], m, cnt; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// m中点，arr中任意两数的差值 &lt;= m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回数字对的数量</span></span><br><span class="line">cnt = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr中任意两数的差值 &lt;= limit</span></span><br><span class="line"><span class="comment">// 这样的数字配对，有几对？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line"><span class="comment">// l......r r+1</span></span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; arr.length &amp;&amp; arr[r + <span class="number">1</span>] - arr[l] &lt;= limit) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[l...r]范围上的数差值的绝对值都不超过limit</span></span><br><span class="line"><span class="comment">// arr[0...3]</span></span><br><span class="line"><span class="comment">// 0,1</span></span><br><span class="line"><span class="comment">// 0,2</span></span><br><span class="line"><span class="comment">// 0,3</span></span><br><span class="line">ans += r - l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同时运行n台电脑的最长时间"><a href="#同时运行n台电脑的最长时间" class="headerlink" title="同时运行n台电脑的最长时间"></a>同时运行n台电脑的最长时间</h2><p>leelcode2141</p><p>你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。</p><p>一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p><p>注意，你不能给电池充电。</p><p>请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</p><p>思路：还是二分答案。答案范围是[0,sum(batteries)]。f函数为当运行时间为m的时候，我能运行的最多电脑数量。如果这个数量大于等于规定的数量，那么我记录mid,然后去右边二分，寻找更长的时间。反之，不计入答案，去左侧二分。 还有一个贪心优化，可以减少二分的次数。详见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> batteries.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            r+=batteries[i];</span><br><span class="line">            max= Math.max(max,batteries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r&gt; (<span class="type">long</span>) max * n) &#123;</span><br><span class="line">            <span class="comment">// 所有电池的最大电量是max</span></span><br><span class="line">            <span class="comment">// 如果此时sum &gt; (long) max * n，</span></span><br><span class="line">            <span class="comment">// 说明 : 最终的供电时间一定在 &gt;= max，而如果最终的供电时间 &gt;= max</span></span><br><span class="line">            <span class="comment">// 说明 : 对于最终的答案X来说，所有电池都是课上讲的&quot;碎片拼接&quot;的概念</span></span><br><span class="line">            <span class="comment">// 那么寻找 ? * n &lt;= sum 的情况中，尽量大的 ? 即可</span></span><br><span class="line">            <span class="comment">// 即sum / n</span></span><br><span class="line">            <span class="keyword">return</span> r / n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        r = max;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f(batteries,mid);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= n )&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] batteries,<span class="type">long</span> maxTime)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxTime == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">litterTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;batteries.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(batteries[i]&lt;maxTime)&#123;</span><br><span class="line">                litterTime+=batteries[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="type">int</span>) (litterTime/maxTime);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二分总结"><a href="#二分总结" class="headerlink" title="二分总结"></a>二分总结</h1><p>二分答案法，其实都可以看成给了三个变量，数组，限制以及答案。正向推导需要我们根据数组以及限制得到答案。但现在根据二分答案法，我们可以先把答案确定下来，然后算出一个跟限制相关的东西，把这个东西跟原限制作比较（这里就观察单调性），来判断下一步应该去哪边找答案。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-28%20212134.png" alt="总结"/></div><span class="image-caption">总结</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;狒狒吃香蕉&quot;&gt;&lt;a href=&quot;#狒狒吃香蕉&quot; class=&quot;headerlink&quot; title=&quot;狒狒吃香蕉&quot;&gt;&lt;/a&gt;狒狒吃香蕉&lt;/h2&gt;&lt;p&gt;思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（八）双指针</title>
    <link href="https://nmcb666.vip/posts/6fd57b4.html"/>
    <id>https://nmcb666.vip/posts/6fd57b4.html</id>
    <published>2026-01-27T16:04:39.000Z</published>
    <updated>2026-01-28T18:22:02.286Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-27%20160658.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="寻找重复数-leetcode-hot100-最后一题"><a href="#寻找重复数-leetcode-hot100-最后一题" class="headerlink" title="寻找重复数 leetcode hot100 最后一题"></a>寻找重复数 leetcode hot100 最后一题</h2><p>思路：当成链表找环处理。每到一个位置i 那下一次就到arr[i]对应的位置。显然入环节点就是重复的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kuai</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">man</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        kuai = nums[nums[kuai]];</span><br><span class="line">        man = nums[man];</span><br><span class="line">        <span class="keyword">if</span>(kuai == man)&#123;</span><br><span class="line">            kuai = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(kuai != man)&#123;</span><br><span class="line">                kuai = nums[kuai];</span><br><span class="line">                man = nums[man];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kuai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>思路：初始版，类似与前缀和跟后缀和，我开两个数组记录i左边的最大值和右边的最大值，然后求出当前位置能接的雨水。sum+=Math.max(0,Math.min(left[i],right[i])-nums[i])</p><p>优化: 双指针思路，左右两边各一个指针。并且维护两个变量记录，左指针左边的最大值和右指针右边的最大值。对于左指针来说左边的最大值肯定是确定的，右指针同理。所以只需要判断两边谁的最大值更小，那么这一边就可以结算了，并且移动指针，更新最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">1</span>,r=height.length-<span class="number">2</span>,lmax = height[<span class="number">0</span>],rmax = height[height.length-<span class="number">1</span>],sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lmax&gt;=rmax)&#123;</span><br><span class="line">            <span class="comment">//结算右边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,rmax-height[r]);</span><br><span class="line">            rmax = Math.max(rmax,height[r--]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//结算左边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,lmax-height[l]);</span><br><span class="line">            lmax= Math.max(lmax,height[l++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="胖娃坐船"><a href="#胖娃坐船" class="headerlink" title="胖娃坐船"></a>胖娃坐船</h2><p>给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回 承载所有人所需的最小船数 。</p><p>思路：排序，然后双指针，一个指针指向最轻的，一个指针指向最重的，如果最轻的+最重的&lt;=limit，那么可以一起载，两个指针同时移动，ans++。否则，最重的指针移动,ans++。即胖子自己一个船。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    Arrays.sort(people);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>people.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[r]+people[l] &lt;= limit)&#123;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种：如果要求两个的体重加起来等于偶数呢？ 很简单，分为奇偶两个数组，然后分别处理，把两个结果加起来即可。</p><h2 id="供暖器"><a href="#供暖器" class="headerlink" title="供暖器"></a>供暖器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">    Arrays.sort(houses);</span><br><span class="line">    Arrays.sort(heaters);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">heaterIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> house : houses) &#123;</span><br><span class="line">        <span class="comment">// 找到离当前房屋最近的加热器</span></span><br><span class="line">        <span class="keyword">while</span> (heaterIndex &lt; heaters.length - <span class="number">1</span> &amp;&amp; </span><br><span class="line">               Math.abs(heaters[heaterIndex] - house) &gt;= </span><br><span class="line">               Math.abs(heaters[heaterIndex + <span class="number">1</span>] - house)) &#123;</span><br><span class="line">            heaterIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(result, Math.abs(heaters[heaterIndex] - house));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><p>思路：我现在就想让每个位置都对应，即i位置上放的就是i+1。此时，我维护两个指针，l的左边是满足我这个条件的，r的右边是肯定不满足的垃圾。初始化l=0,r=n。</p><p>现在开始遍历：每次都观察l位置上的是否满足，如果满足那就l++。如果不满足判断它是不是我需要的，即它在不在当前l到r范围内（因为小于l的已经就位了，不需要你，大于r的已经超过了，不需要你）。关于为什么大于r就算超过这里解释一下。因为理想状态下我数组长度为n那么我就有1-n这些数，但一旦一个数不满足（r—），那我肯定到不了n了,最大就是r。还有一种情况，现在我需要你，但是在num[num[l]-1] 已经有一个相同的你了，说明你重复了。所以也会被当成垃圾。以上三种情况会被当成垃圾，跟—r位置交换。剩下最后一种情况，你是我需要的而且你还没到应该到的位置，于是我把你交换到对应的位置。下次循环，继续看i位置的数。 直到l&lt;r。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n)，额外空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="comment">// l的左边，都是做到i位置上放着i+1的区域</span></span><br><span class="line"><span class="comment">// 永远盯着l位置的数字看，看能不能扩充(l++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [r....]垃圾区</span></span><br><span class="line"><span class="comment">// 最好的状况下，认为1~r是可以收集全的，每个数字收集1个，不能有垃圾</span></span><br><span class="line"><span class="comment">// 有垃圾呢？预期就会变差(r--)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] == l + <span class="number">1</span>) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]) &#123;</span><br><span class="line">swap(arr, l, --r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, l, arr[l] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img&quot; src=&quot;https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（七） 滑动窗口</title>
    <link href="https://nmcb666.vip/posts/aad8ff6.html"/>
    <id>https://nmcb666.vip/posts/aad8ff6.html</id>
    <published>2026-01-26T16:59:21.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="累加和大于等于k的最小长度子数组"><a href="#累加和大于等于k的最小长度子数组" class="headerlink" title="累加和大于等于k的最小长度子数组"></a>累加和大于等于k的最小长度子数组</h2><p>都是正数，所以滑动窗口具有单调性，加入新数肯定会导致累加和变大，减少数字会导致累加和变小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">sum += nums[r];</span><br><span class="line"><span class="keyword">while</span> (sum - nums[l] &gt;= target) &#123;</span><br><span class="line"><span class="comment">// sum : nums[l....r]</span></span><br><span class="line"><span class="comment">// 如果l位置的数从窗口出去，还能继续达标，那就出去</span></span><br><span class="line">sum -= nums[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">ans = Math.min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复子串的最长长度"><a href="#无重复子串的最长长度" class="headerlink" title="无重复子串的最长长度"></a>无重复子串的最长长度</h2><p>记录上次这个字符出现的位置，每次更新左边界，就用当前左边界跟（上次重复位置+1）的最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line"><span class="comment">// char -&gt; int -&gt; 0 ~ 255</span></span><br><span class="line"><span class="comment">// 每一种字符上次出现的位置</span></span><br><span class="line"><span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 所有字符都没有上次出现的位置</span></span><br><span class="line">Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 不含有重复字符的 最长子串 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">l = Math.max(l, last[s[r]] + <span class="number">1</span>);</span><br><span class="line">ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 更新当前字符上一次出现的位置</span></span><br><span class="line">last[s[r]] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>描述：给定两个字符串 s 和 t，长度分别是 m 和 n，返回 s 中的 最短窗口 子串，使得该子串包含 t 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 “”。</p><p>等到满足覆盖条件之后，再开始考虑移动左边界。，只有移动左边界不会导致覆盖条件失效，才能移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String str, String tar)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] t = tar.toCharArray();</span><br><span class="line"><span class="comment">// 每种字符的欠债情况</span></span><br><span class="line"><span class="comment">// cnts[i] = 负数，代表字符i有负债</span></span><br><span class="line"><span class="comment">// cnts[i] = 正数，代表字符i有盈余</span></span><br><span class="line"><span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : t) &#123;</span><br><span class="line">cnts[cha]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小覆盖子串的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// 从哪个位置开头，发现的最小覆盖子串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总债务</span></span><br><span class="line"><span class="type">int</span> <span class="variable">debt</span> <span class="operator">=</span> t.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length; r++) &#123;</span><br><span class="line"><span class="comment">// 窗口右边界向右，给出字符</span></span><br><span class="line"><span class="keyword">if</span> (cnts[s[r]]++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">debt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (debt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 窗口左边界向右，拿回字符</span></span><br><span class="line"><span class="keyword">while</span> (cnts[s[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnts[s[l++]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以r位置结尾的达标窗口，更新答案</span></span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">len = r - l + <span class="number">1</span>;</span><br><span class="line">start = l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : str.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换子串得到平衡字符串"><a href="#替换子串得到平衡字符串" class="headerlink" title="替换子串得到平衡字符串"></a>替换子串得到平衡字符串</h2><p>解释：有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>思路：跟最小覆盖子串思路一样。只需要找到哪些字符超过了多少，我们替换他即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        cnt[pos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">debat</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] &lt;= n/<span class="number">4</span>)&#123;</span><br><span class="line">            cnt[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cnt[i] = n/<span class="number">4</span> - cnt[i];</span><br><span class="line">            debat-=cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>;r&lt;s.length();r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(cnt[pos]++ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            debat--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">            c = s.charAt(l);</span><br><span class="line">            pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>( cnt[pos] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cnt[pos]--;</span><br><span class="line">                l++;</span><br><span class="line">                c = s.charAt(l);</span><br><span class="line">                pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans,r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K个不同整数的子数组"><a href="#K个不同整数的子数组" class="headerlink" title="K个不同整数的子数组"></a>K个不同整数的子数组</h2><p>描述：给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</p><p>如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</p><p>例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。<br>子数组 是数组的 连续 部分。</p><p>思路：转化为求不超过k个不同整数问题，用k 减去 k-1 对应的答案 就是刚好个数为k的个数。</p><p>对于不超过这个问题用滑动窗口解决，只要种类不超过就扩大窗口，否则缩小窗口直到种类不超过。然后统计以窗口右边结尾的子数组的个数。即r-l+1.每次累加这个结果即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 不超过k个不同整数</span></span><br><span class="line">    <span class="keyword">return</span> find(nums,k) - find(nums,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">20001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    Arrays.fill(cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;nums.length;r++)&#123;</span><br><span class="line">        <span class="comment">// 窗口右边界向右，给出字符,并判断是不是新的</span></span><br><span class="line">        <span class="keyword">if</span>(++cnt[nums[r]] == <span class="number">1</span>)&#123;</span><br><span class="line">            kinds++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (kinds &gt; k)&#123;</span><br><span class="line">            <span class="comment">// 窗口左边界向右，拿回字符，如果一个字符没有了，则种类减一</span></span><br><span class="line">            <span class="keyword">if</span>( -- cnt[nums[l++]] == <span class="number">0</span>)&#123;</span><br><span class="line">                kinds--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以r位置结尾的达标窗口，累加个数</span></span><br><span class="line">        sum+= r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;累加和大于等于k的最小长度子数组&quot;&gt;&lt;a href=&quot;#累加和大于等于k的最小长度子数组&quot; class=&quot;headerlink&quot; title=&quot;累加和大于等于k的最小长度子数组&quot;&gt;&lt;/a&gt;累加和大于等于k的最小长度子数组&lt;/h2&gt;&lt;p&gt;都是正数，所以滑动窗口具有单</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聚合与聚合根</title>
    <link href="https://nmcb666.vip/posts/6758315a.html"/>
    <id>https://nmcb666.vip/posts/6758315a.html</id>
    <published>2026-01-26T01:21:51.000Z</published>
    <updated>2026-01-28T18:22:02.283Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。</p><p>1.只能通过聚合根来修改内部对象，不能绕过聚合根。</p><p>2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回！</p><p>3.只有聚合根有repository。（实体可以有factory）</p><p>4.设计聚合最好小而全，最好能做到一个实体就是聚合。但做不到也不强求，能满足要求即可，但切记不能过大，也不能太小。</p><p>5.聚合根不能在内部直接引用其他聚合根，只能根据唯一id去查询另一个聚合根，由服务进行统排。</p><p>6.一个事务只对一个聚合根保存生效。</p><p>7.跨聚合采用最终一致性（因为规定了第6条，所以在跨聚合中经常会对不同的表进行操作），具体可以由领域事件实现。</p><p>8.如果聚合根内部有一个实体列表（1：N关系）那么可以考虑把这个实体也变成聚合根，原聚合根只保留他的唯一id列表。如果是多对多关系，可以考虑再新建一个表示它们两个关系的聚合根。</p><p>9.为什么要拆分聚合根？ 因为一个聚合根保留的信息越多，那么在并发的情况下，保存聚合根时冲突的概率就越大。比如我的用户保留了资源列表，而且我是保留了完整的资源信息，那么可能资源的信息修改（只是修改了资源的更新日期），也会导致我的用户保存失败（乐观锁，数据不一样）。但如果把资源单独变成聚合根，用户聚合只保留资源id那么将会避免这种情况。同时考虑资源跟用户是多对多的关系，所以最好最新建一个角色跟资源绑定的聚合根，角色聚合根里面不会有任何资源相关的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。&lt;/p&gt;
&lt;p&gt;1.只能通过聚合根来修改内部对象，不能绕过聚合根。&lt;/p&gt;
&lt;p&gt;2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>算法（六）前缀和</title>
    <link href="https://nmcb666.vip/posts/3fdde4bd.html"/>
    <id>https://nmcb666.vip/posts/3fdde4bd.html</id>
    <published>2026-01-25T17:52:09.000Z</published>
    <updated>2026-01-28T18:22:02.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和（子数组相关问题）"><a href="#一维前缀和（子数组相关问题）" class="headerlink" title="一维前缀和（子数组相关问题）"></a>一维前缀和（子数组相关问题）</h1><h2 id="和等于k的最长子数组长度"><a href="#和等于k的最长子数组长度" class="headerlink" title="和等于k的最长子数组长度"></a>和等于k的最长子数组长度</h2><p>思路：前缀和+哈希表。哈希表存的是key是前缀和，value是出现的位置。但这个位置必须是最早出现的，而且必须预先插入一条 0 ,-1表示0一开始就是。<br>然后，依次遍历数组计算前缀和，用当前的前缀和减去k的值去哈希表里面查找，当前位置减去对应的位置就是以当前位置结尾的最长子数组长度。遍历求最大即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">map.clear();</span><br><span class="line"><span class="comment">// 重要 : 0这个前缀和，一个数字也没有的时候，就存在了</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - aim)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - aim));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找正负数相等的最长子数组"><a href="#找正负数相等的最长子数组" class="headerlink" title="找正负数相等的最长子数组"></a>找正负数相等的最长子数组</h2><p>思路： 构造前缀和，但是前缀和记录正负数数量的差值。正数为1，负数为-1，0为0.然后每到一个位置靠哈希表查询跟自己前缀和相同的位置，然后求长度，即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+= arr[i] == <span class="number">0</span> ? <span class="number">0</span> : arr[i]&lt;<span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cnt))&#123;</span><br><span class="line">              ans = Math.max(ans,i-map.get(cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(cnt))&#123;</span><br><span class="line">                map.put(cnt,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval"><a href="#表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval" class="headerlink" title="表现良好的最长时间段 链接： https://leetcode.cn/problems/longest-well-performing-interval/"></a>表现良好的最长时间段 链接： <a href="https://leetcode.cn/problems/longest-well-performing-interval/">https://leetcode.cn/problems/longest-well-performing-interval/</a></h2><p>思路：还是前缀和+哈希表。超过时长+1，小于时长-1。如果遇到前缀和为正数说明从一开始就是满足的，返回i+1.如果为负数或者0，那么就找前缀和-1的位置（拉格朗日中值定理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line"><span class="comment">// 某个前缀和，最早出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 0这个前缀和，最早出现在-1，一个数也没有的时候</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">sum += hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// sum &lt;= 0</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - <span class="number">1</span>)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="移除最少子数组长度使数组和可以被p整除"><a href="#移除最少子数组长度使数组和可以被p整除" class="headerlink" title="移除最少子数组长度使数组和可以被p整除"></a>移除最少子数组长度使数组和可以被p整除</h2><p>思路：以余数为前缀和，求出整个数组和的余数mod。然后在遍历过程中遇到当前余数curMod，我们就需要找到之前最后一个余数为 (curMod + p - mod)%p 的位置，然后求出长度。就是需要在当前位置移除的子数组的长度。需要最后判断长度是等于数组长度的时候，返回-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="comment">// 整体余数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">mod = (mod + num) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mod == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key : 前缀和%p的余数</span></span><br><span class="line"><span class="comment">// value : 最晚出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>, find; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="comment">// 0...i这部分的余数</span></span><br><span class="line">cur = (cur + nums[i]) % p;</span><br><span class="line">find = cur &gt;= mod ? (cur - mod) : (cur + p - mod);</span><br><span class="line"><span class="comment">// find = (cur + p - mod) % p;</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(find)) &#123;</span><br><span class="line">ans = Math.min(ans, i - map.get(find));</span><br><span class="line">&#125;</span><br><span class="line">map.put(cur, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == nums.length ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p>解释：现在要进行如下操作：</p><ol><li>给定一个数组，我要在给定区间加上一个同样的数。循环多次</li><li>加完之后返回给我每个位置上的值。</li></ol><p>一维差分：</p><ol><li>区间如果为l,r 要加上a,那么我在arr[l]+a,arr[r+1]-a.</li><li>之后对这个数组求前缀和，就是结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookings</span></span><br><span class="line"><span class="comment">// [1,5,6]</span></span><br><span class="line"><span class="comment">// [2,9,3]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line"><span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 设置差分数组，每一个操作对应两个设置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] book : bookings) &#123;</span><br><span class="line">cnt[book[<span class="number">0</span>]] += book[<span class="number">2</span>];</span><br><span class="line">cnt[book[<span class="number">1</span>] + <span class="number">1</span>] -= book[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加工前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans[i] = cnt[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="等差差分"><a href="#等差差分" class="headerlink" title="等差差分"></a>等差差分</h1><p>解释： 跟一维差分类似，但是我要从l到r 依次加上一个等差数列，而不是一个数。</p><p>结论： 假设这个等差数列 首项为 s , 公差为 d, 末项为 e。那对arr[l]+=s,arr[l+1]+=d-s,arr[r+1]-=d+e,arr[r+2]+=e; 然后进行两次前缀和即可。</p><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>公式： sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + arr[i][j]<br>计算从（a,b）到 （c,d）的子矩阵的和 : sum[c][d] - sum[a-1][d] - sum[c][b-1] + sum[a-1][b-1]</p><h2 id="最大以1为边界的正方形"><a href="#最大以1为边界的正方形" class="headerlink" title="最大以1为边界的正方形"></a>最大以1为边界的正方形</h2><p>描述：给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>核心思路：构造出二维前缀和，依次枚举以（i,j）为左上角的正方形是否合法。假设以(c,d)为右下角。这个正方形的和减去以(i+1,j+1),(c-1,d-1)为对角的正方形和的值应该等于他的（边长-1） * 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> g[<span class="number">0</span>].length;</span><br><span class="line">build(n, m, g);</span><br><span class="line"><span class="keyword">if</span> (sum(g, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, m - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到的最大合法正方形的边长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; m; b++) &#123;</span><br><span class="line"><span class="comment">// (a,b)所有左上角点</span></span><br><span class="line"><span class="comment">//     (c,d)更大边长的右下角点，k是当前尝试的边长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + ans, d = b + ans, k = ans + <span class="number">1</span>; c &lt; n &amp;&amp; d &lt; m; c++, d++, k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum(g, a, b, c, d) - sum(g, a + <span class="number">1</span>, b + <span class="number">1</span>, c - <span class="number">1</span>, d - <span class="number">1</span>) == (k - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>) &#123;</span><br><span class="line">ans = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g : 原始二维数组</span></span><br><span class="line"><span class="comment">// 把g变成原始二维数组的前缀和数组sum，复用自己</span></span><br><span class="line"><span class="comment">// 不能补0行，0列，都是0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">g[i][j] += get(g, i, j - <span class="number">1</span>) + get(g, i - <span class="number">1</span>, j) - get(g, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; c ? <span class="number">0</span> : (g[c][d] - get(g, c, b - <span class="number">1</span>) - get(g, a - <span class="number">1</span>, d) + get(g, a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) ? <span class="number">0</span> : g[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>跟一维差分差不多这里直接给公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维差分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">diff[a][b] += k;</span><br><span class="line">diff[c + <span class="number">1</span>][b] -= k;</span><br><span class="line">diff[a][d + <span class="number">1</span>] -= k;</span><br><span class="line">diff[c + <span class="number">1</span>][d + <span class="number">1</span>] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一维前缀和（子数组相关问题）&quot;&gt;&lt;a href=&quot;#一维前缀和（子数组相关问题）&quot; class=&quot;headerlink&quot; title=&quot;一维前缀和（子数组相关问题）&quot;&gt;&lt;/a&gt;一维前缀和（子数组相关问题）&lt;/h1&gt;&lt;h2 id=&quot;和等于k的最长子数组长度&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Raft与Paxos</title>
    <link href="https://nmcb666.vip/posts/b1c1c3b5.html"/>
    <id>https://nmcb666.vip/posts/b1c1c3b5.html</id>
    <published>2026-01-25T14:05:03.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？"><a href="#深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？" class="headerlink" title="[深度对比] 分布式共识的双雄：Paxos 与 Raft，为何 Raft 成为了工程界的宠儿？"></a>[深度对比] 分布式共识的双雄：Paxos 与 Raft，为何 Raft 成为了工程界的宠儿？</h1><p>在分布式系统的浩瀚宇宙中，<strong>“共识（Consensus）”</strong> 是最核心的难题之一。如何让一堆可能随时宕机、网络延迟的机器对某个值达成一致？这个问题困扰了计算机科学家几十年。</p><p>在这个领域，有两位绝对的主角：一个是理论界的“神” <strong>Paxos</strong>，另一个是工程界的“救世主” <strong>Raft</strong>。</p><p>很多开发者都知道，现在主流的分布式组件（如 Etcd, Consul, TiKV, Kafka的新版本）大多选择了 Raft。那么，Paxos 到底输在哪里？Raft 又为何如此容易实现？本文将带你深入剖析两者的区别与优劣。</p><hr><h2 id="一、-核心设计哲学的差异"><a href="#一、-核心设计哲学的差异" class="headerlink" title="一、 核心设计哲学的差异"></a>一、 核心设计哲学的差异</h2><p>要理解它们的区别，首先要看它们诞生的初衷：</p><ul><li><strong>Paxos (Leslie Lamport, 1990)</strong>：旨在发现共识问题的<strong>数学规律</strong>。它从数学角度证明了在分布式系统中达成一致的充要条件。它追求的是理论的完备性和一般性。</li><li><strong>Raft (Diego Ongaro &amp; John Ousterhout, 2013)</strong>：旨在提供一个<strong>可理解（Understandable）</strong>且<strong>易于实现</strong>的算法。它的设计目标非常明确：<strong>就是为了解决 Paxos 太难懂、太难实现的问题</strong>。</li></ul><p>如果把 Paxos 比作量子力学（解释了世界的本质，但很难直接用来造桥），那么 Raft 就是牛顿力学（在特定约束下，给了你一套造桥的标准公式）。</p><hr><h2 id="二、-为什么-Raft-更容易实现？"><a href="#二、-为什么-Raft-更容易实现？" class="headerlink" title="二、 为什么 Raft 更容易实现？"></a>二、 为什么 Raft 更容易实现？</h2><p>这是 Raft 能够后来居上的最大原因。Raft 并不是在理论上超越了 Paxos，而是通过<strong>增加约束</strong>和<strong>分解问题</strong>，极大地降低了工程落地的复杂度。</p><h3 id="1-问题的分解（Decomposition）"><a href="#1-问题的分解（Decomposition）" class="headerlink" title="1. 问题的分解（Decomposition）"></a>1. 问题的分解（Decomposition）</h3><p>Paxos 将选举、日志复制、确认提交等逻辑混杂在一起，牵一发而动全身。<br>Raft 强制将共识问题拆解为三个独立的子模块：</p><ul><li><strong>Leader Election（选主）</strong>：先选出老大，别的什么都不干。</li><li><strong>Log Replication（日志复制）</strong>：老大负责同步数据，Follower 负责接收。</li><li><strong>Safety（安全性）</strong>：确保数据一旦提交，就永远存在。</li></ul><p>这种解耦使得开发者可以独立编写和测试每个模块。</p><h3 id="2-强-Leader-模型（Strong-Leader）"><a href="#2-强-Leader-模型（Strong-Leader）" class="headerlink" title="2. 强 Leader 模型（Strong Leader）"></a>2. 强 Leader 模型（Strong Leader）</h3><p>这是 Raft 简化的杀手锏。</p><ul><li><strong>Paxos</strong>：允许所有节点同时发起提案（虽然 Multi-Paxos 也会优化为单 Leader，但协议本身允许并发）。这导致需要处理极其复杂的“冲突解决”和“日志乱序”问题。</li><li><strong>Raft</strong>：是<strong>独裁</strong>的。日志流向只能是 <code>Leader -&gt; Follower</code>。Follower 绝对不会修改 Leader 的日志，Leader 也永远不会覆盖自己的日志。这种单向数据流消除了大量边缘状态。</li></ul><h3 id="3-强制日志连续（Log-Continuity）"><a href="#3-强制日志连续（Log-Continuity）" class="headerlink" title="3. 强制日志连续（Log Continuity）"></a>3. 强制日志连续（Log Continuity）</h3><ul><li><strong>Paxos</strong>：允许日志有“空洞”。比如节点 A 确认了第 1、2、5 号日志，缺了 3 和 4。Paxos 允许这种情况存在，后续再通过复杂的逻辑把空洞补齐。</li><li><strong>Raft</strong>：<strong>不允许空洞</strong>。Follower 必须按顺序接收日志。如果 Follower 缺了第 4 号日志，Leader 绝不会发第 5 号给它，而是会强制回退（利用 <code>PrevLogIndex</code> 检查），直到找到一致的点，然后覆盖同步。这让状态机的实现变得极其简单——按顺序执行即可。</li></ul><h3 id="4-选主限制：拥有最新日志者才能当选"><a href="#4-选主限制：拥有最新日志者才能当选" class="headerlink" title="4. 选主限制：拥有最新日志者才能当选"></a>4. 选主限制：拥有最新日志者才能当选</h3><p>在 Paxos 中，任何节点都可能成为 Leader，哪怕它的数据很旧。上位后，它需要先学习历史数据，补全自己的知识，然后才能开始工作。<br>Raft 规定：<strong>只有拥有所有已提交日志的节点，才有资格当选 Leader。</strong> 这意味着新 Leader 上任的第一刻起，它就不需要去问别人“我是不是缺数据了”，直接接受新写入即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Raft 之所以容易实现，是因为它剥夺了节点的自由：</p><p>不准乱序提交（消灭了复杂的并发合并逻辑）。</p><p>不准 Follower 质疑 Leader（消灭了双向同步逻辑）。</p><p>不准旧节点当 Leader（消灭了 Leader 上位后的补数据逻辑）。</p><hr><h2 id="三、-Paxos-与-Raft-的优缺点权衡"><a href="#三、-Paxos-与-Raft-的优缺点权衡" class="headerlink" title="三、 Paxos 与 Raft 的优缺点权衡"></a>三、 Paxos 与 Raft 的优缺点权衡</h2><p>既然 Raft 这么好，Paxos 是不是一无是处？并非如此。两者在不同的维度各有千秋。</p><h3 id="1-Paxos-的优点（对比-Raft）"><a href="#1-Paxos-的优点（对比-Raft）" class="headerlink" title="1. Paxos 的优点（对比 Raft）"></a>1. Paxos 的优点（对比 Raft）</h3><ul><li><strong>理论的极致与通用性</strong>：Paxos 是共识算法的基石。Google 的 Chubby、Spanner 底层依然是 Paxos 的变种。事实上，Raft 可以被看作是 Paxos 的一个特定约束下的子集。</li><li><strong>更高的写入并发潜力</strong>：由于 Paxos 允许日志乱序确认（Out-of-Order Commit），在不依赖强顺序的场景下（或者使用 EPaxos 等变种），它的理论吞吐量可以高于 Raft。Raft 必须一个接一个顺序提交，存在队头阻塞（Head-of-Line Blocking）风险。</li><li><strong>无 Leader 的生存能力</strong>：Basic Paxos 不需要 Leader，在网络极其不稳定、无法维持稳定 Leader 的极端环境下，Basic Paxos 依然能工作，而 Raft 会陷入反复选主的死循环（不可用）。</li></ul><h3 id="2-Raft-的优点（对比-Paxos）"><a href="#2-Raft-的优点（对比-Paxos）" class="headerlink" title="2. Raft 的优点（对比 Paxos）"></a>2. Raft 的优点（对比 Paxos）</h3><ul><li><strong>可理解性（Understandability）</strong>：这是 Raft 的核心竞争力。一个普通的工程师阅读 Raft 论文两遍可能就能写出原型；而阅读 Paxos 论文十遍可能还是一头雾水。</li><li><strong>工程细节完备</strong>：Paxos 论文只讲了如何达成共识，没讲如何增删节点、如何压缩日志（Snapshot）。Raft 对这些工程痛点都给出了标准解决方案（如 Joint Consensus 成员变更算法）。</li><li><strong>调试与排错</strong>：由于 Raft 的状态转换路径非常清晰（且有限），当系统出现 Bug 时，更容易复现和定位。</li></ul><hr><h2 id="四、-总结：如何选择？"><a href="#四、-总结：如何选择？" class="headerlink" title="四、 总结：如何选择？"></a>四、 总结：如何选择？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Paxos (Multi-Paxos)</th><th style="text-align:left">Raft</th></tr></thead><tbody><tr><td style="text-align:left"><strong>设计目标</strong></td><td style="text-align:left">理论证明</td><td style="text-align:left">工程实现、可理解性</td></tr><tr><td style="text-align:left"><strong>日志结构</strong></td><td style="text-align:left">允许空洞，并发确认</td><td style="text-align:left">必须连续，顺序确认</td></tr><tr><td style="text-align:left"><strong>数据流向</strong></td><td style="text-align:left">多点可能（复杂）</td><td style="text-align:left">Leader 单向流向 Follower</td></tr><tr><td style="text-align:left"><strong>实现难度</strong></td><td style="text-align:left">极高（容易写出 Bug）</td><td style="text-align:left">中等（有标准参考）</td></tr><tr><td style="text-align:left"><strong>工业界现状</strong></td><td style="text-align:left">Google Spanner, Zookeeper (ZAB 类似)</td><td style="text-align:left">Etcd, Consul, TiKV, CockroachDB</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？&quot;&gt;&lt;a href=&quot;#深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？&quot; class=&quot;headerlink&quot; title=&quot;[深</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（五） 前缀树</title>
    <link href="https://nmcb666.vip/posts/38c6bd07.html"/>
    <id>https://nmcb666.vip/posts/38c6bd07.html</id>
    <published>2026-01-24T16:36:58.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀树结构"><a href="#前缀树结构" class="headerlink" title="前缀树结构"></a>前缀树结构</h2><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p><p>前缀树的基本操作</p><p>插入字符串：从根节点开始，依次插入字符串的每个字符。如果路径不存在，则创建新节点。最后一个节点标记为字符串的结束。</p><p>删除字符串：从根节点开始，依次减少路径上节点的计数。如果某节点的计数为零，则删除该节点。</p><p>查询字符串出现次数：沿路径遍历字符串，若路径完整且结束节点存在，则返回字符串的计数。</p><p>查询前缀数量：沿路径遍历前缀，若路径完整，则返回最后节点的通过计数。</p><h3 id="节点的结构"><a href="#节点的结构" class="headerlink" title="节点的结构"></a>节点的结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> pass;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"><span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">pass = <span class="number">0</span>;</span><br><span class="line">end = <span class="number">0</span>;</span><br><span class="line">nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">node.pass++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line">node.nexts[path] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">node.pass++;</span><br><span class="line">&#125;</span><br><span class="line">node.end++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询字符串出现次数"><a href="#查询字符串出现次数" class="headerlink" title="查询字符串出现次数"></a>查询字符串出现次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 查询前缀树里，word单词出现了几次</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询前缀数量"><a href="#查询前缀数量" class="headerlink" title="查询前缀数量"></a>查询前缀数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 查询前缀树里，有多少单词以pre做前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String pre)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 如果之前word插入过前缀树，那么此时删掉一次</span></span><br><span class="line"><span class="comment">// 如果之前word没有插入过前缀树，那么什么也不做</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (countWordsEqualTo(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">node.pass--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) &#123;</span><br><span class="line">node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line">node.end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用静态数组实现前缀树"><a href="#使用静态数组实现前缀树" class="headerlink" title="使用静态数组实现前缀树"></a>使用静态数组实现前缀树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 如果将来增加了数据量，就改大这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">150001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">pass[cur]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">pass[cur]++;</span><br><span class="line">&#125;</span><br><span class="line">end[cur]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String pre)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pass[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (search(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 下面这一行代码，讲课的时候没加</span></span><br><span class="line"><span class="comment">// 本题不会用到pass[1]的信息，所以加不加都可以，不过正确的写法是加上</span></span><br><span class="line">pass[cur]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (--pass[tree[cur][path]] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line">end[cur]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">end[i] = <span class="number">0</span>;</span><br><span class="line">pass[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="查询数组中两个数的异或最大值"><a href="#查询数组中两个数的异或最大值" class="headerlink" title="查询数组中两个数的异或最大值"></a>查询数组中两个数的异或最大值</h3><p>思路：我们使用每一个数，根据他的每一位去构建一个前缀树。然后依次遍历每一个数，从最高位开始遍历，我希望找到跟我不一样的位，于是我在前缀树里面查找。如果存在那么把这个位置变成1加入答案，如果不存在那么把这个位置变成0加入答案。然后跳到下一个节点树去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 前缀树的做法</span></span><br><span class="line"><span class="comment">// 好想</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaximumXOR1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">build(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">ans = Math.max(ans, maxXor(num));</span><br><span class="line">&#125;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备这么多静态空间就够了，实验出来的</span></span><br><span class="line"><span class="comment">// 如果测试数据升级了规模，就改大这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">3000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀树目前使用了多少空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字只需要从哪一位开始考虑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 找个最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">max = Math.max(num, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算数组最大值的二进制状态，有多少个前缀的0</span></span><br><span class="line"><span class="comment">// 可以忽略这些前置的0，从left位开始考虑</span></span><br><span class="line">high = <span class="number">31</span> - Integer.numberOfLeadingZeros(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">insert(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high, path; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxXor</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="comment">// 最终异或的结果(尽量大)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 前缀树目前来到的节点编号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high, status, want; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// status : num第i位的状态</span></span><br><span class="line">status = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// want : num第i位希望遇到的状态</span></span><br><span class="line">want = status ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][want] == <span class="number">0</span>) &#123; <span class="comment">// 询问前缀树，能不能达成</span></span><br><span class="line"><span class="comment">// 不能达成</span></span><br><span class="line">want ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// want变成真的往下走的路</span></span><br><span class="line">ans |= (status ^ want) &lt;&lt; i;</span><br><span class="line">cur = tree[cur][want];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">tree[i][<span class="number">0</span>] = tree[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在二维网格中，搜索单词组返回能找到的单词组"><a href="#在二维网格中，搜索单词组返回能找到的单词组" class="headerlink" title="在二维网格中，搜索单词组返回能找到的单词组"></a>在二维网格中，搜索单词组返回能找到的单词组</h3><p>思路：回溯+前缀树减枝</p><p>关键点：1.把走过的格子，标为0，这样不会重复走，但是需要恢复现场</p><p>2.利用前缀树减枝，首先利用单词组构建出前缀树。每次递归的时候根据前缀树有没有路径来判断这个格子里面的单词能不能要。除了路径还要判断这条路径下还有没有剩余的未探索单词（利用pass数组）。</p><p>3.巧用pass跟end数组。pass[i] 表示当前节点剩余还未收集的单词，end[i] 表示在当前节点完结的单词，可以直接加入ans。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">build(words);</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">dfs(board, i, j, <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// board : 二维网格</span></span><br><span class="line"><span class="comment">// i,j : 此时来到的格子位置，i行、j列</span></span><br><span class="line"><span class="comment">// t : 前缀树的编号</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; ans : 收集到了哪些字符串，都放入ans</span></span><br><span class="line"><span class="comment">// 返回值 : 收集到了几个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> t, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line"><span class="comment">// 越界 或者 走了回头路，直接返回0</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || board[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界 且 不是回头路</span></span><br><span class="line"><span class="comment">// 用tmp记录当前字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line"><span class="comment">// 路的编号</span></span><br><span class="line"><span class="comment">// a -&gt; 0</span></span><br><span class="line"><span class="comment">// b -&gt; 1</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// z -&gt; 25</span></span><br><span class="line"><span class="type">int</span> <span class="variable">road</span> <span class="operator">=</span> tmp - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">t = tree[t][road];</span><br><span class="line">       <span class="comment">// 不存在该路径，或者该路径下的单词已经被你找出来完了  其实应该写成 t==0 || pass[t]==0 但是初始化的时候pass就是从1开始，所以这里可以不用判断</span></span><br><span class="line"><span class="keyword">if</span> (pass[t] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i，j位置有必要来</span></span><br><span class="line"><span class="comment">// fix ：从当前i，j位置出发，一共收集到了几个字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">fix</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end[t] != <span class="literal">null</span>) &#123;</span><br><span class="line">fix++;</span><br><span class="line">ans.add(end[t]);</span><br><span class="line">end[t] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把i，j位置的字符，改成0，后续的过程，是不可以再来到i，j位置的！</span></span><br><span class="line">board[i][j] = <span class="number">0</span>;</span><br><span class="line">fix += dfs(board, i - <span class="number">1</span>, j, t, ans);</span><br><span class="line">fix += dfs(board, i + <span class="number">1</span>, j, t, ans);</span><br><span class="line">fix += dfs(board, i, j - <span class="number">1</span>, t, ans);</span><br><span class="line">fix += dfs(board, i, j + <span class="number">1</span>, t, ans);</span><br><span class="line">       <span class="comment">// 减去已经找到的单词数量</span></span><br><span class="line">pass[t] -= fix;</span><br><span class="line">       <span class="comment">// 恢复现场</span></span><br><span class="line">board[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> fix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] end = <span class="keyword">new</span> <span class="title class_">String</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">pass[cur]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">pass[cur]++;</span><br><span class="line">&#125;</span><br><span class="line">end[cur] = word;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">pass[i] = <span class="number">0</span>;</span><br><span class="line">end[i] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前缀树结构&quot;&gt;&lt;a href=&quot;#前缀树结构&quot; class=&quot;headerlink&quot; title=&quot;前缀树结构&quot;&gt;&lt;/a&gt;前缀树结构&lt;/h2&gt;&lt;p&gt;Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CAP中的一致性</title>
    <link href="https://nmcb666.vip/posts/5bb35c22.html"/>
    <id>https://nmcb666.vip/posts/5bb35c22.html</id>
    <published>2026-01-24T14:37:48.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<p>关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）</p><h2 id="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"><a href="#首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？" class="headerlink" title="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"></a>首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？</h2><p>这是一个非常经典且容易混淆的问题，因为“一致性”（Consistency）这个词在计算机科学的不同领域里，虽然名字一样，但含义却大相径庭。</p><p>这三个概念分别对应了：<strong>单机数据库理论（ACID）</strong>、<strong>分布式系统理论（CAP）</strong> 和 <strong>工程实践（分布式事务）</strong>。</p><p>我们可以用一句话概括它们的区别：</p><ul><li><strong>ACID 的一致性</strong>：关乎<strong>数据的“正确性”</strong>（符合业务约束）。</li><li><strong>CAP 的一致性</strong>：关乎<strong>数据的“新旧”</strong>（多副本同步）。</li><li><strong>分布式事务的一致性</strong>：关乎<strong>跨系统的“协调”</strong>（让多个独立系统的数据最终对齐）。</li></ul><hr><h3 id="1-事务的一致性-ACID-中的-C"><a href="#1-事务的一致性-ACID-中的-C" class="headerlink" title="1. 事务的一致性 (ACID 中的 C)"></a>1. 事务的一致性 (ACID 中的 C)</h3><p>这里的背景通常指<strong>单机数据库</strong>（如 MySQL）的本地事务。</p><ul><li><strong>定义</strong>：指事务执行前后，数据库必须从一个<strong>合法状态</strong>变换到另一个<strong>合法状态</strong>。</li><li><strong>核心关注点</strong>：<strong>业务逻辑与约束 (Business Logic &amp; Constraints)</strong>。</li><li><strong>详细解释</strong>：<br>“合法状态”是指数据必须符合预定义的规则。这些规则包括：<ul><li><strong>数据库约束</strong>：主键唯一、外键约束、字段类型、Check约束（例如余额不能小于0）。</li><li><strong>业务逻辑</strong>：例如 A 转账给 B 100元，那么 A 减去 100，B 加上 100，总金额必须不变。如果代码写错了，A 减了 100，B 却只加了 50，虽然数据库没崩溃（原子性满足），但<strong>一致性</strong>被破坏了，因为数据不再符合“总额守恒”的业务规则。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证数据不违背现实世界的业务规则。</strong></li></ul><hr><h3 id="2-分布式系统的一致性-CAP-中的-C"><a href="#2-分布式系统的一致性-CAP-中的-C" class="headerlink" title="2. 分布式系统的一致性 (CAP 中的 C)"></a>2. 分布式系统的一致性 (CAP 中的 C)</h3><p>这里的背景是指<strong>多副本的数据存储系统</strong>（如 Redis Cluster, Cassandra, ZooKeeper, HDFS）。</p><ul><li><strong>定义</strong>：在 CAP 理论中，C 代表 <strong>Linearizability (线性一致性)</strong> 或 <strong>Strong Consistency (强一致性)</strong>。意思是：<strong>所有的节点在同一时间看到的数据是完全相同的</strong>。</li><li><strong>核心关注点</strong>：<strong>多节点间的数据同步 (Synchronization &amp; Timing)</strong>。</li><li><strong>详细解释</strong>：<br>在分布式系统中，为了容灾，数据通常会有多个副本（Replica）。<ul><li>当你向节点 A 写入一个新值 <code>x = 1</code>。</li><li>紧接着向节点 B 读取 <code>x</code>。</li><li><strong>一致性</strong>要求：你必须读到 <code>1</code>。如果你读到了旧值 <code>0</code>，那么这个系统就不满足 CAP 中的 C。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证你读到的永远是最新写入的数据（就像只有一个副本一样）。</strong></li></ul><hr><h3 id="3-分布式事务中的一致性"><a href="#3-分布式事务中的一致性" class="headerlink" title="3. 分布式事务中的一致性"></a>3. 分布式事务中的一致性</h3><p>这里的背景是指<strong>微服务架构</strong>或<strong>跨数据库</strong>的操作（如 订单服务 + 库存服务 + 支付服务）。</p><ul><li><strong>定义</strong>：指在跨越多个独立服务或数据库的操作中，确保所有相关的数据最终能够达成一种<strong>逻辑上的对齐</strong>。它可以理解为事务的原子性，<strong>要么全部成功，要么全部失败</strong>。</li><li><strong>核心关注点</strong>：<strong>跨系统的原子性与最终状态 (Global Outcome)</strong>。</li><li><strong>详细解释</strong>：<br>由于分布式系统很难同时满足 CAP（通常为了可用性 A，必须牺牲强一致性 C），所以在分布式事务中，我们通常讨论两种一致性：<ol><li><strong>强一致性（刚性事务）</strong>：如 XA 协议、2PC（两阶段提交）。要求所有服务同时提交，立刻看到结果。这很像 ACID，但在分布式环境下性能极差。</li><li><strong>最终一致性（柔性事务，BASE理论）</strong>：如 TCC、Saga、消息队列。允许中间有一段时间数据是不一致的（例如订单已创建，但库存还没扣减完），但保证经过一段时间后，所有数据都会变对。</li></ol></li><li><strong>一句话总结</strong>：<strong>它保证多个独立系统的数据，虽然可能有延迟，但最终会“账目”对齐，不会出现“订单成功了但没扣库存”的烂账。</strong></li></ul><hr><h3 id="三者对比总结表"><a href="#三者对比总结表" class="headerlink" title="三者对比总结表"></a>三者对比总结表</h3><p>为了更清晰地理解，我们可以通过下表对比：</p><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">ACID 的一致性 (事务)</th><th style="text-align:left">CAP 的一致性 (分布式系统)</th><th style="text-align:left">分布式事务的一致性</th></tr></thead><tbody><tr><td style="text-align:left"><strong>侧重点</strong></td><td style="text-align:left"><strong>数据的正确性</strong> (逻辑约束)</td><td style="text-align:left"><strong>数据的可见性</strong> (时间同步)</td><td style="text-align:left"><strong>全局操作的协同</strong> (多方对齐)</td></tr><tr><td style="text-align:left"><strong>场景</strong></td><td style="text-align:left">单机数据库 (Oracle, MySQL)</td><td style="text-align:left">分布式存储 (Redis, ZK, NoSQL)</td><td style="text-align:left">微服务、跨库业务</td></tr><tr><td style="text-align:left"><strong>反例</strong></td><td style="text-align:left">转账后总金额变少了 (违反守恒)</td><td style="text-align:left">刚写完主库，读从库还是旧数据</td><td style="text-align:left">订单库显示“已支付”，库存库显示“未扣减”</td></tr><tr><td style="text-align:left"><strong>依赖对象</strong></td><td style="text-align:left">依赖数据库引擎的约束检查</td><td style="text-align:left">依赖共识算法 (Raft, Paxos) 或同步复制</td><td style="text-align:left">依赖协调器、MQ 或 补偿代码</td></tr><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left">“这笔数据合乎逻辑吗？”</td><td style="text-align:left">“我现在读到的是最新的吗？”</td><td style="text-align:left">“这几个系统的数据最后能对上吗？”</td></tr></tbody></table></div><h3 id="举个通俗的例子"><a href="#举个通俗的例子" class="headerlink" title="举个通俗的例子"></a>举个通俗的例子</h3><p>假设你要去买一杯奶茶：</p><ol><li><p><strong>ACID 一致性</strong>：你付了 20 元，店员必须给你一杯 20 元的奶茶。如果店员只给你一杯 10 元的水，或者没收钱就给你奶茶，这就违背了<strong>交易规则</strong>（ACID 破坏）。</p></li><li><p><strong>CAP 一致性</strong>：这家奶茶店有 3 个店员（副本）。店长（主节点）刚刚更新了菜单，把“珍珠奶茶”涨价到 25 元。你问店员 A，他说 25 元；你立刻问店员 B，如果店员 B 还说 20 元，那就是<strong>同步</strong>没做好（CAP 的 C 破坏）。</p></li><li><p><strong>分布式事务一致性</strong>：你在手机 App 上点单。</p><ul><li>你的支付宝扣了钱（支付服务）。</li><li>奶茶店的打印机出了小票（订单服务）。</li><li>如果支付宝扣了钱，但奶茶店没收到单子；或者奶茶店出了单子，支付宝没扣钱，这就是<strong>跨系统</strong>的不一致。分布式事务就是要保证：要么没扣钱也没单子，要么扣了钱也有单子（哪怕中间有几秒延迟）。</li></ul></li></ol><h2 id="线性一致性跟顺序一致性"><a href="#线性一致性跟顺序一致性" class="headerlink" title="线性一致性跟顺序一致性"></a>线性一致性跟顺序一致性</h2><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p><p>•    条件 I：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</p><p>•    条件 II：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>线性一致性的定义，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件 I 和条件 II 之外，还要同时满足一个条件：</p><p>•    条件 III：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>•    它们都试图让系统“表现得像只有一个副本”一样。</p><p>•    它们都保证了程序执行顺序不会被打乱。体现在条件 II 对于进程内各个操作的排序保持上。</p><p>•    线性一致性考虑了时间先后顺序，而顺序一致性没有。</p><p>•    满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</p><p>•    线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</p><p>•    在顺序一致性中，我们有可能读到旧版本的数据。</p><p>具体可以参考这篇博客 <a href="https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA">https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA</a></p><h2 id="最终一致性又是什么？"><a href="#最终一致性又是什么？" class="headerlink" title="最终一致性又是什么？"></a>最终一致性又是什么？</h2><p>其实最终一致性就不满足CAP理论的C,而是对于AP系统的扩充。</p><p><strong>最终一致性（Eventual Consistency）是 CAP 理论中选择了 AP（可用性 + 分区容错性）策略后，为了弥补缺失的 C（强一致性）而不得不采用的一种“妥协”方案。</strong></p><p>或者更简单点说：<strong>最终一致性是 AP 系统的核心特征。</strong></p><p>我们可以从以下几个层面来剖析这段关系：</p><h3 id="1-CAP-的必然性与“二选一”"><a href="#1-CAP-的必然性与“二选一”" class="headerlink" title="1. CAP 的必然性与“二选一”"></a>1. CAP 的必然性与“二选一”</h3><p>CAP 理论告诉我们，在分布式系统中，<strong>P（分区容错性）是不可避免的</strong>（网线总会断，节点总会挂）。所以我们只能在 C（强一致性/线性一致性）和 A（可用性）之间做选择：</p><ul><li><strong>选择 CP（放弃 A）</strong>：为了保证数据绝对一致，当网络出问题时，我宁愿报错拒绝服务，也不让你读到旧数据。<ul><li><em>结果</em>：这是<strong>强一致性</strong>系统（如 Zookeeper, HBase）。</li></ul></li><li><strong>选择 AP（放弃 C）</strong>：为了保证服务永远可用，哪怕网络出问题了，我也让你读，虽然读到的可能是旧数据。<ul><li><em>结果</em>：这就是<strong>最终一致性</strong>发挥作用的地方（如 DNS, Eureka, Cassandra）。</li></ul></li></ul><h3 id="2-最终一致性在-CAP-图谱中的位置"><a href="#2-最终一致性在-CAP-图谱中的位置" class="headerlink" title="2. 最终一致性在 CAP 图谱中的位置"></a>2. 最终一致性在 CAP 图谱中的位置</h3><p>如果把 CAP 画成一个三角形：</p><ul><li><strong>CAP 中的 C (Consistency)</strong>：指的是<strong>线性一致性</strong>（强一致性）。如果你追求 CAP 的 C，你就必须保证写完立刻能读到。</li><li><strong>最终一致性</strong>：它是<strong>弱一致性</strong>的一种特例。<strong>它不属于 CAP 的 C</strong>。相反，它是当我们<strong>抛弃了 CAP 的 C</strong> 之后，退而求其次追求的目标。</li></ul><blockquote><p><strong>关系公式</strong>：<br><strong>CAP (AP 模式)</strong> = <strong>Availability</strong> (高可用) + <strong>Partition Tolerance</strong> (分区容错) + <strong>Eventual Consistency</strong> (最终一致性)</p></blockquote><h3 id="3-为什么-AP-系统必然导致最终一致性？"><a href="#3-为什么-AP-系统必然导致最终一致性？" class="headerlink" title="3. 为什么 AP 系统必然导致最终一致性？"></a>3. 为什么 AP 系统必然导致最终一致性？</h3><p>让我们推演一下：</p><ol><li><strong>前提 (P)</strong>：系统有两个节点 Node A 和 Node B，它们之间的网络断了。</li><li><strong>抉择 (A)</strong>：我们选择了高可用（Availability），所以当用户向 Node A 写入 <code>x=1</code> 时，Node A 必须接受并返回成功，不能报错。</li><li><strong>后果</strong>：此时，Node A 的数据是 <code>x=1</code>，而 Node B 因为网络断了，数据还是 <code>x=0</code>。</li><li><strong>现状</strong>：此时系统已经<strong>不一致</strong>了（违反了 CAP 的 C）。</li><li><strong>补救 (最终一致性)</strong>：我们不能让 Node B 永远是 <code>0</code>。系统承诺：当网络恢复后，Node A 会后台把 <code>x=1</code> 同步给 Node B。经过一段时间（不确定多久），Node B 最终也会变成 <code>1</code>。</li></ol><p><strong>结论</strong>：因为选择了 A（允许在断网时继续写），必然导致数据暂时不一致。而“最终一致性”就是对这种暂时不一致的<strong>容忍</strong>和对未来的<strong>承诺</strong>。</p><h3 id="4-延伸：BASE-理论"><a href="#4-延伸：BASE-理论" class="headerlink" title="4. 延伸：BASE 理论"></a>4. 延伸：BASE 理论</h3><p>讲到最终一致性与 CAP 的关系，就不得不提 <strong>BASE 理论</strong>。它是对 CAP 中 AP 策略的工程化延伸。：</p><ul><li><strong>BA (Basically Available)</strong>：基本可用（允许响应时间慢一点，或者部分降级）。</li><li><strong>S (Soft state)</strong>：软状态（允许系统存在中间状态，即允许数据同步有延迟）。</li><li><strong>E (Eventual consistency)</strong>：最终一致性（数据最终会变对）。</li></ul><h3 id="5-总结表"><a href="#5-总结表" class="headerlink" title="5. 总结表"></a>5. 总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">CAP 的 C (强一致性)</th><th style="text-align:left">最终一致性 (弱一致性的一种)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CAP 选择</strong></td><td style="text-align:left"><strong>CP</strong> (放弃可用性)</td><td style="text-align:left"><strong>AP</strong> (放弃强一致性)</td></tr><tr><td style="text-align:left"><strong>核心逻辑</strong></td><td style="text-align:left">写操作完成后，所有节点<strong>立刻</strong>可见。</td><td style="text-align:left">写操作完成后，数据<strong>异步</strong>复制，经过一段时间才可见。</td></tr><tr><td style="text-align:left"><strong>用户体验</strong></td><td style="text-align:left">“要么读到最新的，要么系统告诉我报错/超时。”</td><td style="text-align:left">“我可能读到旧的，但系统保证随时能用。”</td></tr><tr><td style="text-align:left"><strong>典型场景</strong></td><td style="text-align:left">银行余额、库存扣减、分布式锁 (Etcd/ZK)</td><td style="text-align:left">社交网络点赞、DNS解析、电商商品浏览量</td></tr><tr><td style="text-align:left"><strong>关系</strong></td><td style="text-align:left"><strong>它是 CAP 定义的一致性标准</strong></td><td style="text-align:left"><strong>它是放弃 CAP 的 C 之后的替代方案</strong></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）&lt;/p&gt;
&lt;h2 id=&quot;首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？&quot;&gt;&lt;a href=&quot;#首先我们要知道什么是CAP的一致性，他跟</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（四）递归</title>
    <link href="https://nmcb666.vip/posts/38e6282b.html"/>
    <id>https://nmcb666.vip/posts/38e6282b.html</id>
    <published>2026-01-20T15:24:25.000Z</published>
    <updated>2026-01-28T18:22:02.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归相关的题目"><a href="#递归相关的题目" class="headerlink" title="递归相关的题目"></a>递归相关的题目</h1><h2 id="找一个字符串的不重复的子序列"><a href="#找一个字符串的不重复的子序列" class="headerlink" title="找一个字符串的不重复的子序列"></a>找一个字符串的不重复的子序列</h2><p>递归的思路：每次按要这个位置的字符和不要这个位置的字符两种情况去递归，当i = s.length()时，保存当前的子序列。用hashSet去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String[] generatePermutation(String str) &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">f2(s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">char</span>[s.length], <span class="number">0</span>, set);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> set.size();</span><br><span class="line">String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[m];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String cur : set) &#123;</span><br><span class="line">ans[i++] = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// i是当前要处理的字符的索引,path是当前已经保存的路径，size是path的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">char</span>[] path, <span class="type">int</span> size, HashSet&lt;String&gt; set)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">set.add(String.valueOf(path, <span class="number">0</span>, size));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path[size] = s[i];</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size + <span class="number">1</span>, set);</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size, set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找一个数组中的所有子数组，顺序可以任意"><a href="#找一个数组中的所有子数组，顺序可以任意" class="headerlink" title="找一个数组中的所有子数组，顺序可以任意"></a>找一个数组中的所有子数组，顺序可以任意</h2><p>思路：先将数组排序，然后每次对同一个数讨论，要0个，要1个… 还需要知道对于这个数来说下一个跟自己不同的数的位置，然后调用递归从下个不同的数开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    findSubsetsWithDup(<span class="number">0</span>,nums,<span class="number">0</span>,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findSubsetsWithDup</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span> size,<span class="type">int</span>[] path,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">            temp.add(path[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找出下一个跟自己不同的数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; nums[j] == nums[i])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要0个</span></span><br><span class="line">        findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        <span class="comment">// 依次要多个</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++)&#123;</span><br><span class="line">            path[size++] = nums[i];</span><br><span class="line">            findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。"><a href="#给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。" class="headerlink" title="给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。"></a>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</h2><p>思路： 每次拿一个数跟当前下标的第一个数交换，然后递归调用将下标+1，递归完成后再交换回来。终止条件就算下标==nums.length</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    findPermute(nums,<span class="number">0</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPermute</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            temp.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            findPermute(nums,i+<span class="number">1</span>,ans);</span><br><span class="line">            <span class="comment">// 交换回来</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：如果有重复数字，则需要去重</p><p>思路： 每次递归的时候维护一个set这个set记录哪些数来到过我这个下标，如果发现一个数已经来到过，则不进行交换，也不递归跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">cur.add(num);</span><br><span class="line">&#125;</span><br><span class="line">ans.add(cur);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="comment">// nums[j]没有来到过i位置，才会去尝试</span></span><br><span class="line"><span class="keyword">if</span> (!set.contains(nums[j])) &#123;</span><br><span class="line">set.add(nums[j]);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">f(nums, i + <span class="number">1</span>, ans);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>思路：维护一个路径数组path[],path的第几个数的值表示第几行的皇后放在第几列，每次循环每一行的列去判断是否合法，如果合法则递归调用下一行，并且size++.终止条件是size == n 即找到合法的一个解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    findSolveNQueens(<span class="number">0</span>,n,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findSolveNQueens</span><span class="params">(<span class="type">int</span> size,<span class="type">int</span> n,<span class="type">int</span>[] path,List&lt;List&lt;String&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(size == n)&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span>path[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span> ;j&lt;pos;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> pos+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次尝试</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 尝试第i列</span></span><br><span class="line">            <span class="keyword">if</span>(isvalid(i,path,size))&#123;</span><br><span class="line">                <span class="comment">// 合法</span></span><br><span class="line">                path[size] = i;</span><br><span class="line">                findSolveNQueens(size+<span class="number">1</span>,n,path,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isvalid</span> <span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] path,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k&lt; size; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==path[k])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Math.abs(size-k) == Math.abs(i-path[k]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拓展： 利用位运算去判断当前位置是否合法。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-21%20162737.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalNQueens2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n = 5</span></span><br><span class="line"><span class="comment">// 1 &lt;&lt; 5 = 0...100000 - 1</span></span><br><span class="line"><span class="comment">// limit  = 0...011111; </span></span><br><span class="line"><span class="comment">// n = 7</span></span><br><span class="line"><span class="comment">// limit  = 0...01111111; </span></span><br><span class="line"><span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> f2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// limit : 当前是几皇后问题</span></span><br><span class="line"><span class="comment">// 之前皇后的列影响：col</span></span><br><span class="line"><span class="comment">// 之前皇后的右上 -&gt; 左下对角线影响：left</span></span><br><span class="line"><span class="comment">// 之前皇后的左上 -&gt; 右下对角线影响：right</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> col, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (col == limit) &#123;</span><br><span class="line"><span class="comment">// 所有皇后放完了！</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总限制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ban</span> <span class="operator">=</span> col | left | right;</span><br><span class="line"><span class="comment">// ~ban : 1可放皇后，0不能放</span></span><br><span class="line"><span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> limit &amp; (~ban);</span><br><span class="line"><span class="comment">// 放置皇后的尝试！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 一共有多少有效的方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (candidate != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 提取出最右侧的1</span></span><br><span class="line"><span class="comment">// 0 0 1 1 1 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 1 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 1 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line">place = candidate &amp; (-candidate);</span><br><span class="line">candidate ^= place;</span><br><span class="line">ans += f2(limit, col | place, (left | place) &gt;&gt; <span class="number">1</span>, (right | place) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归相关的题目&quot;&gt;&lt;a href=&quot;#递归相关的题目&quot; class=&quot;headerlink&quot; title=&quot;递归相关的题目&quot;&gt;&lt;/a&gt;递归相关的题目&lt;/h1&gt;&lt;h2 id=&quot;找一个字符串的不重复的子序列&quot;&gt;&lt;a href=&quot;#找一个字符串的不重复的子序列&quot; cla</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（四）二叉树</title>
    <link href="https://nmcb666.vip/posts/44956a51.html"/>
    <id>https://nmcb666.vip/posts/44956a51.html</id>
    <published>2026-01-19T21:48:58.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树相关的题目"><a href="#二叉树相关的题目" class="headerlink" title="二叉树相关的题目"></a>二叉树相关的题目</h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>思路：利用队列进行层序遍历，类似与BFS。</p><p>这里举一个锯齿形层序遍历的例子（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">l = r = <span class="number">0</span>;</span><br><span class="line">queue[r++] = root;</span><br><span class="line"><span class="comment">// false 代表从左往右</span></span><br><span class="line"><span class="comment">// true 代表从右往左</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// reverse == false, 左 -&gt; 右， l....r-1, 收集size个</span></span><br><span class="line"><span class="comment">// reverse == true,  右 -&gt; 左， r-1....l, 收集size个</span></span><br><span class="line"><span class="comment">// 左 -&gt; 右, i = i + 1</span></span><br><span class="line"><span class="comment">// 右 -&gt; 左, i = i - 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reverse ? r - <span class="number">1</span> : l, j = reverse ? -<span class="number">1</span> : <span class="number">1</span>, k = <span class="number">0</span>; k &lt; size; i += j, k++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[i];</span><br><span class="line">list.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line"><span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">queue[r++] = cur.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">queue[r++] = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.add(list);</span><br><span class="line">reverse = !reverse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h2><p>思路：利用队列进行层序遍历，并同步记录当前层节点的索引，将索引保存在数组中，最后计算每一层开始与结束的索引的差值，并返回最大值。想象为完全二叉树，对于节点i，其左子节点为2i，右子节点为2i+1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">3001</span>];</span><br><span class="line">    Long[] idQueue = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">3001</span>];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[r] = root;</span><br><span class="line">    idQueue[r++] = <span class="number">1L</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//每次遍历完成后，l 到 r-1，就是当前层所有节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r-l;</span><br><span class="line">        ans = Math.max(ans,(<span class="type">int</span>)(idQueue[r-<span class="number">1</span>]-idQueue[l]+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue[l];</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idQueue[l++];</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue[r] = node.left;</span><br><span class="line">                idQueue[r++] = id*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue[r] =node.right;</span><br><span class="line">                idQueue[r++] = id*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大深度跟最小深度"><a href="#最大深度跟最小深度" class="headerlink" title="最大深度跟最小深度"></a>最大深度跟最小深度</h2><p>思路：利用递归进行求解，对于每个节点，求左右子树的最大深度，并返回较大的值。（最小深度同理，但要处理根节点为空的情况，因为为空子问题返回0高度，但题目说的最小深度必须到叶节点，所以会干扰最小深度的计算，所以必须子节点不为空才能进行递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right ==<span class="literal">null</span> &amp;&amp; root.left ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lMin</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rMin</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lMin = minDepth(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        rMin = minDepth(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(lMin,rMin)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据中序遍历和前序遍历构建二叉树"><a href="#根据中序遍历和前序遍历构建二叉树" class="headerlink" title="根据中序遍历和前序遍历构建二叉树"></a>根据中序遍历和前序遍历构建二叉树</h2><p>思路：</p><p>确定根节点：<br>前序遍历的第一个元素一定是整个树的根节点。</p><p>划分左右子树：<br>根据根节点在中序遍历中的位置，可以将中序遍历序列划分为左子树和右子树的中序遍历序列。<br>左子树的中序遍历序列位于根节点的左边，右子树的中序遍历序列位于根节点的右边。</p><p>递归构建：<br>根据左子树和右子树的中序遍历序列长度，可以在前序遍历序列中划分出对应的左子树和右子树的前序遍历序列。<br>递归地对左右子树进行上述操作，直到遍历序列为空，返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(preorder,<span class="number">0</span>,len-<span class="number">1</span>,inorder,<span class="number">0</span>,len-<span class="number">1</span>,map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] pre ,<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span>[] in,<span class="type">int</span> l2,<span class="type">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1&gt;r1 || l2 &gt; r2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == r1)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[l1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[l1]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span>map.get(pre[l1]);</span><br><span class="line">    <span class="comment">// 划分左右子树 递归求解</span></span><br><span class="line">    head.left = build(pre,l1+<span class="number">1</span>,k-l2+l1,in,l2,k-<span class="number">1</span>,map);</span><br><span class="line">    head.right = build(pre,k-l2+l1+<span class="number">1</span>,r1,in,k+<span class="number">1</span>,r2,map);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>思路： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line"><span class="comment">// 遇到空，或者p，或者q，直接返回</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"><span class="keyword">if</span> (l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 左树也搜到，右树也搜到，返回root</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="literal">null</span> &amp;&amp; r == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 都没搜到返回空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l和r一个为空，一个不为空</span></span><br><span class="line"><span class="comment">// 返回不空的那个</span></span><br><span class="line"><span class="keyword">return</span> l != <span class="literal">null</span> ? l : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>思路：每个点必须大于左树的最大值，小于右树最小值。递归验证即可。但注意把最大值设为Long.MIN_VALUE，最小值设为Long.MAX_VALUE（为了不对结果造成干扰）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        max = Long.MIN_VALUE;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lok</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">    <span class="type">long</span> <span class="variable">lmax</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lmin</span> <span class="operator">=</span> min;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">rok</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">    <span class="type">long</span> <span class="variable">rmax</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">long</span> <span class="variable">rmin</span> <span class="operator">=</span> min;</span><br><span class="line">    max = Math.max(Math.max(lmax,rmax),root.val);</span><br><span class="line">    min = Math.min(Math.min(lmin,rmin),root.val);</span><br><span class="line">    <span class="keyword">return</span> lok &amp;&amp; rok &amp;&amp; root.val &gt; lmax &amp;&amp; root.val&lt; rmin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树相关的题目&quot;&gt;&lt;a href=&quot;#二叉树相关的题目&quot; class=&quot;headerlink&quot; title=&quot;二叉树相关的题目&quot;&gt;&lt;/a&gt;二叉树相关的题目&lt;/h1&gt;&lt;h2 id=&quot;层序遍历&quot;&gt;&lt;a href=&quot;#层序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DDD领域事件的最佳实践</title>
    <link href="https://nmcb666.vip/posts/8f3b837f.html"/>
    <id>https://nmcb666.vip/posts/8f3b837f.html</id>
    <published>2026-01-16T23:59:31.000Z</published>
    <updated>2026-01-28T18:22:02.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考"><a href="#DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考" class="headerlink" title="DDD 实战：关于领域事件（Domain Events）的设计抉择与工程落地思考"></a>DDD 实战：关于领域事件（Domain Events）的设计抉择与工程落地思考</h1><p>在领域驱动设计（DDD）的战术落地过程中，<strong>领域事件（Domain Event）</strong> 是连接各个子域、聚合以及限界上下文的“胶水”。它不仅解耦了复杂的业务逻辑，更是实现“最终一致性”架构的关键手段。</p><p>本文基于实际开发经验，总结领域事件的建模、生成、发布及可靠性投递的最佳实践，并探讨不同方案背后的权衡。</p><hr><h2 id="一、-什么是领域事件？"><a href="#一、-什么是领域事件？" class="headerlink" title="一、 什么是领域事件？"></a>一、 什么是领域事件？</h2><p>简单来说，领域事件是<strong>聚合内已发生的业务事实</strong>。</p><ul><li><strong>业务事实</strong>：意味着它是过去式。比如“用户已注册”、“订单已支付”。</li><li><strong>命名规范</strong>：推荐使用 <code>动词过去式</code>（如 <code>OrderPaid</code>, <code>AccountActivated</code>）。</li><li><strong>价值</strong>：<ol><li><strong>解耦</strong>：核心业务逻辑不需要知道谁在关注它。</li><li><strong>副作用处理</strong>：触发通知、大数据分析、报表生成等非核心逻辑。</li><li><strong>数据一致性</strong>：跨聚合、跨服务的状态同步。</li></ol></li></ul><hr><h2 id="二、-建模：胖消息-vs-瘦消息"><a href="#二、-建模：胖消息-vs-瘦消息" class="headerlink" title="二、 建模：胖消息 vs 瘦消息"></a>二、 建模：胖消息 vs 瘦消息</h2><p>领域事件通常被建模为<strong>不可变的值对象（Value Object）</strong>。但在设计消息体（Payload）时，我们面临一个经典抉择：</p><h3 id="1-瘦消息（Id-Only）"><a href="#1-瘦消息（Id-Only）" class="headerlink" title="1. 瘦消息（Id-Only）"></a>1. 瘦消息（Id-Only）</h3><p>消息体仅包含最基础的元数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MobileChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;entityId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eventId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uuid-001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eventTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1654156165&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>优点</strong>：消息极小，传输快。</li><li><strong>缺点</strong>：消费者（Subscriber）必须拿着 <code>entityId</code> 反查聚合根信息，导致<strong>读放大</strong>。</li></ul><h3 id="2-胖消息（Event-Enrichment-事件增强）"><a href="#2-胖消息（Event-Enrichment-事件增强）" class="headerlink" title="2. 胖消息（Event Enrichment / 事件增强）"></a>2. 胖消息（Event Enrichment / 事件增强）</h3><p>消息体包含消费者所需的业务数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MobileChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;beforeMobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13800000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;afterMobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18100000000&quot;</span> <span class="comment">// 增强字段</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>优点</strong>：消费者完全自治，无需反查，降低源端系统压力。</li><li><strong>缺点</strong>：消息体较大；可能包含消费者不应关心的敏感数据；存在数据时效性问题（如果消费者处理慢，消息里的数据可能是旧的）。</li></ul><blockquote><p><strong>💡 思考与建议</strong>：<br>在微服务架构下，为了减少跨服务调用带来的耦合与延迟，<strong>推荐适度的“事件增强”</strong>。即：包含消费者处理业务所必须的核心字段，而不是把整个聚合根都塞进去。</p></blockquote><hr><h2 id="三、-生成：如何优雅地创建事件？"><a href="#三、-生成：如何优雅地创建事件？" class="headerlink" title="三、 生成：如何优雅地创建事件？"></a>三、 生成：如何优雅地创建事件？</h2><p>在代码层面，何处创建、何处发布事件，直接影响代码的整洁度（Clean Code）。我们对比四种常见方案：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方案</th><th style="text-align:left">描述</th><th style="text-align:left">评价</th><th style="text-align:left">建议</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. Service层创建</strong></td><td style="text-align:left">业务执行完后，手动 <code>new Event()</code> 并发布</td><td style="text-align:left"><strong>简单粗暴</strong>。适合贫血模型，但容易导致Service层逻辑膨胀，容易遗漏。</td><td style="text-align:left">⭐️⭐️</td></tr><tr><td style="text-align:left"><strong>2. 聚合根依赖Infra</strong></td><td style="text-align:left">聚合根注入 <code>Publisher</code>，内部直接发布</td><td style="text-align:left"><strong>反模式</strong>。聚合根不应依赖基础设施，破坏了POJO的纯净性，且导致单一职责问题。</td><td style="text-align:left">🚫</td></tr><tr><td style="text-align:left"><strong>3. 聚合根返回事件</strong></td><td style="text-align:left">方法签名改为 <code>List&lt;Event&gt; doSomething()</code></td><td style="text-align:left"><strong>侵入性强</strong>。强行改变了业务方法签名，调用方处理繁琐。</td><td style="text-align:left">⭐️</td></tr><tr><td style="text-align:left"><strong>4. 聚合根暂存 + 抽取</strong></td><td style="text-align:left">聚合根内部 <code>List</code> 暂存，Repo保存时抽取</td><td style="text-align:left"><strong>最佳实践</strong>。保证了聚合根的纯净，同时利用基础设施层自动化处理发布，业务无感知。</td><td style="text-align:left">⭐️⭐️⭐️⭐️</td></tr></tbody></table></div><h3 id="推荐方案代码示例"><a href="#推荐方案代码示例" class="headerlink" title="推荐方案代码示例"></a>推荐方案代码示例</h3><p><strong>抽象聚合根基类：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAggregateRoot</span> &#123;</span><br><span class="line">    <span class="comment">// 暂存事件，不持久化到业务表</span></span><br><span class="line">    <span class="meta">@Transient</span> </span><br><span class="line">    <span class="keyword">private</span> List&lt;DomainEvent&gt; domainEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerEvent</span><span class="params">(DomainEvent event)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domainEvents.add(event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供给基础设施层调用</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;DomainEvent&gt; <span class="title function_">pollEvents</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;DomainEvent&gt; events = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.domainEvents);</span><br><span class="line">        <span class="built_in">this</span>.domainEvents.clear();</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>业务聚合根：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractAggregateRoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMobile</span><span class="params">(String newMobile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mobile = newMobile;</span><br><span class="line">        <span class="comment">// 仅仅是注册，不涉及IO操作</span></span><br><span class="line">        registerEvent(<span class="keyword">new</span> <span class="title class_">MobileChangedEvent</span>(<span class="built_in">this</span>.id, newMobile));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="四、-可靠投递：分布式事务的噩梦"><a href="#四、-可靠投递：分布式事务的噩梦" class="headerlink" title="四、 可靠投递：分布式事务的噩梦"></a>四、 可靠投递：分布式事务的噩梦</h2><p>最核心的工程难题在于：<strong>Database保存</strong> 与 <strong>MQ消息发送</strong> 是两个独立的操作。<br>如果 DB 提交了，但 MQ 挂了（或者反过来），就会导致数据不一致。</p><p>为了解决这个问题，我们必须引入<strong>本地消息表（Transactional Outbox Pattern）</strong>。</p><h3 id="1-核心机制"><a href="#1-核心机制" class="headerlink" title="1. 核心机制"></a>1. 核心机制</h3><p>利用关系型数据库的本地事务（ACID），将“业务数据保存”和“事件数据保存”放在同一个事务中提交。</p><ul><li><strong>Step 1</strong>: 开启事务。</li><li><strong>Step 2</strong>: Update 业务表。</li><li><strong>Step 3</strong>: Insert into <code>t_event</code> (状态：PENDING)。</li><li><strong>Step 4</strong>: 提交事务。</li></ul><p>此时，业务操作和事件记录要么同时成功，要么同时失败。</p><h3 id="2-发送与补偿策略"><a href="#2-发送与补偿策略" class="headerlink" title="2. 发送与补偿策略"></a>2. 发送与补偿策略</h3><p>保存到 <code>t_event</code> 后，如何发到 MQ？</p><ul><li><strong>方案 A：应用直接发 + 轮询补偿（适合中小规模）</strong><ul><li>应用在事务提交后，直接异步发送 MQ。发送成功则更新 <code>t_event</code> 为 <code>PUBLISHED</code>。</li><li>后台启动定时任务（Worker），扫描 <code>t_event</code> 中超过 1 分钟仍为 <code>PENDING</code> 的记录，进行重试。</li><li><em>缺点</em>：增加了数据库查询压力。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EventJdbcRepository eventJdbcRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span> <span class="params">(Command cmd)</span> &#123;</span><br><span class="line">        <span class="type">AggregateRoot</span> <span class="variable">root</span> <span class="operator">=</span> repository.load(bizId);</span><br><span class="line">        entity.doBusiness(cmd.getValue());</span><br><span class="line">        repository.save(root);</span><br><span class="line">        <span class="comment">// 发布领域事件</span></span><br><span class="line">        List&lt;DomainEvent&gt; domainEvents = entity.getDomainEvents();</span><br><span class="line">        publisher.publish(domainEvents);</span><br><span class="line">        <span class="comment">// 通过事件的EntityId更新EventStore中事件的状态为已发布</span></span><br><span class="line">        List&lt;String&gt; eventIds = domainEvents.stream()</span><br><span class="line">        .map(e-&gt;e.getEventId())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">     eventJdbcRepository.publishSuccess(eventIds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 1.扫描数据库超时未发布成功的领域事件</span></span><br><span class="line">    <span class="comment">// TODO 2.发布领域事件到消息中间件</span></span><br><span class="line">    <span class="comment">// TODO 3.修改数据库领域事件发布状态为已发布</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>方案 B：事务日志拖尾 / CDC（适合大规模）</strong><ul><li>应用只管写库，不发消息。</li><li>利用 <strong>Canal / Debezium</strong> 监听数据库的 Binlog。</li><li>CDC 组件解析 Binlog 中的 <code>t_event</code> 插入记录，自动投递到 MQ。</li><li><em>优点</em>：应用层完全解耦，性能极高。</li></ul></li></ul><hr><h2 id="五、-订阅：归属于哪一层？"><a href="#五、-订阅：归属于哪一层？" class="headerlink" title="五、 订阅：归属于哪一层？"></a>五、 订阅：归属于哪一层？</h2><p>在 DDD 的分层架构中，事件订阅者（Subscriber/Listener）应该放在哪里？</p><p><strong>结论：用户接口层（User Interface / Adapters Layer）。</strong></p><ul><li><strong>理由</strong>：订阅 MQ 消息本质上和 Controller 接收 HTTP 请求是一样的。它们都是外部世界的输入（Input）。</li><li><strong>流程</strong>：<ol><li>Subscriber 接收 JSON 消息。</li><li>反序列化为 DTO。</li><li><strong>调用 Application Service</strong> 执行具体的业务命令。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 领域事件订阅者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DomainEventSubscriber</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> ApplicationService applicationService;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@KafkaListener(topics = &quot;domain_event_topic&quot;,groupId = &quot;local_consumer_group_id&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span> <span class="params">(String event)</span> &#123;</span><br><span class="line">            <span class="comment">// 解析得到领域事件</span></span><br><span class="line">            <span class="type">DomainEvent</span> <span class="variable">domainEvent</span> <span class="operator">=</span> JSON.parse(event,DomainEvent.class);</span><br><span class="line">            <span class="comment">// 拼装Command</span></span><br><span class="line">            <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="built_in">this</span>.toCommand(domainEvent);</span><br><span class="line">            <span class="comment">// 应用层执行领域模型状态变更</span></span><br><span class="line">            applicationService.handleCommand(command);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="幂等性（Idempotency）"><a href="#幂等性（Idempotency）" class="headerlink" title="幂等性（Idempotency）"></a>幂等性（Idempotency）</h3><p>由于网络抖动或重试机制，消费者必然会收到重复消息。<strong>必须</strong>利用 <code>event_id</code> 建立唯一索引或去重表，确保同一业务逻辑不执行两次。</p><hr><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>领域事件的设计不仅仅是技术实现，更是一种将<strong>业务流程显性化</strong>的手段。</p><ol><li><strong>设计上</strong>：优先选择 <strong>“聚合根暂存 + 基础设施抽取”</strong> 的生成模式，保持领域纯净。</li><li><strong>数据上</strong>：权衡消息大小，推荐使用 <strong>增强型事件</strong> 减少下游依赖。</li><li><strong>架构上</strong>：必须正视分布式一致性问题，<strong>本地消息表</strong> 是实现可靠投递的基石。</li></ol><p>DDD 的路途虽远，但只要处理好领域事件，系统的解耦与演进就会变得从容许多。</p><p>最后有关于领域事件跟事件回溯以及CQRS的结合可以看专门的文章。 CQRS与DDD: <a href="https://juejin.cn/post/7510057969265115146">https://juejin.cn/post/7510057969265115146</a> , 领域事件与事件回溯：<a href="https://juejin.cn/post/7510120678847184906">https://juejin.cn/post/7510120678847184906</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考&quot;&gt;&lt;a href=&quot;#DDD-实战：关于领域事件（Domain-Events）的设计抉择与工程落地思考&quot; class=&quot;headerlink&quot; title=&quot;DDD 实战：关于领域事</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（三) 链表</title>
    <link href="https://nmcb666.vip/posts/73873447.html"/>
    <id>https://nmcb666.vip/posts/73873447.html</id>
    <published>2026-01-16T16:06:09.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表相关的题目"><a href="#链表相关的题目" class="headerlink" title="链表相关的题目"></a>链表相关的题目</h1><p>这里用来记录链表相关的题目以及思路</p><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>思路：每k个翻转一次，可以单独进行反转，但注意上一组的尾节点和下一组的头节点要连接起来，所以需要记录上一组尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> teamEnd(start, k);</span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一组很特殊因为牵扯到换头的问题</span></span><br><span class="line">head = end;</span><br><span class="line">reverse(start, end);</span><br><span class="line"><span class="comment">// 翻转之后start变成了上一组的结尾节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">lastTeamEnd</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="keyword">while</span> (lastTeamEnd.next != <span class="literal">null</span>) &#123;</span><br><span class="line">start = lastTeamEnd.next;</span><br><span class="line">end = teamEnd(start, k);</span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">reverse(start, end);</span><br><span class="line">lastTeamEnd.next = end; <span class="comment">// 上一组结尾节点要连接下一组头节点</span></span><br><span class="line">lastTeamEnd = start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前组的开始节点是s，往下数k个找到当前组的结束节点返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">teamEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; s != <span class="literal">null</span>) &#123;</span><br><span class="line">s = s.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s -&gt; a -&gt; b -&gt; c -&gt; e -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment">// 上面的链表通过如下的reverse方法调整成 : e -&gt; c -&gt; b -&gt; a -&gt; s -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode s, ListNode e)</span> &#123;</span><br><span class="line">e = e.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = s, next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line">next = cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">s.next = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>思路：将每个节点复制一份，并把复制的节点放在原节点后面，比如1-&gt;2-&gt;3-&gt;4-&gt;5，复制之后变成1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;4-&gt;4’-&gt;5-&gt;5’，然后遍历链表，将复制的节点的random指针指向原节点的random指针指向的节点的下一个节点。最后将链表拆分，返回新链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span>head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将链表复制串联</span></span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">Node</span>(pre.val);</span><br><span class="line">        pre.next.next = next;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将random进行复制</span></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next.next;</span><br><span class="line">        pre.next.random = pre.random == <span class="literal">null</span> ? <span class="literal">null</span> : pre.random.next;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离两个链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newPre</span> <span class="operator">=</span> newHead;</span><br><span class="line">    pre =head;</span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = pre.next.next;</span><br><span class="line">        newPre.next = next == <span class="literal">null</span> ? <span class="literal">null</span> : next.next ;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        pre =next;</span><br><span class="line">        newPre = newPre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h2><p>思路：利用快慢指针，找到中点，然后翻转后半部分链表，比较前后两个链表是否相等。最后恢复链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//利用快慢指针找到中点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">man</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">kuai</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (kuai.next != <span class="literal">null</span> &amp;&amp; kuai.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        man = man.next;</span><br><span class="line">        kuai = kuai.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> reverseList(man);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isPal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reversePre</span> <span class="operator">=</span>reverseHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(reversePre!=<span class="literal">null</span> &amp;&amp; pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.val!=reversePre.val)&#123;</span><br><span class="line">            isPal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reversePre = reversePre.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表还原</span></span><br><span class="line">    reverseList(reverseHead);</span><br><span class="line">    <span class="keyword">return</span> isPal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next =head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre =head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表是否存在环-并求环的入口节点"><a href="#链表是否存在环-并求环的入口节点" class="headerlink" title="链表是否存在环 并求环的入口节点"></a>链表是否存在环 并求环的入口节点</h2><p>思路：利用快慢指针，快指针每次移动两步，慢指针每次移动一步，如果快慢指针相遇，则说明链表有环，否则没有环。相遇的时候，快指针回到头节点，慢指针继续移动，但是慢指针和快指针每次都移动一步，再次相遇的时候就是环的入口节点。 a+(nb+c) = 2(a+c)  a = nb - c  所以慢指针再走a步，就能到达入口节点。此时快指针也走a步，慢指针和快指针相遇的节点就是入口节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span>head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>要求：时间复杂度nlog(n),空间复杂度O(1)，且稳定<br>思路：利用非递归版本的归并排序，并且merge是合并两个有序链表。<br>代码很复杂，看看就好<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n*logn)，额外空间复杂度O(1)，有稳定性</span></span><br><span class="line"><span class="comment">// 注意为了额外空间复杂度O(1)，所以不能使用递归</span></span><br><span class="line"><span class="comment">// 因为mergeSort递归需要O(log n)的额外空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">n++;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l1...r1 每组的左部分</span></span><br><span class="line"><span class="comment">// l2...r2 每组的右部分</span></span><br><span class="line"><span class="comment">// next 下一组的开头</span></span><br><span class="line"><span class="comment">// lastTeamEnd 上一组的结尾</span></span><br><span class="line">ListNode l1, r1, l2, r2, next, lastTeamEnd;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 第一组很特殊，因为要决定整个链表的头，所以单独处理</span></span><br><span class="line">l1 = head;</span><br><span class="line">r1 = findEnd(l1, step);</span><br><span class="line">l2 = r1.next;</span><br><span class="line">r2 = findEnd(l2, step);</span><br><span class="line">next = r2.next;</span><br><span class="line">r1.next = <span class="literal">null</span>;</span><br><span class="line">r2.next = <span class="literal">null</span>;</span><br><span class="line">merge(l1, r1, l2, r2);</span><br><span class="line">head = start;</span><br><span class="line">lastTeamEnd = end;</span><br><span class="line"><span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">l1 = next;</span><br><span class="line">r1 = findEnd(l1, step);</span><br><span class="line">l2 = r1.next;</span><br><span class="line"><span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">lastTeamEnd.next = l1;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">r2 = findEnd(l2, step);</span><br><span class="line">next = r2.next;</span><br><span class="line">r1.next = <span class="literal">null</span>;</span><br><span class="line">r2.next = <span class="literal">null</span>;</span><br><span class="line">merge(l1, r1, l2, r2);</span><br><span class="line">lastTeamEnd.next = start;</span><br><span class="line">lastTeamEnd = end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括s在内，往下数k个节点返回</span></span><br><span class="line"><span class="comment">// 如果不够，返回最后一个数到的非空节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (s.next != <span class="literal">null</span> &amp;&amp; --k != <span class="number">0</span>) &#123;</span><br><span class="line">s = s.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l1...r1 -&gt; null : 有序的左部分</span></span><br><span class="line"><span class="comment">// l2...r2 -&gt; null : 有序的右部分</span></span><br><span class="line"><span class="comment">// 整体merge在一起，保证有序</span></span><br><span class="line"><span class="comment">// 并且把全局变量start设置为整体的头，全局变量end设置为整体的尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode r1, ListNode l2, ListNode r2)</span> &#123;</span><br><span class="line">ListNode pre;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">start = l1;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = l2;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">pre.next = l1;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre.next = l2;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">pre.next = l1;</span><br><span class="line">end = r1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre.next = l2;</span><br><span class="line">end = r2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h2><p>思路：利用双向链表和HashMap，双向链表负责维护最久未使用的顺序（最久未使用放到头节点，只要使用就放到尾节点）（实现三个功能 1.加入节点(直接放入尾部)，2.将已经有的节点放入尾部，3.删除头节点），HashMap实现快速查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Listnode</span>&#123;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            Listnode last;</span><br><span class="line">            Listnode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Listnode</span><span class="params">(<span class="type">int</span> val,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.val =val;</span><br><span class="line">                <span class="built_in">this</span>.key =key;</span><br><span class="line">                last =<span class="literal">null</span>;</span><br><span class="line">                next =<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">doubleList</span>&#123;</span><br><span class="line">            Listnode head;</span><br><span class="line">            Listnode tail;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">doubleList</span><span class="params">()</span>&#123;</span><br><span class="line">                head =<span class="literal">null</span>;</span><br><span class="line">                tail =<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Listnode node)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">                    head = node;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tail.next = node;</span><br><span class="line">                    node.last = tail;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNode2Tail</span><span class="params">(Listnode node)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (tail == node) &#123;  <span class="comment">/// 如果是最后一个节点，则不需要移动</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">                    head = node.next;</span><br><span class="line">                    head.last =<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    node.last.next = node.next;</span><br><span class="line">                    node.next.last = node.last;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tail.next = node;</span><br><span class="line">                node.last = tail;</span><br><span class="line">                node.next = <span class="literal">null</span>;</span><br><span class="line">                tail =node;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Listnode <span class="title function_">delHead</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">h</span> <span class="operator">=</span>head;</span><br><span class="line">                <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">                    head = <span class="literal">null</span>;</span><br><span class="line">                    tail =<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Listnode</span> <span class="variable">next</span> <span class="operator">=</span>head.next;</span><br><span class="line">                    head.next = <span class="literal">null</span>;</span><br><span class="line">                    head = next;</span><br><span class="line">                    head.last = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer,Listnode&gt; myMap;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">MaxCap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> doubleList myList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cap = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.MaxCap = capacity;</span><br><span class="line">            myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Listnode&gt;();</span><br><span class="line">            myList = <span class="keyword">new</span> <span class="title class_">doubleList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(key))&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> myMap.get(key);</span><br><span class="line">                myList.moveNode2Tail(node);</span><br><span class="line">                <span class="keyword">return</span> node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.containsKey(key))&#123;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> myMap.get(key);</span><br><span class="line">                node.val = value;</span><br><span class="line">                myList.moveNode2Tail(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cap == MaxCap)&#123;</span><br><span class="line">                    myMap.remove(myList.delHead().key);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    cap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Listnode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Listnode</span>(value,key);</span><br><span class="line">                myMap.put(key,node);</span><br><span class="line">                myList.addNode(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表相关的题目&quot;&gt;&lt;a href=&quot;#链表相关的题目&quot; class=&quot;headerlink&quot; title=&quot;链表相关的题目&quot;&gt;&lt;/a&gt;链表相关的题目&lt;/h1&gt;&lt;p&gt;这里用来记录链表相关的题目以及思路&lt;/p&gt;
&lt;h2 id=&quot;相交链表&quot;&gt;&lt;a href=&quot;#相交链表</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务相关的总结</title>
    <link href="https://nmcb666.vip/posts/fee9ca7b.html"/>
    <id>https://nmcb666.vip/posts/fee9ca7b.html</id>
    <published>2026-01-15T14:13:30.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="TC-如何知道哪些RM属于同一个全局事务？"><a href="#TC-如何知道哪些RM属于同一个全局事务？" class="headerlink" title="TC 如何知道哪些RM属于同一个全局事务？"></a>TC 如何知道哪些RM属于同一个全局事务？</h3><p>以Seate框架为例，在TM向TC发送全局事务开始时，TC会生成对应的全局事务ID（XID），并发送给TM。TM 将 XID 放入当前线程的 ThreadLocal 中，后续的 RM (资源管理器) 分支事务通过解析该 XID 来注册分支。如果涉及RPC调用，每次调用时会在请求头部传递这个XID，让RM知道这个XID,RM向TC发送分支事务开始时,就会携带这个XID,从而告诉TC这个RM属于哪一个全局事务。</p><p>在多线程中，由于每个线程的XID是线程私有的，所以无法确定哪些RM属于同一个全局事务。这时全局事务会失效。解决方案可以是在开启新线程时，将XID传递给新线程，新线程的XID会继承父线程的XID。这样子线程的XID就会和父线程的XID一致，从而可以确定哪些RM属于同一个全局事务。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-15%20142842.png" alt="流程图片"/></div><span class="image-caption">流程图片</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h2&gt;&lt;h3 id=&quot;TC-如何知道哪些RM属于同一个全局事务？&quot;&gt;&lt;a href=&quot;#TC-如何知道哪些RM属于同一个全局事务</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>DDD与MVC的统一</title>
    <link href="https://nmcb666.vip/posts/f4b47790.html"/>
    <id>https://nmcb666.vip/posts/f4b47790.html</id>
    <published>2026-01-11T18:50:35.000Z</published>
    <updated>2026-01-28T18:22:02.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC到DDD：从架构分层到业务建模的思考"><a href="#MVC到DDD：从架构分层到业务建模的思考" class="headerlink" title="MVC到DDD：从架构分层到业务建模的思考"></a>MVC到DDD：从架构分层到业务建模的思考</h1><p>在后端开发学习和实践过程中，我们总会被各种架构模式和设计思想围绕——MVC、Service+DAO分层、DDD四层架构（DDD并非与四层架构绑定 DDD是思想，四层架构是代码落地的一个架构）……这些概念之间到底是替代关系还是互补关系？为什么简单业务用Service+DAO就够，复杂业务却要引入DDD？结合近期的学习思考，我想梳理清楚这些架构之间的核心关联，帮自己（也希望帮到同样困惑的同学）建立清晰的认知。</p><h2 id="一、起点：MVC的核心价值——解决“代码放哪”的基础问题"><a href="#一、起点：MVC的核心价值——解决“代码放哪”的基础问题" class="headerlink" title="一、起点：MVC的核心价值——解决“代码放哪”的基础问题"></a>一、起点：MVC的核心价值——解决“代码放哪”的基础问题</h2><p>最早接触后端开发时，MVC是绕不开的入门架构。它的核心思想非常简单：将软件分为三个核心层级，实现“展示与逻辑”的初步解耦。</p><ul><li><p><strong>Controller（控制器）</strong>：接收用户请求、协调后续处理、返回响应，相当于系统的“入口/出口”，不承载核心业务逻辑；</p></li><li><p><strong>Model（模型）</strong>：封装数据和核心业务逻辑，是系统的“大脑”，负责数据的增删改查和业务规则校验；</p></li><li><p><strong>View（视图）</strong>：展示数据，与用户直接交互（前后端分离场景下，前端页面即View层，后端不再关注）。</p></li></ul><p>MVC的价值在于给出了“代码该放哪”的明确答案，解决了早期开发中“业务逻辑与页面展示混在一起”的混乱问题。但它的局限性也很明显：Model层是一个“大黑盒”，没有明确的内部划分标准——当业务简单时，一个Service+Mapper就能撑起Model层；但当业务复杂（比如电商订单履约、金融风控）时，直接把所有逻辑堆在Service里，很快就会导致代码臃肿、逻辑混乱、难以维护。</p><h2 id="二、演进：Service-DAO分层——MVC-Model层的简易拆分"><a href="#二、演进：Service-DAO分层——MVC-Model层的简易拆分" class="headerlink" title="二、演进：Service+DAO分层——MVC Model层的简易拆分"></a>二、演进：Service+DAO分层——MVC Model层的简易拆分</h2><p>为了弥补MVC Model层的模糊性，在Spring生态实践中，我们自然演化出了“Controller+Service+DAO（Mapper）”的三层落地方案。这本质上是对MVC的Model层做了第一次“粗粒度拆分”，让职责更清晰：</p><ul><li><p><strong>Controller层</strong>：完全对应MVC的Controller层，负责请求接收、参数简单校验、调用Service层；</p></li><li><p><strong>Service层</strong>：对应MVC Model层的“业务逻辑核心”，实现订单支付、库存扣减等核心业务规则；</p></li><li><p><strong>DAO（Mapper）层</strong>：对应MVC Model层的“数据访问部分”，仅负责与数据库交互，不包含任何业务逻辑。</p></li></ul><p>这种拆分方案简单直观、开发效率高，非常适合简单CRUD场景（比如小型管理后台、个人工具）。但它的问题在复杂业务场景下会暴露无遗：Service层很容易变成“万能层”——既要处理跨实体的业务逻辑（比如支付需要协调订单、库存、支付三个模块），又要兼顾事务控制、数据组装等辅助逻辑，最终导致Service层代码臃肿、逻辑缠绕，后续迭代和维护成本极高。</p><h2 id="三、进阶：DDD四层架构——MVC-Model层的精细化升级"><a href="#三、进阶：DDD四层架构——MVC-Model层的精细化升级" class="headerlink" title="三、进阶：DDD四层架构——MVC Model层的精细化升级"></a>三、进阶：DDD四层架构——MVC Model层的精细化升级</h2><p>当业务复杂度上升到一定程度，DDD（领域驱动设计）就成了更优的选择。很多人会误以为DDD是“替代MVC”的架构，其实不然——DDD本质上是一套“业务建模方法论”，它在MVC的大框架下，对Model层做了更精细的拆分，让复杂业务逻辑更清晰、更贴合业务本身。</p><p>DDD提出的四层架构（用户层/接口层、应用层、领域层、基础设施层），与MVC、Service+DAO分层的对应关系非常清晰，核心结论先抛出来：<strong>DDD的用户层对应MVC的Controller层，后三层共同构成MVC的Model层；DDD与MVC完全兼容，只是对Model层的拆分更彻底</strong>。</p><h3 id="1-DDD四层架构的核心职责与对应关系"><a href="#1-DDD四层架构的核心职责与对应关系" class="headerlink" title="1. DDD四层架构的核心职责与对应关系"></a>1. DDD四层架构的核心职责与对应关系</h3><div class="table-container"><table><thead><tr><th>DDD四层架构</th><th>核心职责</th><th>对应MVC分层</th><th>对应Service+DAO分层</th><th>Spring实践落地</th></tr></thead><tbody><tr><td>用户层（接口层）</td><td>接收外部请求（HTTP/RPC/消息）、返回响应、参数非业务校验、权限拦截</td><td>Controller层</td><td>Controller层</td><td>@RestController、ControllerAdvice、RPC接口</td></tr><tr><td>应用层</td><td>协调领域层执行、处理事务、组装返回数据，无核心业务逻辑</td><td>Model层</td><td>Service层的“协调部分”</td><td>XXXApplicationService（应用服务）</td></tr><tr><td>领域层</td><td>封装核心业务规则、聚合根/实体/值对象、跨实体业务逻辑，系统核心</td><td>Model层（核心）</td><td>Service层的“核心业务部分”</td><td>聚合根（Entity）、XXXDomainService（领域服务）</td></tr><tr><td>基础设施层</td><td>封装技术细节（数据库、缓存、第三方接口），为上层提供技术支撑</td><td>Model层</td><td>DAO（Mapper）层</td><td>Repository、Mapper、RedisTemplate、Feign客户端</td></tr></tbody></table></div><h3 id="2-关键演进：从Service层到“应用服务-领域服务”"><a href="#2-关键演进：从Service层到“应用服务-领域服务”" class="headerlink" title="2. 关键演进：从Service层到“应用服务+领域服务”"></a>2. 关键演进：从Service层到“应用服务+领域服务”</h3><p>DDD对Service+DAO分层的核心优化，就是把传统“厚Service”拆成了“薄应用服务”和“厚领域服务”，让业务逻辑的归属更明确：</p><ul><li><p><strong>领域服务</strong>：只负责核心业务逻辑，比如“订单支付”需要校验订单状态、扣减库存、更新支付状态等跨实体逻辑，都放在领域服务；</p></li><li><p><strong>应用服务</strong>：不碰核心业务，只做“协调工作”——比如开启事务、调用领域服务、把领域层的结果组装成前端需要的格式。</p></li></ul><p>同时，DDD还强调“业务驱动建模”：先梳理业务领域的规则（比如“未支付订单24小时自动取消”），再把这些规则封装到实体类中（比如Order实体的canPay()、markAsPaid()方法），而不是像传统Service+DAO那样，把所有业务逻辑都写在Service的if-else里。这种方式让代码更贴合业务，后续迭代时也更容易理解和修改。</p><h2 id="四、核心认知：所有架构的本质都是“解耦”，只是粒度不同"><a href="#四、核心认知：所有架构的本质都是“解耦”，只是粒度不同" class="headerlink" title="四、核心认知：所有架构的本质都是“解耦”，只是粒度不同"></a>四、核心认知：所有架构的本质都是“解耦”，只是粒度不同</h2><p>梳理完从MVC到Service+DAO，再到DDD的演进脉络，会发现一个核心规律：<strong>所有架构分层的最终目标都是“解耦”，只是针对不同业务复杂度，选择了不同的拆分粒度</strong>。</p><ul><li><p>MVC：解决“展示与逻辑”的解耦，给出最基础的分层框架；</p></li><li><p>Service+DAO：解决MVC Model层的内部解耦，让数据访问和业务逻辑分离，适配简单业务；</p></li><li><p>DDD：解决复杂业务下Model层的深度解耦，让核心业务逻辑、协调逻辑、技术细节彻底分离，适配复杂业务。</p></li></ul><p>很多人会误以为“DDD比MVC高级”“用了DDD就不能用MVC”，这其实是误区。DDD和MVC不是对立关系，而是互补关系——MVC提供了整体的架构骨架，DDD则是对这个骨架中“Model层”的精细化设计指南。</p><h2 id="五、实践建议：根据业务复杂度选择合适的架构"><a href="#五、实践建议：根据业务复杂度选择合适的架构" class="headerlink" title="五、实践建议：根据业务复杂度选择合适的架构"></a>五、实践建议：根据业务复杂度选择合适的架构</h2><p>架构没有“最优解”，只有“最合适”。结合自己的实践经验，给出几点选择建议：</p><ol><li><p><strong>简单CRUD场景（小型管理后台、个人工具）</strong>：直接用“Controller+Service+DAO”，开发效率高、维护成本低，没必要过度设计；</p></li><li><p><strong>中等复杂度场景（常规业务系统）</strong>：可以借鉴DDD的思想，在Service层内部做简单拆分（比如把核心业务逻辑抽成单独的方法或类），避免Service层臃肿；</p></li><li><p><strong>高复杂度场景（电商、金融、供应链）</strong>：推荐使用DDD四层架构，通过领域建模让复杂业务逻辑更清晰，为长期迭代打下基础；</p></li><li><p><strong>渐进式改造</strong>：不用一开始就全盘重构为DDD，可以从“拆分Service层”开始，先把核心业务逻辑抽成领域服务，再逐步完善应用层和基础设施层，降低改造风险。</p></li></ol><h2 id="六、DDD跟四层架构什么关系？"><a href="#六、DDD跟四层架构什么关系？" class="headerlink" title="六、DDD跟四层架构什么关系？"></a>六、DDD跟四层架构什么关系？</h2><p>DDD（领域驱动设计）本身不强制规定 “四层架构”。DDD 的核心在于战略设计（限界上下文、领域模型）和战术设计（实体、值对象、聚合根、领域服务、仓储等），而 “四层架构” 确实是为了让这些战术设计模式在代码层面更好落地而总结出的一套经典工程实践。</p><p>在实际落地 DDD 时，代码架构的选择确实非常重要。虽然 DDD 是一种思想，不强求特定目录结构，但业界已经沉淀出两套最主流的架构模式：</p><ol><li><strong>经典的四层架构（Layered Architecture）</strong> —— 最容易理解，适合起步。</li><li><strong>整洁/六边形架构（Clean / Hexagonal Architecture）</strong> —— 依赖倒置更彻底，现代微服务主流。</li></ol><p>此外，国内 Java 圈（特别是阿里系）还常用 <strong>COLA 架构</strong>。</p><p>下面详细拆解这几种架构的代码目录结构和核心要点。</p><hr><h3 id="方案一：经典的四层架构-Standard-4-Layer"><a href="#方案一：经典的四层架构-Standard-4-Layer" class="headerlink" title="方案一：经典的四层架构 (Standard 4-Layer)"></a>方案一：经典的四层架构 (Standard 4-Layer)</h3><p>这是最符合上文所提出观点的理解的结构，结构清晰，适合从三层架构转型过来的团队。</p><h4 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h4><p><strong>依赖倒置（DIP）</strong>：虽然物理上是四层，但在逻辑上，<strong>领域层（Domain）必须是独立的</strong>。</p><ul><li><strong>错误的做法</strong>：Domain 层 <code>import</code> Infrastructure 层的代码。</li><li><strong>正确的做法</strong>：Domain 层定义接口（Repository Interface），Infrastructure 层去实现它。</li></ul><h4 id="目录结构示例"><a href="#目录结构示例" class="headerlink" title="目录结构示例"></a>目录结构示例</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.company.project</span><br><span class="line">├── interfaces (用户接口层 / Web)</span><br><span class="line">│   ├── controller       // 处理 HTTP 请求</span><br><span class="line">│   └── dto              // 数据传输对象 (Request/Response)</span><br><span class="line">├── application (应用层)</span><br><span class="line">│   ├── service          // 应用服务 (流程编排)</span><br><span class="line">│   └── assembler        // DTO 与 Entity 的转换器</span><br><span class="line">├── domain (领域层 - 核心)</span><br><span class="line">│   ├── model            // 聚合根、实体、值对象</span><br><span class="line">│   │   ├── aggregate    // 聚合</span><br><span class="line">│   │   └── entity       // 实体</span><br><span class="line">│   ├── service          // 领域服务 (跨实体逻辑)</span><br><span class="line">│   └── repository       // 仓储接口 (注意：这里只放接口！)</span><br><span class="line">└── infrastructure (基础设施层)</span><br><span class="line">    ├── repository       // 仓储实现 (Impl，这里依赖 JPA/MyBatis)</span><br><span class="line">    ├── entity           // PO (Persistent Object，对应数据库表)</span><br><span class="line">    └── util             // 通用工具</span><br></pre></td></tr></table></figure><hr><h3 id="方案二：整洁架构-六边形架构-Clean-Hexagonal"><a href="#方案二：整洁架构-六边形架构-Clean-Hexagonal" class="headerlink" title="方案二：整洁架构 / 六边形架构 (Clean / Hexagonal)"></a>方案二：整洁架构 / 六边形架构 (Clean / Hexagonal)</h3><p>这是目前 DDD 社区<strong>最推荐</strong>的架构，特别是在微服务场景下。它不再强调“上下层”，而是强调“<strong>内外</strong>”。</p><ul><li><strong>内核（Inner）</strong>：Domain + Application。这是雷打不动的业务核心。</li><li><strong>外壳（Outer）</strong>：Web、Database、Redis、MQ。这些都是“插件”。</li></ul><h4 id="核心原则-1"><a href="#核心原则-1" class="headerlink" title="核心原则"></a>核心原则</h4><p><strong>依赖只能由外向内</strong>。外壳（Web、DB）依赖内核（Domain），内核谁也不依赖。</p><h4 id="目录结构示例-1"><a href="#目录结构示例-1" class="headerlink" title="目录结构示例"></a>目录结构示例</h4><p>这种架构通常会把文件夹分为 <code>adapter</code>（适配器/外壳）和 <code>core</code>（内核）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com.company.project</span><br><span class="line">├── adapter (适配器层 - 对应“六边形”的端口)</span><br><span class="line">│   ├── inbound (输入端 / 驱动端)</span><br><span class="line">│   │   └── web          // RestController</span><br><span class="line">│   └── outbound (输出端 / 被驱动端)</span><br><span class="line">│       ├── persistence  // 数据库实现 (Repository Impl)</span><br><span class="line">│       └── thirdparty   // 第三方调用 (如调用支付接口)</span><br><span class="line">├── application (应用层 - 业务流程)</span><br><span class="line">│   ├── service          // 应用服务</span><br><span class="line">│   └── port             // 端口定义 (如果是严格六边形，接口定义在这里)</span><br><span class="line">└── domain (领域层 - 业务核心)</span><br><span class="line">    ├── model            // 实体、聚合根</span><br><span class="line">    ├── service          // 领域服务</span><br><span class="line">    └── repository       // 仓储接口 (定义数据该怎么存，但不关心存哪里)</span><br></pre></td></tr></table></figure><p><strong>区别点</strong>：<br>你会发现 <code>Controller</code> 和 <code>RepositoryImpl</code> 变成了兄弟关系，都属于 <code>Adapter</code>（外围设施），而 <code>Domain</code> 被层层保护在最里面。</p><hr><h3 id="方案三：COLA-架构-Clean-Object-Oriented-and-Layered-Architecture"><a href="#方案三：COLA-架构-Clean-Object-Oriented-and-Layered-Architecture" class="headerlink" title="方案三：COLA 架构 (Clean Object-Oriented and Layered Architecture)"></a>方案三：COLA 架构 (Clean Object-Oriented and Layered Architecture)</h3><p>如果你是 Java 开发者，特别是在国内大厂环境，阿里开源的 <strong>COLA 架构</strong> 是一个非常流行的 DDD 落地模板。它结合了四层架构和整洁架构的优点。</p><p>它的特点是把<strong>对外暴露的接口（API）</strong>单独抽离成一个模块，方便微服务之间调用。</p><h4 id="Maven-模块结构"><a href="#Maven-模块结构" class="headerlink" title="Maven 模块结构"></a>Maven 模块结构</h4><p>COLA 通常是多 Module 的 Maven 项目：</p><ol><li><strong><code>start</code> (启动层)</strong><ul><li>Spring Boot 启动类，各种配置。</li></ul></li><li><strong><code>adapter</code> (适配层)</strong><ul><li>Controller (Web), Consumer (MQ)。</li></ul></li><li><strong><code>client</code> (API 层 / SDK)</strong><ul><li><strong>重点</strong>：这里放 DTO 和 API 接口定义。外部系统只需要依赖这个 jar 包。</li></ul></li><li><strong><code>app</code> (应用层)</strong><ul><li>Application Service, Command Handler。</li></ul></li><li><strong><code>domain</code> (领域层)</strong><ul><li>Entity, ValueObject, DomainService, Repository Interface。</li><li><strong>最纯净的一层，不依赖 Spring，只依赖 JDK。</strong></li></ul></li><li><strong><code>infrastructure</code> (基础设施层)</strong><ul><li>MyBatis Mapper, Repository Impl, Redis Util。</li></ul></li></ol><hr><h3 id="总结：我该怎么选？"><a href="#总结：我该怎么选？" class="headerlink" title="总结：我该怎么选？"></a>总结：我该怎么选？</h3><ol><li><p><strong>如果你是初学者，或者项目规模不大</strong>：<br>推荐 <strong>方案一（经典的四层架构）</strong>。</p><ul><li>理由：最符合直觉，文件夹分层清晰，从 MVC 迁移过来认知负担最小。</li><li><em>注意点：一定要坚持“领域层定义接口，基础层实现接口”，不要让领域层依赖 MyBatis。</em></li></ul></li><li><p><strong>如果你在做微服务，或者业务逻辑极度复杂</strong>：<br>推荐 <strong>方案二（整洁/六边形架构）</strong>。</p><ul><li>理由：能够完美隔离技术实现的变动（比如从 MySQL 换到 MongoDB，核心业务代码一行都不用改）。</li></ul></li><li><p><strong>如果你的团队用 Java 且由于规范要求</strong>：<br>推荐 <strong>方案三（COLA）</strong>。</p><ul><li>理由：国内资料多，规范约束性强，适合团队协作。</li></ul></li></ol><h3 id="关键点（无论选哪个架构）"><a href="#关键点（无论选哪个架构）" class="headerlink" title="关键点（无论选哪个架构）"></a>关键点（无论选哪个架构）</h3><p>不管你选哪个文件结构，DDD 落地的<strong>生死线</strong>只有一条：</p><blockquote><p><strong>Domain 层（领域层）必须是“纯净”的。</strong></p></blockquote><ul><li>它可以引用 <code>java.util.List</code>。</li><li>它<strong>绝对不能</strong>引用 <code>javax.sql.DataSource</code>、<code>org.springframework.xxx</code>、<code>com.github.pagehelper</code>。</li><li>它只谈业务（账号、金额、冻结），不谈技术（表、JSON、HTTP）。</li></ul><p>只要守住了这条线，你的架构就是合格的 DDD 架构。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>从MVC到Service+DAO，再到DDD，不是架构的“替代”，而是架构的“演进”。它们的核心都是通过分层实现解耦，只是针对不同的业务复杂度，选择了不同的拆分粒度。</p><p>对于开发者而言，不用盲目追求“高大上”的架构，而应该理解每种架构的核心价值和适用场景：简单业务用简单架构，复杂业务用精细架构。同时，要抓住架构设计的本质——让代码结构清晰、职责明确，便于维护和迭代。这才是我们学习各种架构思想的最终目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC到DDD：从架构分层到业务建模的思考&quot;&gt;&lt;a href=&quot;#MVC到DDD：从架构分层到业务建模的思考&quot; class=&quot;headerlink&quot; title=&quot;MVC到DDD：从架构分层到业务建模的思考&quot;&gt;&lt;/a&gt;MVC到DDD：从架构分层到业务建模的思考&lt;/</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络问题总结</title>
    <link href="https://nmcb666.vip/posts/a3a5550f.html"/>
    <id>https://nmcb666.vip/posts/a3a5550f.html</id>
    <published>2026-01-08T15:32:51.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习过程中的疑惑"><a href="#学习过程中的疑惑" class="headerlink" title="学习过程中的疑惑"></a>学习过程中的疑惑</h2><h3 id="通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-那我应该得到谁的mac地址呢"><a href="#通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-那我应该得到谁的mac地址呢" class="headerlink" title="通过ARP协议我们可以知道目的ip的mac地址  那要是这个ip不在我的局域网里面 那我应该得到谁的mac地址呢"></a>通过ARP协议我们可以知道目的ip的mac地址  那要是这个ip不在我的局域网里面 那我应该得到谁的mac地址呢</h3><p>这是一个非常经典且关键的网络问题。</p><p>简单直接的回答是：<strong>你会得到你所在局域网的“网关”（Gateway）的 MAC 地址。</strong></p><h4 id="详细原理解析"><a href="#详细原理解析" class="headerlink" title="详细原理解析"></a>详细原理解析</h4><p>当你的电脑（主机 A）想要发送数据包给一个 IP 地址（主机 B）时，它会经历以下逻辑判断流程：</p><ol><li><p><strong>判断目标 IP 是否在同一个局域网（子网）内：</strong></p><ul><li>电脑会查看自己的子网掩码（Subnet Mask）。</li><li>如果 <code>目标IP</code> 和 <code>本机IP</code> 在同一个网段内，电脑认为它可以直接通信。</li><li><strong>如果不在同一个网段内</strong>，电脑认为“我够不着它”，必须找一个“中介”来帮忙转发。</li></ul></li><li><p><strong>寻找“中介”（网关）：</strong></p><ul><li>这个“中介”就是你配置的<strong>默认网关（Default Gateway）</strong>。通常这是你路由器（Router）的内网 IP 地址（例如 <code>192.168.1.1</code> 或 <code>192.168.0.1</code>）。</li><li>电脑会把数据包发给网关，由网关负责把数据包投递到外网。</li></ul></li><li><p><strong>ARP 解析的对象发生变化：</strong></p><ul><li>既然数据包要发给网关，那么在数据链路层（二层），目标 MAC 地址就必须是网关的 MAC 地址。</li><li>因此，你的电脑会发起一个 <strong>ARP 请求</strong>，但是请求的目标 IP 不再是“目的 IP”，而是 <strong>“网关的 IP”</strong>。</li></ul></li><li><p><strong>获取 MAC 地址：</strong></p><ul><li>网关（路由器）收到 ARP 请求后，回复它的 MAC 地址。</li><li>你的电脑将数据包封装，<strong>目标 IP 仍然是远方的 IP，但目标 MAC 地址变成了网关的 MAC 地址</strong>。</li></ul></li></ol><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假设你的网络环境如下：</p><ul><li><strong>你的电脑 IP：</strong> <code>192.168.1.100</code></li><li><strong>你的网关 IP：</strong> <code>192.168.1.1</code> （MAC: <code>AA:AA:AA:AA:AA:AA</code>）</li><li><strong>你想访问的百度服务器 IP：</strong> <code>110.242.68.4</code> （这显然不在你的局域网）</li></ul><p><strong>发生的过程：</strong></p><ol><li>你要 ping <code>110.242.68.4</code>。</li><li>你的电脑计算一下，发现 <code>110.242.68.4</code> 不在 <code>192.168.1.x</code> 这个圈子里。</li><li>你的电脑决定：“我要把这个包交给网关 <code>192.168.1.1</code> 处理。”</li><li>你的电脑发出 ARP 请求：“谁是 <code>192.168.1.1</code>？请告诉我你的 MAC 地址。”</li><li>路由器回复：“我是 <code>192.168.1.1</code>，我的 MAC 是 <code>AA:AA:AA:AA:AA:AA</code>。”</li><li>你的电脑发送数据包：<ul><li><strong>源 IP：</strong> <code>192.168.1.100</code></li><li><strong>目的 IP：</strong> <code>110.242.68.4</code> （IP 头不变）</li><li><strong>源 MAC：</strong> <code>你的电脑 MAC</code></li><li><strong>目的 MAC：</strong> <code>AA:AA:AA:AA:AA:AA</code> （变成了网关的 MAC）</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>同网段通信：</strong> ARP 解析 <strong>目标 IP</strong> 的 MAC。</li><li><strong>跨网段通信：</strong> ARP 解析 <strong>网关 IP</strong> 的 MAC。</li></ul><p>这就是为什么当你访问互联网上任何网站时，你电脑的 ARP 缓存表中，主要变动的其实是网关的记录，而不是互联网上无数服务器的 MAC 地址（你也无法直接获取互联网服务器的 MAC 地址，因为路由器会隔离广播域）。</p><h3 id="封装好网络包后如何送达目标IP？"><a href="#封装好网络包后如何送达目标IP？" class="headerlink" title="封装好网络包后如何送达目标IP？"></a>封装好网络包后如何送达目标IP？</h3><p>在网络通信中，“封装好网络包后如何送达目标IP”是最核心的基础问题之一。这个过程涉及链路层、网络层的协同工作，以及交换机、路由器等设备的核心机制。本文将结合此前的讨论，以技术思考的视角，完整梳理从网络包封装完成到最终送达目标IP的全流程，拆解其中的关键逻辑与设备分工。</p><h4 id="一、核心前提：网络包的“两层身份”与核心寻址要素"><a href="#一、核心前提：网络包的“两层身份”与核心寻址要素" class="headerlink" title="一、核心前提：网络包的“两层身份”与核心寻址要素"></a>一、核心前提：网络包的“两层身份”与核心寻址要素</h4><p>当我们在主机上完成网络包封装后（通常是TCP/UDP头部+IP头部+数据的封装），这个包要在物理网络中传输，必须具备“两层身份标识”，对应网络分层模型的不同职责：</p><ul><li><p><strong>网络层身份</strong>：即源IP地址（发送方主机IP）和目标IP地址（最终接收方IP），核心作用是“跨网段导航”，确定数据包的最终目的地，全程不变。</p></li><li><p><strong>链路层身份</strong>：即源MAC地址（当前发送设备网卡MAC）和目标MAC地址（当前链路下一跳设备MAC），核心作用是“局域网内定位”，每经过一跳链路都会更新，仅在当前链路有效。</p></li></ul><p>核心结论：IP地址负责“找最终目的地在哪”，MAC地址负责“找当前链路上下一跳是谁”，两者协同完成全路径传输。</p><h4 id="二、发送前的关键决策：目标IP是否在同一局域网？"><a href="#二、发送前的关键决策：目标IP是否在同一局域网？" class="headerlink" title="二、发送前的关键决策：目标IP是否在同一局域网？"></a>二、发送前的关键决策：目标IP是否在同一局域网？</h4><p>封装完成后，主机的TCP/IP协议栈首先会进行一个核心判断——目标IP是否与本机在同一局域网（通过子网掩码计算网段）。这个判断直接决定了后续的发送逻辑：是直接发送给目标主机，还是先发送给网关（路由器）。</p><h4 id="三、同一局域网场景：直接发送至目标主机"><a href="#三、同一局域网场景：直接发送至目标主机" class="headerlink" title="三、同一局域网场景：直接发送至目标主机"></a>三、同一局域网场景：直接发送至目标主机</h4><p>当目标IP在同一网段时，主机需要直接与目标主机通信，核心问题是“如何获取目标IP对应的MAC地址”，这就需要ARP协议的参与。</p><h5 id="3-1-步骤1：查询ARP缓存表"><a href="#3-1-步骤1：查询ARP缓存表" class="headerlink" title="3.1 步骤1：查询ARP缓存表"></a>3.1 步骤1：查询ARP缓存表</h5><p>主机本地会维护一个ARP缓存表，存储“IP地址-MAC地址”的映射关系。协议栈会先查询该表：</p><ul><li><p>若存在目标IP对应的MAC地址：直接进入链路层封装，将目标MAC填入以太网帧头，源MAC填入本机网卡MAC，然后将帧发送至交换机。</p></li><li><p>若不存在目标IP对应的MAC地址：触发ARP广播流程。</p></li></ul><h5 id="3-2-步骤2：ARP广播获取目标MAC"><a href="#3-2-步骤2：ARP广播获取目标MAC" class="headerlink" title="3.2 步骤2：ARP广播获取目标MAC"></a>3.2 步骤2：ARP广播获取目标MAC</h5><p>主机发送ARP请求包（链路层目标MAC为广播地址FF:FF:FF:FF:FF:FF），该广播包会被交换机泛洪至局域网内所有设备：</p><ul><li><p>非目标设备收到后，发现目标IP不是自己，直接丢弃；</p></li><li><p>目标设备收到后，识别出目标IP是自己，回复ARP响应包，包含自身MAC地址；</p></li><li><p>主机收到ARP响应后，将“目标IP-目标MAC”映射存入ARP缓存表，后续通信可直接使用。</p></li></ul><h5 id="3-3-步骤3：交换机的转发逻辑"><a href="#3-3-步骤3：交换机的转发逻辑" class="headerlink" title="3.3 步骤3：交换机的转发逻辑"></a>3.3 步骤3：交换机的转发逻辑</h5><p>主机将封装好的以太网帧发送至交换机后，交换机会通过自身的MAC地址表（记录“MAC地址-端口”映射）进行转发：</p><ul><li><p>若MAC地址表存在目标MAC对应的端口：直接将帧从该端口转发（单播），仅目标设备能接收；</p></li><li><p>若MAC地址表不存在目标MAC对应的端口：交换机执行“泛洪”，将帧从除接收端口外的所有端口转发，直到目标设备接收后，交换机通过源MAC学习，将目标MAC与对应端口的映射存入MAC地址表，后续通信直接单播。</p></li></ul><p>核心要点：交换机仅识别MAC地址，不关心IP地址；ARP广播仅在当前局域网内传播，不会跨网段。</p><h4 id="四、跨局域网场景：通过网关转发至目标IP"><a href="#四、跨局域网场景：通过网关转发至目标IP" class="headerlink" title="四、跨局域网场景：通过网关转发至目标IP"></a>四、跨局域网场景：通过网关转发至目标IP</h4><p>当目标IP不在同一网段时，主机无法直接与目标主机通信，必须通过网关（路由器）转发——网关是连接本地局域网与外部网络的“桥梁”，同时属于两个网络（本地局域网和外网），拥有两个IP和两个MAC（局域网侧IP/MAC、外网侧IP/MAC）。</p><h5 id="4-1-步骤1：获取网关的IP和MAC地址"><a href="#4-1-步骤1：获取网关的IP和MAC地址" class="headerlink" title="4.1 步骤1：获取网关的IP和MAC地址"></a>4.1 步骤1：获取网关的IP和MAC地址</h5><ul><li><p>网关IP的获取：主机通过DHCP自动获取（常见）或手动配置，存储在本地网络设置中；</p></li><li><p>网关MAC的获取：与同一局域网获取目标MAC逻辑一致，通过查询ARP缓存表或发送ARP广播获取网关IP对应的MAC地址。</p></li></ul><h5 id="4-2-步骤2：发送至网关"><a href="#4-2-步骤2：发送至网关" class="headerlink" title="4.2 步骤2：发送至网关"></a>4.2 步骤2：发送至网关</h5><p>主机将以太网帧的目标MAC填入网关的局域网侧MAC，源MAC填入本机MAC，发送至交换机，由交换机转发至网关。</p><h5 id="4-3-步骤3：网关的转发逻辑（跨网段核心）"><a href="#4-3-步骤3：网关的转发逻辑（跨网段核心）" class="headerlink" title="4.3 步骤3：网关的转发逻辑（跨网段核心）"></a>4.3 步骤3：网关的转发逻辑（跨网段核心）</h5><p>网关（路由器）收到帧后，会执行“剥帧-路由-重新封装”的核心流程：</p><ol><li><p>剥帧：路由器工作在网络层，会剥离链路层以太网帧头（MAC地址信息失效），查看IP头部的目标IP；</p></li><li><p>路由决策：查询自身路由表，确定目标IP对应的“下一跳网关”（可能是运营商路由器、骨干网路由器等）；</p></li><li><p>重新封装：通过ARP获取下一跳网关的MAC地址，将新的以太网帧头封装（源MAC为网关的外网侧MAC，目标MAC为下一跳网关的MAC），发送至下一跳；</p></li><li><p>重复转发：数据包在互联网中经过多个路由器接力转发，每一跳都重复“剥帧-路由-重新封装”，直到到达目标IP所在的局域网网关。</p></li></ol><h5 id="4-4-步骤4：NAT地址转换（家庭-企业网络必备）"><a href="#4-4-步骤4：NAT地址转换（家庭-企业网络必备）" class="headerlink" title="4.4 步骤4：NAT地址转换（家庭/企业网络必备）"></a>4.4 步骤4：NAT地址转换（家庭/企业网络必备）</h5><p>家庭/企业内网使用私有IP（如192.168.x.x），无法直接在互联网中路由。因此，网关在转发时会触发NAT（网络地址转换）：</p><ul><li><p>出口转换：将数据包的源IP从私有IP改为网关的公网IP，同时记录“私有IP:端口-公网IP:端口”的映射关系（NAT表）；</p></li><li><p>入口转换：当目标IP的响应包返回至网关时，网关通过NAT表反向查询，将目标IP改为对应的内网私有IP，目标MAC改为该主机的MAC，转发至目标主机。</p></li></ul><p>核心要点：NAT仅发生在本地网关的出口处，是私有IP访问互联网的必要条件；源IP在NAT转换后，在互联网传输过程中保持不变，直到到达目标局域网。</p><h5 id="4-5-步骤5：目标局域网内的最后一跳"><a href="#4-5-步骤5：目标局域网内的最后一跳" class="headerlink" title="4.5 步骤5：目标局域网内的最后一跳"></a>4.5 步骤5：目标局域网内的最后一跳</h5><p>当数据包到达目标IP所在的局域网网关后，网关会再次执行“剥帧-路由”，发现目标IP在当前局域网内，通过ARP获取目标主机的MAC地址，重新封装帧后发送至目标主机，完成全链路传输。</p><h4 id="五、关键设备分工总结"><a href="#五、关键设备分工总结" class="headerlink" title="五、关键设备分工总结"></a>五、关键设备分工总结</h4><div class="table-container"><table><thead><tr><th>设备</th><th>工作层级</th><th>核心职责</th><th>关键特性</th></tr></thead><tbody><tr><td>主机</td><td>网络层+链路层</td><td>封装网络包、ARP查询/广播、判断目标IP网段</td><td>维护ARP缓存表，不直接跨网段转发</td></tr><tr><td>交换机</td><td>链路层</td><td>根据MAC地址表转发帧、泛洪未知MAC帧、学习源MAC</td><td>不识别IP地址，不隔离广播域（二层交换机）</td></tr><tr><td>路由器（网关）</td><td>网络层+链路层</td><td>路由决策、跨网段转发、NAT转换、隔离广播域</td><td>丢弃广播包，同时属于多个网络，维护路由表</td></tr></tbody></table></div><h4 id="六、全流程核心总结（思维导图式）"><a href="#六、全流程核心总结（思维导图式）" class="headerlink" title="六、全流程核心总结（思维导图式）"></a>六、全流程核心总结（思维导图式）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">封装完成网络包</span><br><span class="line">├─ 决策：目标IP是否在同一局域网？</span><br><span class="line">│  ├─ 是：</span><br><span class="line">│  │  ├─ 查询ARP缓存表 → 有目标MAC？</span><br><span class="line">│  │  │  ├─ 是：封装帧（目标MAC=目标主机MAC）→ 交换机转发 → 目标主机</span><br><span class="line">│  │  │  └─ 否：ARP广播获取目标MAC → 存入缓存 → 封装转发</span><br><span class="line">│  └─ 否：</span><br><span class="line">│     ├─ 获取网关IP（DHCP/手动配置）</span><br><span class="line">│     ├─ 获取网关MAC（ARP查询/广播）</span><br><span class="line">│     ├─ 封装帧（目标MAC=网关MAC）→ 交换机转发 → 网关</span><br><span class="line">│     ├─ 网关NAT：源IP从私有IP改为公网IP</span><br><span class="line">│     ├─ 网关路由决策 → 转发至下一跳（互联网多路由器接力）</span><br><span class="line">│     ├─ 到达目标局域网网关 → 剥帧路由 → 获取目标主机MAC</span><br><span class="line">│     └─ 转发至目标主机</span><br><span class="line">└─ 核心不变量：目标IP全程不变；核心变量：MAC地址每跳更新</span><br></pre></td></tr></table></figure><h4 id="七、关键疑问解答（补充思考）"><a href="#七、关键疑问解答（补充思考）" class="headerlink" title="七、关键疑问解答（补充思考）"></a>七、关键疑问解答（补充思考）</h4><ul><li><p>Q：如果指定的MAC地址不在局域网内怎么办？<br>A：主机发送前会通过ARP验证，若ARP广播无响应，会判定“目标不可达”，直接报错，数据包不会发送。</p></li><li><p>Q：交换机有ARP吗？知道IP对应MAC吗？<br>A：二层交换机无ARP，不识别IP，仅通过MAC地址转发；三层交换机集成路由功能，才会有ARP表。</p></li><li><p>Q：ARP是广播，如何隔离广播域？<br>A：路由器会丢弃广播包，不跨网段转发，因此广播域被路由器隔离，仅在当前局域网内传播。</p></li></ul><h4 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h4><p>网络包从封装完成到送达目标IP的过程，本质是“IP地址导航+MAC地址定位”的协同过程，涉及ARP寻址、交换机泛洪/转发、路由器路由/NAT等核心机制。理解这一过程的关键，是分清网络层与链路层的职责边界，以及各设备的分工逻辑——IP负责“找终点”，MAC负责“找下一跳”，交换机管“局域网内搬运”，路由器管“跨网段导航+隔离广播”，最终实现数据包的精准传输。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习过程中的疑惑&quot;&gt;&lt;a href=&quot;#学习过程中的疑惑&quot; class=&quot;headerlink&quot; title=&quot;学习过程中的疑惑&quot;&gt;&lt;/a&gt;学习过程中的疑惑&lt;/h2&gt;&lt;h3 id=&quot;通过ARP协议我们可以知道目的ip的mac地址-那要是这个ip不在我的局域网里面-</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（二）</title>
    <link href="https://nmcb666.vip/posts/d323df1a.html"/>
    <id>https://nmcb666.vip/posts/d323df1a.html</id>
    <published>2026-01-05T18:03:11.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法总结（二）"><a href="#算法总结（二）" class="headerlink" title="算法总结（二）"></a>算法总结（二）</h1><h2 id="异或运算的骚操作"><a href="#异或运算的骚操作" class="headerlink" title="异或运算的骚操作"></a>异或运算的骚操作</h2><h3 id="异或解释"><a href="#异或解释" class="headerlink" title="异或解释"></a>异或解释</h3><ol><li>异或运算，相同的值异或为0，不同的值异或为1</li><li>也可以理解为无进位的加法</li><li>异或运算满足交换律，结合律</li><li>一个数组中所有数的异或和 跟 某些数异或的结果 相当于 减去某些数的异或和</li></ol><h3 id="使用异或进行交换两个数"><a href="#使用异或进行交换两个数" class="headerlink" title="使用异或进行交换两个数"></a>使用异或进行交换两个数</h3><ol><li>a = a^b</li><li>b = a^b (此时相当于a^b^b = a , 就让b等于a)</li><li>a = a^b (此时相当于a^b^a = b , 就让a等于b)</li></ol><p><em>局限性：注意这个交换不能对同一个地址的两个变量进行操作。因为第一步就会把他们都变为0</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">2323</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><h3 id="使用异或不用判断语句去判断两个数的大小"><a href="#使用异或不用判断语句去判断两个数的大小" class="headerlink" title="使用异或不用判断语句去判断两个数的大小"></a>使用异或不用判断语句去判断两个数的大小</h3><p>大体思路就是根据a-b的符号，来判断a和b的大小。<br>但是这样有溢出的风险（a-b会溢出）<br>优化思路：</p><ol><li>获取a和b的符号</li><li>获取c=a-b的符号</li><li>综合判断</li><li>如果a,b符号相同，则不可能溢出，直接根据c的符号来判断大小</li><li>如果a,b符号不同，则a-b可能会溢出，判断a的符号 如果a是非负的，就可以直接返回a更大</li><li>除了以上两种情况，其余情况都返回b</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 必须保证n一定是0或者1</span></span><br><span class="line"><span class="comment">// 0变1，1变0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非负数返回1</span></span><br><span class="line"><span class="comment">// 负数返回0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> flip(n &gt;&gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有溢出风险的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line"><span class="comment">// c非负，returnA -&gt; 1</span></span><br><span class="line"><span class="comment">// c非负，returnB -&gt; 0</span></span><br><span class="line"><span class="comment">// c负数，returnA -&gt; 0</span></span><br><span class="line"><span class="comment">// c负数，returnB -&gt; 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> sign(c);</span><br><span class="line"><span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line"><span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有任何问题的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="comment">// c可能是溢出的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line"><span class="comment">// a的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sa</span> <span class="operator">=</span> sign(a);</span><br><span class="line"><span class="comment">// b的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> sign(b);</span><br><span class="line"><span class="comment">// c的符号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sc</span> <span class="operator">=</span> sign(c);</span><br><span class="line"><span class="comment">// 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">diffAB</span> <span class="operator">=</span> sa ^ sb;</span><br><span class="line"><span class="comment">// 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sameAB</span> <span class="operator">=</span> flip(diffAB);</span><br><span class="line"><span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> diffAB * sa + sameAB * sc;</span><br><span class="line"><span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line"><span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异或去返回出现了奇数次的数（其余数都出现了偶数次）"><a href="#使用异或去返回出现了奇数次的数（其余数都出现了偶数次）" class="headerlink" title="使用异或去返回出现了奇数次的数（其余数都出现了偶数次）"></a>使用异或去返回出现了奇数次的数（其余数都出现了偶数次）</h3><p>思路很简单，就是把所有的数异或一遍，最后剩下的数就是出现了奇数次的数。<br>因为异或满足交换律。凡是出现偶数次的数，异或结果都为0，最后结果就是奇数次的数^0 = 奇数次的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">eor ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）"><a href="#使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）" class="headerlink" title="使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）"></a>使用异或去返回两个出现奇数次的数（其余数都出现了偶数次）</h3><p>思路：(假设那两个数为a和b)</p><ol><li>先将数组中所有数异或一遍，得到一个数xor1=a^b</li><li>找到xor1最右边的1，即xor1 &amp; (-xor1) (解释：xor1 &amp; (-xor1)可以获取xor1最右边的1。并且这个1就是a跟b肯定不一样的数位（当然不只这一个，但是只需要这一个我们就可以区分它们了）)</li><li>将数组中所有数分为两组，一组是xor1最右边的1为1的数，一组是xor1最右边的1为0的数 （a,b肯定在不同的组中）</li><li>对其中一组数异或，得到XOR2  (XOR可能是a也有可能是b) （每组还是满足除了a,b之外所有数出现次数都是偶数）</li><li>讲XOR2与XOR1异或，得到另一个数 （XOR2^XOR1=a^b^b=a (假设XOR是b)）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="comment">// nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次</span></span><br><span class="line">eor1 ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eor1 : a ^ b</span></span><br><span class="line"><span class="comment">// Brian Kernighan算法</span></span><br><span class="line"><span class="comment">// 提取出二进制里最右侧的1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor1 &amp; (-eor1);</span><br><span class="line"><span class="type">int</span> <span class="variable">eor2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> ((num &amp; rightOne) == <span class="number">0</span>) &#123;</span><br><span class="line">eor2 ^= num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; eor2, eor1 ^ eor2 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他位运算的骚操作"><a href="#其他位运算的骚操作" class="headerlink" title="其他位运算的骚操作"></a>其他位运算的骚操作</h2><h3 id="判断一个数是不是2的幂"><a href="#判断一个数是不是2的幂" class="headerlink" title="判断一个数是不是2的幂"></a>判断一个数是不是2的幂</h3><p>原理： 如果是2的幂，那么二进制数只有一位为1，其他为0 。这时候我们用a&amp;-a 拿到到的数，就是a最右边的1。然后判断a是不是等于a&amp;-a 等于的话，那么a就是2的幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; <span class="number">0</span> &amp;&amp; a==(a&amp;-a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是不是三的幂"><a href="#判断一个数是不是三的幂" class="headerlink" title="判断一个数是不是三的幂"></a>判断一个数是不是三的幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子</span></span><br><span class="line"><span class="comment">// 1162261467是int型范围内，最大的3的幂，它是3的19次方</span></span><br><span class="line"><span class="comment">// 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么</span></span><br><span class="line"><span class="comment">// 1162261467 % n == 0</span></span><br><span class="line"><span class="comment">// 反之如果1162261467 % n != 0 说明n一定含有其他因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回大于等于n的最小的2某次方"><a href="#返回大于等于n的最小的2某次方" class="headerlink" title="返回大于等于n的最小的2某次方"></a>返回大于等于n的最小的2某次方</h3><p>先对n-1 然后把n最左边的1一直让右边全变为1.最后的答案就是n+1 (00111111 -&gt; 01000000)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">near2power</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="此区间内所有数字-amp-的结果-连续"><a href="#此区间内所有数字-amp-的结果-连续" class="headerlink" title="此区间内所有数字 &amp; 的结果(连续)"></a>此区间内所有数字 &amp; 的结果(连续)</h3><p>形如 0111001000 如果此时还存在一个比自己还小的数，那么我最右边的1肯定会被与运算变成0.直到最小的数都大于我，我的最右侧的1才能保留下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">right -= right &amp; -right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计一个数的二进制中1的个数"><a href="#统计一个数的二进制中1的个数" class="headerlink" title="统计一个数的二进制中1的个数"></a>统计一个数的二进制中1的个数</h3><p>具体思路参考 【算法讲解031【必备】位运算的骚操作】<a href="https://www.bilibili.com/video/BV1ch4y1Q7vd?vd_source=c6cdeb45f015e4ab4447a6c61482633a">https://www.bilibili.com/video/BV1ch4y1Q7vd?vd_source=c6cdeb45f015e4ab4447a6c61482633a</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cntOnes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算实现加减乘除操作"><a href="#位运算实现加减乘除操作" class="headerlink" title="位运算实现加减乘除操作"></a>位运算实现加减乘除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == MIN &amp;&amp; b == MIN) &#123;</span><br><span class="line"><span class="comment">// a和b都是整数最小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != MIN &amp;&amp; b != MIN) &#123;</span><br><span class="line"><span class="comment">// a和b都不是整数最小，那么正常去除</span></span><br><span class="line"><span class="keyword">return</span> div(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == MIN) &#123;</span><br><span class="line"><span class="comment">// a不是整数最小，b是整数最小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了</span></span><br><span class="line"><span class="keyword">if</span> (b == neg(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是整数最小，b不是整数最小，b也不是-1</span></span><br><span class="line">a = add(a, b &gt; <span class="number">0</span> ? b : neg(b));</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> div(a, b);</span><br><span class="line"><span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> b &gt; <span class="number">0</span> ? neg(<span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> add(ans, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须保证a和b都不是整数最小值，返回a除以b的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a &lt; <span class="number">0</span> ? neg(a) : a;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> b &lt; <span class="number">0</span> ? neg(b) : b;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &gt;= <span class="number">0</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">x = minus(x, y &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a &lt; <span class="number">0</span> ^ b &lt; <span class="number">0</span> ? neg(ans) : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ans : a和b无进位相加的结果</span></span><br><span class="line">ans = a ^ b;</span><br><span class="line"><span class="comment">// b : a和b相加时的进位信息</span></span><br><span class="line">b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">a = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(a, neg(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种乘法后面有大用处，尤其是求(a的b次方 % m)的结果，也叫龟速乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 考察b当前最右的状态！</span></span><br><span class="line">ans = add(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">b &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法总结（二）&quot;&gt;&lt;a href=&quot;#算法总结（二）&quot; class=&quot;headerlink&quot; title=&quot;算法总结（二）&quot;&gt;&lt;/a&gt;算法总结（二）&lt;/h1&gt;&lt;h2 id=&quot;异或运算的骚操作&quot;&gt;&lt;a href=&quot;#异或运算的骚操作&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（一）</title>
    <link href="https://nmcb666.vip/posts/e33533c2.html"/>
    <id>https://nmcb666.vip/posts/e33533c2.html</id>
    <published>2026-01-02T15:26:44.000Z</published>
    <updated>2026-01-28T18:22:02.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法总结（一）"><a href="#算法总结（一）" class="headerlink" title="算法总结（一）"></a>算法总结（一）</h1><h2 id="归并分治"><a href="#归并分治" class="headerlink" title="归并分治"></a>归并分治</h2><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ol><li>左边结果+右边结果+跨越两边的结果是否等于最终结果</li><li>对于两边排序之后对于统计跨越两边的结果是否有帮助</li></ol><h3 id="注意与总结"><a href="#注意与总结" class="headerlink" title="注意与总结"></a>注意与总结</h3><ol><li>主要思想跟归并排序一样 只不过是在merge的时候进行一些额外统计操作（统计跨越两边的结果）</li><li>如果只是单纯的比大小（比如 小和，逆序对）可以直接在merge的时候进行比较<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小和 直接在合并的时候进行比较统计</span></span><br><span class="line">        <span class="keyword">while</span>(a &lt;=m &amp;&amp; b&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]&lt;nums[b])&#123;</span><br><span class="line">                help[i++] = nums[a];</span><br><span class="line">                sum+= (nums[a]*(r-b+<span class="number">1</span>));</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                help[i++] = nums[b++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>如果不只是比大小 而是比较乘以二倍的结果，那么就需要在merge的时候 添加额外的统计操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当左边的数大于右边的两倍时进行统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ll=l,rr=m+<span class="number">1</span>;ll&lt;=m;ll++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(rr&lt;=r &amp;&amp; (<span class="type">long</span>)nums[ll]&gt;((<span class="type">long</span>)nums[rr]&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                rr++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="两种partition-普通-荷兰国旗"><a href="#两种partition-普通-荷兰国旗" class="headerlink" title="两种partition (普通+荷兰国旗)"></a>两种partition (普通+荷兰国旗)</h3><ol><li>普通partition 一次只能确定一个数的位置</li></ol><p>核心思想：初始化索引i a xi<br>1.1 遍历数组，如果当前数小于等于x，则交换i和a数 i++ a++<br>1.2 如果大于x，则i++ a不动<br>1.3 如果遇到nums[a] == x,用xi记录他的位置<br>1.4 遍历结束后，交换xi和a-1的位置，让x放到对应的位置。<br>1.5 返回a-1（x应该在的位置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个区号 小于等于   大于</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= x)&#123;</span><br><span class="line">                swap(nums,a,i);</span><br><span class="line">                <span class="keyword">if</span>(nums[a] == x)&#123;</span><br><span class="line">                    xi = a;</span><br><span class="line">                &#125;</span><br><span class="line">                a++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,xi,a-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>荷兰国旗partition 一次可以确定多个相同的数的位置</li></ol><p>核心思路：初始化索引i a(小于区间) b（大于区间）<br>1.1 遍历数组，如果当前数小于x，则交换i和a数 i++ a++<br>1.2 如果大于x，则i不动 b—<br>1.3 如果等于x，则i++<br>1.4 遍历结束后，a-1（小于区间的末尾） b+1（大于区间的开头） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first,last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个区间 小于  大于   等于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=l;</span><br><span class="line">    <span class="type">int</span> b=r;</span><br><span class="line">    <span class="type">int</span> i=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; x)&#123;</span><br><span class="line">            swap(nums,a++,i++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x)&#123;</span><br><span class="line">            swap(nums,i,b--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first = a;</span><br><span class="line">    last = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-快速选择"><a href="#扩展-快速选择" class="headerlink" title="扩展 快速选择"></a>扩展 快速选择</h3><p>快速选择：给定一个数组，返回第k小的数</p><ol><li>快速排序的思想，partition之后，如果在当前区间内的排名大于指定的排名，则递归quickselect(l,left-1,k)</li><li>快速排序的思想，partition之后，如果在当前区间内的排名小于指定的排名，则递归quickselect(right+1,r,k-rightNow)  (rightNow指定的数在当前区间内的最靠右的排名)</li><li>快速排序的思想，partition之后，如果在当前区间内的排名等于指定的排名，则返回用于partition的数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">partitor</span> <span class="operator">=</span> nums[l+ (<span class="type">int</span>)(Math.random()*(r-l+<span class="number">1</span>))];</span><br><span class="line">    <span class="comment">//荷兰国旗</span></span><br><span class="line">    partition2(nums,l,r,partitor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftNow</span> <span class="operator">=</span> left -l +<span class="number">1</span>; <span class="comment">//当前区间内partitor靠左的排名（可能存在多个partitor）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightNow</span> <span class="operator">=</span> right -l+<span class="number">1</span>; <span class="comment">//当前区间内partitor靠右的排名</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;leftNow)&#123; <span class="comment">//要找的位置在左边 再去左边找</span></span><br><span class="line">        <span class="keyword">return</span> quick(nums,l,left-<span class="number">1</span>,pos);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;rightNow)&#123; <span class="comment">//要找的位置在右边 再去右边找</span></span><br><span class="line">        <span class="keyword">return</span> quick(nums,right+<span class="number">1</span>,r,pos-rightNow);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//要找的位置在中间 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nums[pos+l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序本身没什么好说的，就是利用堆这个数据结构进行排序。这里重点说一下heapify 跟 heapInsert</p><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>将节点下移到合适的位置，直接贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// i位置的数，变小了，又想维持大根堆结构</span></span><br><span class="line"><span class="comment">// 向下调整大根堆</span></span><br><span class="line"><span class="comment">// 当前堆的大小为size</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; size) &#123;</span><br><span class="line"><span class="comment">// 有左孩子，l</span></span><br><span class="line"><span class="comment">// 右孩子，l+1</span></span><br><span class="line"><span class="comment">// 评选，最强的孩子，是哪个下标的孩子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> l + <span class="number">1</span> &lt; size &amp;&amp; arr[l + <span class="number">1</span>] &gt; arr[l] ? l + <span class="number">1</span> : l;</span><br><span class="line"><span class="comment">// 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁</span></span><br><span class="line">best = arr[best] &gt; arr[i] ? best : i;</span><br><span class="line"><span class="keyword">if</span> (best == i) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, best, i);</span><br><span class="line">i = best;</span><br><span class="line">l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也有递归的版本也很简单，这里不详细说了。</p><p>此外使用heapify可以自底向上的构建堆 时间复杂度为O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapify(arr, i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="heapInsert"><a href="#heapInsert" class="headerlink" title="heapInsert"></a>heapInsert</h3><p>将节点上移到合适位置，直接贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// i位置的数，变大了，又想维持小根堆结构</span></span><br><span class="line"><span class="comment">// 向上调整小根堆</span></span><br><span class="line"><span class="comment">// 当前堆的大小为size</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">i = (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外使用heapInsert可以自上到下的构建堆 时间复杂度为O(n*logn) (不如上面的方法)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">heapInsert(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用堆结构去解决一些其他问题"><a href="#利用堆结构去解决一些其他问题" class="headerlink" title="利用堆结构去解决一些其他问题"></a>利用堆结构去解决一些其他问题</h3><h4 id="1-合并k个有序链表"><a href="#1-合并k个有序链表" class="headerlink" title="1. 合并k个有序链表"></a>1. 合并k个有序链表</h4><ol><li>创建一个最小堆，将k个链表的头节点加入堆中</li><li>弹出最小的节点，并加入到结果链表中</li><li>弹出的节点的next节点加入堆中</li><li>重复2-3，直到堆为空</li><li>返回结果链表</li></ol><p>复杂度 O(n*logk)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode listNode : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.add(listNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span>h;</span><br><span class="line">    <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        heap.add(pre.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">        pre.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            heap.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-线段最多重合问题"><a href="#2-线段最多重合问题" class="headerlink" title="2. 线段最多重合问题"></a>2. 线段最多重合问题</h4><p> 线段最多重合问题，就是给定很多线段，求线段最多重合的次数 </p><ol><li>将所有线段按开始的点进行排序</li><li>依次开始遍历线段</li><li>弹出堆中的最小点，如果最小点小于当前线段的开始点，则说明在当前线段开始时，这里面的线段已经结束不会重合。弹出堆中的最小点</li><li>循环3步直到堆里面的元素不小于当前线段的开始点。</li><li>将当前线段的结束点加入最小堆中</li><li>当前最小堆的size就是以这个线段开始为重合开始区间的重合的次数，用这个跟记录的最大次数进行比较，更新最大次数</li><li>循环2-6，直到所有线段都遍历结束</li><li>返回最大次数</li></ol><p>时间复杂度  O(n*logn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 堆的清空</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段一共有n条，line[0...n-1][2] : line[i][0] line[i][1], 左闭右闭</span></span><br><span class="line"><span class="comment">// 所有线段，根据开始位置排序，结束位置无所谓</span></span><br><span class="line"><span class="comment">// 比较器的用法</span></span><br><span class="line"><span class="comment">// line [0...n) 排序 : 所有小数组，开始位置谁小谁在前</span></span><br><span class="line">Arrays.sort(line, <span class="number">0</span>, n, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// i : line[i][0] line[i][1]</span></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; heap[<span class="number">0</span>] &lt;= line[i][<span class="number">0</span>]) &#123;</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line">add(line[i][<span class="number">1</span>]);</span><br><span class="line">ans = Math.max(ans, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-累加和减半最小操作次数"><a href="#3-累加和减半最小操作次数" class="headerlink" title="3.累加和减半最小操作次数"></a>3.累加和减半最小操作次数</h4><p>给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择任意一个数并将它减小到恰好一半。（注意，在后续操作中你可以对减半过的数继续执行操作）<br>请你返回将 nums 数组和至少减少一半的最少操作数。</p><p>思路： 其实就是贪心算法，每次把最大的数减到一半，直到和减少到一半。其中找最大的数就可以用大根堆来实现。</p><ol><li>创建一个大根堆，将数组中的数放入大根堆中。</li><li>取出最大的数，除以2 ，操作数++，并判断和是否减少到一半。如果和减少到一半，则返回当前操作数。</li><li>循环第二步。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">halveArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">PriorityQueue&lt;Double&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">heap.add((<span class="type">double</span>) num);</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum，整体累加和，-&gt; 要减少的目标！</span></span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">minus</span> <span class="operator">=</span> <span class="number">0</span>, cur; minus &lt; sum; ans++, minus += cur) &#123;</span><br><span class="line">cur = heap.poll() / <span class="number">2</span>;</span><br><span class="line">heap.add(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化思路：可以自己实现大根堆，并且不用Double类型，用long类型将所有数乘以2的20次方，相当于小数部分可以保留20位，可以精确到小数点后20位。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>原理很简单 不细说 主要说说感悟</p><p>为什么要逆序遍历 Array：</p><ol><li>排序的稳定性：<br>在基数排序的实现中，逆序访问原数组 arr 的目的是为了保证排序的稳定性。稳定性是指排序算法在处理相等元素时能够保持它们在原数组中的相对顺序不变。<br>在循环中，我们逆序遍历原数组 arr。这样做的好处是，当存在相等的元素时，先出现的元素会先放入对应的位置，而后出现的相等元素会放在它们之后的位置。这样可以保证相等元素的相对顺序不变，从而保证了排序的稳定性。<br>如果我们采用顺序访问 arr 的方式，那么在处理相等元素时，后出现的相等元素可能会先放入对应的位置，从而打破了它们在原数组中的相对顺序，导致排序不稳定。<br>因此，为了确保排序的稳定性，我们需要在逆序遍历原数组 arr 的情况下进行元素的放置操作。</li><li>自己的理解：<br>2.1 基数排序，是基于数字的每一位（从低位到高位）进行排序，每一位的排序 基于 上一位（较低位）排好的基础上<br>2.2 先将所有元素按照低位排序，再保持低位位序不变的情况下去排高位的位序（能让已经排好的低位的位序变化的原因只能受高位数值的影响）<br>2.3 如果是顺序排序，那么低位顺序的改变不仅仅受到高位数值的影响，也受到错位的影响<br>2.4 错位的影响：有数组：arr【 11 , 12 , 13 , 14 , 15】<br>低位序已经排好，如果按照高位顺序遍历，会导致数组变成 【15 , 14 , 13 , 12 , 11】<br>使得原先在 15 之前的 11 排在了 15 之后<br>这种错位的影响是 顺序遍历 和 使用词频统计方法往Help中放元素(逆序) 相互作用决定的</li></ol><h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/blog1.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法总结（一）&quot;&gt;&lt;a href=&quot;#算法总结（一）&quot; class=&quot;headerlink&quot; title=&quot;算法总结（一）&quot;&gt;&lt;/a&gt;算法总结（一）&lt;/h1&gt;&lt;h2 id=&quot;归并分治&quot;&gt;&lt;a href=&quot;#归并分治&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>feign的三种异常处理关系</title>
    <link href="https://nmcb666.vip/posts/20b8d2ff.html"/>
    <id>https://nmcb666.vip/posts/20b8d2ff.html</id>
    <published>2025-12-31T10:00:37.000Z</published>
    <updated>2026-01-28T18:22:02.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"><a href="#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘" class="headerlink" title="Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘"></a>Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘</h1><p>在微服务架构中，Feign作为声明式HTTP客户端，是服务间调用的核心组件。而异常处理是保障微服务稳定性的关键环节——当Feign调用下游服务抛出异常时，我们常通过 <code>ErrorDecoder</code>、容错组件的 <code>Fallback</code>（如Sentinel/Hystrix）、Spring全局异常捕获器（<code>@RestControllerAdvice</code>）三种方式处理异常。但三者并存时，执行顺序如何？优先级背后的原理是什么？特殊场景下又会出现哪些变化？本文将结合实践拆解这一核心问题。</p><h2 id="一、核心结论：三者的优先执行顺序"><a href="#一、核心结论：三者的优先执行顺序" class="headerlink" title="一、核心结论：三者的优先执行顺序"></a>一、核心结论：三者的优先执行顺序</h2><p>当Feign调用发生异常（非2xx HTTP状态码、超时、网络异常等）时，三者的执行优先级从高到低依次为：</p><p><strong>ErrorDecoder（Feign原生） → Fallback（容错组件） → 全局异常捕获器（Spring MVC）</strong></p><p>完整执行链路可概括为：</p><blockquote><p>Feign调用触发异常 → ResponseInterceptor（OpenFeign 12.0+ 可选预处理） → ErrorDecoder（异常解码/转换） → 容错组件拦截异常 → Fallback（异常兜底，返回正常数据） → （Fallback失效时）全局异常捕获器 → （均未处理时）向上抛出原始异常</p></blockquote><p>其中，前两者属于Feign调用链路的“前置处理”，全局异常捕获器属于“后置兜底”，且Fallback默认会阻断异常向上传播，使全局异常捕获器无法触发。</p><h2 id="二、优先级原理：层级与职责边界决定执行顺序"><a href="#二、优先级原理：层级与职责边界决定执行顺序" class="headerlink" title="二、优先级原理：层级与职责边界决定执行顺序"></a>二、优先级原理：层级与职责边界决定执行顺序</h2><p>三者优先级的本质的是执行层级和职责边界的差异，不同层级对应不同的异常处理目标，形成了“层层拦截、各司其职”的链路。</p><h3 id="1-第一优先级：ErrorDecoder（Feign原生扩展点）"><a href="#1-第一优先级：ErrorDecoder（Feign原生扩展点）" class="headerlink" title="1. 第一优先级：ErrorDecoder（Feign原生扩展点）"></a>1. 第一优先级：ErrorDecoder（Feign原生扩展点）</h3><p><code>ErrorDecoder</code> 是Feign原生提供的异常解码扩展点，属于「Feign调用响应处理层级」，是异常进入业务链路前的“第一道关口”。</p><p>其核心职责是：拦截Feign调用返回的非2xx异常响应，将Feign默认抛出的 <code>FeignException</code>（包含杂乱的HTTP响应信息）转换为标准化的自定义业务异常，同时可解析异常响应体、提取下游服务异常详情，为后续处理提供统一的异常格式。</p><p>优先级最高的原因的是：它直接嵌入Feign的响应处理流程，在异常被传递给业务层或容错组件前，就完成了解码和转换。后续的Fallback和全局异常捕获器，处理的都是经过它转换后的异常（或未自定义时的默认异常）。</p><h3 id="2-第二优先级：Fallback（容错组件能力）"><a href="#2-第二优先级：Fallback（容错组件能力）" class="headerlink" title="2. 第二优先级：Fallback（容错组件能力）"></a>2. 第二优先级：Fallback（容错组件能力）</h3><p><code>Fallback</code> 是Sentinel、Hystrix、Resilience4j等容错组件提供的兜底能力，属于「微服务容错防护层级」，是异常传播的“第二道关口”。</p><p>其核心职责是：通过AOP或代理模式，拦截Feign调用/业务方法抛出的异常（已被ErrorDecoder处理），将“异常结果”转换为“合法的业务返回数据”，消化异常以防止服务雪崩，同时避免业务层手动try-catch。</p><p>优先级高于全局异常捕获器的原因的是：它在异常产生点附近直接拦截，且处理后返回正常数据——异常被完全“消化”，不再向上传播，导致全局异常捕获器失去触发前提（全局异常捕获器仅处理未被拦截的传播异常）。</p><h3 id="3-第三优先级：全局异常捕获器（Spring-MVC层级）"><a href="#3-第三优先级：全局异常捕获器（Spring-MVC层级）" class="headerlink" title="3. 第三优先级：全局异常捕获器（Spring MVC层级）"></a>3. 第三优先级：全局异常捕获器（Spring MVC层级）</h3><p>全局异常捕获器（基于 <code>@RestControllerAdvice</code> + <code>@ExceptionHandler</code>）是Spring MVC提供的全局能力，属于「应用层异常兜底层级」，是异常处理的“最后一道关口”。</p><p>其核心职责是：捕获所有向上传播到Controller层及以上的未处理异常，统一返回标准化错误响应，避免裸异常暴露给前端。</p><p>优先级最低的原因的是：它的执行依赖“异常未被前置逻辑处理且成功传播”，而Fallback通常会提前消化异常，只有在Fallback失效时，它才会补位生效。</p><h2 id="三、实战验证：直观感受执行顺序"><a href="#三、实战验证：直观感受执行顺序" class="headerlink" title="三、实战验证：直观感受执行顺序"></a>三、实战验证：直观感受执行顺序</h2><p>我们以「OpenFeign 12.0+ + Sentinel + Spring Boot」为例，通过代码验证三者的执行顺序，同时覆盖正常场景与特殊场景。</p><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>依赖核心组件：OpenFeign（12.0+）、Spring Cloud Alibaba Sentinel、Spring Web。</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><h4 id="（1）自定义ErrorDecoder（第一优先级）"><a href="#（1）自定义ErrorDecoder（第一优先级）" class="headerlink" title="（1）自定义ErrorDecoder（第一优先级）"></a>（1）自定义ErrorDecoder（第一优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【1. 执行 ErrorDecoder】：解码Feign异常，状态码=&quot;</span> + response.status());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorBody</span> <span class="operator">=</span> Util.toString(response.body().asReader(Util.UTF_8));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;服务调用异常（ErrorDecoder转换）：&quot;</span> + errorBody);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义业务异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）配置Fallback（第二优先级）"><a href="#（2）配置Fallback（第二优先级）" class="headerlink" title="（2）配置Fallback（第二优先级）"></a>（2）配置Fallback（第二优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Feign接口</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-service&quot;, fallback = ProviderFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/provider/getData&quot;)</span></span><br><span class="line">    String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback兜底类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id + <span class="string">&quot;（服务调用异常）&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）全局异常捕获器（第三优先级）"><a href="#（3）全局异常捕获器（第三优先级）" class="headerlink" title="（3）全局异常捕获器（第三优先级）"></a>（3）全局异常捕获器（第三优先级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleAllException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【3. 执行全局异常捕获器】：捕获异常：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;全局兜底：&quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）业务调用层"><a href="#（4）业务调用层" class="headerlink" title="（4）业务调用层"></a>（4）业务调用层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProviderClient providerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getData&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providerClient.getData(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-场景测试结果"><a href="#3-场景测试结果" class="headerlink" title="3. 场景测试结果"></a>3. 场景测试结果</h3><h4 id="（1）正常场景：三者并存，Fallback正常触发"><a href="#（1）正常场景：三者并存，Fallback正常触发" class="headerlink" title="（1）正常场景：三者并存，Fallback正常触发"></a>（1）正常场景：三者并存，Fallback正常触发</h4><p>当下游服务抛出异常时，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br></pre></td></tr></table></figure><p>接口返回：<code>兜底数据：id=123（服务调用异常）</code>，全局异常捕获器未触发（被Fallback阻断）。</p><h4 id="（2）特殊场景：Fallback自身抛出异常"><a href="#（2）特殊场景：Fallback自身抛出异常" class="headerlink" title="（2）特殊场景：Fallback自身抛出异常"></a>（2）特殊场景：Fallback自身抛出异常</h4><p>修改Fallback逻辑，故意抛出空指针异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderFallback</span> <span class="keyword">implements</span> <span class="title class_">ProviderClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【2. 执行 Fallback】：触发兜底逻辑，返回正常数据&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nullStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        nullStr.length(); <span class="comment">// 空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;兜底数据：id=&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【2. 执行 Fallback】：触发兜底逻辑，返回正常数据</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：null</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：null</code>，Fallback异常向上传播，触发全局异常捕获器。</p><h4 id="（3）特殊场景：Fallback未触发（配置失效）"><a href="#（3）特殊场景：Fallback未触发（配置失效）" class="headerlink" title="（3）特殊场景：Fallback未触发（配置失效）"></a>（3）特殊场景：Fallback未触发（配置失效）</h4><p>若未开启Sentinel与Feign的整合（未配置 <code>feign.sentinel.enabled=true</code>），Fallback配置失效，控制台输出顺序：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【1. 执行 ErrorDecoder】：解码Feign异常，状态码=500</span><br><span class="line">【3. 执行全局异常捕获器】：捕获异常：服务调用异常（ErrorDecoder转换）：xxx</span><br></pre></td></tr></table></figure><p>接口返回：<code>全局兜底：服务调用异常（ErrorDecoder转换）：xxx</code>，Fallback未触发，异常传播至全局捕获器。</p><h2 id="四、实践建议：三者协同的最佳姿势"><a href="#四、实践建议：三者协同的最佳姿势" class="headerlink" title="四、实践建议：三者协同的最佳姿势"></a>四、实践建议：三者协同的最佳姿势</h2><p>三者并非互斥关系，而是互补关系，合理搭配可实现“异常标准化+容错兜底+最终补位”的三层防护体系，提升微服务稳定性。</p><h3 id="1-分工明确，各司其职"><a href="#1-分工明确，各司其职" class="headerlink" title="1. 分工明确，各司其职"></a>1. 分工明确，各司其职</h3><ul><li><p><strong>ErrorDecoder</strong>：专注“异常标准化”，统一转换Feign原生异常为业务异常，解析异常详情，不做兜底逻辑；</p></li><li><p><strong>Fallback</strong>：专注“容错兜底”，针对核心服务调用，返回预设兜底数据（如缓存数据、默认值），防止服务雪崩；</p></li><li><p><strong>全局异常捕获器</strong>：专注“最终补位”，捕获所有漏网异常（Fallback异常、配置错误导致的异常），统一返回前端友好响应。</p></li></ul><h3 id="2-规避常见坑点"><a href="#2-规避常见坑点" class="headerlink" title="2. 规避常见坑点"></a>2. 规避常见坑点</h3><ul><li><p>Fallback方法签名必须与原方法一致（参数、返回值类型匹配），否则配置失效，异常直接传播；</p></li><li><p>Hystrix会忽略 <code>HystrixBadRequestException</code> 及 <code>ignoreExceptions</code> 配置的异常，这类异常不触发Fallback，需通过全局捕获器处理；</p></li><li><p>ErrorDecoder中避免抛出非业务异常，建议统一转换为自定义异常，便于Fallback和全局捕获器识别。</p></li></ul><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><ul><li>异常多层包装（含 Error 类型）会阻断 Spring 自动穿透。当异常链中存在 AssertionError 等 Error 类型异常时（如 Sentinel 整合 Feign 场景，在fallback函数中抛出RuntimeException异常会被Sentinel自动包装为AssertionError 继承 Error分支，然后又被Spring MVC DispatcherServlet自动抛出为NestedServletException异常），Spring 的 @ExceptionHandler 自动穿透功能仅支持 Exception 分支，无法穿透 Error 类型异常，导致自定义异常（CommonException）无法被精准捕获，最终被 Exception 兜底处理器捕获（或者被NestedServletException异常捕获器捕获）；</li><li><p>解决方案：手动解析完整的 Throwable 链（包含 Error 和 Exception），通过循环遍历 cause 链主动提取目标自定义异常，再手动分发到对应异常处理器；</p></li><li><p>下面是spring对于异常处理的源码。可以看见如果遇到非Exception的Throwable。它会自动抛出NestedServletException</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用处理器方法（Controller方法、Feign调用、Service方法等都在这一步执行）</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 捕获Exception类型异常，直接赋值给dispatchException，不包装</span></span><br><span class="line">    dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    <span class="comment">// 捕获Throwable类型（非Exception，如Error、AssertionError等），包装为NestedServletException</span></span><br><span class="line">    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-组件选择建议"><a href="#4-组件选择建议" class="headerlink" title="4. 组件选择建议"></a>4. 组件选择建议</h3><p>Hystrix已进入维护模式，推荐使用 <strong>Resilience4j</strong>（轻量、Spring官方推荐）或 <strong>Sentinel</strong>（阿里生态，支持流量控制、熔断降级等丰富特性）作为Fallback载体；OpenFeign 12.0+ 建议搭配 <code>ResponseInterceptor</code> 做响应日志预处理，与ErrorDecoder协同提升异常排查效率。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Feign异常处理的三重机制，本质是不同层级的“异常拦截-处理”链路：ErrorDecoder负责“入口标准化”，Fallback负责“中间容错”，全局异常捕获器负责“最终补位”。优先级的核心逻辑是“先处理异常、再消化异常、最后补位异常”。</p><p>在实际开发中，三者协同使用，既能保证异常处理的规范性和灵活性，又能提升微服务的高可用性，避免因单一异常处理机制失效导致的服务不稳定问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘&quot;&gt;&lt;a href=&quot;#Feign异常处理三重奏：ErrorDecoder、Fallback与全局异常捕获器的优先级探秘&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://nmcb666.vip/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>微服务之间的全局异常捕获</title>
    <link href="https://nmcb666.vip/posts/df97f9d4.html"/>
    <id>https://nmcb666.vip/posts/df97f9d4.html</id>
    <published>2025-12-24T02:09:18.000Z</published>
    <updated>2026-01-28T18:22:02.284Z</updated>
    
    <content type="html"><![CDATA[<p>在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是500，错误信息固定为INTERNAL_SERVER_ERROR，全局异常捕获器形同虚设，尤其在微服务间通过OpenFeign调用API时，该问题更为突出。本文将围绕这一问题，从原因分析、解决方案到特殊场景适配，逐步拆解实战过程中的思考与踩坑。</p><h2 id="一、问题现象：单体架构异常捕获在微服务中失效"><a href="#一、问题现象：单体架构异常捕获在微服务中失效" class="headerlink" title="一、问题现象：单体架构异常捕获在微服务中失效"></a>一、问题现象：单体架构异常捕获在微服务中失效</h2><p>在单体应用中，我们通常会编写如下全局异常捕获器，针对不同业务异常返回自定义状态码和信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(e.getCode(), e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在微服务架构中，当服务A通过OpenFeign调用服务B，服务B抛出BusinessException并被自身全局异常捕获器处理，返回400状态码和自定义信息时，服务A接收到的响应却依然是500 INTERNAL_SERVER_ERROR，无法获取服务B返回的真实异常信息，导致异常排查困难，也无法根据真实异常类型做后续业务处理。</p><h2 id="二、根源分析：OpenFeign对非2XX响应的默认处理机制"><a href="#二、根源分析：OpenFeign对非2XX响应的默认处理机制" class="headerlink" title="二、根源分析：OpenFeign对非2XX响应的默认处理机制"></a>二、根源分析：OpenFeign对非2XX响应的默认处理机制</h2><p>问题的核心在于微服务间的调用方式——OpenFeign的异常处理逻辑。当被调用方（服务B）抛出异常后，其自身的全局异常捕获器会正常工作，返回自定义的非2XX状态码（如400、502）和错误信息。但调用方（服务A）通过OpenFeign调用时，OpenFeign有一个默认规则：<strong>对所有非2XX的HTTP响应，都会自动抛出FeignException异常</strong>。</p><p>这就导致服务A无法直接获取服务B返回的自定义异常信息，只能捕获到OpenFeign封装的FeignException，而该异常默认对应500 INTERNAL_SERVER_ERROR状态码，最终呈现出“所有异常都返回500”的现象。本质上是OpenFeign的默认异常转换，覆盖了被调用方的自定义异常响应。</p><h2 id="三、解决方案一：自定义ErrorDecoder处理状态码异常"><a href="#三、解决方案一：自定义ErrorDecoder处理状态码异常" class="headerlink" title="三、解决方案一：自定义ErrorDecoder处理状态码异常"></a>三、解决方案一：自定义ErrorDecoder处理状态码异常</h2><p>要解决上述问题，我们可以通过自定义ErrorDecoder接口实现，覆写decode方法，对不同状态码的响应进行差异化处理，还原被调用方的真实异常信息，甚至返回自定义异常类型。</p><h3 id="3-1-自定义ErrorDecoder实现"><a href="#3-1-自定义ErrorDecoder实现" class="headerlink" title="3.1 自定义ErrorDecoder实现"></a>3.1 自定义ErrorDecoder实现</h3><p>注意：decode方法的核心是<strong>返回FeignException，而非直接抛出异常</strong>，OpenFeign会对该返回值做进一步处理并传递给调用方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomErrorDecoder</span> <span class="keyword">implements</span> <span class="title class_">ErrorDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorDecoder</span> <span class="variable">defaultErrorDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">decode</span><span class="params">(String methodKey, Response response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeignException</span>.InternalServerError(methodKey, response, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据响应状态码自定义异常</span></span><br><span class="line">        <span class="keyword">switch</span> (response.status()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                <span class="comment">// 解析响应体，封装自定义业务异常信息</span></span><br><span class="line">                <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">                <span class="keyword">return</span> FeignException.badRequest(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>)</span><br><span class="line">                        .reason(errorResponse.getMsg());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                <span class="keyword">return</span> FeignException.serviceUnavailable(methodKey, response, responseBody.getBytes(), <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 其他状态码可按需扩展</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 默认使用OpenFeign原生解码器</span></span><br><span class="line">                <span class="keyword">return</span> defaultErrorDecoder.decode(methodKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-配置FeignConfig注册Bean"><a href="#3-2-配置FeignConfig注册Bean" class="headerlink" title="3.2 配置FeignConfig注册Bean"></a>3.2 配置FeignConfig注册Bean</h3><p>将自定义的CustomErrorDecoder配置为Spring Bean，纳入Feign的配置体系中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ErrorDecoder <span class="title function_">errorDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomErrorDecoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，当服务A通过OpenFeign调用服务B时，若服务B返回非2XX状态码，CustomErrorDecoder会解析响应体，返回对应状态码的FeignException，并携带真实错误信息，服务A即可通过捕获FeignException获取详细异常内容，再结合自身全局异常捕获器做进一步处理。</p><h2 id="四、特殊场景：基于业务状态码的响应处理"><a href="#四、特殊场景：基于业务状态码的响应处理" class="headerlink" title="四、特殊场景：基于业务状态码的响应处理"></a>四、特殊场景：基于业务状态码的响应处理</h2><p>上述方案适用于HTTP状态码区分异常的场景，但在实际项目开发中，很多团队会采用“统一HTTP状态码”的设计：所有接口均返回200 OK，异常信息通过响应体中的自定义业务状态码（如code字段）、msg字段区分，data字段存储业务数据，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">10001</span><span class="punctuation">,</span> <span class="comment">// 10001代表业务异常，200代表成功</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;参数校验失败&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种场景下，ErrorDecoder将完全失效——因为ErrorDecoder仅拦截HTTP状态码为4XX、5XX的响应，而当前所有请求的HTTP状态码都是200，无法触发自定义解码逻辑。此时需要寻找新的解决方案。</p><h2 id="五、解决方案二：CustomResponseInterceptor（版本限制）"><a href="#五、解决方案二：CustomResponseInterceptor（版本限制）" class="headerlink" title="五、解决方案二：CustomResponseInterceptor（版本限制）"></a>五、解决方案二：CustomResponseInterceptor（版本限制）</h2><p>针对HTTP 200响应中嵌入业务状态码的场景，可通过自定义ResponseInterceptor接口实现，覆写intercept方法，在响应返回后解析业务状态码，判断是否存在异常并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResponseInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ResponseInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intercept</span><span class="params">(Response response, Chain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析响应体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().asInputStream()) &#123;</span><br><span class="line">            responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> JSON.parseObject(responseBody, ErrorResponse.class);</span><br><span class="line">            <span class="comment">// 根据业务状态码判断是否抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (errorResponse.getCode() != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorResponse.getCode(), errorResponse.getMsg());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(<span class="string">&quot;响应解析异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.proceed(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要在FeignConfig中配置该拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ResponseInterceptor <span class="title function_">responseInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomResponseInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该方案存在明显局限性：<strong>ResponseInterceptor接口仅在OpenFeign 12.0+版本中提供</strong>，对于一些基于低版本OpenFeign（如Spring Cloud Netflix早期版本）的老项目，无法使用该方案，兼容性较差。</p><h2 id="六、尝试方案：AOP拦截Feign调用（失效原因分析）"><a href="#六、尝试方案：AOP拦截Feign调用（失效原因分析）" class="headerlink" title="六、尝试方案：AOP拦截Feign调用（失效原因分析）"></a>六、尝试方案：AOP拦截Feign调用（失效原因分析）</h2><p>针对低版本OpenFeign无法使用ResponseInterceptor的问题，我尝试通过AOP切面，在Feign客户端调用API后，对响应结果进行解析，根据业务状态码抛出对应异常。但实际测试发现，AOP切面完全不生效，无法拦截Feign客户端的方法调用。</p><p>查阅资料后，明确了失效的核心原因：</p><ol><li><p><strong>Feign客户端的创建机制</strong>：Feign客户端是通过动态代理生成的，而非Spring容器管理的普通Bean，其代理逻辑由Feign自身控制。</p></li><li><p><strong>Spring AOP的拦截限制</strong>：Spring AOP默认采用JDK动态代理，仅能拦截Spring容器管理的Bean的方法调用，无法直接拦截Feign生成的动态代理对象。</p></li><li><p><strong>代理优先级问题</strong>：Feign动态代理的优先级高于Spring AOP代理，导致AOP切面无法切入Feign客户端的方法执行流程。</p></li></ol><p>即便尝试切换为CGLIB代理，也无法有效拦截Feign客户端的调用，该方案最终宣告失败。</p><h2 id="七、现状与思考：待解决的痛点"><a href="#七、现状与思考：待解决的痛点" class="headerlink" title="七、现状与思考：待解决的痛点"></a>七、现状与思考：待解决的痛点</h2><p>综合以上实践，目前针对微服务间异常捕获的解决方案存在明显的场景局限性：</p><ul><li><p>基于ErrorDecoder的方案：适用于HTTP状态码区分异常的场景，兼容性好，无版本限制，是目前最成熟的方案。</p></li><li><p>基于ResponseInterceptor的方案：适用于HTTP 200+业务状态码的场景，但仅支持OpenFeign 12.0+版本，老项目无法适配。</p></li><li><p>AOP方案：理论上可适配所有版本，但因Feign动态代理机制限制，无法生效，暂无可行的优化方向。</p></li></ul><p>对于“低版本OpenFeign + HTTP 200 + 业务状态码”的组合场景，目前仍没有优雅且兼容的解决方案。可以考虑在调用api的方法中，去接受api返回的响应结果，根据业务状态码判断是否抛出异常，但这种方案侵入性强，违背了面向切面编程的思想。</p><p>在此也欢迎各位同行分享实践经验，探讨更优的解决方案，共同完善微服务异常处理体系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>微服务间的异常捕获相比单体架构更复杂，核心难点在于OpenFeign的代理机制和响应处理逻辑。在实际开发中，建议优先采用“HTTP状态码+自定义响应体”的方式设计接口，通过CustomErrorDecoder实现异常透传，兼顾兼容性和优雅性；若因业务需求必须使用统一HTTP 200状态码，则需评估升级OpenFeign版本的可行性，或权衡侵入性方案的取舍。后续将持续关注OpenFeign的版本更新和社区实践，寻找更完善的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在单体架构中，我们通过全局异常捕获器（如@ControllerAdvice+@ExceptionHandler）就能优雅地处理各类异常，自定义响应状态码和错误信息。但迁移到Spring Cloud微服务架构后，却遇到了一个棘手的问题：无论发生何种异常，接口返回的状态码始终是</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://nmcb666.vip/tags/spring-cloud/"/>
    
  </entry>
  
</feed>
