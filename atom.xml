<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳斯卡可`Blog</title>
  <icon>https://www.gravatar.com/avatar/feb67af737a34cba9363ed2d415c9ae9</icon>
  <subtitle>😶‍🌫️</subtitle>
  <link href="https://nmcb666.vip/atom.xml" rel="self"/>
  
  <link href="https://nmcb666.vip/"/>
  <updated>2026-02-07T05:35:43.510Z</updated>
  <id>https://nmcb666.vip/</id>
  
  <author>
    <name>纳斯卡可</name>
    <email>2843035026@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka为什么这么快</title>
    <link href="https://nmcb666.vip/posts/4b1bdc5.html"/>
    <id>https://nmcb666.vip/posts/4b1bdc5.html</id>
    <published>2026-02-07T13:32:58.000Z</published>
    <updated>2026-02-07T05:35:43.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计"><a href="#深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计" class="headerlink" title="深度解析：为什么 Kafka 能快到“突破天际”？—— 论 Kafka 的机械共鸣设计"></a>深度解析：为什么 Kafka 能快到“突破天际”？—— 论 Kafka 的机械共鸣设计</h1><p>在分布式系统领域，Apache Kafka 几乎是高性能消息队列的代名词。令人惊叹的是，作为一个<strong>基于磁盘存储</strong>的系统，Kafka 的吞吐量竟然能超越许多基于内存的数据库。</p><p>很多人将其归结为“快”，但这种快并不是某种单一的黑科技，而是一场<strong>对硬件特性的极致压榨</strong>。这种设计思想在计算机科学中被称为 <strong>“机械共鸣”</strong> —— 即了解底层硬件的工作原理，并让软件设计顺应这些原理。</p><p>本文将从五个核心维度，拆解 Kafka 性能神话背后的技术思考。</p><hr><h3 id="一、-颠覆认知：磁盘并不慢，随机读写才慢"><a href="#一、-颠覆认知：磁盘并不慢，随机读写才慢" class="headerlink" title="一、 颠覆认知：磁盘并不慢，随机读写才慢"></a>一、 颠覆认知：磁盘并不慢，随机读写才慢</h3><p>很多人对 Kafka 的第一个疑问是：“数据存磁盘上，怎么可能快？”</p><p>事实上，磁盘的<strong>顺序写（Sequential Writing）</strong>性能极高。在某些场景下，磁盘顺序写的速度甚至可以媲美随机内存读写。</p><ul><li><strong>Kafka 的做法</strong>：Kafka 将所有消息以 <strong>Append-only（仅追加）</strong> 的方式写入日志文件（Log）。它不执行任何随机位置的更新，也不删除单条数据。</li><li><strong>技术思考</strong>：通过将“逻辑上的随机写”转换为“物理上的顺序写”，Kafka 绕过了磁盘磁头寻道的最大延迟。这种简单到极致的追加设计，是其写入性能的基础。</li></ul><h3 id="二、-零拷贝（Zero-Copy）：减少-CPU-的“搬运工”工作"><a href="#二、-零拷贝（Zero-Copy）：减少-CPU-的“搬运工”工作" class="headerlink" title="二、 零拷贝（Zero-Copy）：减少 CPU 的“搬运工”工作"></a>二、 零拷贝（Zero-Copy）：减少 CPU 的“搬运工”工作</h3><p>在传统的网络传输中，数据从磁盘到网卡需要经历 <strong>4 次拷贝</strong>和 <strong>4 次上下文切换</strong>。</p><ol><li>磁盘 -&gt; 内核缓冲区</li><li>内核缓冲区 -&gt; 用户空间应用缓冲区（CPU 参与）</li><li>用户空间应用缓冲区 -&gt; 内核 Socket 缓冲区（CPU 参与）</li><li>Socket 缓冲区 -&gt; 网卡</li></ol><ul><li><strong>Kafka 的优化</strong>：Kafka 利用了 Linux 内核的 <code>sendfile</code> 系统调用。数据直接从<strong>内核页缓存（Page Cache）</strong>传输到<strong>网卡</strong>，跳过了用户空间。</li><li><strong>技术思考</strong>：这意味着数据在传输过程中不需要经过 Java 堆内存，不仅减少了 CPU 消耗，更重要的是<strong>彻底消除了 JVM 的垃圾回收（GC）压力</strong>。对于海量数据流，不进 JVM 才是最快的。</li></ul><h3 id="三、-页缓存（Page-Cache）-vs-JVM-缓存"><a href="#三、-页缓存（Page-Cache）-vs-JVM-缓存" class="headerlink" title="三、 页缓存（Page Cache） vs JVM 缓存"></a>三、 页缓存（Page Cache） vs JVM 缓存</h3><p>传统的 Java 应用喜欢在内存中维护各种 Cache。但 Kafka 反其道而行之：它几乎不自己管理缓存，而是完全交由操作系统的 <strong>Page Cache</strong> 处理。</p><ul><li><strong>带来的红利</strong>：<ul><li><strong>内存利用率更高</strong>：Page Cache 由内核管理，避免了对象存储在 JVM 堆中带来的额外内存开销（Header, Padding 等）。</li><li><strong>热数据直达</strong>：如果消费者紧跟生产者的脚步，消息直接从内存中读取，根本不会产生真实的磁盘 I/O。</li><li><strong>容错性</strong>：即使 Kafka 进程崩溃，数据依然在系统缓存中，重启后依然可以立即通过缓存提供服务。</li></ul></li></ul><h3 id="四、-网络通信的艺术：多级-Reactor-模型"><a href="#四、-网络通信的艺术：多级-Reactor-模型" class="headerlink" title="四、 网络通信的艺术：多级 Reactor 模型"></a>四、 网络通信的艺术：多级 Reactor 模型</h3><p>Kafka 的网络层是高性能并发处理的典范。它采用了<strong>基于 Java NIO 的多级 Reactor 模型</strong>：</p><ol><li><strong>Acceptor</strong>：只负责接收连接。</li><li><strong>Processor 线程池</strong>：负责处理 I/O 读写。每个线程维护一个 Selector，并发管理成千上万个连接。</li><li><strong>RequestHandler 线程池</strong>：解耦网络 I/O 与业务逻辑。</li></ol><ul><li><strong>技术思考</strong>：这种设计实现了<strong>读写分离</strong>。即便某个请求因为磁盘压力变慢，Processor 线程依然可以继续接收其他连接的数据，不会导致整个系统的网络阻塞。</li></ul><h3 id="五、-批量化与压缩：压榨每一比特带宽"><a href="#五、-批量化与压缩：压榨每一比特带宽" class="headerlink" title="五、 批量化与压缩：压榨每一比特带宽"></a>五、 批量化与压缩：压榨每一比特带宽</h3><p>在高性能系统中，网络往返（RTT）和系统调用的开销往往比数据处理本身更贵。</p><ul><li><strong>批量（Batching）</strong>：Kafka 允许生产者将多条消息打包成一个 Batch 发送。对 Broker 来说，一次 I/O 操作写入的是一批消息，大大减少了系统调用次数。</li><li><strong>压缩（Compression）</strong>：Kafka 支持端到端的压缩（Producer 压缩 -&gt; Broker 存储 -&gt; Consumer 解压）。</li><li><strong>技术思考</strong>：在现代系统中，带宽往往比 CPU 更珍贵。通过在 Producer 端消耗少量 CPU 进行压缩，换取更小的网络延迟和存储空间，是一笔极其划算的买卖。</li></ul><hr><h3 id="总结：Kafka-给我们的架构启示"><a href="#总结：Kafka-给我们的架构启示" class="headerlink" title="总结：Kafka 给我们的架构启示"></a>总结：Kafka 给我们的架构启示</h3><p>Kafka 的成功并非源于它发明了什么深奥的算法，而在于它对<strong>操作系统基础原语</strong>的深刻理解：</p><ol><li><strong>顺应硬件</strong>：既然随机 I/O 慢，就只用顺序 I/O。</li><li><strong>相信系统</strong>：既然内核管缓存管得好，就不要在 JVM 里重复造轮子。</li><li><strong>减少损耗</strong>：既然搬运数据浪费 CPU，就用零拷贝绕过去。</li><li><strong>分而治之</strong>：既然单机有上限，就通过分区（Partitioning）实现横向扩展。</li></ol><p><strong>“快”的本质，其实是消除浪费。</strong> Kafka 的架构告诉我们：有时候，为了获得极致的性能，你不需要做得更多，而是要学会“少做”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计&quot;&gt;&lt;a href=&quot;#深度解析：为什么-Kafka-能快到“突破天际”？——-论-Kafka-的机械共鸣设计&quot; class=&quot;headerlink&quot; title=&quot;深度解析：为</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java中的NIO就是操作系统的同步非阻塞IO吗？</title>
    <link href="https://nmcb666.vip/posts/9edb0695.html"/>
    <id>https://nmcb666.vip/posts/9edb0695.html</id>
    <published>2026-02-07T02:26:33.000Z</published>
    <updated>2026-02-07T05:35:43.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”"><a href="#Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”" class="headerlink" title="Java NIO：不仅仅是“非阻塞”，更是 IO 模型的“Pro Max”"></a>Java NIO：不仅仅是“非阻塞”，更是 IO 模型的“Pro Max”</h1><p>在 Java 后端面试或高并发系统设计的讨论中，<strong>NIO (New I/O)</strong> 永远是一个绕不开的话题。</p><p>很多同学在初学时，往往会被教科书上的定义绕晕：</p><ul><li>“NIO 是同步非阻塞的。”</li><li>“NIO 有三大组件：Channel、Buffer、Selector。”</li><li>“NIO 性能比 BIO 好。”</li></ul><p>但如果继续追问：“为什么非阻塞就快？Selector 到底是个什么东西？它和操作系统的 epoll 有什么关系？”很多人可能就卡壳了。</p><p>今天我们就从<strong>操作系统的底层模型</strong>出发，来聊聊 Java NIO 的前世今生，以及为什么我说它是 IO 模型的“Pro Max”版。</p><h2 id="1-痛点：BIO-时代的“贵族服务”"><a href="#1-痛点：BIO-时代的“贵族服务”" class="headerlink" title="1. 痛点：BIO 时代的“贵族服务”"></a>1. 痛点：BIO 时代的“贵族服务”</h2><p>在 JDK 1.4 之前，我们使用的是 BIO（Blocking I/O，阻塞 IO）。<br>BIO 的编程模型非常简单符合直觉：<strong>建立连接 -&gt; 读数据 -&gt; 写数据</strong>。</p><p>但是它有一个致命的弱点：<strong>阻塞</strong>。<br>就像一个传统的餐厅，<strong>每一桌客人（Socket 连接）必须配备一名专属服务员（Thread）</strong>。</p><ul><li>客人看菜单（数据未就绪），服务员就得傻站在旁边等着，什么都不能干。</li><li>客人吃饭（数据传输中），服务员还是得等着。</li></ul><p><strong>后果是显而易见的：</strong><br>如果餐厅来了 1 万桌客人，老板就需要雇佣 1 万个服务员。在计算机世界里，线程是昂贵的资源，内存占用高、上下文切换开销大。这种“一对一”的贵族服务模式，注定了 BIO 无法支撑高并发。</p><h2 id="2-误区：NIO-就是“非阻塞”吗？"><a href="#2-误区：NIO-就是“非阻塞”吗？" class="headerlink" title="2. 误区：NIO 就是“非阻塞”吗？"></a>2. 误区：NIO 就是“非阻塞”吗？</h2><p>为了解决阻塞问题，操作系统引入了 <strong>Non-blocking I/O（非阻塞 IO）</strong> 的概念。很多人认为 Java NIO 指的就是这个。</p><p><strong>并不完全是。</strong></p><p>如果仅仅把 Socket 设置为非阻塞（Non-blocking），模型是这样的：</p><ul><li>用户线程发起读取请求。</li><li>内核看了一眼：没数据。立刻返回一个错误（EWOULDBLOCK）。</li><li>用户线程不死心，过一会儿再来问，还没有，再返回错误。</li></ul><p>这在技术上叫<strong>“轮询”（Polling）</strong>。<br>这就好比服务员不傻站着了，他在餐厅里跑来跑去，不停地问每一桌：“你要点菜吗？你要点菜吗？”</p><p>虽然线程没被卡死，但 CPU 却在空转（Busy Waiting）。每一次询问都是一次用户态到内核态的切换，这种<strong>“用户态轮询”</strong>效率极低，甚至比 BIO 还糟糕。</p><h2 id="3-破局：IO-多路复用"><a href="#3-破局：IO-多路复用" class="headerlink" title="3. 破局：IO 多路复用"></a>3. 破局：IO 多路复用</h2><p>Java NIO 的真正威力，不仅仅在于“非阻塞”，而在于它引入了 <strong>Selector（选择器）</strong>。</p><p>Selector 的本质，是利用了操作系统的 <strong>I/O 多路复用（I/O Multiplexing）</strong> 技术。<br>这才是真正的 <strong>Pro Max</strong> 进化。</p><h3 id="什么是多路复用？"><a href="#什么是多路复用？" class="headerlink" title="什么是多路复用？"></a>什么是多路复用？</h3><p>复用，是指<strong>多个连接复用同一个线程</strong>。<br>在这个模型下，餐厅不再需要几千个服务员，也不需要一个服务员像没头苍蝇一样轮询。我们引入了一个<strong>“智能管家”（Selector）</strong>。</p><ol><li><strong>注册：</strong> 所有的桌子（Channel）都在管家那里登记：“我有事会按铃，没按铃别烦我。”</li><li><strong>监听：</strong> 管家在吧台坐着，只听铃声（事件）。</li><li><strong>处理：</strong> 只有当某一桌按铃了（数据就绪），管家才通知服务员过去处理。</li></ol><h3 id="这里的关键点在于：谁在轮询？"><a href="#这里的关键点在于：谁在轮询？" class="headerlink" title="这里的关键点在于：谁在轮询？"></a>这里的关键点在于：谁在轮询？</h3><ul><li><strong>普通非阻塞 IO：</strong> 是<strong>用户程序</strong>在轮询（低效）。</li><li><strong>IO 多路复用（Java NIO）：</strong> 是<strong>操作系统内核</strong>在帮你轮询（高效）。</li></ul><h2 id="4-底层黑科技：从-select-到-epoll"><a href="#4-底层黑科技：从-select-到-epoll" class="headerlink" title="4. 底层黑科技：从 select 到 epoll"></a>4. 底层黑科技：从 select 到 epoll</h2><p>Java NIO 的 Selector 只是一个 Java API，它的性能取决于底层的操作系统实现。</p><ul><li><strong>JDK 1.4 / 早期 Linux：</strong> 使用 <code>select</code> 或 <code>poll</code> 模型。<ul><li>这就像管家虽然不跑了，但他手里拿个长长的单子（1万个连接）。每次有人按铃，他都要从头到尾检查一遍单子：“是谁按的铃？”（时间复杂度 O(N)）。</li></ul></li><li><strong>JDK 1.5+ / 现代 Linux：</strong> 使用 <strong>epoll</strong> 模型。<ul><li>Epoll 是<strong>事件驱动</strong>的。它在内核里维护了一个“就绪列表”。</li><li>谁按铃，硬件中断直接把谁的名字扔进“就绪列表”。</li><li>管家只需要看一眼“就绪列表”里有没有人就行了，根本不需要遍历那 1 万个连接。（时间复杂度 O(1)）。</li></ul></li></ul><p><strong>所以，当我们说 Java NIO 高性能时，默认是在 Linux 环境下，因为其底层依托于 epoll 强大的事件驱动能力。</strong></p><h2 id="5-总结与思考"><a href="#5-总结与思考" class="headerlink" title="5. 总结与思考"></a>5. 总结与思考</h2><p>回答标题的问题：<br><strong>Java NIO 是什么？</strong><br>它是一套工具包，它引入了 Buffer（内存管理）、Channel（双向通道），但其灵魂是 <strong>Selector</strong>。</p><p><strong>它是 IO 多路复用吗？</strong><br>Java NIO 的 Selector 是 <strong>IO 多路复用</strong> 在 JVM 层面的封装。而在 Linux 上，它最终进化为 <strong>epoll</strong>，解决了传统轮询的性能瓶颈。</p><p><strong>技术思考图谱：</strong></p><ol><li><strong>BIO</strong> = 阻塞 + 多线程（资源耗尽）</li><li><strong>OS NIO</strong> = 非阻塞 + 用户态轮询（CPU 空转）</li><li><strong>Java NIO (Selector)</strong> = 非阻塞 + <strong>IO 多路复用</strong> (内核态轮询/事件驱动) = <strong>高并发的基石</strong></li></ol><p>理解了这一点，你再去看 Netty 这种框架，就会明白它为什么这么快：因为它不仅把 Java NIO 难用的 API 封装好了，还通过 Reactor 模型将这种“多路复用”的优势发挥到了极致。</p><h2 id="补充说明，操作系统的NIO跟多路复用的区别"><a href="#补充说明，操作系统的NIO跟多路复用的区别" class="headerlink" title="补充说明，操作系统的NIO跟多路复用的区别"></a>补充说明，操作系统的NIO跟多路复用的区别</h2><p>NIO就是用户进程轮询，多路复用是内核里面的选择器去轮询。这正是区分 <strong>“单纯的非阻塞 IO（OS NIO）”</strong> 和 <strong>“IO 多路复用”</strong> 最核心的界限：<strong>苦力活（轮询）到底是谁在干？</strong></p><h3 id="1-单纯的-OS-NIO-用户进程在轮询"><a href="#1-单纯的-OS-NIO-用户进程在轮询" class="headerlink" title="1. 单纯的 OS NIO = 用户进程在轮询"></a>1. 单纯的 OS NIO = 用户进程在轮询</h3><p><strong>“用户进程自己去轮询”</strong>。</p><ul><li><strong>场景：</strong> 你写了一个 <code>while(true)</code> 循环。</li><li><strong>动作：</strong> 你的代码里遍历 1000 个 Socket，挨个调用系统函数 <code>read()</code>。</li><li><strong>对话：</strong><ul><li>用户：“Socket A 有数据吗？” -&gt; 内核：“没。”（上下文切换 1 次）</li><li>用户：“Socket B 有数据吗？” -&gt; 内核：“没。”（上下文切换 1 次）</li><li>…</li><li>用户：“Socket Z 有数据吗？” -&gt; 内核：“没。”（上下文切换 1 次）</li></ul></li><li><strong>代价：</strong><ul><li><strong>CPU 瞎忙：</strong> 你的进程跑得飞快，CPU 占用率 100%，但全是空转。</li><li><strong>系统开销巨大：</strong> 每一次 <code>read()</code> 都是一次 <strong>用户态 &lt;-&gt; 内核态</strong> 的切换。1000 次循环就是 1000 次切换，这简直是性能杀手。</li></ul></li></ul><h3 id="2-IO-多路复用-内核在轮询-监控"><a href="#2-IO-多路复用-内核在轮询-监控" class="headerlink" title="2. IO 多路复用 = 内核在轮询/监控"></a>2. IO 多路复用 = 内核在轮询/监控</h3><p><strong>“内核里面的选择器去轮询”</strong>。</p><ul><li><strong>场景：</strong> 你把 1000 个 Socket 打包，调用一次 <code>select()</code> 或 <code>epoll_wait()</code>。</li><li><strong>动作：</strong> 你的进程此时<strong>休息了</strong>（阻塞在这一行），把监控的任务甩锅给内核。</li><li><strong>对话：</strong><ul><li>用户：“内核，这 1000 个兄弟你帮我盯着，谁有数据了叫醒我。” -&gt; <strong>（只有 1 次上下文切换）</strong></li><li>… （用户睡觉，内核在干活） …</li><li>内核：“醒醒！Socket C 和 Socket F 有数据了！” -&gt; <strong>（再切换 1 次回来）</strong></li></ul></li><li><strong>收益：</strong><ul><li><strong>用户态不忙了：</strong> 用户进程不需要写死循环，不需要做无意义的系统调用。</li><li><strong>切换次数极少：</strong> 从 N 次切换变成了 1 次切换。</li></ul></li></ul><hr><h3 id="还有一个深层次的细节（关于-epoll）"><a href="#还有一个深层次的细节（关于-epoll）" class="headerlink" title="还有一个深层次的细节（关于 epoll）"></a>还有一个深层次的细节（关于 epoll）</h3><p>“内核选择器去轮询”，这对于 <code>select</code> 和 <code>poll</code> 是完全正确的。</p><p>但对于 <strong>epoll</strong>，内核甚至<strong>都不用轮询</strong>，它更高级：</p><ul><li><strong>select/poll（内核轮询）：</strong> 内核在一个死循环里检查这 1000 个 Socket 的状态。（虽然比用户态轮询快，但内核也很累）。</li><li><strong>epoll（内核回调）：</strong> 内核根本不轮询。它在网卡驱动上注册了<strong>回调函数</strong>。<ul><li>网卡收到数据 -&gt; 触发硬件中断 -&gt; 触发回调 -&gt; <strong>直接把有数据的那个 Socket 扔进“就绪列表”</strong>。</li><li>内核只需要看一眼那个列表是不是空的就行了。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><strong>NIO（指 OS 原始非阻塞）是用户态自己在死循环检查；</strong><br><strong>多路复用是把这个检查的动作挪到了内核态（由 select 轮询或 epoll 事件驱动），从而解放了用户进程。</strong></p></blockquote><p>这也是为什么 Java NIO（使用多路复用）比单纯使用非阻塞 Socket 性能高出几个数量级的原因。</p><hr><blockquote><p><strong>写在最后</strong><br>技术名词层出不穷，但底层的原理往往是通用的。从 BIO 到 NIO 的演进，本质上是<strong>为了压榨 CPU 性能，减少无效等待和上下文切换</strong>。理解了“谁在等”和“谁在问”，就理解了高并发 IO 的核心。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”&quot;&gt;&lt;a href=&quot;#Java-NIO：不仅仅是“非阻塞”，更是-IO-模型的“Pro-Max”&quot; class=&quot;headerlink&quot; title=&quot;Java NIO：不仅仅是“非阻塞”</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法（十五） 背包dp</title>
    <link href="https://nmcb666.vip/posts/2707a2f4.html"/>
    <id>https://nmcb666.vip/posts/2707a2f4.html</id>
    <published>2026-02-05T16:34:22.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="基础背包"><a href="#基础背包" class="headerlink" title="基础背包"></a>基础背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[weight+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=weight;j&gt;=nums[i-<span class="number">1</span>];j--)&#123;</span><br><span class="line">        dp[j] = Math.max(dp[j-nums[i-<span class="number">1</span>]]+nums[i-<span class="number">1</span>],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[weight];</span><br></pre></td></tr></table></figure><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>leetcode 494</p><p>思路：见代码注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新思路，转化为01背包问题</span></span><br><span class="line"><span class="comment">// 思考1:</span></span><br><span class="line"><span class="comment">// 虽然题目说nums是非负数组，但即使nums中有负数比如[3,-4,2]</span></span><br><span class="line"><span class="comment">// 因为能在每个数前面用+或者-号</span></span><br><span class="line"><span class="comment">// 所以[3,-4,2]其实和[3,4,2]会达成一样的结果</span></span><br><span class="line"><span class="comment">// 所以即使nums中有负数，也可以把负数直接变成正数，也不会影响结果</span></span><br><span class="line"><span class="comment">// 思考2:</span></span><br><span class="line"><span class="comment">// 如果nums都是非负数，并且所有数的累加和是sum</span></span><br><span class="line"><span class="comment">// 那么如果target&gt;sum，很明显没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line"><span class="comment">// 思考3:</span></span><br><span class="line"><span class="comment">// nums内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性</span></span><br><span class="line"><span class="comment">// 所以，如果所有数的累加和是sum，并且与target的奇偶性不一样</span></span><br><span class="line"><span class="comment">// 那么没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line"><span class="comment">// 思考4(最重要):</span></span><br><span class="line"><span class="comment">// 比如说给定一个数组, nums = [1, 2, 3, 4, 5] 并且 target = 3</span></span><br><span class="line"><span class="comment">// 其中一个方案是 : +1 -2 +3 -4 +5 = 3</span></span><br><span class="line"><span class="comment">// 该方案中取了正的集合为A = &#123;1，3，5&#125;</span></span><br><span class="line"><span class="comment">// 该方案中取了负的集合为B = &#123;2，4&#125;</span></span><br><span class="line"><span class="comment">// 所以任何一种方案，都一定有 sum(A) - sum(B) = target</span></span><br><span class="line"><span class="comment">// 现在我们来处理一下这个等式，把左右两边都加上sum(A) + sum(B)，那么就会变成如下：</span></span><br><span class="line"><span class="comment">// sum(A) - sum(B) + sum(A) + sum(B) = target + sum(A) + sum(B)</span></span><br><span class="line"><span class="comment">// 2 * sum(A) = target + 数组所有数的累加和</span></span><br><span class="line"><span class="comment">// sum(A) = (target + 数组所有数的累加和) / 2</span></span><br><span class="line"><span class="comment">// 也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2</span></span><br><span class="line"><span class="comment">// 那么就一定对应一种target的方式</span></span><br><span class="line"><span class="comment">// 比如非负数组nums，target = 1, nums所有数累加和是11</span></span><br><span class="line"><span class="comment">// 求有多少方法组成1，其实就是求，有多少种子集累加和达到6的方法，(1+11)/2=6</span></span><br><span class="line"><span class="comment">// 因为，子集累加和6 - 另一半的子集累加和5 = 1(target)</span></span><br><span class="line"><span class="comment">// 所以有多少个累加和为6的不同集合，就代表有多少个target==1的表达式数量</span></span><br><span class="line"><span class="comment">// 至此已经转化为01背包问题了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">sum += n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> subsets(nums, (target + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求非负数组nums有多少个子序列累加和是t</span></span><br><span class="line"><span class="comment">// 01背包问题(子集累加和严格是t) + 空间压缩</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123; <span class="comment">// i省略了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= num; j--) &#123;</span><br><span class="line">dp[j] += dp[j - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h2><p>leetcode 1049</p><p>思路：转化为找出一个数组中最接近和的一半的子序列和。答案就是sum - 2 * 子序列和，找最接近和的一半的子序列和就是01背包问题。背包容量为一半，然后找出价值最高的子序列和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">        sum+=stone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">near</span> <span class="operator">=</span> findLSW(stones,sum/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> sum - near - near;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLSW</span><span class="params">(<span class="type">int</span>[] stones, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=stone;j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-stone]+stone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>同一个组的物品只能选一个，求最大价值。</p><p>思路：还是分为要跟不要。但是要的情况需要讨论要一组里的哪一个。所以dp[i][j] 中的i表示物品组，j表示背包容量。开始时可以按组号排序，一组一组处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">teams</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i - <span class="number">1</span>][<span class="number">2</span>] != arr[i][<span class="number">2</span>]) &#123;</span><br><span class="line">teams++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组的编号1~teams</span></span><br><span class="line"><span class="comment">// dp[i][j] : 1~i是组的范围，每个组的物品挑一件，容量不超过j的情况下，最大收益</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[teams + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// dp[0][....] = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>, i = <span class="number">1</span>; start &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start ... end-1 -&gt; i组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="comment">// arr[start...end-1]是当前组，组号一样</span></span><br><span class="line"><span class="comment">// 其中的每一件商品枚举一遍</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line"><span class="comment">// k是组内的一个商品编号</span></span><br><span class="line"><span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - arr[k][<span class="number">0</span>]] + arr[k][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start去往下一组的第一个物品</span></span><br><span class="line"><span class="comment">// 继续处理剩下的组</span></span><br><span class="line">start = end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[teams][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][...] = 0</span></span><br><span class="line">Arrays.fill(dp, <span class="number">0</span>, m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>; start &lt;= n;) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start....end-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], arr[k][<span class="number">1</span>] + dp[j - arr[k][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">start = end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从栈中取出k个硬币的最大面值和"><a href="#从栈中取出k个硬币的最大面值和" class="headerlink" title="从栈中取出k个硬币的最大面值和"></a>从栈中取出k个硬币的最大面值和</h2><p>leetcode 2218</p><p>思路：以一个栈里面的硬币为分组。一组里面的元素就是拿一个硬币，两个硬币，三个硬币…得到的面值。一组我也只能拿一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// piles是一组一组的硬币</span></span><br><span class="line"><span class="comment">// m是容量，表示一定要进行m次操作</span></span><br><span class="line"><span class="comment">// dp[i][j] : 1~i组上，一共拿走j个硬币的情况下，获得的最大价值</span></span><br><span class="line"><span class="comment">// 1) 不要i组的硬币 : dp[i-1][j]</span></span><br><span class="line"><span class="comment">// 2) i组里尝试每一种方案</span></span><br><span class="line"><span class="comment">// 比如，i组里拿走前k个硬币的方案 : dp[i-1][j-k] + 从顶部开始前k个硬币的价值和</span></span><br><span class="line"><span class="comment">// 枚举每一个k，选出最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins1</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.size();</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">// i从1组开始（我们的设定），但是题目中的piles是从下标0开始的</span></span><br><span class="line"><span class="comment">// 所以来到i的时候，piles.get(i-1)是当前组</span></span><br><span class="line">List&lt;Integer&gt; team = piles.get(i - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.min(team.size(), m);</span><br><span class="line"><span class="comment">// 预处理前缀和，为了加速计算</span></span><br><span class="line"><span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">sum += team.get(j);</span><br><span class="line">preSum[j + <span class="number">1</span>] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新动态规划表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="comment">// 当前组一个硬币也不拿的方案</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= Math.min(t, j); k++) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k] + preSum[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (List&lt;Integer&gt; team : piles) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.min(team.size(), m);</span><br><span class="line"><span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">sum += team.get(j);</span><br><span class="line">preSum[j + <span class="number">1</span>] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= Math.min(t, j); k++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - k] + preSum[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="模板题-1"><a href="#模板题-1" class="headerlink" title="模板题"></a>模板题</h2><p>一个物品可以重复取，求最大价值。</p><p>dp[i][j] = Max(dp[i-1][j],dp[i][j-w[i]]+v[i]) //拿了之后i也不减一，就可以拿多次。空间压缩需要正着遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// 会空间不够，导致无法通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][.....] = 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="comment">// 可以通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>, t + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cost[i]; j &lt;= t; j++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>leetcode 10</p><p>思路：在dfs注解里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch1</span><span class="params">(String str, String pat)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] p = pat.toCharArray();</span><br><span class="line"><span class="keyword">return</span> f1(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s[i....]能不能被p[j....]完全匹配出来</span></span><br><span class="line"><span class="comment">// p[j]这个字符，一定不是&#x27;*&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line"><span class="comment">// s没了</span></span><br><span class="line"><span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line"><span class="comment">// 如果p也没了，返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// p还剩下一些后缀</span></span><br><span class="line"><span class="comment">// 如果p[j+1]是*，那么p[j..j+1]可以消掉，然后看看p[j+2....]是不是都能消掉</span></span><br><span class="line"><span class="keyword">return</span> j + <span class="number">1</span> &lt; p.length &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f1(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line"><span class="comment">// s有后缀</span></span><br><span class="line"><span class="comment">// p没后缀了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// s有后缀</span></span><br><span class="line">    <span class="comment">// p有后缀</span></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> == p.length || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// s[i....]</span></span><br><span class="line"><span class="comment">// p[j....]</span></span><br><span class="line"><span class="comment">// 如果p[j+1]不是*，那么当前的字符必须能匹配：(s[i] == p[j] || p[j] == &#x27;?&#x27;)</span></span><br><span class="line"><span class="comment">// 同时，后续也必须匹配上：process1(s, p, i + 1, j + 1);</span></span><br><span class="line"><span class="keyword">return</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f1(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果p[j+1]是*</span></span><br><span class="line"><span class="comment">// 完全背包！</span></span><br><span class="line"><span class="comment">// s[i....]</span></span><br><span class="line"><span class="comment">// p[j....]</span></span><br><span class="line"><span class="comment">// 选择1: 当前p[j..j+1]是x*，就是不让它搞定s[i]，那么继续 : process1(s, p, i, j + 2)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">p1</span> <span class="operator">=</span> f1(s, p, i, j + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 选择2: 当前p[j..j+1]是x*，如果可以搞定s[i]，那么继续 : process1(s, p, i + 1, j)</span></span><br><span class="line"><span class="comment">// 如果可以搞定s[i] : (s[i] == p[j] || p[j] == &#x27;.&#x27;)</span></span><br><span class="line"><span class="comment">// 继续匹配 : process1(s, p, i + 1, j)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">p2</span> <span class="operator">=</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f1(s, p, i + <span class="number">1</span>, j);</span><br><span class="line"><span class="comment">// 两个选择，有一个可以搞定就返回true，都无法搞定返回false</span></span><br><span class="line"><span class="keyword">return</span> p1 || p2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s1, String p1)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = p1.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// s到头了 ， p还没结束</span></span><br><span class="line">        dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            dp[n][j] = j+<span class="number">1</span> &lt; m &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普遍情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> == m || p[j+<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || ( (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h2><p>leetcode 44</p><p>思路： 还是一样的。先初始化边界条件。然后如果遇到不是’<em>‘ 就正常判断 dp[i][j] = dp[i+1][j+1] &amp;&amp; (s[i] == p[j] || p[j] == ‘？’);’ 。遇到</em>就是完全背包问题，可以用<em>匹配一个之后不移动j , 也可以直接跳过 </em>。 dp[i][j] = dp[i][j+1] || dp[i+1][j];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s1, String p1)</span> &#123;</span><br><span class="line">     <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">     <span class="type">char</span>[] p = p1.toCharArray();</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">     <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">     <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">     <span class="comment">//填s1完了但p1没完</span></span><br><span class="line">    dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        dp[n][j] = p[j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普遍情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//不是* 就正常递推</span></span><br><span class="line">                dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line">                dp[i][j] = dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="干草问题"><a href="#干草问题" class="headerlink" title="干草问题"></a>干草问题</h2><p>购买足量干草的最小花费</p><p>有n个提供干草的公司，每个公司都有两个信息</p><p>cost[i]代表购买1次产品需要花的钱</p><p>val[i]代表购买1次产品所获得的干草数量</p><p>每个公司的产品都可以购买任意次</p><p>你一定要至少购买h数量的干草，返回最少要花多少钱</p><p>测试链接 : <a href="https://www.luogu.com.cn/problem/P2918">https://www.luogu.com.cn/problem/P2918</a></p><p>思路：还是完全背包但是定义dp。 dp[i][j] 表示1….i公司购买严格等于j份甘草时花费最小。 那么最后只用遍历 h 到 m 找出最小值即可。 m = h + max(val[i])。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] : 1...i里挑公司，购买严格j磅干草，需要的最少花费</span></span><br><span class="line"><span class="comment">// 1) dp[i-1][j]</span></span><br><span class="line"><span class="comment">// 2) dp[i][j-val[i]] + cost[i]</span></span><br><span class="line"><span class="comment">// 两种可能性中选最小</span></span><br><span class="line"><span class="comment">// 但是关于j需要进行一定的扩充，原因视频里讲了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>, m + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - val[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j - val[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j], dp[i][j - val[i]] + cost[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// &gt;= h</span></span><br><span class="line"><span class="comment">// h h+1 h+2 ... m</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h; j &lt;= m; j++) &#123;</span><br><span class="line">ans = Math.min(ans, dp[n][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>, m + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> val[i]; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[j - val[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[j] = Math.min(dp[j], dp[j - val[i]] + cost[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h; j &lt;= m; j++) &#123;</span><br><span class="line">ans = Math.min(ans, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包问题：就是有数量限制的完全背包。每个物品有一定数量，不能无限拿。</p><p>思路：每到一个物品就枚举拿多少个的情况，求出最大值即可。但这里没用枚举优化可能会超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n * t * 每种商品的平均个数)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// dp[0][....] = 0，表示没有货物的情况下，背包容量不管是多少，最大价值都是0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= c[i] &amp;&amp; w[i] * k &lt;= j; k++) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k * w[i]] + k * v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="comment">// 部分测试用例超时</span></span><br><span class="line"><span class="comment">// 因为没有优化枚举</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n * t * 每种商品的平均个数)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= c[i] &amp;&amp; w[i] * k &lt;= j; k++) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - k * w[i]] + k * v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制分组优化枚举。假如一个货物有13个，那么可以拆分为 1，2，4，6 。然后将这四个数看出四个物品即可。转化为了01背包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">       <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">       <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">       a=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">           n = (<span class="type">int</span>)in.nval;</span><br><span class="line">           in.nextToken(); W = (<span class="type">int</span>) in.nval;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,v,w,m;i&lt;=n;i++)&#123;</span><br><span class="line">               in.nextToken(); v = (<span class="type">int</span>) in.nval;</span><br><span class="line">               in.nextToken(); w = (<span class="type">int</span>) in.nval;</span><br><span class="line">               in.nextToken(); m = (<span class="type">int</span>) in.nval;</span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; m&gt;=j ; j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                   val[a] =  v*j;</span><br><span class="line">                   weight[a++] = w*j;</span><br><span class="line">                   m-=j;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   val[a] = m*v;</span><br><span class="line">                   weight[a++] = w*m;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           out.println(compute());</span><br><span class="line">       &#125;</span><br><span class="line">       out.flush();</span><br><span class="line">       out.close();</span><br><span class="line">       br.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01背包</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">       Arrays.fill(dp,<span class="number">0</span>,W+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W;j&gt;=weight[i];j--)&#123;</span><br><span class="line">               dp[j] = Math.max(dp[j],dp[j-weight[i]]+val[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[W];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h1&gt;&lt;h2 id=&quot;基础背包&quot;&gt;&lt;a href=&quot;#基础背包&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（十四）动态规划</title>
    <link href="https://nmcb666.vip/posts/915e2077.html"/>
    <id>https://nmcb666.vip/posts/915e2077.html</id>
    <published>2026-02-02T19:58:44.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<p>关于动态规划内容很多，这里只列举一些我觉都有意思的题目。</p><h1 id="二维简单动态规划"><a href="#二维简单动态规划" class="headerlink" title="二维简单动态规划"></a>二维简单动态规划</h1><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>leetcode 64</p><p>思路：状态转移方程：f[i][j] = Math.min(f[i-1][j],f[i][j-1]) + grid[i][j] 因为一个位置只能从上或者左转移过来，所以状态转移方程就是这个样子的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i] = grid[<span class="number">0</span>][i]+dp[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>]+=grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">           dp[j] = Math.min(dp[j-<span class="number">1</span>],dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>leetcode 1143</p><p>思路：状态转移方程：f[i][j] = if(s1[i]==s2[j]) f[i-1][j-1]+1 else max(f[i-1][j],f[i][j-1])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s1 = text1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] s2 = text2.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>s1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>leetcode 516</p><p>思路：第一种思路，把原字符串翻转，然后求最长子序列。</p><p>第二种思路，二维dp,记录从l到r的回文子序列的长度。 初始化dp[i][i] = 1;,dp[i][i+1] = s[i] == s[i+1] ? 2 : 1; 每个格子依赖于左下，下，左边的格子。于是dp的顺序就是从下到上，从左到右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n-<span class="number">1</span>;l&gt;=<span class="number">0</span>;l--)&#123;</span><br><span class="line">        dp[l][l] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            dp[l][l+<span class="number">1</span>] = c[l] == c[l+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l+<span class="number">2</span>;r&lt;n;r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[r] == c[l])&#123;</span><br><span class="line">                dp[l][r] = dp[l+<span class="number">1</span>][r-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[l][r] = Math.max(dp[l+<span class="number">1</span>][r],dp[l][r-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>leetcode 115</p><p>思路：dp[i][j] 表示s1的前i个字符，s2的前j个字符，有多少个不同的子序列。 那么当s1[i]==s2[j] 时，dp[i][j] = dp[i-1][j-1]+dp[i-1][j] 否则dp[i][j] = dp[i-1][j]<br>然后初始化dp[i][0] = 1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= Math.min(i,n-<span class="number">1</span>); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.min(i,n); j &gt;=<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>leetcode 72 在此基础上新增了每种操作的代价。</p><p>思路：dp[i][j]含义为需要多少代价才能使得s1前i个字符和s2前j个字符相等。当s1[i] == s2[j]时，dp[i][j] = dp[i-1][j-1] 此时不用任何操作。如果不相等，就可以进行三种操作。</p><ol><li>插入s1[i]， 但需要s1前i个字符和s2前j-1个字符相等。就是dp[i][j-1]。最后加上插入代价 + a</li><li>删除s1[i]， 但需要s1前i-1个字符和s2前j个字符相等。就是dp[i-1][j]。最后加上删除代价 + b</li><li>替换s1[i]， 但需要s1前i-1个字符和s2前j-1个字符相等。就是dp[i-1][j-1]。最后加上替换代价 + c</li></ol><p>初始化时dp[0][j] = j <em> a（因为从空字符串到s2只能插入）; dp[i][0] = i </em> b（从s1到空字符串只能删除）;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistance2</span><span class="params">(String str1, String str2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line"><span class="comment">// dp[i][j] :</span></span><br><span class="line"><span class="comment">// s1[前缀长度为i]想变成s2[前缀长度为j]，至少付出多少代价</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + b, dp[i][j - <span class="number">1</span>] + a), dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//空间压缩</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fff</span><span class="params">(<span class="type">char</span>[] s1, <span class="type">char</span>[] s2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">           dp[i] = i*a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">leftup</span> <span class="operator">=</span> dp[<span class="number">0</span>] ,backup;</span><br><span class="line">           dp[<span class="number">0</span>] = i*b;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">               backup = dp[j];</span><br><span class="line">               <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                   dp[j] = leftup;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   dp[j] = Math.min(Math.min(dp[j-<span class="number">1</span>]+a,dp[j]+b),leftup+c);</span><br><span class="line">               &#125;</span><br><span class="line">               leftup = backup;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h2><p>leetcode 97</p><p>思路： dp[i][j]表示s1的前i个字符和s2的前j个字符是否可以交错组成s3的前i+j个字符。然后判断</p><ol><li>如果s1[i-1] == s3[i+j-1]，说明是s1提供了最后一个字符，那么此时我就保证s1的前i-1个字符和s2的前j个字符可以交错组成s3的前i+j-1个字符。即dp[i-1][j];</li><li>如果s2[j-1] == s3[i+j-1]，说明是s2提供了最后一个字符，那么此时我就保证s1的前i个字符和s2的前j-1个字符可以交错组成s3的前i+j-1个字符。即dp[i][j-1];</li></ol><p>初始化： dp[i][0] 表示 s2不参与拼接，就是纯靠s1去拼接s3的前i个字符。 dp[0][j] 表示 s1不参与拼接，就是纯靠s2去拼接s3的前j个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave1</span><span class="params">(String str1, String str2, String str3)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str1.length() + str2.length() != str3.length()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"><span class="type">char</span>[] s3 = str3.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line"><span class="comment">// dp[i][j]:</span></span><br><span class="line"><span class="comment">// s1[前缀长度为i]和s2[前缀长度为j]，能否交错组成出s3[前缀长度为i+j]</span></span><br><span class="line"><span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i - <span class="number">1</span>] != s3[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s2[j - <span class="number">1</span>] != s3[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[i][j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子数组和相关问题"><a href="#子数组和相关问题" class="headerlink" title="子数组和相关问题"></a>子数组和相关问题</h1><h2 id="子数组最大和"><a href="#子数组最大和" class="headerlink" title="子数组最大和"></a>子数组最大和</h2><p>leetcode 53</p><p>思路：dp[i]表示以i为结尾的子数组的和最大是多少。那么dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// dp[i] : 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和</span></span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre = nums[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">pre = Math.max(nums[i], pre + nums[i]);</span><br><span class="line">ans = Math.max(ans, pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环数组中子数组的最大和"><a href="#循环数组中子数组的最大和" class="headerlink" title="循环数组中子数组的最大和"></a>循环数组中子数组的最大和</h2><p>leetcode 918</p><p>思路：求子数组最大和跟最小和即可。用sum - minSum 就是分开的子数组的最大和。 但需要特判一下是不是全是负数的情况.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>] ,minSum = nums[<span class="number">0</span>],preMax=nums[<span class="number">0</span>],preMin=nums[<span class="number">0</span>],sum=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        preMax = Math.max(preMax+nums[i],nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum,preMax);</span><br><span class="line">        preMin = Math.min(preMin+nums[i],nums[i]);</span><br><span class="line">        minSum = Math.min(minSum,preMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == minSum ? maxSum : (Math.max(maxSum, sum - minSum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍2"><a href="#打家劫舍2" class="headerlink" title="打家劫舍2"></a>打家劫舍2</h2><p>leetcode 213</p><p>思路：分开讨论即可，要么不偷第一家，在2-n之间偷，要么偷第一家，在1-n-1之间偷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分开讨论</span></span><br><span class="line">    <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不拿第一家</span></span><br><span class="line">    dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp1[<span class="number">2</span>] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不拿最后一家</span></span><br><span class="line">    dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp2[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp1[n],dp2[n-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍4"><a href="#打家劫舍4" class="headerlink" title="打家劫舍4"></a>打家劫舍4</h2><p>leetcode 2560</p><p>思路：二分+dp。 转化为给定能力，小偷最多偷多少家即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCapability</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        max = Math.max(nums[i],max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>max;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f(nums,mid,k))&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> cap,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = cap &gt;= nums[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &gt; cap)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] &gt;= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>leetcode 152</p><p>思路：dp1[i] 表示以i为结尾的子数组乘积最大是多少。dp2[i] 表示以i为结尾的子数组乘积最小是多少。 每次正在一个位置比较最小值乘以自己，最大值乘以自己，跟自己的大小即可。并且更新dp1[i]，dp2[i]。  代码直接给出空间压缩版本.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        temp = max;</span><br><span class="line">        temp = Math.max(Math.max(max*nums[i],min*nums[i]),nums[i]);</span><br><span class="line">        min = Math.min(Math.min(min*nums[i],max*nums[i]),nums[i]);</span><br><span class="line">        max = temp;</span><br><span class="line">        ans = Math.max(max,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="被7整除的最大子序列和"><a href="#被7整除的最大子序列和" class="headerlink" title="被7整除的最大子序列和"></a>被7整除的最大子序列和</h2><p>思路：dp[i][j] 表示以第i个数为结尾，模数为j的子序列和最大是多少。那么dp[i][j] = dp[i-1][j]  或者 dp[i-1][(j+7-nums[i-1]%7)%7] + nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// dp[i][j] : nums[0...i-1]</span></span><br><span class="line"><span class="comment">// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j</span></span><br><span class="line"><span class="comment">// 这样的子序列最大累加和是多少</span></span><br><span class="line"><span class="comment">// 注意 : dp[i][j] == -1代表不存在这样的子序列</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">7</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, x, cur, need; i &lt;= n; i++) &#123;</span><br><span class="line">x = nums[i - <span class="number">1</span>];</span><br><span class="line">cur = nums[i - <span class="number">1</span>] % <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="comment">// 这里求need是核心</span></span><br><span class="line">need = cur &lt;= j ? (j - cur) : (j - cur + <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 或者如下这种写法也对</span></span><br><span class="line"><span class="comment">// need = (7 + j - cur) % 7;</span></span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][need] != -<span class="number">1</span>) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][need] + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以翻转1次的情况下子数组最大累加和"><a href="#可以翻转1次的情况下子数组最大累加和" class="headerlink" title="可以翻转1次的情况下子数组最大累加和"></a>可以翻转1次的情况下子数组最大累加和</h2><p>给定一个数组nums，</p><p>现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整</p><p>比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]</p><p>返回必须随意翻转1次之后，子数组的最大累加和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumReverse2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// start[i] : 所有必须以i开头的子数组中，最大累加和是多少</span></span><br><span class="line"><span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">start[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// nums[i]</span></span><br><span class="line"><span class="comment">// nums[i] + start[i+1]</span></span><br><span class="line">start[i] = Math.max(nums[i], nums[i] + start[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> start[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// end : 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// maxEnd :</span></span><br><span class="line"><span class="comment">// 0~i-1范围上，</span></span><br><span class="line"><span class="comment">// 子数组必须以0结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// 子数组必须以1结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line"><span class="comment">// 所有情况中，最大的那个累加和就是maxEnd</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// maxend   i....</span></span><br><span class="line"><span class="comment">// 枚举划分点 i...</span></span><br><span class="line">ans = Math.max(ans, maxEnd + start[i]);</span><br><span class="line"><span class="comment">// 子数组必须以i结尾，其中的最大累加和</span></span><br><span class="line">end = Math.max(nums[i], end + nums[i]);</span><br><span class="line">maxEnd = Math.max(maxEnd, end);</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(ans, maxEnd);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最长递增子序列相关题目"><a href="#最长递增子序列相关题目" class="headerlink" title="最长递增子序列相关题目"></a>最长递增子序列相关题目</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>leetcode 300</p><p>思路：最基础的复杂度O(n^2)，优化版本</p><p>维护一个ends[]数组，表示ends[i]表示长度为i+1的递增子序列的最小末尾元素。那么以后我要新增一个元素，那么我需要二分找到大于等于这个元素的最左位置，然后更新这个位置的元素为这个元素。如果没找到，那么就插入到数组末尾。并且len++。最后返回len即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n * logn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line"><span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">find = bs1(ends, len, nums[i]);</span><br><span class="line"><span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">ends[len++] = nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ends[find] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line"><span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line"><span class="comment">// 如果不存在返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="俄罗斯套娃信封"><a href="#俄罗斯套娃信封" class="headerlink" title="俄罗斯套娃信封"></a>俄罗斯套娃信封</h2><p>leetcode 354</p><p>思路：先将宽高进行排序，按宽度升序，高度降序。然后对于高度求最长递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">    Arrays.sort(envelopes,(a,b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> bs1(ends,len,envelopes[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(find == -<span class="number">1</span>)&#123;</span><br><span class="line">            ends[len++] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ends[find] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ends[mid] &gt;= target)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长对数链"><a href="#最长对数链" class="headerlink" title="最长对数链"></a>最长对数链</h2><p>leetcode 646</p><p>思路：每个数对按第一个数降序排列。然后求最长递增子序列。但是注意，这里在二分查找的时候，查找跟放入的不是一个数。按开始位置进行查找，但是放入自己的结束位置，所以不能直接放入，应该判断跟原位置的大小（因为这里只能知道开始的值是小于等于找到的位置的，结束值跟这个位置的大小关系不确定）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>,ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ends[mid] &gt;= target)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLongestChain</span><span class="params">(<span class="type">int</span>[][] pairs)</span> &#123;</span><br><span class="line">    Arrays.sort(pairs,(a,b)-&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>pairs.length;</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//根据开始值进行二分查找 找个大于等于自己的最左位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> bs1(ends,len,pairs[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(find == -<span class="number">1</span>)&#123;</span><br><span class="line">            ends[len++] = pairs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里不能直接放入 而是应该判断跟原位置的大小关系</span></span><br><span class="line">            ends[find] = Math.min(pairs[i][<span class="number">1</span>],ends[find]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于动态规划内容很多，这里只列举一些我觉都有意思的题目。&lt;/p&gt;
&lt;h1 id=&quot;二维简单动态规划&quot;&gt;&lt;a href=&quot;#二维简单动态规划&quot; class=&quot;headerlink&quot; title=&quot;二维简单动态规划&quot;&gt;&lt;/a&gt;二维简单动态规划&lt;/h1&gt;&lt;h2 id=&quot;最小路径和</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我们讨论分布式中的一致性到底是什么</title>
    <link href="https://nmcb666.vip/posts/2db9d40c.html"/>
    <id>https://nmcb666.vip/posts/2db9d40c.html</id>
    <published>2026-02-02T12:22:49.000Z</published>
    <updated>2026-02-07T05:35:43.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？"><a href="#分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？" class="headerlink" title="分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？"></a>分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？</h1><p>在技术圈里摸爬滚打，你一定听过无数次“分布式系统”这个词，也背过无数次 CAP 定理、BASE 理论。</p><p>但你是否在某个深夜调试代码时感到困惑：</p><ul><li><em>“为什么 Seata 的文档里在谈一致性，Raft 的论文里也在谈一致性，但我总感觉它们说的不是一回事？”</em></li><li><em>“微服务拆分后的一致性，和 Redis 集群的一致性，是一样的吗？”</em></li></ul><p>其实，你的直觉是对的。<strong>“分布式系统”这个词是个大筐，里面装了两个完全不同的流派。</strong> 它们虽然都叫分布式，都追求一致性，但它们的灵魂截然不同。</p><p>今天，我们就把这两个流派拆开来看一看。</p><hr><h2 id="流派一：为了“分工与解耦”-——-分布式计算-服务化"><a href="#流派一：为了“分工与解耦”-——-分布式计算-服务化" class="headerlink" title="流派一：为了“分工与解耦” —— 分布式计算/服务化"></a>流派一：为了“分工与解耦” —— 分布式计算/服务化</h2><p>这个流派的典型代表是 <strong>微服务架构（Spring Cloud, Dubbo, gRPC）</strong>。</p><h3 id="1-它的本质：从“一个人干”变成“一群人干”"><a href="#1-它的本质：从“一个人干”变成“一群人干”" class="headerlink" title="1. 它的本质：从“一个人干”变成“一群人干”"></a>1. 它的本质：从“一个人干”变成“一群人干”</h3><p>在这个流派里，我们把一个巨大的单体应用（Monolith）拆成了订单服务、库存服务、支付服务。</p><ul><li><strong>目的：</strong> 为了解耦，为了让不同的团队开发不同的模块，为了逻辑清晰。</li><li><strong>物理形态：</strong> 哪怕每个服务只部署在一台机器上（没有副本），它依然是标准的分布式系统。</li></ul><h3 id="2-这个流派的“痛点”：事务（Transaction）"><a href="#2-这个流派的“痛点”：事务（Transaction）" class="headerlink" title="2. 这个流派的“痛点”：事务（Transaction）"></a>2. 这个流派的“痛点”：事务（Transaction）</h3><p>因为业务逻辑被拆散到了不同的机器上，原本在单机数据库里一个 <code>Begin Transaction ... Commit</code> 就能搞定的事，现在变成了跨越网络的难题。</p><ul><li><strong>场景：</strong> 支付服务扣了钱，库存服务却因为报错没扣库存。</li><li><strong>后果：</strong> 账不平了，老板发火了。</li></ul><h3 id="3-这里的一致性：事务一致性-ACID"><a href="#3-这里的一致性：事务一致性-ACID" class="headerlink" title="3. 这里的一致性：事务一致性 (ACID)"></a>3. 这里的一致性：事务一致性 (ACID)</h3><p>当我们在这个流派下讨论“一致性”时，我们指的是 <strong>“多步操作的原子性”</strong>。</p><ul><li><strong>核心定义：</strong> 一连串的操作，要么全做完，要么全不做，不能停在中间。</li><li><strong>学术术语：</strong> <strong>可串行化 (Serializability)</strong>。</li><li><strong>解决方案：</strong><ul><li><strong>强一致性（刚性事务）：</strong> 比如 <strong>XA/2PC</strong>。通过长时间加锁，保证在事务结束前，外界谁也看不见中间状态。</li><li><strong>最终一致性（柔性事务）：</strong> 比如 <strong>Seata 的 AT/TCC 模式</strong>，或者基于消息队列的 <strong>Saga 模式</strong>。为了性能，允许外界看到短暂的中间状态（脏读/预扣），但保证最终数据是对齐的。</li></ul></li></ul><blockquote><p><strong>一句话总结：</strong> 这里的“一致性”，是<strong>逻辑与时间</strong>的保卫战，防止业务逻辑跑偏。</p></blockquote><hr><h2 id="流派二：为了“生存与扩容”-——-分布式存储-副本"><a href="#流派二：为了“生存与扩容”-——-分布式存储-副本" class="headerlink" title="流派二：为了“生存与扩容” —— 分布式存储/副本"></a>流派二：为了“生存与扩容” —— 分布式存储/副本</h2><p>这个流派的典型代表是 <strong>Redis Cluster, HDFS, Cassandra, Zookeeper, TiDB</strong>。</p><h3 id="1-它的本质：从“一份数据”变成“多份副本”"><a href="#1-它的本质：从“一份数据”变成“多份副本”" class="headerlink" title="1. 它的本质：从“一份数据”变成“多份副本”"></a>1. 它的本质：从“一份数据”变成“多份副本”</h3><p>在这个流派里，我们要解决的不是逻辑复杂的问题，而是机器不可靠的问题。我们把同一份数据（State）复制到 A、B、C 三台机器上。</p><ul><li><strong>目的：</strong> 为了高可用（A 挂了 B 顶上）和高性能（读写分离）。</li><li><strong>物理形态：</strong> 必须是多节点集群，且持有数据副本。</li></ul><h3 id="2-这个流派的“痛点”：同步（Replication）"><a href="#2-这个流派的“痛点”：同步（Replication）" class="headerlink" title="2. 这个流派的“痛点”：同步（Replication）"></a>2. 这个流派的“痛点”：同步（Replication）</h3><p>既然有副本，就涉及到了“我改了 A，B 什么时候改”的问题。</p><ul><li><strong>场景：</strong> 用户在这个毫秒往主节点写了“x=10”，下一个毫秒去从节点读“x”。</li><li><strong>后果：</strong> 如果同步慢了，用户读到了旧值“x=5”，用户会觉得系统在骗人。</li></ul><h3 id="3-这里的一致性：数据一致性-CAP"><a href="#3-这里的一致性：数据一致性-CAP" class="headerlink" title="3. 这里的一致性：数据一致性 (CAP)"></a>3. 这里的一致性：数据一致性 (CAP)</h3><p>当我们在这个流派下讨论“一致性”时，我们指的是 <strong>“多个副本的实时同步”</strong>。</p><ul><li><strong>核心定义：</strong> 写入成功后，所有的副本是否能立刻读到最新值？</li><li><strong>学术术语：</strong> <strong>线性一致性 (Linearizability)</strong>。</li><li><strong>解决方案：</strong> 这就是 <strong>CAP 定理</strong> 的主场。<ul><li><strong>CP (强一致)：</strong> 像 <strong>Zookeeper, Etcd, TiKV</strong>。为了保证所有节点数据一样，必须使用 Paxos/Raft 协议，甚至在网络分区时牺牲可用性（拒绝服务）。</li><li><strong>AP (高可用)：</strong> 像 <strong>Eureka, Cassandra</strong>。为了保证服务永远能连上，允许不同节点暂时数据不一样（最终一致）。</li></ul></li></ul><blockquote><p><strong>一句话总结：</strong> 这里的“一致性”，是<strong>空间与物理</strong>的保卫战，防止数据分身乏术。</p></blockquote><hr><h2 id="终极对决：一张表看懂区别"><a href="#终极对决：一张表看懂区别" class="headerlink" title="终极对决：一张表看懂区别"></a>终极对决：一张表看懂区别</h2><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">流派一：微服务/分布式事务</th><th style="text-align:left">流派二：分布式存储/副本</th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left"><strong>怎么把事情做对？</strong> (Transaction)</td><td style="text-align:left"><strong>怎么把数据存对？</strong> (Storage)</td></tr><tr><td style="text-align:left"><strong>典型组件</strong></td><td style="text-align:left">Spring Cloud, Seata, RocketMQ</td><td style="text-align:left">Redis, Zookeeper, MySQL主从</td></tr><tr><td style="text-align:left"><strong>一致性学术名</strong></td><td style="text-align:left"><strong>Serializability (可串行化)</strong></td><td style="text-align:left"><strong>Linearizability (线性一致性)</strong></td></tr><tr><td style="text-align:left"><strong>关注点</strong></td><td style="text-align:left"><strong>原子性 (Atomicity)</strong> <br> 要么全成功，要么全失败。</td><td style="text-align:left"><strong>可见性 (Visibility)</strong> <br> 写完能不能立刻读到？</td></tr><tr><td style="text-align:left"><strong>指导理论</strong></td><td style="text-align:left"><strong>ACID, BASE</strong></td><td style="text-align:left"><strong>CAP, PACELC</strong></td></tr><tr><td style="text-align:left"><strong>强一致意味着</strong></td><td style="text-align:left">加锁，直到整个业务流程结束，别人<strong>看不见中间状态</strong>。</td><td style="text-align:left">同步，写入主节点成功后，从节点<strong>必须也是新值</strong>。</td></tr><tr><td style="text-align:left"><strong>常见算法</strong></td><td style="text-align:left">2PC, 3PC, TCC</td><td style="text-align:left">Paxos, Raft, Gossip</td></tr></tbody></table></div><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所以，下次当你和别人争论“这个系统是不是强一致性”的时候，先停下来问一句：</p><p><strong>“哥们，我们现在是在聊业务逻辑的原子性（流派一），还是在聊数据库副本的同步（流派二）？”</strong></p><ul><li>如果是前者，<strong>Seata 的 AT 模式</strong> 虽然叫“最终一致性”，但它解决的是<strong>业务</strong>的一致性。 <strong>Seata 的 XA 模式</strong> 是‘强一致性’，解决的是也是<strong>业务</strong>的强一致性。</li><li>如果是后者，<strong>Redis 的主从异步复制</strong> 虽然也叫“最终一致性”，但它解决的是<strong>数据副本</strong>的一致性。<strong>Raft算法</strong> 是‘强一致性’，解决的是<strong>数据副本</strong>的强一致性。</li></ul><p><strong>分布式系统没有银弹，只有权衡（Trade-off）。</strong> 理解了这两个流派的区别，你才能在架构设计中，准确地选择你手中的武器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？&quot;&gt;&lt;a href=&quot;#分布式系统的“人格分裂”：当我们在谈论一致性时，我们到底在谈什么？&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的“人格分裂”：当我们在谈论一致性时，我们</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（十三） 图</title>
    <link href="https://nmcb666.vip/posts/ad899ecc.html"/>
    <id>https://nmcb666.vip/posts/ad899ecc.html</id>
    <published>2026-02-01T22:20:20.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建图的几种方式-邻接矩阵、邻接表、链式前向星"><a href="#建图的几种方式-邻接矩阵、邻接表、链式前向星" class="headerlink" title="建图的几种方式 邻接矩阵、邻接表、链式前向星"></a>建图的几种方式 邻接矩阵、邻接表、链式前向星</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点的最大数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的最大数量</span></span><br><span class="line"><span class="comment">// 只有链式前向星方式建图需要这个数量</span></span><br><span class="line"><span class="comment">// 注意如果无向图的最大数量是m条边，数量要准备m*2</span></span><br><span class="line"><span class="comment">// 因为一条无向边要加两条有向边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵方式建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] graph1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表方式建图</span></span><br><span class="line"><span class="comment">// public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph2 = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星方式建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果边有权重，那么需要这个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵清空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">graph1[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表清空和准备</span></span><br><span class="line">graph2.clear();</span><br><span class="line"><span class="comment">// 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">graph2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星清空</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">Arrays.fill(head, <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星加边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line"><span class="comment">// u -&gt; v , 边权重是w</span></span><br><span class="line">next[cnt] = head[u];</span><br><span class="line">to[cnt] = v;</span><br><span class="line">weight[cnt] = w;</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种方式建立有向图带权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line"><span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line">graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种方式建立无向图带权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undirectGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line"><span class="comment">// 邻接矩阵建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">graph1[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line"><span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line"><span class="comment">// graph2.get(edge[1]).add(edge[0]);</span></span><br><span class="line">graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">graph2.get(edge[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">0</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;邻接矩阵遍历 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">System.out.print(graph1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;邻接表遍历 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : graph2.get(i)) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;(&quot;</span> + edge[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + edge[<span class="number">1</span>] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;链式前向星 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line"><span class="comment">// 注意这个for循环，链式前向星的方式遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[i]; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;(&quot;</span> + to[ei] + <span class="string">&quot;,&quot;</span> + weight[ei] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课程表二（拓扑排序）"><a href="#课程表二（拓扑排序）" class="headerlink" title="课程表二（拓扑排序）"></a>课程表二（拓扑排序）</h2><p>leetcode 210</p><p>思路：判断入度，每次找到入度为0的点，加入队列，然后遍历这个点的所有边，将边指向的点的入度减1，如果减1后为0，则加入队列。最后判断加入队列的数量是否等于n，如果等于n，则说明有解，否则无解。排序结果就是这个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边的编号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] weight)</span> &#123;</span><br><span class="line">    <span class="comment">//加边逻辑</span></span><br><span class="line">    next[cnt] = head[u];</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    <span class="comment">//入度加一</span></span><br><span class="line">    weight[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numCourses;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> prerequisites.length;</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        add(prerequisites[i][<span class="number">1</span>],prerequisites[i][<span class="number">0</span>],head,next,to,weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历得到所有0入度的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(weight[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            queue[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始消除所有0入度</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[i];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">toi</span> <span class="operator">=</span> to[ie];</span><br><span class="line">            <span class="keyword">if</span>(--weight[toi] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = toi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n ? queue : <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="火星词典"><a href="#火星词典" class="headerlink" title="火星词典"></a>火星词典</h2><p>leetcode LCR114</p><p>思路：依次比较相邻的两个字符串，从字符串开头依次比较两个的字符。直到遇到不同的字符，那么就说明就是因为这个位置上的字符让前面的字符排在前面。于是增加一条从前面的字符指向后面的字符的边。这样得到一个图之后，就可以进行拓扑排序了。拓扑排序的结果就是字典序.但返回答案之前要判断得到的字典序里面的字符个数是否等于出现的字符个数，少了说明存在环，返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] in)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alienOrder</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(cnt,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    cnt[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//开始遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">curNext</span> <span class="operator">=</span> words[i+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(cur.length(),curNext.length());</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.charAt(j)!=curNext.charAt(j))&#123;</span><br><span class="line">                    <span class="comment">//添加边</span></span><br><span class="line">                    add(cur.charAt(j) - <span class="string">&#x27;a&#x27;</span>,curNext.charAt(j)-<span class="string">&#x27;a&#x27;</span>,head,next,to,cnt);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j&lt;cur.length() &amp;&amp; j == curNext.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始拓扑排序</span></span><br><span class="line">        <span class="comment">//有多少个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出初始入度为0的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                kinds++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="type">char</span> <span class="variable">ansChar</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + temp);</span><br><span class="line">            kinds --;</span><br><span class="line">            sb.append(ansChar);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[temp];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--cnt[to[ie]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = to[ie];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kinds == <span class="number">0</span> ? sb.toString(): <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大食物链计数"><a href="#最大食物链计数" class="headerlink" title="最大食物链计数"></a>最大食物链计数</h2><p>思路：拓扑排序，只不过每次出队时的节点要把自己的信息告诉自己的邻居节点。(其实这道题也能用dfs,而且更简单)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_FoodLines</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的入度表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序需要的推送信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] lines = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">Arrays.fill(indegree, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(lines, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(head, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">next[cnt] = head[u];</span><br><span class="line">to[cnt] = v;</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">n = (<span class="type">int</span>) in.nval;</span><br><span class="line">in.nextToken();</span><br><span class="line">m = (<span class="type">int</span>) in.nval;</span><br><span class="line">build(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, u, v; i &lt; m; i++) &#123;</span><br><span class="line">in.nextToken();</span><br><span class="line">u = (<span class="type">int</span>) in.nval;</span><br><span class="line">in.nextToken();</span><br><span class="line">v = (<span class="type">int</span>) in.nval;</span><br><span class="line">addEdge(u, v);</span><br><span class="line">indegree[v]++;</span><br><span class="line">&#125;</span><br><span class="line">out.println(ways());</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">queue[r++] = i;</span><br><span class="line">lines[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue[l++];</span><br><span class="line"><span class="keyword">if</span> (head[u] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 当前的u节点不再有后续邻居了</span></span><br><span class="line">ans = (ans + lines[u]) % MOD;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[u], v; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line"><span class="comment">// u -&gt; v</span></span><br><span class="line">v = to[ei];</span><br><span class="line">lines[v] = (lines[v] + lines[u]) % MOD;</span><br><span class="line"><span class="keyword">if</span> (--indegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">queue[r++] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="喧闹与富有"><a href="#喧闹与富有" class="headerlink" title="喧闹与富有"></a>喧闹与富有</h2><p>leetcode 851</p><p>思路：拓扑排序，但出队的时候把自己的答案推送到下一个节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span>[] head,<span class="type">int</span>[] next,<span class="type">int</span>[] to,<span class="type">int</span>[] in)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] loudAndRich(<span class="type">int</span>[][] richer, <span class="type">int</span>[] quiet) &#123;</span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> quiet.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> richer.length;</span><br><span class="line">        <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            add(richer[i][<span class="number">0</span>],richer[i][<span class="number">1</span>],head,next,to,in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ie</span> <span class="operator">=</span> head[pos];ie&gt;<span class="number">0</span>;ie = next[ie])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextP</span> <span class="operator">=</span> to[ie];</span><br><span class="line">                <span class="comment">// 如果我的答案更好，推送给你进行更新，之后我就可以出队了</span></span><br><span class="line">                <span class="keyword">if</span>(quiet[ans[pos]] &lt; quiet[ans[nextP]])&#123;</span><br><span class="line">                    ans[nextP] = ans[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(--in[nextP] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = nextP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是图论基本内容，其实就是建图加拓扑排序。或者有简单的bfs或者dfs。 至于更复杂的图论，以后再学吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建图的几种方式-邻接矩阵、邻接表、链式前向星&quot;&gt;&lt;a href=&quot;#建图的几种方式-邻接矩阵、邻接表、链式前向星&quot; class=&quot;headerlink&quot; title=&quot;建图的几种方式 邻接矩阵、邻接表、链式前向星&quot;&gt;&lt;/a&gt;建图的几种方式 邻接矩阵、邻接表、链式前</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（十二）并查集</title>
    <link href="https://nmcb666.vip/posts/19844410.html"/>
    <id>https://nmcb666.vip/posts/19844410.html</id>
    <published>2026-01-31T16:05:26.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-31%20172011.png" alt="用法"/></div><span class="image-caption">用法</span></div><h2 id="并查集模板-扁平化-小挂大"><a href="#并查集模板-扁平化-小挂大" class="headerlink" title="并查集模板 扁平化+小挂大"></a>并查集模板 扁平化+小挂大</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i号节点，往上一直找，找到代表节点返回！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="comment">// 沿途收集了几个点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != father[i]) &#123;</span><br><span class="line">stack[size++] = i;</span><br><span class="line">i = father[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 沿途节点收集好了，i已经跳到代表节点了</span></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">father[stack[--size]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line"><span class="comment">// fx是集合的代表：拿大小</span></span><br><span class="line"><span class="comment">// fy是集合的代表：拿大小</span></span><br><span class="line"><span class="keyword">if</span> (size[fx] &gt;= size[fy]) &#123;</span><br><span class="line">size[fx] += size[fy];</span><br><span class="line">father[fy] = fx;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">size[fy] += size[fx];</span><br><span class="line">father[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板2-只有扁平化"><a href="#模板2-只有扁平化" class="headerlink" title="模板2 只有扁平化"></a>模板2 只有扁平化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">father[find(x)] = find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情侣牵手"><a href="#情侣牵手" class="headerlink" title="情侣牵手"></a>情侣牵手</h2><p>leetcode 765</p><p>思路：把编号i，i+1的情侣看出编号为i/2的情侣对.按顺序每次让两个人的情侣编号两两进行合并，如果是一对情侣（情侣编号一样）那么集合个数不会变，如果不是比如第一个人属于第3对，第二个人属于第5对，那么把3，5合成一个集合。最后原始的情侣对数减去剩下的集合个数就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">        father[i] = find(father[i]); <span class="comment">// 路径压缩：递归更新父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        cnts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnts;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>row.length;</span><br><span class="line">    cnts = n/<span class="number">2</span>;</span><br><span class="line">    build(n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        union(row[i]/<span class="number">2</span>,row[i+<span class="number">1</span>]/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n/<span class="number">2</span> - cnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相似字符串组"><a href="#相似字符串组" class="headerlink" title="相似字符串组"></a>相似字符串组</h2><p>leetcode 839</p><p>思路：两层for循环每次判断两个字符串是否相似，相似的话就合并两个字符串的集合。最后返回集合个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sets = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">father[fx] = fy;</span><br><span class="line">sets--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSimilarGroups</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">build(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (find(i) != find(j)) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m &amp;&amp; diff &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (strs[i].charAt(k) != strs[j].charAt(k)) &#123;</span><br><span class="line">diff++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (diff == <span class="number">0</span> || diff == <span class="number">2</span>) &#123;</span><br><span class="line">union(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>leetcode 200</p><p>思路：其实这道题最优解是洪水填充，但是这里用并查集也可以做。把二维下标转为一维编号 i*n+j。然后依次遍历，如果自己是1 的话就 查看 右边 跟 下边是不是1，如果是的话就合并。最后返回集合个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    cnts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                father[i*n+j] = i*n+j;</span><br><span class="line">                cnts++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i != father[i])&#123;</span><br><span class="line">        father[i] = find(father[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        cnts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    build(grid,m,n);</span><br><span class="line">    <span class="comment">//合并岛屿</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//只用合并右边跟下边即可</span></span><br><span class="line">                <span class="keyword">if</span>( i!=m-<span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    union(i*n+j,(i+<span class="number">1</span>)*n+j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j!=n-<span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    union(i*n+j,i*n+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="专家开会"><a href="#专家开会" class="headerlink" title="专家开会"></a>专家开会</h2><p>leetcode 2092</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的标签信息 : 设置集合的一些属性</span></span><br><span class="line"><span class="comment">// 属性在哪？secret[代表元素] 代表集合的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] secret = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> first)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">secret[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">father[first] = <span class="number">0</span>;</span><br><span class="line">secret[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">father[i] = find(father[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line"><span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">father[fx] = fy;</span><br><span class="line">secret[fy] |= secret[fx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议排序 : m * log m</span></span><br><span class="line"><span class="comment">// 处理过程 : O(m)</span></span><br><span class="line"><span class="comment">// 收集答案 : O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">findAllPeople</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">build(n, first);</span><br><span class="line"><span class="comment">// &#123;0 : 专家   1 : 专家编号   2 : 时刻&#125;</span></span><br><span class="line">Arrays.sort(meetings, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> meetings.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r; l &lt; m;) &#123;</span><br><span class="line">r = l;</span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; m &amp;&amp; meetings[l][<span class="number">2</span>] == meetings[r + <span class="number">1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l....r这些会议，一定是一个时刻</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">union(meetings[i][<span class="number">0</span>], meetings[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有小的撤销行为，但这不是可撤销并查集</span></span><br><span class="line"><span class="comment">// 只是每一批没有知道秘密的专家重新建立集合而已</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, a, b; i &lt;= r; i++) &#123;</span><br><span class="line">a = meetings[i][<span class="number">0</span>];</span><br><span class="line">b = meetings[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!secret[find(a)]) &#123;</span><br><span class="line">father[a] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!secret[find(b)]) &#123;</span><br><span class="line">father[b] = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l = r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (secret[find(i)]) &#123;</span><br><span class="line">ans.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img&quot; src=&quot;https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AQS是什么？</title>
    <link href="https://nmcb666.vip/posts/6079905e.html"/>
    <id>https://nmcb666.vip/posts/6079905e.html</id>
    <published>2026-01-31T01:30:22.000Z</published>
    <updated>2026-02-07T05:35:43.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Java并发】AQS详解：JUC包背后的“幕后大佬”"><a href="#【Java并发】AQS详解：JUC包背后的“幕后大佬”" class="headerlink" title="【Java并发】AQS详解：JUC包背后的“幕后大佬”"></a>【Java并发】AQS详解：JUC包背后的“幕后大佬”</h1><p>在 Java 并发编程（JUC）的世界里，我们经常使用 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 这些赫赫有名的工具类。</p><p>但你是否想过，这些功能各异的工具背后，其实共用着同一套“底盘”？</p><p>这就是我们今天要聊的主角——<strong>AQS (AbstractQueuedSynchronizer，抽象队列同步器)</strong>。它是 JUC 包的心脏，掌握了它，你就掌握了 Java 并发的半壁江山。</p><h2 id="一、-什么是-AQS？"><a href="#一、-什么是-AQS？" class="headerlink" title="一、 什么是 AQS？"></a>一、 什么是 AQS？</h2><p><strong>AQS 是一个用于构建锁和同步器的框架。</strong></p><p>如果把 <code>ReentrantLock</code>、<code>CountDownLatch</code> 等比作是<strong>成品的汽车</strong>（跑车、卡车、公交车），那么 AQS 就是通用的<strong>汽车底盘和引擎</strong>。</p><ul><li><strong>AQS 负责脏活累活</strong>：它处理了线程的排队、阻塞、唤醒、线程安全等最复杂的底层逻辑。</li><li><strong>同步器负责业务逻辑</strong>：具体的工具类只需要告诉 AQS，“什么时候算获取锁成功”，“资源一共有多少”，剩下的交给 AQS 即可。</li></ul><p>简单来说，<strong>AQS 是一个“原材料”，我们可以根据它加工出各种各样的同步器。</strong></p><h2 id="二、-AQS-的核心架构"><a href="#二、-AQS-的核心架构" class="headerlink" title="二、 AQS 的核心架构"></a>二、 AQS 的核心架构</h2><p>AQS 的内部并没有多么神秘，它的核心逻辑主要由三部分组成：</p><h3 id="1-核心资源：State-volatile-int"><a href="#1-核心资源：State-volatile-int" class="headerlink" title="1. 核心资源：State (volatile int)"></a>1. 核心资源：State (volatile int)</h3><p>AQS 内部维护了一个 <code>state</code> 变量，用来表示<strong>“同步状态”</strong>。</p><ul><li>这是一个 <code>volatile</code> 修饰的 <code>int</code> 变量，保证了多线程下的可见性。</li><li>AQS 提供了 CAS (Compare And Swap) 方法来原子性地修改这个值。</li></ul><p><strong>这个 state 具体代表什么？AQS 不关心，由子类定义：</strong></p><ul><li>在 <strong>ReentrantLock</strong> 中，<code>state=0</code> 代表没锁，<code>state=1</code> 代表上锁。</li><li>在 <strong>CountDownLatch</strong> 中，<code>state</code> 代表倒计时的数值。</li><li>在 <strong>Semaphore</strong> 中，<code>state</code> 代表剩余的许可证数量。</li></ul><h3 id="2-等待队列：CLH-队列"><a href="#2-等待队列：CLH-队列" class="headerlink" title="2. 等待队列：CLH 队列"></a>2. 等待队列：CLH 队列</h3><p>如果有线程想抢资源（修改 state）失败了怎么办？总不能让它一直死循环空转（自旋）吧？</p><p>AQS 会把这些竞争失败的线程包装成一个 <strong>Node 节点</strong>，加入到一个<strong>双向链表</strong>（CLH队列）的尾部，并将线程<strong>阻塞</strong>（Park）。等待持有资源的线程释放后，再唤醒队列头部的线程。</p><h3 id="3-阻塞与唤醒工具"><a href="#3-阻塞与唤醒工具" class="headerlink" title="3. 阻塞与唤醒工具"></a>3. 阻塞与唤醒工具</h3><p>AQS 底层利用 <code>LockSupport</code> 类中的 <code>park()</code> 和 <code>unpark()</code> 方法，真正实现了操作系统的线程挂起和唤醒。</p><hr><h2 id="三、-AQS-是如何工作的？（以抢锁为例）"><a href="#三、-AQS-是如何工作的？（以抢锁为例）" class="headerlink" title="三、 AQS 是如何工作的？（以抢锁为例）"></a>三、 AQS 是如何工作的？（以抢锁为例）</h2><p>我们可以把 AQS 的工作流程想象成<strong>“去银行柜台办理业务”</strong>：</p><ol><li><strong>尝试获取 (TryAcquire)</strong>：<ul><li>线程 A 来了，看到柜台窗口（State）是空的（0），立马坐下办理，把窗口状态改为“忙碌”（1）。</li></ul></li><li><strong>入队 (Enqueue)</strong>：<ul><li>线程 B 来了，发现窗口状态是“忙碌”（1）。</li><li>AQS 这位大堂经理就会把线程 B 领到旁边的<strong>等待区（CLH 队列）</strong>，让它排在队伍后面，并告诉它：“你先睡会儿（Block），轮到你了叫你”。</li></ul></li><li><strong>释放与唤醒 (Release &amp; Unpark)</strong>：<ul><li>线程 A 办完业务了，离开柜台，把窗口状态改回“空闲”（0）。</li><li>AQS 大堂经理发现窗口空了，就去等待区叫醒排在最前面的线程 B：“醒醒，轮到你了”。</li><li>线程 B 醒来，高高兴兴去柜台办理业务。</li></ul></li></ol><hr><h2 id="四、-AQS-的设计模式：模板方法模式"><a href="#四、-AQS-的设计模式：模板方法模式" class="headerlink" title="四、 AQS 的设计模式：模板方法模式"></a>四、 AQS 的设计模式：模板方法模式</h2><p>AQS 之所以强大，是因为它使用了<strong>模板方法设计模式</strong>。</p><p>AQS 把“排队”、“阻塞”、“唤醒”这些通用的逻辑都写死了（<code>acquire</code>、<code>release</code> 方法）。但是，<strong>“如何判断资源是否足够”</strong>、<strong>“如何修改 state”</strong> 这些逻辑是留给子类去实现的。</p><p><strong>作为开发者，我们如果想自定义一个锁，只需要继承 AQS 并重写以下几个“钩子方法”：</strong></p><ul><li><code>tryAcquire(int)</code>: 独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li><code>tryRelease(int)</code>: 独占方式。尝试释放资源。</li><li><code>tryAcquireShared(int)</code>: 共享方式。尝试获取资源。</li><li><code>tryReleaseShared(int)</code>: 共享方式。尝试释放资源。</li><li><code>isHeldExclusively()</code>: 该线程是否正在独占资源。</li></ul><h2 id="五、-AQS-的“成品”展示"><a href="#五、-AQS-的“成品”展示" class="headerlink" title="五、 AQS 的“成品”展示"></a>五、 AQS 的“成品”展示</h2><p>让我们看看 Java 大佬们是如何利用 AQS 这个“原材料”加工出著名工具类的：</p><h3 id="1-ReentrantLock（可重入锁）"><a href="#1-ReentrantLock（可重入锁）" class="headerlink" title="1. ReentrantLock（可重入锁）"></a>1. ReentrantLock（可重入锁）</h3><ul><li><strong>模式</strong>：独占模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为 0。</li><li>线程 A 抢锁，通过 CAS 把 <code>state</code> 变成 1。</li><li>如果是同一个线程 A 再次抢锁（重入），就把 <code>state</code> 加 1（变成 2, 3…）。</li><li>释放锁时，<code>state</code> 减 1，直到减为 0 时才真正释放。</li></ul></li></ul><h3 id="2-CountDownLatch（倒计时器）"><a href="#2-CountDownLatch（倒计时器）" class="headerlink" title="2. CountDownLatch（倒计时器）"></a>2. CountDownLatch（倒计时器）</h3><ul><li><strong>模式</strong>：共享模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为 N（比如 5）。</li><li>主线程调用 <code>await()</code>，如果 <code>state &gt; 0</code>，就进入队列等待。</li><li>其他线程调用 <code>countDown()</code>，通过 CAS 把 <code>state</code> 减 1。</li><li>当 <code>state</code> 减到 0 时，AQS 唤醒队列里所有等待的主线程。</li></ul></li></ul><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong>模式</strong>：共享模式。</li><li><strong>加工逻辑</strong>：<ul><li><code>state</code> 初始化为许可证数量（比如 3）。</li><li>线程来获取许可，<code>state</code> 减 1。</li><li>如果 <code>state</code> 变为负数或者不足，线程进入队列等待。</li><li>释放许可时，<code>state</code> 加 1。</li></ul></li></ul><hr><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>AQS 是 Java 并发编程的基石。</p><ul><li><strong>宏观上</strong>：它是一个框架，通过<strong>State（资源状态）</strong>和<strong>CLH Queue（等待队列）</strong>来管理线程的同步。</li><li><strong>设计上</strong>：它采用了模板方法模式，将复杂的队列管理封装起来，只暴露简单的状态修改接口给子类。</li><li><strong>应用上</strong>：它是 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等工具类的父类（的内部实现）。</li></ul><p>理解了 AQS，你就理解了 Java 锁机制的灵魂。下次面试官问你：“ReentrantLock 是怎么实现的？”你就可以自信地从 AQS 的 <code>state</code> 和队列讲起了！</p><p>AQS的具体原理可以参考： <a href="https://javaguide.cn/java/concurrent/aqs.html">https://javaguide.cn/java/concurrent/aqs.html</a></p><hr><p><em>希望这篇文章能帮你彻底搞懂 AQS！如果有帮助，欢迎点赞收藏。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【Java并发】AQS详解：JUC包背后的“幕后大佬”&quot;&gt;&lt;a href=&quot;#【Java并发】AQS详解：JUC包背后的“幕后大佬”&quot; class=&quot;headerlink&quot; title=&quot;【Java并发】AQS详解：JUC包背后的“幕后大佬”&quot;&gt;&lt;/a&gt;【Java</summary>
      
    
    
    
    
    <category term="八股" scheme="https://nmcb666.vip/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法（十一） 单调队列</title>
    <link href="https://nmcb666.vip/posts/435449ef.html"/>
    <id>https://nmcb666.vip/posts/435449ef.html</id>
    <published>2026-01-30T16:41:51.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1><p>配合滑动窗口，可以快速得到滑动窗口内的最大值或者最小值。如果要最大值，那维护一个大到小队列（存的是下标），如果要最小值，那维护一个小到大的队列。</p><p>拿最大值举例：</p><p>扩大窗口的时候，判断新加入的元素跟队尾元素的大小，只要队尾元素小于等于新值，则队尾元素出队，直到队尾元素大于新值或者队列为空。然后这个新值的下标从队尾入队</p><p>缩小窗口时，判断这个要出去的元素下标跟单调队列队头的下标是否相等，如果相等则队头元素出队。l++.否则就不移除队头。</p><p>如果要最大值，就是数组的队头元素位置的值。 nums[deque[l]]</p><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>leetcode 239</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">h = t = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="comment">// 先形成长度为k-1的窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 大 -&gt; 小</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[i]) &#123;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line">deque[t++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - k + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="comment">// 当前窗口k-1长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k - <span class="number">1</span>; l &lt; m; l++, r++) &#123;</span><br><span class="line"><span class="comment">// 少一个，要让r位置的数进来</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[r]) &#123;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line">deque[t++] = r;</span><br><span class="line"><span class="comment">// 收集答案</span></span><br><span class="line">ans[l] = arr[deque[h]];</span><br><span class="line"><span class="comment">// l位置的数出去</span></span><br><span class="line"><span class="keyword">if</span> (deque[h] == l) &#123;</span><br><span class="line">h++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绝对差不超过限制的最长连续数组"><a href="#绝对差不超过限制的最长连续数组" class="headerlink" title="绝对差不超过限制的最长连续数组"></a>绝对差不超过限制的最长连续数组</h2><p>leetcode 1438</p><p>思路：利用两个单调队列，一个记录窗口的最小值，一个记录窗口的最大值。窗口开始滑动，每新加一个元素，就维护队列。然后一直缩窗口直到窗口内最大值和最小值之差小于等于limit。之后记录答案，j-i+1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    l2 = <span class="number">0</span>;</span><br><span class="line">    r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">        <span class="comment">//进队</span></span><br><span class="line">        <span class="keyword">while</span>( r &gt; l &amp;&amp; nums[queue[r-<span class="number">1</span>]] &lt;= nums[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="keyword">while</span>( r2 &gt; l2 &amp;&amp; nums[queue2[r2-<span class="number">1</span>]] &gt;= nums[j])&#123;</span><br><span class="line">            r2--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue2[r2++] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( nums[queue[l]] - nums[queue2[l2]] &gt; limit )&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue2[l2] == i)&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(j - i + <span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非经典用法"><a href="#非经典用法" class="headerlink" title="非经典用法"></a>非经典用法</h1><h2 id="和至少为K的最短子数组"><a href="#和至少为K的最短子数组" class="headerlink" title="和至少为K的最短子数组"></a>和至少为K的最短子数组</h2><p>leetcode 862</p><p>思路：计算以每个位置结尾的最小长度。这里最关键的是如果已经算出一个答案的时候，你的窗口右扩，你想找到更短的就只能左缩窗口才行（不用从头开始缩）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以一个位置结尾，向前面走多远能达标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="comment">//加入窗口</span></span><br><span class="line">        <span class="keyword">while</span>( l&lt;r &amp;&amp; prefix[queue[r-<span class="number">1</span>]] &gt;= prefix[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="comment">//看当前是否满足</span></span><br><span class="line">        <span class="keyword">if</span>(prefix[j] - prefix[queue[l]] &gt;= k)&#123;</span><br><span class="line">            <span class="comment">//缩小窗口，直到不行</span></span><br><span class="line">            <span class="keyword">while</span> (prefix[j] - prefix[queue[l]] &gt;= k)&#123;</span><br><span class="line">                <span class="comment">//左边缩小</span></span><br><span class="line">                <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i前面那个位置就是至少的位置</span></span><br><span class="line">            ans = Math.min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="满足不等式的最大值"><a href="#满足不等式的最大值" class="headerlink" title="满足不等式的最大值"></a>满足不等式的最大值</h2><p>leetcode 1499</p><p>给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 &lt;= i &lt; j &lt;= points.length 的前提下， xi &lt; xj 总成立。</p><p>请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| &lt;= k 且 1 &lt;= i &lt; j &lt;= points.length。</p><p>题目测试数据保证至少存在一对能够满足 |xi - xj| &lt;= k 的点。</p><p>思路：还是以每个点为结尾。窗口左边从0下标开始，判断是否合法，不合法就左缩窗口，直到合法。这个过程一直记录窗口内点的y-x的最大值。合法之后，用结尾的点加上这个窗口内的最大值就是这个点的对应的最大值，然后把这个点也加入窗口，并且更新单调队列，单调队列以y-x为单调递减。即头部为y-x最大的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxValueOfEquation</span><span class="params">(<span class="type">int</span>[][] points, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>points.length;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//把第一个点放进去</span></span><br><span class="line">    queue[r++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//缩小窗口到合法</span></span><br><span class="line">        <span class="keyword">while</span>( j&gt;i &amp;&amp; points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>] &gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到答案</span></span><br><span class="line">        <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> queue[l];</span><br><span class="line">            ans = Math.max(ans,points[j][<span class="number">0</span>]+points[j][<span class="number">1</span>]-points[best][<span class="number">0</span>]+points[best][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 j 加入</span></span><br><span class="line">        <span class="keyword">while</span> ( l&lt;r &amp;&amp; (points[j][<span class="number">1</span>] - points[j][<span class="number">0</span>]) &gt;= (points[queue[r-<span class="number">1</span>]][<span class="number">1</span>]-points[queue[r-<span class="number">1</span>]][<span class="number">0</span>]))&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预算内最多机器人的数目"><a href="#预算内最多机器人的数目" class="headerlink" title="预算内最多机器人的数目"></a>预算内最多机器人的数目</h2><p>leetcode 2389</p><p>思路：单调队列算窗口内的最大值，前缀和算窗口的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue  =<span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRobots</span><span class="params">(<span class="type">int</span>[] chargeTimes, <span class="type">int</span>[] runningCosts, <span class="type">long</span> budget)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chargeTimes.length;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//搞一个前缀和，快速计算子数组的和</span></span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        prefix[i+<span class="number">1</span>] = prefix[i] + runningCosts[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始滑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//把 j 放进去</span></span><br><span class="line">        <span class="keyword">while</span> ( l&lt;r &amp;&amp; chargeTimes[queue[r-<span class="number">1</span>]] &lt;= chargeTimes[j])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = j;</span><br><span class="line">        <span class="comment">// 左移直到合法</span></span><br><span class="line">        <span class="keyword">while</span>( i&lt;=j &amp;&amp; chargeTimes[queue[l]]+ (<span class="type">long</span>) (j - i + <span class="number">1</span>) *(prefix[j+<span class="number">1</span>]-prefix[i]) &gt; budget)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue[l] == i)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计答案</span></span><br><span class="line">        ans = Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三个无重叠子数组的最大和"><a href="#三个无重叠子数组的最大和" class="headerlink" title="三个无重叠子数组的最大和"></a>三个无重叠子数组的最大和</h2><p>leetcode 689</p><p>思路：化成三个部分，中间部分一定为i…i+k-1,左边为0….i-1 右边为i+k…n-1。此时只要知道截至到i位置最大的开始下标就可以知道前面的最大值。知道从i位置到n-1的最大值开始下标就可以确定后面最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSumOfThreeSubarrays(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sumNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//求sum[] 代表从i位置开始连续k个数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">        sumNum+=nums[r];</span><br><span class="line">        <span class="keyword">if</span>(r-l+<span class="number">1</span> == k)&#123;</span><br><span class="line">            sum[l] = sumNum;</span><br><span class="line">            sumNum-=nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求一个prefix[]  prefix[i]代表从0.....i 连续k个数和最大的开始下标</span></span><br><span class="line">    <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    queue[r++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; sum[queue[l]] &lt; sum[i-k+<span class="number">1</span>])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = i-k+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//为最小下标</span></span><br><span class="line">        prefix[i] = queue[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求suffix[]  suffix[]代表从 i....n-1 连续k个数和最大的开始下标</span></span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    suffix[n-k] = n-k;</span><br><span class="line">    queue[r++] = n-k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; sum[queue[l]] &lt;= sum[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[r++] = i;</span><br><span class="line">        suffix[i] = queue[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//借助这三个数组开始解答</span></span><br><span class="line">    <span class="comment">// （0....) (i...i+k-1) (i+k....n-1) 三个部分 中间部分和确定，只需要考虑前面跟后面即可</span></span><br><span class="line">    <span class="comment">// 它们的结果又从prefix 和 suffix可以拿到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= k,j=k*<span class="number">2</span>-<span class="number">1</span>;j&lt;n-k;i++,j++)&#123;</span><br><span class="line">        <span class="comment">//前面最大的开始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> prefix[i-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//后面最大的开始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> suffix[j+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> sum[m] + sum[i] + sum[p];</span><br><span class="line">        <span class="keyword">if</span>(all &gt; max)&#123;</span><br><span class="line">            max = all;</span><br><span class="line">            a=m;</span><br><span class="line">            b=i;</span><br><span class="line">            c=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典用法&quot;&gt;&lt;a href=&quot;#经典用法&quot; class=&quot;headerlink&quot; title=&quot;经典用法&quot;&gt;&lt;/a&gt;经典用法&lt;/h1&gt;&lt;p&gt;配合滑动窗口，可以快速得到滑动窗口内的最大值或者最小值。如果要最大值，那维护一个大到小队列（存的是下标），如果要最小值，那维</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（十） 单调栈</title>
    <link href="https://nmcb666.vip/posts/b11a54f5.html"/>
    <id>https://nmcb666.vip/posts/b11a54f5.html</id>
    <published>2026-01-29T21:32:22.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1><p>单调栈问题，就是当你分析问题时，需要你找到一个索引左右两边大于或者小于自己的最近索引时，就使用单调栈！</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-29%20232614.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="每日最高温度"><a href="#每日最高温度" class="headerlink" title="每日最高温度"></a>每日最高温度</h2><p>leetcode 739</p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>思路：将下标一次放入栈，但遵循以下要求，如果当前的温度大于栈顶的温度，则栈顶的索引出栈，并记录当前索引与栈顶索引的差值，即当前索引与栈顶索引的差值就是当前索引对应的天数。循环弹出，直到栈为空或者栈顶的索引对应的温度大于等于当前索引对应的温度。则当前索引入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>( size&gt;<span class="number">0</span> &amp;&amp; temperatures[stack[size-<span class="number">1</span>]] &lt; temperatures[i])&#123;</span><br><span class="line">            ans[stack[size-<span class="number">1</span>]] = i - stack[size-<span class="number">1</span>];</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子数组的最小值之和"><a href="#子数组的最小值之和" class="headerlink" title="子数组的最小值之和"></a>子数组的最小值之和</h2><p>leetcode 907</p><p>思路：根据单调栈，可以知道每个索引左边跟右边小于他的最近索引，那么对于每个索引，左边小于它的最近索引为left[i]，右边小于它的最近索引为right[i]，则对于索引i，最小值之和为(right[i] - i) <em> (i - left[i]) </em> arr[i]。（这就是包含了i的且i为最小值的所有子数组的最小值之和）。最后剩在栈里面的它的右边索引就在n的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注意课上讲的相等情况的修正</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[stack[r - <span class="number">1</span>]] &gt;= arr[i]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = (ans + (<span class="type">long</span>) (cur - left) * (i - cur) * arr[cur]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = (ans + (<span class="type">long</span>) (cur - left) * (arr.length - cur) * arr[cur]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h2><p>leetcode 84</p><p>思路：单调栈，对于每个索引，左边小于它最近索引为left[i]，右边小于它最近索引为right[i]，则对于索引i，最大矩形为(right[i] - left[i] - 1) * heights[i]。这道题就是一个非常标准的单调栈问题。</p><p>标准模板<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>heights.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span> &amp;&amp; heights[stack[size-<span class="number">1</span>]] &gt;= heights[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">            ansArr[temp][<span class="number">0</span>] = size == <span class="number">0</span> ? -<span class="number">1</span> : stack[size-<span class="number">1</span>];</span><br><span class="line">            ansArr[temp][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">        ansArr[temp][<span class="number">0</span>] = size==<span class="number">0</span>? -<span class="number">1</span> :stack[size-<span class="number">1</span>];</span><br><span class="line">        ansArr[temp][<span class="number">1</span>] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修正右边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansArr[i][<span class="number">1</span>] != n &amp;&amp; heights[ansArr[i][<span class="number">1</span>]] == heights[i])&#123;</span><br><span class="line">            ansArr[i][<span class="number">1</span>] = ansArr[ansArr[i][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans = Math.max((ansArr[i][<span class="number">1</span>] - ansArr[i][<span class="number">0</span>] -<span class="number">1</span>)*heights[i],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简化分析相等情况  因为就算相等你也给我弹出，可能这时你无法得到你对应的最大值。但你的那个最后一个相等的就会帮你结算你的最大值！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>heights.length;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span> &amp;&amp; heights[stack[size-<span class="number">1</span>]] &gt;= heights[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> size == <span class="number">0</span> ? -<span class="number">1</span> : stack[size-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            ans = Math.max((right-left-<span class="number">1</span>)*heights[temp],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--size];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> size==<span class="number">0</span>? -<span class="number">1</span> :stack[size-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        ans = Math.max((right-left-<span class="number">1</span>)*heights[temp],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>leetcode 85</p><p>思路：压缩数组！把问题转化为以每一行作为底部时的最大矩形问题 跟上一题一样。每一个的高度就是从该行开始连续的1的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">Arrays.fill(height, <span class="number">0</span>, m, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 来到i行，长方形一定要以i行做底！</span></span><br><span class="line"><span class="comment">// 加工高度数组(压缩数组)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">height[j] = grid[i][j] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : height[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(largestRectangleArea(m), ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, cur, left;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="comment">// i -&gt; arr[i]</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; height[stack[r - <span class="number">1</span>]] &gt;= height[i]) &#123;</span><br><span class="line">cur = stack[--r];</span><br><span class="line">left = r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = Math.max(ans, height[cur] * (i - left - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cur = stack[--r];</span><br><span class="line">left = r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>];</span><br><span class="line">ans = Math.max(ans, height[cur] * (m - left - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非经典用法"><a href="#非经典用法" class="headerlink" title="非经典用法"></a>非经典用法</h1><p><strong>下面的题目利用单调栈思想，而不是经典的用法。</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-29%20232336.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="最大宽度坡"><a href="#最大宽度坡" class="headerlink" title="最大宽度坡"></a>最大宽度坡</h2><p>leetcode 962</p><p>思路：先进行一次遍历把可能作为坡的起点的下标找到。怎么找？ 每次只入栈比当前栈顶元素更小的元素。为什么？因为如果我比栈顶大，我找到一个坡的终点，那么栈顶元素它比我的下标还要小，那他跟这个坡的终点构成的坡宽度肯定比我大，所以我没资格入栈。</p><p>然后倒着遍历找坡的终点。一旦栈顶的元素发现一个值可以作为自己终点那么弹出，并且这个坡就是以自己为起点的最大坡，为什么？因为当前终点已经是最靠右边的索引了，再往前遍历得到的结果只会更小！ 循环一直把栈里面的元素全部弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxWidthRamp</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    stack[size++] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找可能的起点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[stack[size-<span class="number">1</span>]])&#123;</span><br><span class="line">            stack[size++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒着遍历找终点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(size &gt; <span class="number">0</span> &amp;&amp; i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>( size &gt; <span class="number">0</span> &amp;&amp; nums[stack[size-<span class="number">1</span>]] &lt;= nums[i])&#123;</span><br><span class="line">            ans = Math.max(ans,i-stack[size-<span class="number">1</span>]);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h2><p>leetcode 316</p><p>思路： 单调栈大压小，遇到更小的尽量往前面走，但有条件限制，即被弹出的元素还有剩余。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line">Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(enter, <span class="literal">false</span>);</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : s) &#123;</span><br><span class="line">cnts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cur : s) &#123;</span><br><span class="line"><span class="comment">// 从左往右依次遍历字符，a -&gt; 0 b -&gt; 1 ... z -&gt; 25</span></span><br><span class="line"><span class="comment">// cur -&gt; cur - &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!enter[cur - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="comment">// 栈顶元素比当前元素大，并且栈顶元素还有剩余，那么弹出栈顶元素</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; stack[r - <span class="number">1</span>] &gt; cur &amp;&amp; cnts[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">enter[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">stack[r++] = cur;</span><br><span class="line">enter[cur - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnts[cur - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(stack, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大鱼吃小鱼"><a href="#大鱼吃小鱼" class="headerlink" title="大鱼吃小鱼"></a>大鱼吃小鱼</h2><p>leetcode 2289</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Max</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] stackT = <span class="keyword">new</span> <span class="title class_">int</span>[Max][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSteps</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( r &gt; <span class="number">0</span> &amp;&amp; stackT[r-<span class="number">1</span>][<span class="number">0</span>] &lt; nums[i])&#123;</span><br><span class="line">            cnt = Math.max(cnt+<span class="number">1</span>,stackT[r-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        stackT[r][<span class="number">0</span>] = nums[i];</span><br><span class="line">        stackT[r++][<span class="number">1</span>] = cnt;</span><br><span class="line">        ans = Math.max(ans,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典用法&quot;&gt;&lt;a href=&quot;#经典用法&quot; class=&quot;headerlink&quot; title=&quot;经典用法&quot;&gt;&lt;/a&gt;经典用法&lt;/h1&gt;&lt;p&gt;单调栈问题，就是当你分析问题时，需要你找到一个索引左右两边大于或者小于自己的最近索引时，就使用单调栈！&lt;/p&gt;
&lt;div c</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java实现基于raft算法的kv存储系统</title>
    <link href="https://nmcb666.vip/posts/6eb88918.html"/>
    <id>https://nmcb666.vip/posts/6eb88918.html</id>
    <published>2026-01-29T02:02:09.000Z</published>
    <updated>2026-02-07T05:35:43.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java手写Raft篇：核心流程与并发模型优化"><a href="#Java手写Raft篇：核心流程与并发模型优化" class="headerlink" title="Java手写Raft篇：核心流程与并发模型优化"></a>Java手写Raft篇：核心流程与并发模型优化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇基于Java实现raft分布式KV存储系统的博客。本项目基于 <a href="https://github.com/stateIs0/lu-raft-kv">https://github.com/stateIs0/lu-raft-kv</a> 该开源项目进行的二次开发。主要按照Raft协议的生命周期（选主、日志复制、安全性、一致性读）进行了改造。本篇博客记录了我的改造思路，以及一些值得注意的地方。Raft 算法作为分布式一致性协议的标准解法，以其清晰的模块化设计著称。本文将基于我如何改造原开源项目，深入剖析其中的核心机制。从选主逻辑、日志复制的细节，到解决“幽灵复现”问题的 No-Op 日志，再到利用 <code>CompletableFuture</code> 对并发模型的重构，以此记录构建高一致性分布式存储系统的思考过程。</p><hr><h2 id="一、-选举机制-Leader-Election"><a href="#一、-选举机制-Leader-Election" class="headerlink" title="一、 选举机制 (Leader Election)"></a>一、 选举机制 (Leader Election)</h2><p>选主是集群启动或 Leader 宕机后的首要任务。在此阶段，不仅要保证票数过半，更要严格校验节点资格。</p><h3 id="1-状态流转与拉票"><a href="#1-状态流转与拉票" class="headerlink" title="1. 状态流转与拉票"></a>1. 状态流转与拉票</h3><p>当 Follower 的心跳倒计时结束（在一定范围内随机时间，我选择的是跟最大选举时间到它的两倍这个范围，避免同时存在多个候选人导致效率下降）仍未收到 Leader 消息时，将触发选举流程：</p><ul><li><strong>自增任期</strong>：将 <code>term + 1</code>，并将状态流转为 Candidate。</li><li><strong>给自己投票</strong>：先投自己一票，避免 split vote。</li><li><strong>广播请求</strong>：向所有节点发起拉票请求，请求中必须携带 <code>lastLogTerm</code> 和 <code>lastLogIndex</code>，以便其他节点校验“日志是否足够新”。</li></ul><h3 id="2-投票方逻辑与并发控制"><a href="#2-投票方逻辑与并发控制" class="headerlink" title="2. 投票方逻辑与并发控制"></a>2. 投票方逻辑与并发控制</h3><p>节点收到投票请求时的处理逻辑非常关键：</p><ul><li><strong>Term 更新</strong>：如果请求中的 Term 严格大于自身，需将之前的投票记录（votedFor）置空，防止因持有旧锁导致无法投票，这样也尽可能的保证在一个投票间隔中能选出Leader。</li><li><strong>加锁防重</strong>：整个投票判断过程需要上锁，避免高并发下的重复投票。</li><li><strong>资格校验</strong>：只有当请求者的 Term &gt;= 自身 Term，且日志比自己新（Log Completeness），且自己在本任期未投过票时，才予以投票。</li><li><strong>收尾</strong>：更新本地 Term 和投票信息，释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RvoteResult <span class="title function_">requestVote</span><span class="params">(RvoteParam param)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RvoteResult.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RvoteResult.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (!voteLock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.term(node.getCurrentTerm()).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对方任期没有自己新</span></span><br><span class="line">        <span class="keyword">if</span> (param.getTerm() &lt; node.getCurrentTerm()) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.term(node.getCurrentTerm()).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新的投票term来临，应该放弃之前的投票</span></span><br><span class="line">        <span class="keyword">if</span> (param.getTerm() &gt; node.getCurrentTerm()) &#123;</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line">            node.setVotedFor(<span class="literal">null</span>);</span><br><span class="line">            node.status = NodeStatus.FOLLOWER; <span class="comment">// 任期升级后回归Follower</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (当前节点并没有投票 或者 已经投票过了且是对方节点) &amp;&amp; 对方日志和自己一样新</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;node &#123;&#125; current vote for [&#123;&#125;], param candidateId : &#123;&#125;&quot;</span>, node.peerSet.getSelf(), node.getVotedFor(), param.getCandidateId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((StringUtil.isNullOrEmpty(node.getVotedFor()) || node.getVotedFor().equals(param.getCandidateId()))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.getLogModule().getLast() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 对方没有自己新</span></span><br><span class="line">                <span class="keyword">if</span> (node.getLogModule().getLast().getTerm() &gt; param.getLastLogTerm()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;节点&#123;&#125; 拒绝给 候选人 &#123;&#125; 投票,因为日志的term值更大&quot;</span>,node.peerSet.getSelf(),param.getCandidateId());</span><br><span class="line">                    <span class="keyword">return</span> RvoteResult.fail();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对方没有自己新</span></span><br><span class="line">                <span class="keyword">if</span> (node.getLogModule().getLastIndex() &gt; param.getLastLogIndex()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;节点&#123;&#125; 拒绝给 候选人 &#123;&#125; 投票,因为日志的Index更大&quot;</span>,node.peerSet.getSelf(),param.getCandidateId());</span><br><span class="line">                    <span class="keyword">return</span> RvoteResult.fail();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换状态</span></span><br><span class="line">            node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            node.peerSet.setLeader(<span class="keyword">new</span> <span class="title class_">Peer</span>(param.getCandidateId()));</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line">            node.setVotedFor(param.getCandidateId());</span><br><span class="line">            log.warn(<span class="string">&quot;节点 &#123;&#125; 在第 &#123;&#125; 轮中 ， 投给了 &#123;&#125; 节点&quot;</span>,node.peerSet.getSelf(),node.currentTerm,node.getVotedFor());</span><br><span class="line">            <span class="comment">// 返回成功</span></span><br><span class="line">            <span class="keyword">return</span> builder.term(node.currentTerm).voteGranted(<span class="literal">true</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.term(node.currentTerm).voteGranted(<span class="literal">false</span>).build();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        voteLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-异步并发模型的优化"><a href="#3-异步并发模型的优化" class="headerlink" title="3. 异步并发模型的优化"></a>3. 异步并发模型的优化</h3><p>在实现拉票请求时，我对并发模型进行了重构：</p><ul><li><strong>旧方案</strong>：<code>线程池 + Future + CountDownLatch</code>。<code>Future.get()</code> 会阻塞调用线程，且 CountDownLatch 代码冗余。</li><li><strong>新方案</strong>：<code>CompletableFuture + 线程池</code>。<ul><li>使用 <code>List&lt;CompletableFuture&lt;&gt;&gt;</code> 保存所有 RPC 请求。</li><li>利用 <code>CompletableFuture.allOf(...)</code> 实现多线程的非阻塞同步。</li><li>配合 <code>AtomicInteger</code> 记录获胜票数，线程安全且代码更优雅。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == NodeStatus.LEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 基于 RAFT 的随机时间,解决冲突.（范围为[electiontimeout, 2 * electiontimeout - 1]）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">myElectionTime</span> <span class="operator">=</span> electionTime + ThreadLocalRandom.current().nextInt(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (current - preElectionTime &lt; myElectionTime) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">status = NodeStatus.CANDIDATE;</span><br><span class="line">log.error(<span class="string">&quot;node &#123;&#125; will become CANDIDATE and start election leader, current term : [&#123;&#125;], LastEntry : [&#123;&#125;]&quot;</span>,</span><br><span class="line">        peerSet.getSelf(), currentTerm, logModule.getLast());</span><br><span class="line"></span><br><span class="line">preElectionTime = System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(<span class="number">200</span>) + <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">currentTerm = currentTerm + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 推荐自己.</span></span><br><span class="line">votedFor = peerSet.getSelf().getAddr();</span><br><span class="line"></span><br><span class="line">List&lt;Peer&gt; peers = peerSet.getPeersWithOutSelf();</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用CompletableFuture 改造</span></span><br><span class="line">ArrayList&lt;CompletableFuture&lt;RvoteResult&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//成功次数</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">NumberOfVotesInFavor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">log.info(<span class="string">&quot;peerList size : &#123;&#125;, peer list content : &#123;&#125;&quot;</span>, peers.size(), peers);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Peer peer : peers) &#123;</span><br><span class="line"></span><br><span class="line">    futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装自己最后一个日志的term</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">lastTerm</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">last</span> <span class="operator">=</span> logModule.getLast();</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">            lastTerm = last.getTerm();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以及最后一条日志的索引</span></span><br><span class="line">        <span class="type">RvoteParam</span> <span class="variable">param</span> <span class="operator">=</span> RvoteParam.builder().</span><br><span class="line">                term(currentTerm).</span><br><span class="line">                candidateId(peerSet.getSelf().getAddr()).</span><br><span class="line">                lastLogIndex(LongConvert.convert(logModule.getLastIndex())).</span><br><span class="line">                lastLogTerm(lastTerm).</span><br><span class="line">                build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> Request.builder()</span><br><span class="line">                .cmd(Request.R_VOTE)</span><br><span class="line">                .obj(param)</span><br><span class="line">                .url(peer.getAddr())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送投票请求，500ms超时</span></span><br><span class="line">            <span class="keyword">return</span> getRpcClient().&lt;RvoteResult&gt;send(request,<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RaftRemotingException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;ElectionTask RPC Fail , URL : &quot;</span> + request.getUrl());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,RaftThreadPool.giveMePool())</span><br><span class="line">            .whenComplete((result,throwable) -&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isVoteGranted</span> <span class="operator">=</span> result.isVoteGranted();</span><br><span class="line">                <span class="keyword">if</span> (isVoteGranted) &#123;</span><br><span class="line">                    <span class="comment">//增加选票</span></span><br><span class="line">                    NumberOfVotesInFavor.incrementAndGet();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对方拒绝投票。</span></span><br><span class="line">                    <span class="comment">// 更新自己的任期。</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">resTerm</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                    <span class="keyword">if</span> (resTerm &gt;= currentTerm) &#123;</span><br><span class="line">                        currentTerm = resTerm;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待所有结果出来</span></span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">//多个任务</span></span><br><span class="line">    CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">    CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">success</span> <span class="operator">=</span> NumberOfVotesInFavor.get();</span><br><span class="line">log.warn(<span class="string">&quot;node &#123;&#125; maybe become leader , success count = &#123;&#125; , status : &#123;&#125;&quot;</span>, peerSet.getSelf(), success, NodeStatus.Enum.value(status));</span><br><span class="line"><span class="comment">// 如果投票期间,有其他服务器发送 appendEntry 或者心跳 , 就可能变成 follower ,这时,应该停止.</span></span><br><span class="line"><span class="keyword">if</span> (status == NodeStatus.FOLLOWER) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;节点 &#123;&#125; 目前不是候选人 ，无法成为领导者&quot;</span>, peerSet.getSelf().getAddr());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加上自身.</span></span><br><span class="line"><span class="keyword">if</span> (success &gt;= (peers.size()+<span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;node &#123;&#125; become leader 他的选票有 &#123;&#125; 票&quot;</span>, peerSet.getSelf(),success+<span class="number">1</span>);</span><br><span class="line">    status = NodeStatus.LEADER;</span><br><span class="line">    peerSet.setLeader(peerSet.getSelf());</span><br><span class="line">    votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这个会马上插入一条空日志</span></span><br><span class="line">    becomeLeaderToDoThing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else 重新选举</span></span><br><span class="line">    votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    log.warn(<span class="string">&quot;节点 &#123;&#125; 在 &#123;&#125; 轮落选,他获得的选票有 &#123;&#125; 票&quot;</span>,peerSet.getSelf(),currentTerm,success+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次更新选举时间 随机更新</span></span><br><span class="line">preElectionTime = System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(<span class="number">200</span>) + <span class="number">150</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="二、-日志复制与心跳-Log-Replication-amp-Heartbeat"><a href="#二、-日志复制与心跳-Log-Replication-amp-Heartbeat" class="headerlink" title="二、 日志复制与心跳 (Log Replication &amp; Heartbeat)"></a>二、 日志复制与心跳 (Log Replication &amp; Heartbeat)</h2><p>Leader 确立后，进入正常的日志同步阶段。</p><h3 id="1-心跳与日志同步的合并"><a href="#1-心跳与日志同步的合并" class="headerlink" title="1. 心跳与日志同步的合并"></a>1. 心跳与日志同步的合并</h3><p>为了简化逻辑，我将“同步日志”与“发送心跳”合并处理：</p><ul><li>Leader 周期性遍历所有 Follower。</li><li><strong>判断同步需求</strong>：检查 <code>Leader.lastIndex &gt;= Follower.nextIndex</code>。<ul><li>如果满足，说明有新日志，发送从 <code>nextIndex</code> 开始的日志条目。</li><li>如果不满足，说明日志已经同步，仅发送空的心跳包保活(根据心跳结果，判断自己是否还能继续当leader)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != NodeStatus.LEADER) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (current - preHeartBeatTime &lt; heartBeatTick) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;=========== NextIndex =============&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Peer &#123;&#125; nextIndex=&#123;&#125;&quot;</span>, peer.getAddr(), nextIndexs.get(peer));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preHeartBeatTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            List&lt;CompletableFuture&lt;Boolean&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            List&lt;Boolean&gt; resultList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 日志跟心跳放在一起</span></span><br><span class="line">            <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">nextIndex</span> <span class="operator">=</span> nextIndexs.get(peer);</span><br><span class="line">                <span class="comment">//我的最后一条日志大于你应该写入的日志位置，那我就要复制给你日志</span></span><br><span class="line">                <span class="keyword">if</span>(logModule.getLastIndex() &gt;= nextIndex)&#123;</span><br><span class="line">                    CompletableFuture&lt;Boolean&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; replication(peer), RaftThreadPool.giveMePool()</span><br><span class="line">                    ).exceptionally( ex -&gt;&#123;</span><br><span class="line">                        log.error(<span class="string">&quot;&#123;&#125; 节点发送日志失败&quot;</span>, peer.getAddr());</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">                    ).whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                            resultList.add(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;&#123;&#125; 节点发送日志失败&quot;</span>, peer.getAddr());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    futureList.add(future);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//发送心跳</span></span><br><span class="line">                    <span class="type">AentryParam</span> <span class="variable">param</span> <span class="operator">=</span> AentryParam.builder()</span><br><span class="line">                            .entries(<span class="literal">null</span>)<span class="comment">// 心跳,空日志.</span></span><br><span class="line">                            .leaderId(peerSet.getSelf().getAddr())</span><br><span class="line">                            .serverId(peer.getAddr())</span><br><span class="line">                            .term(currentTerm)</span><br><span class="line">                            .leaderCommit(commitIndex) <span class="comment">// 心跳时与跟随者同步 commit index</span></span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                            Request.A_ENTRIES,</span><br><span class="line">                            param,</span><br><span class="line">                            peer.getAddr());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    CompletableFuture.supplyAsync(()-&gt; getRpcClient().&lt;AentryResult&gt;send(request,<span class="number">450</span>),RaftThreadPool.giveMePool())</span><br><span class="line">                            .exceptionally( ex -&gt; <span class="literal">null</span>).whenComplete((result, throwable)-&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                            log.error(<span class="string">&quot;无法收到&#123;&#125; 节点的心跳回应，该节点可能已经宕机&quot;</span>,peer.getAddr());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">term</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                        <span class="keyword">if</span> (term &gt; currentTerm) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;self will become follower, he&#x27;s term : &#123;&#125;, my term : &#123;&#125;&quot;</span>, term, currentTerm);</span><br><span class="line">                            currentTerm = term;</span><br><span class="line">                            votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            status = NodeStatus.FOLLOWER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待所有日志完成</span></span><br><span class="line">            <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="comment">//多个任务</span></span><br><span class="line">                CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">                CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在一个满足N &gt; commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，</span></span><br><span class="line">            <span class="comment">// 并且log[N].term == currentTerm成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</span></span><br><span class="line">            List&lt;Long&gt; matchIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchIndexs.values());</span><br><span class="line">            <span class="comment">// 小于 2, 没有意义</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (matchIndexList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                Collections.sort(matchIndexList);</span><br><span class="line">                median = matchIndexList.size() / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">N</span> <span class="operator">=</span> matchIndexList.get(median);</span><br><span class="line">            <span class="keyword">if</span> (N &gt; commitIndex) &#123;</span><br><span class="line">                <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> logModule.read(N);</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getTerm() == currentTerm) &#123;</span><br><span class="line">                    commitIndex = N;</span><br><span class="line">                    <span class="comment">// 应用到状态机</span></span><br><span class="line">                    RaftThreadPool.execute(()-&gt;&#123;</span><br><span class="line">                        commitLock.lock();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">myCommitIndex</span> <span class="operator">=</span> commitIndex;</span><br><span class="line">                            <span class="comment">//应该从lastApplied开始应用，直到异步开始时的commitIndex（防止重复提交）</span></span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= myCommitIndex; i++)&#123;</span><br><span class="line">                                getStateMachine().apply(logModule.read(i));</span><br><span class="line">                                log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                            &#125;</span><br><span class="line">                            lastApplied = myCommitIndex;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            commitLock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-批量发送与回溯"><a href="#2-批量发送与回溯" class="headerlink" title="2. 批量发送与回溯"></a>2. 批量发送与回溯</h3><ul><li><strong>批量优化</strong>：发送日志时，会把从 <code>nextIndex</code> 到 Leader <code>lastIndex</code> 的所有日志打包发送。Follower 匹配成功后可批量写入，极大提升同步吞吐。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AentryParam</span> <span class="variable">aentryParam</span> <span class="operator">=</span> AentryParam.builder().build();</span><br><span class="line">aentryParam.setTerm(currentTerm);</span><br><span class="line">aentryParam.setServerId(peer.getAddr());</span><br><span class="line">aentryParam.setLeaderId(peerSet.getSelf().getAddr());</span><br><span class="line"></span><br><span class="line">aentryParam.setLeaderCommit(commitIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以我这边为准。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">nextIndex</span> <span class="operator">=</span> nextIndexs.get(peer);</span><br><span class="line"><span class="type">Long</span> <span class="variable">myNewIndex</span> <span class="operator">=</span> logModule.getLastIndex();</span><br><span class="line">LinkedList&lt;LogEntry&gt; logEntries = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (myNewIndex &gt;= nextIndex) &#123;</span><br><span class="line">    <span class="comment">// 把nextIndex 到 自己的最后一条日志都复制给follower</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex; i &lt;= myNewIndex; i++) &#123;</span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">l</span> <span class="operator">=</span> logModule.read(i);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            logEntries.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的日志(如果nextIndex为0 ，会返回一条term为-1，index为-1的日志，follower收到后会跳过匹配因为已经到底了)</span></span><br><span class="line"><span class="type">LogEntry</span> <span class="variable">preLog</span> <span class="operator">=</span> getPreLog(logEntries.getFirst());</span><br><span class="line">aentryParam.setPreLogTerm(preLog.getTerm());</span><br><span class="line">aentryParam.setPrevLogIndex(preLog.getIndex());</span><br><span class="line"></span><br><span class="line">aentryParam.setEntries(logEntries.toArray(<span class="keyword">new</span> <span class="title class_">LogEntry</span>[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> Request.builder()</span><br><span class="line">        .cmd(Request.A_ENTRIES)</span><br><span class="line">        .obj(aentryParam)</span><br><span class="line">        .url(peer.getAddr())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></li></ul><p>getPreLog() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LogEntry <span class="title function_">getPreLog</span><span class="params">(LogEntry logEntry)</span> &#123;</span><br><span class="line"></span><br><span class="line">    LogEntry entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(logEntry.getIndex() == <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;已经匹配到底了，需要从头开始覆盖&quot;</span>);</span><br><span class="line">        entry = LogEntry.builder().index(-<span class="number">1L</span>).term(-<span class="number">1</span>).command(<span class="literal">null</span>).build();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        entry = logModule.read(logEntry.getIndex() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>失败回溯</strong>：发送请求会携带 <code>prevLogTerm</code> 和 <code>prevLogIndex</code>。如果 Follower 返回失败（日志不匹配或 Leader Term 过旧）：<ul><li>如果是Leader Term 过旧，那就降级为Follower。</li><li>如果不是因为Term过旧，Leader 就将该 Follower 的 <code>nextIndex</code> 减一。</li><li>下次心跳时重试前一条日志，直到找到匹配点（MatchIndex）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">AentryResult</span> <span class="variable">result</span> <span class="operator">=</span> getRpcClient().send(request,<span class="number">450</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;append follower entry success , follower=[&#123;&#125;], entry=[&#123;&#125;]&quot;</span>, peer, aentryParam.getEntries());</span><br><span class="line">        <span class="comment">// update 这两个追踪值</span></span><br><span class="line">        nextIndexs.put(peer, myNewIndex+<span class="number">1</span>);</span><br><span class="line">        matchIndexs.put(peer, myNewIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 对方比我大</span></span><br><span class="line">        <span class="keyword">if</span> (result.getTerm() &gt; currentTerm) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;follower [&#123;&#125;] term [&#123;&#125;] than more self, and my term = [&#123;&#125;], so, I will become follower&quot;</span>,</span><br><span class="line">                    peer, result.getTerm(), currentTerm);</span><br><span class="line">            currentTerm = result.getTerm();</span><br><span class="line">            <span class="comment">// 认怂, 变成跟随者</span></span><br><span class="line">            status = NodeStatus.FOLLOWER;</span><br><span class="line">        &#125; <span class="comment">// 没我大, 却失败了,说明 index 不对.或者 term 不对.</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将nextIndex 减一 下一次心跳继续匹配。</span></span><br><span class="line">            nextIndexs.put(peer, nextIndex - <span class="number">1</span>);</span><br><span class="line">            log.warn(<span class="string">&quot;follower &#123;&#125; nextIndex not match, will reduce nextIndex and retry RPC append, nextIndex : [&#123;&#125;]&quot;</span>, peer.getAddr(),</span><br><span class="line">                    nextIndex);</span><br><span class="line">            <span class="comment">// 下次心跳重来, 直到成功.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;当前接受节点 &#123;&#125; 已宕机&quot;</span>, peer.getAddr());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="3-Follower-的处理逻辑"><a href="#3-Follower-的处理逻辑" class="headerlink" title="3. Follower 的处理逻辑"></a>3. Follower 的处理逻辑</h3><p>Follower 在接收端的处理也做了细致的锁管理：</p><ul><li><strong>日志写入</strong>：收到日志后严格校验匹配性。匹配成功则<strong>加锁</strong>写入本地日志,之后根据leader 的 <code>commitIndex</code>跟自己的 <code>lastIndex</code> 更新自己 <code>commitIndex</code>，异步应用到状态机，并返回成功。</li><li><strong>心跳处理</strong>：收到心跳时，若 Leader Term 小于自己，则拒绝并告知对方退位。若 Term 合法，重置选举超时，转为 Follower（因为自己之前可能是候选人，或者分区之后又合区的老leader）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AentryResult <span class="title function_">appendEntries</span><span class="params">(AentryParam param)</span> &#123;</span><br><span class="line">        <span class="type">AentryResult</span> <span class="variable">result</span> <span class="operator">=</span> AentryResult.fail();</span><br><span class="line">        <span class="comment">// 原appendLock仅保护日志写入/删除等临界操作，锁范围缩小</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!appendLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.setTerm(node.getCurrentTerm());</span><br><span class="line">            <span class="comment">// 1. 任期检查：对方任期更小，直接返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (param.getTerm() &lt; node.getCurrentTerm()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 更新节点状态（Follower）和时间戳</span></span><br><span class="line">            node.preHeartBeatTime = System.currentTimeMillis();</span><br><span class="line">            node.preElectionTime = System.currentTimeMillis();</span><br><span class="line">            node.peerSet.setLeader(<span class="keyword">new</span> <span class="title class_">Peer</span>(param.getLeaderId()));</span><br><span class="line">            <span class="keyword">if</span> (param.getTerm() &gt;= node.getCurrentTerm()) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">&quot;node &#123;&#125; become FOLLOWER, currentTerm : &#123;&#125;, param Term : &#123;&#125;, param serverId = &#123;&#125;&quot;</span>,</span><br><span class="line">                        node.peerSet.getSelf(), node.currentTerm, param.getTerm(), param.getServerId());</span><br><span class="line">                <span class="comment">// 退为跟随者</span></span><br><span class="line">                node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            &#125;</span><br><span class="line">            node.setCurrentTerm(param.getTerm());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 处理心跳请求</span></span><br><span class="line">            <span class="keyword">if</span> (param.getEntries() == <span class="literal">null</span> || param.getEntries().length == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;node &#123;&#125; append heartbeat success , he&#x27;s term : &#123;&#125;, my term : &#123;&#125;&quot;</span>,</span><br><span class="line">                        param.getLeaderId(), param.getTerm(), node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 心跳仅更新commitIndex，状态机提交异步执行</span></span><br><span class="line">                <span class="keyword">if</span> (param.getLeaderCommit() &gt; node.getCommitIndex()) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">newCommitIndex</span> <span class="operator">=</span> Math.min(param.getLeaderCommit(), node.getLogModule().getLastIndex());</span><br><span class="line">                    node.setCommitIndex(newCommitIndex);</span><br><span class="line">                    <span class="comment">// 异步提交状态机（核心改造点）</span></span><br><span class="line">                    submitToStateMachineAsync();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 心跳直接返回成功，无需等待提交</span></span><br><span class="line">                <span class="keyword">return</span> AentryResult.newBuilder().term(node.getCurrentTerm()).success(<span class="literal">true</span>).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理真实日志同步请求</span></span><br><span class="line">            <span class="comment">// 4.1 前置日志检查：prevLogIndex/prevLogTerm不匹配则返回失败</span></span><br><span class="line">            <span class="comment">// 如果prevLogIndex=-1，则代表该日志是leader的第一条日志，此时不需要匹配，因为已经是第一个了。</span></span><br><span class="line">            <span class="keyword">if</span> (param.getPrevLogIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> node.getLogModule().read(param.getPrevLogIndex());</span><br><span class="line">                <span class="keyword">if</span> (logEntry == <span class="literal">null</span> || logEntry.getTerm() != param.getPreLogTerm()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 冲突日志处理：索引相同但任期不同则删除后续所有日志</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nextLogIndex</span> <span class="operator">=</span> param.getPrevLogIndex() + <span class="number">1</span>;</span><br><span class="line">            <span class="type">LogEntry</span> <span class="variable">existLog</span> <span class="operator">=</span> node.getLogModule().read(nextLogIndex);</span><br><span class="line">            <span class="keyword">if</span> (existLog != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existLog.getTerm() != param.getEntries()[<span class="number">0</span>].getTerm()) &#123;</span><br><span class="line">                    <span class="comment">// 删除冲突日志及后续</span></span><br><span class="line">                    node.getLogModule().removeOnStartIndex(nextLogIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 日志已存在，无需重复写入，直接返回成功</span></span><br><span class="line">                    result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">                    result.setTerm(node.getCurrentTerm());</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.3 写入日志（核心：写入完成即可返回成功）</span></span><br><span class="line">            <span class="keyword">for</span> (LogEntry entry : param.getEntries()) &#123;</span><br><span class="line">                node.getLogModule().write(entry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 日志写入成功，先标记结果为成功</span></span><br><span class="line">            result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">            result.setTerm(node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.4 更新commitIndex，状态机提交异步执行</span></span><br><span class="line">            <span class="keyword">if</span> (param.getLeaderCommit() &gt; node.getCommitIndex()) &#123;</span><br><span class="line">                <span class="comment">// 更新commitIndex为leaderCommit跟本节点的lastIndex取最小值</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">newCommitIndex</span> <span class="operator">=</span> Math.min(param.getLeaderCommit(), node.getLogModule().getLastIndex());</span><br><span class="line">                node.setCommitIndex(newCommitIndex);</span><br><span class="line">                <span class="comment">// 异步提交状态机（核心改造点）</span></span><br><span class="line">                submitToStateMachineAsync();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.5 立即返回成功，无需等待状态机提交</span></span><br><span class="line">            node.status = NodeStatus.FOLLOWER;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放日志操作锁</span></span><br><span class="line">            <span class="keyword">if</span> (appendLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                appendLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>异步应用 (Async Apply)</strong>：<ul><li>心跳包中包含 Leader 的 <code>commitIndex</code>。</li><li>Follower 取 <code>min(leaderCommit, lastLogIndex)</code> 作为本地提交点。</li><li><strong>优化点</strong>：写入本地日志后，或者更新 commitIndex 后，采用<strong>异步方式</strong>将日志应用（Apply）到状态机，避免阻塞 IO 线程，提升效率。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitToStateMachineAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提交到专用线程池，异步执行</span></span><br><span class="line">        commitExecutor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 加锁保证串行提交，避免重复/并发提交</span></span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 基于lastApplied计算下一个要提交的索引（断点续传核心）</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">nextCommit</span> <span class="operator">=</span> node.getLastApplied() + <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">commitIndex</span> <span class="operator">=</span> node.getCommitIndex();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextCommit &gt; commitIndex) &#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">&quot;暂无需要提交的日志，lastApplied=&#123;&#125;, commitIndex=&#123;&#125;&quot;</span>, nextCommit-<span class="number">1</span>, commitIndex);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOGGER.info(<span class="string">&quot;开始异步提交日志，从索引&#123;&#125;到&#123;&#125;&quot;</span>, nextCommit, commitIndex);</span><br><span class="line">                <span class="comment">// 循环提交日志到状态机</span></span><br><span class="line">                <span class="keyword">while</span> (nextCommit &lt;= commitIndex) &#123;</span><br><span class="line">                    <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> node.getLogModule().read(nextCommit);</span><br><span class="line">                    <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            node.stateMachine.apply(logEntry);</span><br><span class="line">                            <span class="comment">// 每提交一条更新一次lastApplied，保证断点续传</span></span><br><span class="line">                            node.setLastApplied(nextCommit);</span><br><span class="line">                            LOGGER.info(<span class="string">&quot;异步提交日志成功，索引=&#123;&#125;&quot;</span>, nextCommit);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOGGER.error(<span class="string">&quot;异步提交日志到状态机失败，索引=&#123;&#125;&quot;</span>, nextCommit, e);</span><br><span class="line">                            <span class="comment">// 提交失败则终止，避免后续日志错位</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOGGER.warn(<span class="string">&quot;日志不存在，索引=&#123;&#125;&quot;</span>, nextCommit);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextCommit++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放提交锁</span></span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、-CommitIndex-的计算与安全性"><a href="#三、-CommitIndex-的计算与安全性" class="headerlink" title="三、 CommitIndex 的计算与安全性"></a>三、 CommitIndex 的计算与安全性</h2><p>如何确定一条日志可以被安全提交？</p><h3 id="1-基于中位数的-CommitIndex-计算"><a href="#1-基于中位数的-CommitIndex-计算" class="headerlink" title="1. 基于中位数的 CommitIndex 计算"></a>1. 基于中位数的 CommitIndex 计算</h3><p>不再简单依赖单次 RPC 的成功率，而是基于全局视图：</p><ul><li>在每次心跳/日志发送完成（<code>CompletableFuture.allOf</code> 结束）后，统计所有节点的 <code>matchIndex</code>。</li><li><strong>求中位数</strong>：通过排序或统计算法，找出超过半数节点都拥有的最大索引值。</li><li><strong>任期检查</strong>：Raft 规定只能提交当前任期的日志。因此，计算出的索引对应的日志 term 必须等于 <code>currentTerm</code> 才能更新 <code>commitIndex</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待所有日志完成</span></span><br><span class="line"><span class="keyword">try</span>  &#123;</span><br><span class="line">    <span class="comment">//多个任务</span></span><br><span class="line">    CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">    CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在一个满足N &gt; commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，</span></span><br><span class="line"><span class="comment">// 并且log[N].term == currentTerm成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</span></span><br><span class="line">List&lt;Long&gt; matchIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchIndexs.values());</span><br><span class="line"><span class="comment">// 小于 2, 没有意义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (matchIndexList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Collections.sort(matchIndexList);</span><br><span class="line">    median = matchIndexList.size() / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Long</span> <span class="variable">N</span> <span class="operator">=</span> matchIndexList.get(median);</span><br><span class="line"><span class="keyword">if</span> (N &gt; commitIndex) &#123;</span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> logModule.read(N);</span><br><span class="line">    <span class="comment">// 只能提交当前任期日志</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getTerm() == currentTerm) &#123;</span><br><span class="line">        commitIndex = N;</span><br><span class="line">        <span class="comment">// 异步应用到状态机</span></span><br><span class="line">        RaftThreadPool.execute(()-&gt;&#123;</span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">myCommitIndex</span> <span class="operator">=</span> commitIndex;</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到异步开始时的commitIndex（防止重复提交）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= myCommitIndex; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = myCommitIndex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-解决“幽灵复现”：No-Op-Log"><a href="#2-解决“幽灵复现”：No-Op-Log" class="headerlink" title="2. 解决“幽灵复现”：No-Op Log"></a>2. 解决“幽灵复现”：No-Op Log</h3><p>针对“只能提交当前任期日志”导致旧日志可能无法及时提交的问题（如果允许提交可能会导致同一个位置的日志重复提交），采用了<strong>插入空日志</strong>策略：</p><ul><li>新 Leader 上任后，立即append一条空日志（No-Op Log）。</li><li>一旦这条当前任期的空日志被提交，根据日志连续性原则，之前所有未提交的旧日志也会被间接提交。</li><li>初始化：新 Leader 将所有 Follower 的 <code>nextIndex</code> 初始化为 <code>lastIndex + 1</code>， <code>matchIndex</code> 初始化为 <code>0</code>。利用后续的心跳回溯机制自动对其。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">becomeLeaderToDoThing</span><span class="params">()</span> &#123;</span><br><span class="line">        nextIndexs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        matchIndexs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">            nextIndexs.put(peer, logModule.getLastIndex() + <span class="number">1</span>);</span><br><span class="line">            matchIndexs.put(peer, <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建[空日志]并提交，用于处理前任领导者未提交的日志</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> LogEntry.builder()</span><br><span class="line">                .command(<span class="literal">null</span>)</span><br><span class="line">                .term(currentTerm)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只用提交到本地日志 ， 同步操作在下一次发送心跳时进行。</span></span><br><span class="line">        logModule.write(logEntry);</span><br><span class="line">        log.info(<span class="string">&quot;write logModule success, logEntry info : &#123;&#125;, log index : &#123;&#125;&quot;</span>, logEntry, logEntry.getIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、-线性一致性读-Linearizable-Read"><a href="#四、-线性一致性读-Linearizable-Read" class="headerlink" title="四、 线性一致性读 (Linearizable Read)"></a>四、 线性一致性读 (Linearizable Read)</h2><p>为了防止读取到旧数据（Stale Read），实现了 Follower Read 和 Leader Read。</p><ul><li><strong>Leader Read</strong>：Leader 收到读请求后，不能直接返回。需先广播一轮心跳（同样使用 <code>CompletableFuture</code> 机制），确认自己仍持有过半数选票（未发生脑裂）。确认成功后，等待状态机应用到 <code>commitIndex</code> 后返回结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断自己是否还是leader</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isStillLeader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">Agree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        List&lt;CompletableFuture&lt;AentryResult&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Peer peer : peerSet.getPeersWithOutSelf()) &#123;</span><br><span class="line">            <span class="type">AentryParam</span> <span class="variable">param</span> <span class="operator">=</span> AentryParam.builder()</span><br><span class="line">                    .entries(<span class="literal">null</span>)<span class="comment">// 心跳,空日志.</span></span><br><span class="line">                    .leaderId(peerSet.getSelf().getAddr())</span><br><span class="line">                    .serverId(peer.getAddr())</span><br><span class="line">                    .term(currentTerm)</span><br><span class="line">                    .leaderCommit(commitIndex) <span class="comment">// 心跳时与跟随者同步 commit index</span></span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                    Request.A_ENTRIES,</span><br><span class="line">                    param,</span><br><span class="line">                    peer.getAddr());</span><br><span class="line">            futureList.add(CompletableFuture.supplyAsync(()-&gt; getRpcClient().&lt;AentryResult&gt;send(request,<span class="number">300</span>)</span><br><span class="line">                    ,RaftThreadPool.giveMePool()).exceptionally(ex -&gt; <span class="literal">null</span>)</span><br><span class="line">                    .whenComplete((result,throwable)-&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                            log.error(<span class="string">&quot;无法收到 &#123;&#125; 节点的心跳回应，该节点可能已经宕机&quot;</span>,peer.getAddr());</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">term</span> <span class="operator">=</span> result.getTerm();</span><br><span class="line">                            <span class="keyword">if</span>(term &gt; currentTerm)&#123;</span><br><span class="line">                                log.error(<span class="string">&quot;收到更大的term来自节点&#123;&#125;  当前节点&#123;&#125;目前已不适合当leader&quot;</span>,peer.getAddr(),peerSet.getSelf().getAddr());</span><br><span class="line">                                currentTerm = term;</span><br><span class="line">                                votedFor = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                                status = NodeStatus.FOLLOWER;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">//成功回复</span></span><br><span class="line">                                <span class="keyword">if</span>(result.isSuccess())&#123;</span><br><span class="line">                                    log.info(<span class="string">&quot;成功收到来自节点&#123;&#125;的心跳回复且合法&quot;</span>,peer.getAddr());</span><br><span class="line">                                    Agree.incrementAndGet();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有心跳回应</span></span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">            <span class="comment">//多个任务</span></span><br><span class="line">            CompletableFuture[] futureArray = futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//将多个任务，汇总成一个任务，总共耗时不超时2秒</span></span><br><span class="line">            CompletableFuture.allOf(futureArray).get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;CompletableFuture.allOf Exception error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断现在自己还是不是leader</span></span><br><span class="line">        <span class="keyword">if</span>(status!=NodeStatus.LEADER)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断收到的回复数是否大于等于一半（加上自己即大于一半）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">agreeNum</span> <span class="operator">=</span> Agree.get();</span><br><span class="line">        <span class="keyword">if</span>(agreeNum &gt;= (peerSet.getPeersWithOutSelf().size()+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Follower Read</strong>：<ol><li>Follower 收到读请求，向 Leader 发送 <code>ReadIndex</code> RPC。</li><li>Leader 收到后，执行上述“确认领导权”流程，返回当前的 <code>commitIndex</code>。</li><li>Follower 拿到 <code>commitIndex</code> 后，等待本地 <code>appliedIndex &gt;= commitIndex</code>，再将数据返回给客户端。</li></ol></li></ul><p>响应客户端请求的接口代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  ClientKVAck <span class="title function_">handlerClientRequest</span><span class="params">(ClientKVReq request)</span> &#123;</span><br><span class="line"></span><br><span class="line">    log.warn(<span class="string">&quot;handlerClientRequest handler &#123;&#125; operation,  and key : [&#123;&#125;], value : [&#123;&#125;]&quot;</span>,</span><br><span class="line">            ClientKVReq.Type.value(request.getType()), request.getKey(), request.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写请求必须转给leader</span></span><br><span class="line">    <span class="keyword">if</span> (status != NodeStatus.LEADER &amp;&amp; request.getType() == ClientKVReq.PUT) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;I not am leader , only invoke redirect write method, leader addr : &#123;&#125;, my addr : &#123;&#125;&quot;</span>,</span><br><span class="line">                peerSet.getLeader(), peerSet.getSelf().getAddr());</span><br><span class="line">        <span class="keyword">return</span> redirect(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader收到读请求。</span></span><br><span class="line">    <span class="comment">//为了满足顺序一致性要求，必须让lastApplied == commitIndex才行</span></span><br><span class="line">    <span class="keyword">if</span> (request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.LEADER) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断自己是否还是leader</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeader</span> <span class="operator">=</span> isStillLeader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLeader)&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证自己的lastApplied == commitIndex</span></span><br><span class="line">        <span class="keyword">if</span>(lastApplied != commitIndex)&#123;</span><br><span class="line">            commitLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到commitIndex</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= commitIndex; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;异步应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = commitIndex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;leader 节点 &#123;&#125; 日志应用到状态机失败&quot;</span>,peerSet.getSelf());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                commitLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> stateMachine.get(request.getKey());</span><br><span class="line">        <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(logEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是follower收到读请求</span></span><br><span class="line">    <span class="comment">//可以实现follower read , follower向leader发送查询当前readIndex的请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.FOLLOWER)&#123;</span><br><span class="line">        <span class="comment">//向leader发送获取当前最新commitIndex的请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(</span><br><span class="line">                Request.GET_READ_INDEX,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                peerSet.getLeader().getAddr());</span><br><span class="line"></span><br><span class="line">        GetCommitIndexResult result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             result = getRpcClient().send(request1,<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;无法与leader &#123;&#125; 取得连续，无法返回读请求&quot;</span>,peerSet.getLeader().getAddr());</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result.isSuccess())&#123;</span><br><span class="line">            <span class="comment">//说明当前发送的已经不是leader</span></span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">readIndex</span> <span class="operator">=</span> result.getReadIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须在2s内响应</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        commitLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">2</span>*<span class="number">1000</span>)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastIndex</span> <span class="operator">=</span> logModule.getLastIndex();</span><br><span class="line">                <span class="type">long</span> <span class="variable">shouldCommit</span> <span class="operator">=</span> Math.min(readIndex,lastIndex);</span><br><span class="line">                <span class="comment">//应该从lastApplied开始应用，直到shouldCommit</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> lastApplied + <span class="number">1</span>; i &lt;= shouldCommit; i++)&#123;</span><br><span class="line">                    getStateMachine().apply(logModule.read(i));</span><br><span class="line">                    log.info(<span class="string">&quot;应用日志成功,  logEntry info : &#123;&#125;&quot;</span>, logModule.read(i));</span><br><span class="line">                &#125;</span><br><span class="line">                lastApplied = shouldCommit;</span><br><span class="line">                <span class="comment">//满足要求</span></span><br><span class="line">                <span class="keyword">if</span>(lastApplied == readIndex)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待一段时间，继续</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    commitLock.unlock();</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    log.error(<span class="string">&quot;同步 ReadIndex 时线程被中断&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    commitLock.lock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            commitLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2秒过后还是没同步</span></span><br><span class="line">        <span class="keyword">if</span>(lastApplied!=readIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> stateMachine.get(request.getKey());</span><br><span class="line">        <span class="keyword">if</span> (logEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(logEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientKVAck</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是候选人响应读请求，则返回失败，因为自己是不稳定的</span></span><br><span class="line">    <span class="keyword">if</span>(request.getType() == ClientKVReq.GET &amp;&amp; status == NodeStatus.CANDIDATE)&#123;</span><br><span class="line">        <span class="keyword">return</span> ClientKVAck.fail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是leader处理写请求，但他只会写入本地，同步日志在心跳时完成。</span></span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">logEntry</span> <span class="operator">=</span> LogEntry.builder()</span><br><span class="line">            .command(Command.builder().</span><br><span class="line">                    key(request.getKey()).</span><br><span class="line">                    value(request.getValue()).</span><br><span class="line">                    build())</span><br><span class="line">            .term(currentTerm)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到本地日志</span></span><br><span class="line">    logModule.write(logEntry);</span><br><span class="line">    log.info(<span class="string">&quot;write logModule success, logEntry info : &#123;&#125;, log index : &#123;&#125;&quot;</span>, logEntry, logEntry.getIndex());</span><br><span class="line">    <span class="keyword">return</span> ClientKVAck.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五、-原项目的一些问题"><a href="#五、-原项目的一些问题" class="headerlink" title="五、 原项目的一些问题"></a>五、 原项目的一些问题</h2><ol><li>原项目只有在有新日志来的时候才会进行日志同步，没有新日志来的时候不会进行日志同步，但是一个落后的节点恢复之后，应该让他同步日志，这样就不会同步及时，于是我改造成了每次心跳时进行日志同步。</li><li>原项目在多个异步线程的同步（比如拉票请求，使用多线程进行发送拉票，但必须都完成之后才开始统计）上使用了 线程池+future+countDownLatch 使用future.get()获得结果，然后使用countDownLatch.await()等待所有线程完成，但是future.get()这个方法会阻塞线程，导致无法进行下一步操作。于是我改造成了CompletableFuture+线程池的方式实现。具体见前文中的代码。</li><li>原项目把lastApplied初始化为0，我认为并不合理，因为这个就默认0位置的日志已经应用了。所以应该改为-1。（我看了一下原项目并没有说明0位置的日志是垃圾日志，并且写入日志也都是从0开始，所以0位置是有用的，不应该跳过）。</li><li>原项目没有对RPC请求进行超时限制。这样在投票中极有可能发生如下情况：一个节点发起拉票请求，但有一个节点宕机，其他节点都投了赞成票。这个宕机节点会导致RPC请求一直处于等待状态，在最后统计得票的时候，会在多个异步任务同步这里超时（一般设为3秒）。但就是在这个时候，其他节点也极有可能发起新一轮的拉票请求，这样本来第一次发送拉票的节点，本应该在他那一轮变成leader但是在3秒之后，虽然拿到了多数票数，但是自己状态是follower（这里参考前文写的节点处理拉票请求），于是失败。这样就会导致多轮无效投票，导致效率低。于是设置一个RPC超时时间（500ms）保证能快速结算票数，让其他节点发起新一轮投票的概率变小。（其实原项目在投票的时候跟我的实现有一定出入，他并未对新一轮投票作出管理（我在当新一轮投票来临时，把自己得投票人置为空，并且把自己变成follower），只有自己变成候选人，然后落选之后才会把投票人清空，我觉得这样效率不高）</li><li>针对第5点的补充说明，原项目只有自己变成候选人，然后落选之后才会把投票人清空。这样做的话，在一个周期内如果没选出来领导人，那就必须等到下一个周期（因为重置投票人会在一个周期后，而不是一个新的term）。而我的改进，让一个节点收到更大的term之后会让出自己的位置，并且释放投票人，这样在每次新的term中每个节点都可以进行投票。这样在一个选举周期内大概率可以成功选举。我这种方案的随机时间设置范围最好为[electiontimeout, 2 * electiontimeout - 1],避免冲突。 （其实我这个思路跟6.824 lab2思路一样）</li><li>原项目并未实现Follower Read。我的具体实现见前文</li></ol><hr><h2 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h2><p>以下是我的一些心得 共12条</p><ol><li>投票时，如果遇到更新的term则把之前的投票人置空，防止无法投票（投票时也需要上锁，避免重复投票），然后判断自己没有投过票，当前发送请求的候选人是否有资格，即持有比自己更新的日志，如果都满足这个followe节点就可以投票给该节点。并更新相应的信息，释放锁。</li><li>Follower收到日志时，判断日志是否匹配，不匹配返回失败，匹配则写入本地。写入本地之后，根据leader的commitIndex异步应用日志，提升效率。但都需要上锁（写入与提交都需要）</li><li>follower收到心跳时，判断leader的term是否小于自己，如果小于返回失败，并且告诉leader自己的term，让他退位。如果大于等于自己，则把自己的状态变为follower(因为节点的状态可能是候选人，或者分区之后又加入的老leader)。然后重置投票倒计时。然后每次心跳还会带有leader的commitIndex，把这个跟自己最后的日志索引取最小值，然后异步应用日志到这个位置，跟leader保持同步。</li><li>在learder中把同步日志到followe操作 跟 心跳放在一起，即每次判断不同的follower是否需要同步日志，如果不需要则发送心跳。通过判断自己的lastIndex&gt;=每个follower的nextIndex（对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一））。如果是则发送nextIndex对应的日志。</li><li>在发送日志阶段，每次发送会带上indexIndex的前一条日志的term和index用于日志匹配。如果follower拒收，那就是日志不匹配（也有可能是leader的term小了，那么leader就应该退为follower），那么就把他的nextIndex 减一。这样下次心跳时就会发送前一个日志给他。直到成功，更新他对应的nextIndex以及matchIndex（对于每一个服务器，已经复制给他的日志的最高索引值）</li><li>合并发送，每次发送日志时，会把nextindex对应日志一直到自己的lastIndex日志一起发送，这样follower一旦匹配就可以批量写入新日志，快速同步。</li><li>当一个节点的投票倒计时结束后，还没收到leader的心跳。自己则会把自己的term+1,把自己变成候选人，投自己一票，然后向所有其他节点发起拉票，这个请求会携带自己的term,最后一个日志的term,index。通过这个其他节点才能判断你是否有资格。</li><li>把实现发起拉票操作的 线程池+Future+CountDownLatch 改成了 CompletableFuture+线程池。因为Future的get方法会阻塞调用，性能不如直接使用CompletableFuture的whenComplete。并且使用一个List<CompletableFuture>去保存这些对象，使用CompletableFuture.allOf方法保持多个异步线程的同步，从而不使用CountDownLatch进行同步。使用AtomicInteger记录投票成功数量，保证安全性。</li><li>在确定Leader的commitIndex时，不再使用每次同步的结果来判断（如果大部分成功就提交）。因为现在是在心跳时同步日志，给每个follower同步的不一定是同一个索引的日志。而是在每次心跳（日志）发送完成之后（跟8一样必须在发送都完成之后），使用每个follower的matchIndex 来判断leade的commitIndex。转化为已知每个节点的最大匹配数，求超过一半的匹配索引（其实就是求中位数即可）。得到对应的commitIndex。判断当前commitIndex的日志是否是自己当前任期的，否则不能提交（防止幽灵复现问题，即重复提交同一个位置的日志），但是可以通过提交当前任期的日志顺带一并提交之前的，但是如果当前任期一直没新日志难道迟迟不提交吗？</li><li>插入空日志，插入空日志就是解决9中提到的幽灵复现问题。每次新leader上任就插入一条空日志，这样就可以实现顺带提交之前任期未提交的日志。也可以及时提交，不依赖于新的日志。新上任的leader初始化所有的 nextIndex 值为自己的最后一条日志的 index + 1，这样下次心跳如果不匹配就会跟第5步一样。</li><li>Leader发送心跳也是使用的CompletableFuture但是这时就不用同步了，根据follower的返回值中的term是否大于自己的term来判断自己是否还能继续当，否则变成follower。</li><li>实现线性一致性的follower read。如果是leader收到读请求，先广播请求来判断当前自己是否还是leader(具体实现还是跟拉票类似，CompletableFuture+线程池)，如果收到过半数的成功回复，则保证将日志应用至commitIndex的位置之后返回读取请求。如果失败则不响应或者返回失败。如果是follower收到了此次读请求，那么发送一个请求当前最新commitIndex(readIndex)的RPC给leader,leader收到请求也会先判断自己是否还是leader,之后返回当前的commitIndex。Follower拿到之后即保证应用至commitIndex位置之后返回读请求，否则返回失败。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java手写Raft篇：核心流程与并发模型优化&quot;&gt;&lt;a href=&quot;#Java手写Raft篇：核心流程与并发模型优化&quot; class=&quot;headerlink&quot; title=&quot;Java手写Raft篇：核心流程与并发模型优化&quot;&gt;&lt;/a&gt;Java手写Raft篇：核心流程与</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（九） 二分</title>
    <link href="https://nmcb666.vip/posts/14894eda.html"/>
    <id>https://nmcb666.vip/posts/14894eda.html</id>
    <published>2026-01-28T16:23:15.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="狒狒吃香蕉"><a href="#狒狒吃香蕉" class="headerlink" title="狒狒吃香蕉"></a>狒狒吃香蕉</h2><p>思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计答案，右侧二分寻找更大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : piles) &#123;</span><br><span class="line">        r = Math.max(r,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(fMinEatingSpeed(piles,mid) &lt;= h)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">fMinEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles,<span class="type">int</span> speed)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">        cnt += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割数组最大值"><a href="#分割数组最大值" class="headerlink" title="分割数组最大值"></a>分割数组最大值</h2><p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。</p><p>返回分割后最小的和的最大值。</p><p>子数组 是数组中连续的部份。</p><p>思路： 对答案进行二分，答案范围为[0,sum(nums)]。f函数为当最小值为limit的时候，我需要的最小划分数。如果这个最小划分数&lt;=k,则记录答案，并且去左侧二分，寻找更小的答案。反之，则去右侧二分，不记录答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0,sum]二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = sum, m, need; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// 中点m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 必须让数组每一部分的累加和 &lt;= m，请问划分成几个部分才够!</span></span><br><span class="line">need = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (need &lt;= k) &#123;</span><br><span class="line"><span class="comment">// 达标</span></span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须让数组arr每一部分的累加和 &lt;= limit，请问划分成几个部分才够!</span></span><br><span class="line"><span class="comment">// 返回需要的部分数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">parts</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &gt; limit) &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum + num &gt; limit) &#123;</span><br><span class="line">parts++;</span><br><span class="line">sum = num;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出第k小的数对距离"><a href="#找出第k小的数对距离" class="headerlink" title="找出第k小的数对距离"></a>找出第k小的数对距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [0, 最大-最小]，不停二分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>], m, cnt; l &lt;= r;) &#123;</span><br><span class="line"><span class="comment">// m中点，arr中任意两数的差值 &lt;= m</span></span><br><span class="line">m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回数字对的数量</span></span><br><span class="line">cnt = f(nums, m);</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr中任意两数的差值 &lt;= limit</span></span><br><span class="line"><span class="comment">// 这样的数字配对，有几对？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line"><span class="comment">// l......r r+1</span></span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; arr.length &amp;&amp; arr[r + <span class="number">1</span>] - arr[l] &lt;= limit) &#123;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[l...r]范围上的数差值的绝对值都不超过limit</span></span><br><span class="line"><span class="comment">// arr[0...3]</span></span><br><span class="line"><span class="comment">// 0,1</span></span><br><span class="line"><span class="comment">// 0,2</span></span><br><span class="line"><span class="comment">// 0,3</span></span><br><span class="line">ans += r - l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同时运行n台电脑的最长时间"><a href="#同时运行n台电脑的最长时间" class="headerlink" title="同时运行n台电脑的最长时间"></a>同时运行n台电脑的最长时间</h2><p>leelcode2141</p><p>你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。</p><p>一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p><p>注意，你不能给电池充电。</p><p>请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</p><p>思路：还是二分答案。答案范围是[0,sum(batteries)]。f函数为当运行时间为m的时候，我能运行的最多电脑数量。如果这个数量大于等于规定的数量，那么我记录mid,然后去右边二分，寻找更长的时间。反之，不计入答案，去左侧二分。 还有一个贪心优化，可以减少二分的次数。详见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> batteries.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            r+=batteries[i];</span><br><span class="line">            max= Math.max(max,batteries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r&gt; (<span class="type">long</span>) max * n) &#123;</span><br><span class="line">            <span class="comment">// 所有电池的最大电量是max</span></span><br><span class="line">            <span class="comment">// 如果此时sum &gt; (long) max * n，</span></span><br><span class="line">            <span class="comment">// 说明 : 最终的供电时间一定在 &gt;= max，而如果最终的供电时间 &gt;= max</span></span><br><span class="line">            <span class="comment">// 说明 : 对于最终的答案X来说，所有电池都是课上讲的&quot;碎片拼接&quot;的概念</span></span><br><span class="line">            <span class="comment">// 那么寻找 ? * n &lt;= sum 的情况中，尽量大的 ? 即可</span></span><br><span class="line">            <span class="comment">// 即sum / n</span></span><br><span class="line">            <span class="keyword">return</span> r / n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        r = max;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f(batteries,mid);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= n )&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] batteries,<span class="type">long</span> maxTime)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxTime == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">litterTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;batteries.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(batteries[i]&lt;maxTime)&#123;</span><br><span class="line">                litterTime+=batteries[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="type">int</span>) (litterTime/maxTime);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二分总结"><a href="#二分总结" class="headerlink" title="二分总结"></a>二分总结</h1><p>二分答案法，其实都可以看成给了三个变量，数组，限制以及答案。正向推导需要我们根据数组以及限制得到答案。但现在根据二分答案法，我们可以先把答案确定下来，然后算出一个跟限制相关的东西，把这个东西跟原限制作比较（这里就观察单调性），来判断下一步应该去哪边找答案。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-28%20212134.png" alt="总结"/></div><span class="image-caption">总结</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;狒狒吃香蕉&quot;&gt;&lt;a href=&quot;#狒狒吃香蕉&quot; class=&quot;headerlink&quot; title=&quot;狒狒吃香蕉&quot;&gt;&lt;/a&gt;狒狒吃香蕉&lt;/h2&gt;&lt;p&gt;思路：最小值为1，最大值就是数组最大值。在这个范围上不断二分。遇到能吃完记录答案，往左侧二分寻找更小的，吃不完往不计</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（八）双指针</title>
    <link href="https://nmcb666.vip/posts/6fd57b4.html"/>
    <id>https://nmcb666.vip/posts/6fd57b4.html</id>
    <published>2026-01-27T16:04:39.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-27%20160658.png" alt="总结"/></div><span class="image-caption">总结</span></div><h2 id="寻找重复数-leetcode-hot100-最后一题"><a href="#寻找重复数-leetcode-hot100-最后一题" class="headerlink" title="寻找重复数 leetcode hot100 最后一题"></a>寻找重复数 leetcode hot100 最后一题</h2><p>思路：当成链表找环处理。每到一个位置i 那下一次就到arr[i]对应的位置。显然入环节点就是重复的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kuai</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">man</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        kuai = nums[nums[kuai]];</span><br><span class="line">        man = nums[man];</span><br><span class="line">        <span class="keyword">if</span>(kuai == man)&#123;</span><br><span class="line">            kuai = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(kuai != man)&#123;</span><br><span class="line">                kuai = nums[kuai];</span><br><span class="line">                man = nums[man];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kuai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>思路：初始版，类似与前缀和跟后缀和，我开两个数组记录i左边的最大值和右边的最大值，然后求出当前位置能接的雨水。sum+=Math.max(0,Math.min(left[i],right[i])-nums[i])</p><p>优化: 双指针思路，左右两边各一个指针。并且维护两个变量记录，左指针左边的最大值和右指针右边的最大值。对于左指针来说左边的最大值肯定是确定的，右指针同理。所以只需要判断两边谁的最大值更小，那么这一边就可以结算了，并且移动指针，更新最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">1</span>,r=height.length-<span class="number">2</span>,lmax = height[<span class="number">0</span>],rmax = height[height.length-<span class="number">1</span>],sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lmax&gt;=rmax)&#123;</span><br><span class="line">            <span class="comment">//结算右边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,rmax-height[r]);</span><br><span class="line">            rmax = Math.max(rmax,height[r--]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//结算左边</span></span><br><span class="line">            sum+=Math.max(<span class="number">0</span>,lmax-height[l]);</span><br><span class="line">            lmax= Math.max(lmax,height[l++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="胖娃坐船"><a href="#胖娃坐船" class="headerlink" title="胖娃坐船"></a>胖娃坐船</h2><p>给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回 承载所有人所需的最小船数 。</p><p>思路：排序，然后双指针，一个指针指向最轻的，一个指针指向最重的，如果最轻的+最重的&lt;=limit，那么可以一起载，两个指针同时移动，ans++。否则，最重的指针移动,ans++。即胖子自己一个船。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    Arrays.sort(people);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>people.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[r]+people[l] &lt;= limit)&#123;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种：如果要求两个的体重加起来等于偶数呢？ 很简单，分为奇偶两个数组，然后分别处理，把两个结果加起来即可。</p><h2 id="供暖器"><a href="#供暖器" class="headerlink" title="供暖器"></a>供暖器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">    Arrays.sort(houses);</span><br><span class="line">    Arrays.sort(heaters);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">heaterIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> house : houses) &#123;</span><br><span class="line">        <span class="comment">// 找到离当前房屋最近的加热器</span></span><br><span class="line">        <span class="keyword">while</span> (heaterIndex &lt; heaters.length - <span class="number">1</span> &amp;&amp; </span><br><span class="line">               Math.abs(heaters[heaterIndex] - house) &gt;= </span><br><span class="line">               Math.abs(heaters[heaterIndex + <span class="number">1</span>] - house)) &#123;</span><br><span class="line">            heaterIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(result, Math.abs(heaters[heaterIndex] - house));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><p>思路：我现在就想让每个位置都对应，即i位置上放的就是i+1。此时，我维护两个指针，l的左边是满足我这个条件的，r的右边是肯定不满足的垃圾。初始化l=0,r=n。</p><p>现在开始遍历：每次都观察l位置上的是否满足，如果满足那就l++。如果不满足判断它是不是我需要的，即它在不在当前l到r范围内（因为小于l的已经就位了，不需要你，大于r的已经超过了，不需要你）。关于为什么大于r就算超过这里解释一下。因为理想状态下我数组长度为n那么我就有1-n这些数，但一旦一个数不满足（r—），那我肯定到不了n了,最大就是r。还有一种情况，现在我需要你，但是在num[num[l]-1] 已经有一个相同的你了，说明你重复了。所以也会被当成垃圾。以上三种情况会被当成垃圾，跟—r位置交换。剩下最后一种情况，你是我需要的而且你还没到应该到的位置，于是我把你交换到对应的位置。下次循环，继续看i位置的数。 直到l&lt;r。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 时间复杂度O(n)，额外空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="comment">// l的左边，都是做到i位置上放着i+1的区域</span></span><br><span class="line"><span class="comment">// 永远盯着l位置的数字看，看能不能扩充(l++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// [r....]垃圾区</span></span><br><span class="line"><span class="comment">// 最好的状况下，认为1~r是可以收集全的，每个数字收集1个，不能有垃圾</span></span><br><span class="line"><span class="comment">// 有垃圾呢？预期就会变差(r--)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] == l + <span class="number">1</span>) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]) &#123;</span><br><span class="line">swap(arr, l, --r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, l, arr[l] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img&quot; src=&quot;https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（七） 滑动窗口</title>
    <link href="https://nmcb666.vip/posts/aad8ff6.html"/>
    <id>https://nmcb666.vip/posts/aad8ff6.html</id>
    <published>2026-01-26T16:59:21.000Z</published>
    <updated>2026-02-07T05:35:43.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="累加和大于等于k的最小长度子数组"><a href="#累加和大于等于k的最小长度子数组" class="headerlink" title="累加和大于等于k的最小长度子数组"></a>累加和大于等于k的最小长度子数组</h2><p>都是正数，所以滑动窗口具有单调性，加入新数肯定会导致累加和变大，减少数字会导致累加和变小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">sum += nums[r];</span><br><span class="line"><span class="keyword">while</span> (sum - nums[l] &gt;= target) &#123;</span><br><span class="line"><span class="comment">// sum : nums[l....r]</span></span><br><span class="line"><span class="comment">// 如果l位置的数从窗口出去，还能继续达标，那就出去</span></span><br><span class="line">sum -= nums[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">ans = Math.min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复子串的最长长度"><a href="#无重复子串的最长长度" class="headerlink" title="无重复子串的最长长度"></a>无重复子串的最长长度</h2><p>记录上次这个字符出现的位置，每次更新左边界，就用当前左边界跟（上次重复位置+1）的最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line"><span class="comment">// char -&gt; int -&gt; 0 ~ 255</span></span><br><span class="line"><span class="comment">// 每一种字符上次出现的位置</span></span><br><span class="line"><span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 所有字符都没有上次出现的位置</span></span><br><span class="line">Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 不含有重复字符的 最长子串 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">l = Math.max(l, last[s[r]] + <span class="number">1</span>);</span><br><span class="line">ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 更新当前字符上一次出现的位置</span></span><br><span class="line">last[s[r]] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>描述：给定两个字符串 s 和 t，长度分别是 m 和 n，返回 s 中的 最短窗口 子串，使得该子串包含 t 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 “”。</p><p>等到满足覆盖条件之后，再开始考虑移动左边界。，只有移动左边界不会导致覆盖条件失效，才能移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String str, String tar)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] t = tar.toCharArray();</span><br><span class="line"><span class="comment">// 每种字符的欠债情况</span></span><br><span class="line"><span class="comment">// cnts[i] = 负数，代表字符i有负债</span></span><br><span class="line"><span class="comment">// cnts[i] = 正数，代表字符i有盈余</span></span><br><span class="line"><span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : t) &#123;</span><br><span class="line">cnts[cha]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小覆盖子串的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// 从哪个位置开头，发现的最小覆盖子串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总债务</span></span><br><span class="line"><span class="type">int</span> <span class="variable">debt</span> <span class="operator">=</span> t.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length; r++) &#123;</span><br><span class="line"><span class="comment">// 窗口右边界向右，给出字符</span></span><br><span class="line"><span class="keyword">if</span> (cnts[s[r]]++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">debt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (debt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 窗口左边界向右，拿回字符</span></span><br><span class="line"><span class="keyword">while</span> (cnts[s[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnts[s[l++]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以r位置结尾的达标窗口，更新答案</span></span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">len = r - l + <span class="number">1</span>;</span><br><span class="line">start = l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : str.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换子串得到平衡字符串"><a href="#替换子串得到平衡字符串" class="headerlink" title="替换子串得到平衡字符串"></a>替换子串得到平衡字符串</h2><p>解释：有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>思路：跟最小覆盖子串思路一样。只需要找到哪些字符超过了多少，我们替换他即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        cnt[pos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">debat</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] &lt;= n/<span class="number">4</span>)&#123;</span><br><span class="line">            cnt[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cnt[i] = n/<span class="number">4</span> - cnt[i];</span><br><span class="line">            debat-=cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>;r&lt;s.length();r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(cnt[pos]++ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            debat--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debat == <span class="number">0</span>)&#123;</span><br><span class="line">            c = s.charAt(l);</span><br><span class="line">            pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>( cnt[pos] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cnt[pos]--;</span><br><span class="line">                l++;</span><br><span class="line">                c = s.charAt(l);</span><br><span class="line">                pos = c == <span class="string">&#x27;W&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;E&#x27;</span> ? <span class="number">2</span> : (c== <span class="string">&#x27;R&#x27;</span> ? <span class="number">3</span> : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans,r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K个不同整数的子数组"><a href="#K个不同整数的子数组" class="headerlink" title="K个不同整数的子数组"></a>K个不同整数的子数组</h2><p>描述：给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</p><p>如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</p><p>例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。<br>子数组 是数组的 连续 部分。</p><p>思路：转化为求不超过k个不同整数问题，用k 减去 k-1 对应的答案 就是刚好个数为k的个数。</p><p>对于不超过这个问题用滑动窗口解决，只要种类不超过就扩大窗口，否则缩小窗口直到种类不超过。然后统计以窗口右边结尾的子数组的个数。即r-l+1.每次累加这个结果即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 不超过k个不同整数</span></span><br><span class="line">    <span class="keyword">return</span> find(nums,k) - find(nums,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">20001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    Arrays.fill(cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kinds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;nums.length;r++)&#123;</span><br><span class="line">        <span class="comment">// 窗口右边界向右，给出字符,并判断是不是新的</span></span><br><span class="line">        <span class="keyword">if</span>(++cnt[nums[r]] == <span class="number">1</span>)&#123;</span><br><span class="line">            kinds++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (kinds &gt; k)&#123;</span><br><span class="line">            <span class="comment">// 窗口左边界向右，拿回字符，如果一个字符没有了，则种类减一</span></span><br><span class="line">            <span class="keyword">if</span>( -- cnt[nums[l++]] == <span class="number">0</span>)&#123;</span><br><span class="line">                kinds--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以r位置结尾的达标窗口，累加个数</span></span><br><span class="line">        sum+= r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;累加和大于等于k的最小长度子数组&quot;&gt;&lt;a href=&quot;#累加和大于等于k的最小长度子数组&quot; class=&quot;headerlink&quot; title=&quot;累加和大于等于k的最小长度子数组&quot;&gt;&lt;/a&gt;累加和大于等于k的最小长度子数组&lt;/h2&gt;&lt;p&gt;都是正数，所以滑动窗口具有单</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聚合与聚合根</title>
    <link href="https://nmcb666.vip/posts/6758315a.html"/>
    <id>https://nmcb666.vip/posts/6758315a.html</id>
    <published>2026-01-26T01:21:51.000Z</published>
    <updated>2026-02-07T05:35:43.508Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。</p><p>1.只能通过聚合根来修改内部对象，不能绕过聚合根。</p><p>2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回！</p><p>3.只有聚合根有repository。（实体可以有factory）</p><p>4.设计聚合最好小而全，最好能做到一个实体就是聚合。但做不到也不强求，能满足要求即可，但切记不能过大，也不能太小。</p><p>5.聚合根不能在内部直接引用其他聚合根，只能根据唯一id去查询另一个聚合根，由服务进行统排。</p><p>6.一个事务只对一个聚合根保存生效。</p><p>7.跨聚合采用最终一致性（因为规定了第6条，所以在跨聚合中经常会对不同的表进行操作），具体可以由领域事件实现。</p><p>8.如果聚合根内部有一个实体列表（1：N关系）那么可以考虑把这个实体也变成聚合根，原聚合根只保留他的唯一id列表。如果是多对多关系，可以考虑再新建一个表示它们两个关系的聚合根。</p><p>9.为什么要拆分聚合根？ 因为一个聚合根保留的信息越多，那么在并发的情况下，保存聚合根时冲突的概率就越大。比如我的用户保留了资源列表，而且我是保留了完整的资源信息，那么可能资源的信息修改（只是修改了资源的更新日期），也会导致我的用户保存失败（乐观锁，数据不一样）。但如果把资源单独变成聚合根，用户聚合只保留资源id那么将会避免这种情况。同时考虑资源跟用户是多对多的关系，所以最好最新建一个角色跟资源绑定的聚合根，角色聚合根里面不会有任何资源相关的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章用于存放我在阅读《悟道领域驱动设计》时，关于聚合与聚合根的笔记。&lt;/p&gt;
&lt;p&gt;1.只能通过聚合根来修改内部对象，不能绕过聚合根。&lt;/p&gt;
&lt;p&gt;2.就算想引用聚合根里面的对象，比如订单里面的订单项列表。那么订单这个聚合根提供的get方法也必须new 一个新列表返回</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://nmcb666.vip/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>算法（六）前缀和</title>
    <link href="https://nmcb666.vip/posts/3fdde4bd.html"/>
    <id>https://nmcb666.vip/posts/3fdde4bd.html</id>
    <published>2026-01-25T17:52:09.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和（子数组相关问题）"><a href="#一维前缀和（子数组相关问题）" class="headerlink" title="一维前缀和（子数组相关问题）"></a>一维前缀和（子数组相关问题）</h1><h2 id="和等于k的最长子数组长度"><a href="#和等于k的最长子数组长度" class="headerlink" title="和等于k的最长子数组长度"></a>和等于k的最长子数组长度</h2><p>思路：前缀和+哈希表。哈希表存的是key是前缀和，value是出现的位置。但这个位置必须是最早出现的，而且必须预先插入一条 0 ,-1表示0一开始就是。<br>然后，依次遍历数组计算前缀和，用当前的前缀和减去k的值去哈希表里面查找，当前位置减去对应的位置就是以当前位置结尾的最长子数组长度。遍历求最大即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">map.clear();</span><br><span class="line"><span class="comment">// 重要 : 0这个前缀和，一个数字也没有的时候，就存在了</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - aim)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - aim));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找正负数相等的最长子数组"><a href="#找正负数相等的最长子数组" class="headerlink" title="找正负数相等的最长子数组"></a>找正负数相等的最长子数组</h2><p>思路： 构造前缀和，但是前缀和记录正负数数量的差值。正数为1，负数为-1，0为0.然后每到一个位置靠哈希表查询跟自己前缀和相同的位置，然后求长度，即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt+= arr[i] == <span class="number">0</span> ? <span class="number">0</span> : arr[i]&lt;<span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cnt))&#123;</span><br><span class="line">              ans = Math.max(ans,i-map.get(cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(cnt))&#123;</span><br><span class="line">                map.put(cnt,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval"><a href="#表现良好的最长时间段-链接：-https-leetcode-cn-problems-longest-well-performing-interval" class="headerlink" title="表现良好的最长时间段 链接： https://leetcode.cn/problems/longest-well-performing-interval/"></a>表现良好的最长时间段 链接： <a href="https://leetcode.cn/problems/longest-well-performing-interval/">https://leetcode.cn/problems/longest-well-performing-interval/</a></h2><p>思路：还是前缀和+哈希表。超过时长+1，小于时长-1。如果遇到前缀和为正数说明从一开始就是满足的，返回i+1.如果为负数或者0，那么就找前缀和-1的位置（拉格朗日中值定理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line"><span class="comment">// 某个前缀和，最早出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 0这个前缀和，最早出现在-1，一个数也没有的时候</span></span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">sum += hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// sum &lt;= 0</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum - <span class="number">1</span>)) &#123;</span><br><span class="line">ans = Math.max(ans, i - map.get(sum - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="移除最少子数组长度使数组和可以被p整除"><a href="#移除最少子数组长度使数组和可以被p整除" class="headerlink" title="移除最少子数组长度使数组和可以被p整除"></a>移除最少子数组长度使数组和可以被p整除</h2><p>思路：以余数为前缀和，求出整个数组和的余数mod。然后在遍历过程中遇到当前余数curMod，我们就需要找到之前最后一个余数为 (curMod + p - mod)%p 的位置，然后求出长度。就是需要在当前位置移除的子数组的长度。需要最后判断长度是等于数组长度的时候，返回-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="comment">// 整体余数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">mod = (mod + num) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mod == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key : 前缀和%p的余数</span></span><br><span class="line"><span class="comment">// value : 最晚出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>, find; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="comment">// 0...i这部分的余数</span></span><br><span class="line">cur = (cur + nums[i]) % p;</span><br><span class="line">find = cur &gt;= mod ? (cur - mod) : (cur + p - mod);</span><br><span class="line"><span class="comment">// find = (cur + p - mod) % p;</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(find)) &#123;</span><br><span class="line">ans = Math.min(ans, i - map.get(find));</span><br><span class="line">&#125;</span><br><span class="line">map.put(cur, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == nums.length ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p>解释：现在要进行如下操作：</p><ol><li>给定一个数组，我要在给定区间加上一个同样的数。循环多次</li><li>加完之后返回给我每个位置上的值。</li></ol><p>一维差分：</p><ol><li>区间如果为l,r 要加上a,那么我在arr[l]+a,arr[r+1]-a.</li><li>之后对这个数组求前缀和，就是结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookings</span></span><br><span class="line"><span class="comment">// [1,5,6]</span></span><br><span class="line"><span class="comment">// [2,9,3]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line"><span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 设置差分数组，每一个操作对应两个设置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] book : bookings) &#123;</span><br><span class="line">cnt[book[<span class="number">0</span>]] += book[<span class="number">2</span>];</span><br><span class="line">cnt[book[<span class="number">1</span>] + <span class="number">1</span>] -= book[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加工前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans[i] = cnt[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="等差差分"><a href="#等差差分" class="headerlink" title="等差差分"></a>等差差分</h1><p>解释： 跟一维差分类似，但是我要从l到r 依次加上一个等差数列，而不是一个数。</p><p>结论： 假设这个等差数列 首项为 s , 公差为 d, 末项为 e。那对arr[l]+=s,arr[l+1]+=d-s,arr[r+1]-=d+e,arr[r+2]+=e; 然后进行两次前缀和即可。</p><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>公式： sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + arr[i][j]<br>计算从（a,b）到 （c,d）的子矩阵的和 : sum[c][d] - sum[a-1][d] - sum[c][b-1] + sum[a-1][b-1]</p><h2 id="最大以1为边界的正方形"><a href="#最大以1为边界的正方形" class="headerlink" title="最大以1为边界的正方形"></a>最大以1为边界的正方形</h2><p>描述：给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>核心思路：构造出二维前缀和，依次枚举以（i,j）为左上角的正方形是否合法。假设以(c,d)为右下角。这个正方形的和减去以(i+1,j+1),(c-1,d-1)为对角的正方形和的值应该等于他的（边长-1） * 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> g[<span class="number">0</span>].length;</span><br><span class="line">build(n, m, g);</span><br><span class="line"><span class="keyword">if</span> (sum(g, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, m - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到的最大合法正方形的边长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; m; b++) &#123;</span><br><span class="line"><span class="comment">// (a,b)所有左上角点</span></span><br><span class="line"><span class="comment">//     (c,d)更大边长的右下角点，k是当前尝试的边长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + ans, d = b + ans, k = ans + <span class="number">1</span>; c &lt; n &amp;&amp; d &lt; m; c++, d++, k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum(g, a, b, c, d) - sum(g, a + <span class="number">1</span>, b + <span class="number">1</span>, c - <span class="number">1</span>, d - <span class="number">1</span>) == (k - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>) &#123;</span><br><span class="line">ans = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g : 原始二维数组</span></span><br><span class="line"><span class="comment">// 把g变成原始二维数组的前缀和数组sum，复用自己</span></span><br><span class="line"><span class="comment">// 不能补0行，0列，都是0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">g[i][j] += get(g, i, j - <span class="number">1</span>) + get(g, i - <span class="number">1</span>, j) - get(g, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; c ? <span class="number">0</span> : (g[c][d] - get(g, c, b - <span class="number">1</span>) - get(g, a - <span class="number">1</span>, d) + get(g, a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[][] g, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) ? <span class="number">0</span> : g[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>跟一维差分差不多这里直接给公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维差分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">diff[a][b] += k;</span><br><span class="line">diff[c + <span class="number">1</span>][b] -= k;</span><br><span class="line">diff[a][d + <span class="number">1</span>] -= k;</span><br><span class="line">diff[c + <span class="number">1</span>][d + <span class="number">1</span>] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一维前缀和（子数组相关问题）&quot;&gt;&lt;a href=&quot;#一维前缀和（子数组相关问题）&quot; class=&quot;headerlink&quot; title=&quot;一维前缀和（子数组相关问题）&quot;&gt;&lt;/a&gt;一维前缀和（子数组相关问题）&lt;/h1&gt;&lt;h2 id=&quot;和等于k的最长子数组长度&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Raft与Paxos</title>
    <link href="https://nmcb666.vip/posts/b1c1c3b5.html"/>
    <id>https://nmcb666.vip/posts/b1c1c3b5.html</id>
    <published>2026-01-25T14:05:03.000Z</published>
    <updated>2026-02-07T05:35:43.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？"><a href="#深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？" class="headerlink" title="[深度对比] 分布式共识的双雄：Paxos 与 Raft，为何 Raft 成为了工程界的宠儿？"></a>[深度对比] 分布式共识的双雄：Paxos 与 Raft，为何 Raft 成为了工程界的宠儿？</h1><p>在分布式系统的浩瀚宇宙中，<strong>“共识（Consensus）”</strong> 是最核心的难题之一。如何让一堆可能随时宕机、网络延迟的机器对某个值达成一致？这个问题困扰了计算机科学家几十年。</p><p>在这个领域，有两位绝对的主角：一个是理论界的“神” <strong>Paxos</strong>，另一个是工程界的“救世主” <strong>Raft</strong>。</p><p>很多开发者都知道，现在主流的分布式组件（如 Etcd, Consul, TiKV, Kafka的新版本）大多选择了 Raft。那么，Paxos 到底输在哪里？Raft 又为何如此容易实现？本文将带你深入剖析两者的区别与优劣。</p><hr><h2 id="一、-核心设计哲学的差异"><a href="#一、-核心设计哲学的差异" class="headerlink" title="一、 核心设计哲学的差异"></a>一、 核心设计哲学的差异</h2><p>要理解它们的区别，首先要看它们诞生的初衷：</p><ul><li><strong>Paxos (Leslie Lamport, 1990)</strong>：旨在发现共识问题的<strong>数学规律</strong>。它从数学角度证明了在分布式系统中达成一致的充要条件。它追求的是理论的完备性和一般性。</li><li><strong>Raft (Diego Ongaro &amp; John Ousterhout, 2013)</strong>：旨在提供一个<strong>可理解（Understandable）</strong>且<strong>易于实现</strong>的算法。它的设计目标非常明确：<strong>就是为了解决 Paxos 太难懂、太难实现的问题</strong>。</li></ul><p>如果把 Paxos 比作量子力学（解释了世界的本质，但很难直接用来造桥），那么 Raft 就是牛顿力学（在特定约束下，给了你一套造桥的标准公式）。</p><hr><h2 id="二、-为什么-Raft-更容易实现？"><a href="#二、-为什么-Raft-更容易实现？" class="headerlink" title="二、 为什么 Raft 更容易实现？"></a>二、 为什么 Raft 更容易实现？</h2><p>这是 Raft 能够后来居上的最大原因。Raft 并不是在理论上超越了 Paxos，而是通过<strong>增加约束</strong>和<strong>分解问题</strong>，极大地降低了工程落地的复杂度。</p><h3 id="1-问题的分解（Decomposition）"><a href="#1-问题的分解（Decomposition）" class="headerlink" title="1. 问题的分解（Decomposition）"></a>1. 问题的分解（Decomposition）</h3><p>Paxos 将选举、日志复制、确认提交等逻辑混杂在一起，牵一发而动全身。<br>Raft 强制将共识问题拆解为三个独立的子模块：</p><ul><li><strong>Leader Election（选主）</strong>：先选出老大，别的什么都不干。</li><li><strong>Log Replication（日志复制）</strong>：老大负责同步数据，Follower 负责接收。</li><li><strong>Safety（安全性）</strong>：确保数据一旦提交，就永远存在。</li></ul><p>这种解耦使得开发者可以独立编写和测试每个模块。</p><h3 id="2-强-Leader-模型（Strong-Leader）"><a href="#2-强-Leader-模型（Strong-Leader）" class="headerlink" title="2. 强 Leader 模型（Strong Leader）"></a>2. 强 Leader 模型（Strong Leader）</h3><p>这是 Raft 简化的杀手锏。</p><ul><li><strong>Paxos</strong>：允许所有节点同时发起提案（虽然 Multi-Paxos 也会优化为单 Leader，但协议本身允许并发）。这导致需要处理极其复杂的“冲突解决”和“日志乱序”问题。</li><li><strong>Raft</strong>：是<strong>独裁</strong>的。日志流向只能是 <code>Leader -&gt; Follower</code>。Follower 绝对不会修改 Leader 的日志，Leader 也永远不会覆盖自己的日志。这种单向数据流消除了大量边缘状态。</li></ul><h3 id="3-强制日志连续（Log-Continuity）"><a href="#3-强制日志连续（Log-Continuity）" class="headerlink" title="3. 强制日志连续（Log Continuity）"></a>3. 强制日志连续（Log Continuity）</h3><ul><li><strong>Paxos</strong>：允许日志有“空洞”。比如节点 A 确认了第 1、2、5 号日志，缺了 3 和 4。Paxos 允许这种情况存在，后续再通过复杂的逻辑把空洞补齐。</li><li><strong>Raft</strong>：<strong>不允许空洞</strong>。Follower 必须按顺序接收日志。如果 Follower 缺了第 4 号日志，Leader 绝不会发第 5 号给它，而是会强制回退（利用 <code>PrevLogIndex</code> 检查），直到找到一致的点，然后覆盖同步。这让状态机的实现变得极其简单——按顺序执行即可。</li></ul><h3 id="4-选主限制：拥有最新日志者才能当选"><a href="#4-选主限制：拥有最新日志者才能当选" class="headerlink" title="4. 选主限制：拥有最新日志者才能当选"></a>4. 选主限制：拥有最新日志者才能当选</h3><p>在 Paxos 中，任何节点都可能成为 Leader，哪怕它的数据很旧。上位后，它需要先学习历史数据，补全自己的知识，然后才能开始工作。<br>Raft 规定：<strong>只有拥有所有已提交日志的节点，才有资格当选 Leader。</strong> 这意味着新 Leader 上任的第一刻起，它就不需要去问别人“我是不是缺数据了”，直接接受新写入即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Raft 之所以容易实现，是因为它剥夺了节点的自由：</p><p>不准乱序提交（消灭了复杂的并发合并逻辑）。</p><p>不准 Follower 质疑 Leader（消灭了双向同步逻辑）。</p><p>不准旧节点当 Leader（消灭了 Leader 上位后的补数据逻辑）。</p><hr><h2 id="三、-Paxos-与-Raft-的优缺点权衡"><a href="#三、-Paxos-与-Raft-的优缺点权衡" class="headerlink" title="三、 Paxos 与 Raft 的优缺点权衡"></a>三、 Paxos 与 Raft 的优缺点权衡</h2><p>既然 Raft 这么好，Paxos 是不是一无是处？并非如此。两者在不同的维度各有千秋。</p><h3 id="1-Paxos-的优点（对比-Raft）"><a href="#1-Paxos-的优点（对比-Raft）" class="headerlink" title="1. Paxos 的优点（对比 Raft）"></a>1. Paxos 的优点（对比 Raft）</h3><ul><li><strong>理论的极致与通用性</strong>：Paxos 是共识算法的基石。Google 的 Chubby、Spanner 底层依然是 Paxos 的变种。事实上，Raft 可以被看作是 Paxos 的一个特定约束下的子集。</li><li><strong>更高的写入并发潜力</strong>：由于 Paxos 允许日志乱序确认（Out-of-Order Commit），在不依赖强顺序的场景下（或者使用 EPaxos 等变种），它的理论吞吐量可以高于 Raft。Raft 必须一个接一个顺序提交，存在队头阻塞（Head-of-Line Blocking）风险。</li><li><strong>无 Leader 的生存能力</strong>：Basic Paxos 不需要 Leader，在网络极其不稳定、无法维持稳定 Leader 的极端环境下，Basic Paxos 依然能工作，而 Raft 会陷入反复选主的死循环（不可用）。</li></ul><h3 id="2-Raft-的优点（对比-Paxos）"><a href="#2-Raft-的优点（对比-Paxos）" class="headerlink" title="2. Raft 的优点（对比 Paxos）"></a>2. Raft 的优点（对比 Paxos）</h3><ul><li><strong>可理解性（Understandability）</strong>：这是 Raft 的核心竞争力。一个普通的工程师阅读 Raft 论文两遍可能就能写出原型；而阅读 Paxos 论文十遍可能还是一头雾水。</li><li><strong>工程细节完备</strong>：Paxos 论文只讲了如何达成共识，没讲如何增删节点、如何压缩日志（Snapshot）。Raft 对这些工程痛点都给出了标准解决方案（如 Joint Consensus 成员变更算法）。</li><li><strong>调试与排错</strong>：由于 Raft 的状态转换路径非常清晰（且有限），当系统出现 Bug 时，更容易复现和定位。</li></ul><hr><h2 id="四、-总结：如何选择？"><a href="#四、-总结：如何选择？" class="headerlink" title="四、 总结：如何选择？"></a>四、 总结：如何选择？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Paxos (Multi-Paxos)</th><th style="text-align:left">Raft</th></tr></thead><tbody><tr><td style="text-align:left"><strong>设计目标</strong></td><td style="text-align:left">理论证明</td><td style="text-align:left">工程实现、可理解性</td></tr><tr><td style="text-align:left"><strong>日志结构</strong></td><td style="text-align:left">允许空洞，并发确认</td><td style="text-align:left">必须连续，顺序确认</td></tr><tr><td style="text-align:left"><strong>数据流向</strong></td><td style="text-align:left">多点可能（复杂）</td><td style="text-align:left">Leader 单向流向 Follower</td></tr><tr><td style="text-align:left"><strong>实现难度</strong></td><td style="text-align:left">极高（容易写出 Bug）</td><td style="text-align:left">中等（有标准参考）</td></tr><tr><td style="text-align:left"><strong>工业界现状</strong></td><td style="text-align:left">Google Spanner, Zookeeper (ZAB 类似)</td><td style="text-align:left">Etcd, Consul, TiKV, CockroachDB</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？&quot;&gt;&lt;a href=&quot;#深度对比-分布式共识的双雄：Paxos-与-Raft，为何-Raft-成为了工程界的宠儿？&quot; class=&quot;headerlink&quot; title=&quot;[深</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（五） 前缀树</title>
    <link href="https://nmcb666.vip/posts/38c6bd07.html"/>
    <id>https://nmcb666.vip/posts/38c6bd07.html</id>
    <published>2026-01-24T16:36:58.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀树结构"><a href="#前缀树结构" class="headerlink" title="前缀树结构"></a>前缀树结构</h2><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p><p>前缀树的基本操作</p><p>插入字符串：从根节点开始，依次插入字符串的每个字符。如果路径不存在，则创建新节点。最后一个节点标记为字符串的结束。</p><p>删除字符串：从根节点开始，依次减少路径上节点的计数。如果某节点的计数为零，则删除该节点。</p><p>查询字符串出现次数：沿路径遍历字符串，若路径完整且结束节点存在，则返回字符串的计数。</p><p>查询前缀数量：沿路径遍历前缀，若路径完整，则返回最后节点的通过计数。</p><h3 id="节点的结构"><a href="#节点的结构" class="headerlink" title="节点的结构"></a>节点的结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> pass;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"><span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">pass = <span class="number">0</span>;</span><br><span class="line">end = <span class="number">0</span>;</span><br><span class="line">nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">node.pass++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line">node.nexts[path] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">node.pass++;</span><br><span class="line">&#125;</span><br><span class="line">node.end++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询字符串出现次数"><a href="#查询字符串出现次数" class="headerlink" title="查询字符串出现次数"></a>查询字符串出现次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 查询前缀树里，word单词出现了几次</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询前缀数量"><a href="#查询前缀数量" class="headerlink" title="查询前缀数量"></a>查询前缀数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 查询前缀树里，有多少单词以pre做前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String pre)</span> &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 如果之前word插入过前缀树，那么此时删掉一次</span></span><br><span class="line"><span class="comment">// 如果之前word没有插入过前缀树，那么什么也不做</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (countWordsEqualTo(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">node.pass--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) &#123;</span><br><span class="line">node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[path];</span><br><span class="line">&#125;</span><br><span class="line">node.end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用静态数组实现前缀树"><a href="#使用静态数组实现前缀树" class="headerlink" title="使用静态数组实现前缀树"></a>使用静态数组实现前缀树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 如果将来增加了数据量，就改大这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">150001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">pass[cur]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">pass[cur]++;</span><br><span class="line">&#125;</span><br><span class="line">end[cur]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String pre)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pass[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (search(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 下面这一行代码，讲课的时候没加</span></span><br><span class="line"><span class="comment">// 本题不会用到pass[1]的信息，所以加不加都可以，不过正确的写法是加上</span></span><br><span class="line">pass[cur]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (--pass[tree[cur][path]] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line">end[cur]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">end[i] = <span class="number">0</span>;</span><br><span class="line">pass[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="查询数组中两个数的异或最大值"><a href="#查询数组中两个数的异或最大值" class="headerlink" title="查询数组中两个数的异或最大值"></a>查询数组中两个数的异或最大值</h3><p>思路：我们使用每一个数，根据他的每一位去构建一个前缀树。然后依次遍历每一个数，从最高位开始遍历，我希望找到跟我不一样的位，于是我在前缀树里面查找。如果存在那么把这个位置变成1加入答案，如果不存在那么把这个位置变成0加入答案。然后跳到下一个节点树去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 前缀树的做法</span></span><br><span class="line"><span class="comment">// 好想</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaximumXOR1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">build(nums);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">ans = Math.max(ans, maxXor(num));</span><br><span class="line">&#125;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备这么多静态空间就够了，实验出来的</span></span><br><span class="line"><span class="comment">// 如果测试数据升级了规模，就改大这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">3000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀树目前使用了多少空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字只需要从哪一位开始考虑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 找个最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">max = Math.max(num, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算数组最大值的二进制状态，有多少个前缀的0</span></span><br><span class="line"><span class="comment">// 可以忽略这些前置的0，从left位开始考虑</span></span><br><span class="line">high = <span class="number">31</span> - Integer.numberOfLeadingZeros(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">insert(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high, path; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxXor</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="comment">// 最终异或的结果(尽量大)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 前缀树目前来到的节点编号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high, status, want; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// status : num第i位的状态</span></span><br><span class="line">status = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// want : num第i位希望遇到的状态</span></span><br><span class="line">want = status ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][want] == <span class="number">0</span>) &#123; <span class="comment">// 询问前缀树，能不能达成</span></span><br><span class="line"><span class="comment">// 不能达成</span></span><br><span class="line">want ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// want变成真的往下走的路</span></span><br><span class="line">ans |= (status ^ want) &lt;&lt; i;</span><br><span class="line">cur = tree[cur][want];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">tree[i][<span class="number">0</span>] = tree[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在二维网格中，搜索单词组返回能找到的单词组"><a href="#在二维网格中，搜索单词组返回能找到的单词组" class="headerlink" title="在二维网格中，搜索单词组返回能找到的单词组"></a>在二维网格中，搜索单词组返回能找到的单词组</h3><p>思路：回溯+前缀树减枝</p><p>关键点：1.把走过的格子，标为0，这样不会重复走，但是需要恢复现场</p><p>2.利用前缀树减枝，首先利用单词组构建出前缀树。每次递归的时候根据前缀树有没有路径来判断这个格子里面的单词能不能要。除了路径还要判断这条路径下还有没有剩余的未探索单词（利用pass数组）。</p><p>3.巧用pass跟end数组。pass[i] 表示当前节点剩余还未收集的单词，end[i] 表示在当前节点完结的单词，可以直接加入ans。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">build(words);</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">dfs(board, i, j, <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// board : 二维网格</span></span><br><span class="line"><span class="comment">// i,j : 此时来到的格子位置，i行、j列</span></span><br><span class="line"><span class="comment">// t : 前缀树的编号</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; ans : 收集到了哪些字符串，都放入ans</span></span><br><span class="line"><span class="comment">// 返回值 : 收集到了几个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> t, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line"><span class="comment">// 越界 或者 走了回头路，直接返回0</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || board[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界 且 不是回头路</span></span><br><span class="line"><span class="comment">// 用tmp记录当前字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line"><span class="comment">// 路的编号</span></span><br><span class="line"><span class="comment">// a -&gt; 0</span></span><br><span class="line"><span class="comment">// b -&gt; 1</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// z -&gt; 25</span></span><br><span class="line"><span class="type">int</span> <span class="variable">road</span> <span class="operator">=</span> tmp - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">t = tree[t][road];</span><br><span class="line">       <span class="comment">// 不存在该路径，或者该路径下的单词已经被你找出来完了  其实应该写成 t==0 || pass[t]==0 但是初始化的时候pass就是从1开始，所以这里可以不用判断</span></span><br><span class="line"><span class="keyword">if</span> (pass[t] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i，j位置有必要来</span></span><br><span class="line"><span class="comment">// fix ：从当前i，j位置出发，一共收集到了几个字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">fix</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end[t] != <span class="literal">null</span>) &#123;</span><br><span class="line">fix++;</span><br><span class="line">ans.add(end[t]);</span><br><span class="line">end[t] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把i，j位置的字符，改成0，后续的过程，是不可以再来到i，j位置的！</span></span><br><span class="line">board[i][j] = <span class="number">0</span>;</span><br><span class="line">fix += dfs(board, i - <span class="number">1</span>, j, t, ans);</span><br><span class="line">fix += dfs(board, i + <span class="number">1</span>, j, t, ans);</span><br><span class="line">fix += dfs(board, i, j - <span class="number">1</span>, t, ans);</span><br><span class="line">fix += dfs(board, i, j + <span class="number">1</span>, t, ans);</span><br><span class="line">       <span class="comment">// 减去已经找到的单词数量</span></span><br><span class="line">pass[t] -= fix;</span><br><span class="line">       <span class="comment">// 恢复现场</span></span><br><span class="line">board[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> fix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] end = <span class="keyword">new</span> <span class="title class_">String</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">pass[cur]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) &#123;</span><br><span class="line">tree[cur][path] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">cur = tree[cur][path];</span><br><span class="line">pass[cur]++;</span><br><span class="line">&#125;</span><br><span class="line">end[cur] = word;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">pass[i] = <span class="number">0</span>;</span><br><span class="line">end[i] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前缀树结构&quot;&gt;&lt;a href=&quot;#前缀树结构&quot; class=&quot;headerlink&quot; title=&quot;前缀树结构&quot;&gt;&lt;/a&gt;前缀树结构&lt;/h2&gt;&lt;p&gt;Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CAP中的一致性</title>
    <link href="https://nmcb666.vip/posts/5bb35c22.html"/>
    <id>https://nmcb666.vip/posts/5bb35c22.html</id>
    <published>2026-01-24T14:37:48.000Z</published>
    <updated>2026-02-07T05:35:43.509Z</updated>
    
    <content type="html"><![CDATA[<p>关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）</p><h2 id="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"><a href="#首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？" class="headerlink" title="首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？"></a>首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？</h2><p>这是一个非常经典且容易混淆的问题，因为“一致性”（Consistency）这个词在计算机科学的不同领域里，虽然名字一样，但含义却大相径庭。</p><p>这三个概念分别对应了：<strong>单机数据库理论（ACID）</strong>、<strong>分布式系统理论（CAP）</strong> 和 <strong>工程实践（分布式事务）</strong>。</p><p>我们可以用一句话概括它们的区别：</p><ul><li><strong>ACID 的一致性</strong>：关乎<strong>数据的“正确性”</strong>（符合业务约束）。</li><li><strong>CAP 的一致性</strong>：关乎<strong>数据的“新旧”</strong>（多副本同步）。</li><li><strong>分布式事务的一致性</strong>：关乎<strong>跨系统的“协调”</strong>（让多个独立系统的数据最终对齐）。</li></ul><hr><h3 id="1-事务的一致性-ACID-中的-C"><a href="#1-事务的一致性-ACID-中的-C" class="headerlink" title="1. 事务的一致性 (ACID 中的 C)"></a>1. 事务的一致性 (ACID 中的 C)</h3><p>这里的背景通常指<strong>单机数据库</strong>（如 MySQL）的本地事务。</p><ul><li><strong>定义</strong>：指事务执行前后，数据库必须从一个<strong>合法状态</strong>变换到另一个<strong>合法状态</strong>。</li><li><strong>核心关注点</strong>：<strong>业务逻辑与约束 (Business Logic &amp; Constraints)</strong>。</li><li><strong>详细解释</strong>：<br>“合法状态”是指数据必须符合预定义的规则。这些规则包括：<ul><li><strong>数据库约束</strong>：主键唯一、外键约束、字段类型、Check约束（例如余额不能小于0）。</li><li><strong>业务逻辑</strong>：例如 A 转账给 B 100元，那么 A 减去 100，B 加上 100，总金额必须不变。如果代码写错了，A 减了 100，B 却只加了 50，虽然数据库没崩溃（原子性满足），但<strong>一致性</strong>被破坏了，因为数据不再符合“总额守恒”的业务规则。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证数据不违背现实世界的业务规则。</strong></li></ul><hr><h3 id="2-分布式系统的一致性-CAP-中的-C"><a href="#2-分布式系统的一致性-CAP-中的-C" class="headerlink" title="2. 分布式系统的一致性 (CAP 中的 C)"></a>2. 分布式系统的一致性 (CAP 中的 C)</h3><p>这里的背景是指<strong>多副本的数据存储系统</strong>（如 Redis Cluster, Cassandra, ZooKeeper, HDFS）。</p><ul><li><strong>定义</strong>：在 CAP 理论中，C 代表 <strong>Linearizability (线性一致性)</strong> 或 <strong>Strong Consistency (强一致性)</strong>。意思是：<strong>所有的节点在同一时间看到的数据是完全相同的</strong>。</li><li><strong>核心关注点</strong>：<strong>多节点间的数据同步 (Synchronization &amp; Timing)</strong>。</li><li><strong>详细解释</strong>：<br>在分布式系统中，为了容灾，数据通常会有多个副本（Replica）。<ul><li>当你向节点 A 写入一个新值 <code>x = 1</code>。</li><li>紧接着向节点 B 读取 <code>x</code>。</li><li><strong>一致性</strong>要求：你必须读到 <code>1</code>。如果你读到了旧值 <code>0</code>，那么这个系统就不满足 CAP 中的 C。</li></ul></li><li><strong>一句话总结</strong>：<strong>它保证你读到的永远是最新写入的数据（就像只有一个副本一样）。</strong></li></ul><hr><h3 id="3-分布式事务中的一致性"><a href="#3-分布式事务中的一致性" class="headerlink" title="3. 分布式事务中的一致性"></a>3. 分布式事务中的一致性</h3><p>这里的背景是指<strong>微服务架构</strong>或<strong>跨数据库</strong>的操作（如 订单服务 + 库存服务 + 支付服务）。</p><ul><li><strong>定义</strong>：指在跨越多个独立服务或数据库的操作中，确保所有相关的数据最终能够达成一种<strong>逻辑上的对齐</strong>。它可以理解为事务的原子性，<strong>要么全部成功，要么全部失败</strong>。</li><li><strong>核心关注点</strong>：<strong>跨系统的原子性与最终状态 (Global Outcome)</strong>。</li><li><strong>详细解释</strong>：<br>由于分布式系统很难同时满足 CAP（通常为了可用性 A，必须牺牲强一致性 C），所以在分布式事务中，我们通常讨论两种一致性：<ol><li><strong>强一致性（刚性事务）</strong>：如 XA 协议、2PC（两阶段提交）。要求所有服务同时提交，立刻看到结果。这很像 ACID，但在分布式环境下性能极差。</li><li><strong>最终一致性（柔性事务，BASE理论）</strong>：如 TCC、Saga、消息队列。允许中间有一段时间数据是不一致的（例如订单已创建，但库存还没扣减完），但保证经过一段时间后，所有数据都会变对。</li></ol></li><li><strong>一句话总结</strong>：<strong>它保证多个独立系统的数据，虽然可能有延迟，但最终会“账目”对齐，不会出现“订单成功了但没扣库存”的烂账。</strong></li></ul><hr><h3 id="三者对比总结表"><a href="#三者对比总结表" class="headerlink" title="三者对比总结表"></a>三者对比总结表</h3><p>为了更清晰地理解，我们可以通过下表对比：</p><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">ACID 的一致性 (事务)</th><th style="text-align:left">CAP 的一致性 (分布式系统)</th><th style="text-align:left">分布式事务的一致性</th></tr></thead><tbody><tr><td style="text-align:left"><strong>侧重点</strong></td><td style="text-align:left"><strong>数据的正确性</strong> (逻辑约束)</td><td style="text-align:left"><strong>数据的可见性</strong> (时间同步)</td><td style="text-align:left"><strong>全局操作的协同</strong> (多方对齐)</td></tr><tr><td style="text-align:left"><strong>场景</strong></td><td style="text-align:left">单机数据库 (Oracle, MySQL)</td><td style="text-align:left">分布式存储 (Redis, ZK, NoSQL)</td><td style="text-align:left">微服务、跨库业务</td></tr><tr><td style="text-align:left"><strong>反例</strong></td><td style="text-align:left">转账后总金额变少了 (违反守恒)</td><td style="text-align:left">刚写完主库，读从库还是旧数据</td><td style="text-align:left">订单库显示“已支付”，库存库显示“未扣减”</td></tr><tr><td style="text-align:left"><strong>依赖对象</strong></td><td style="text-align:left">依赖数据库引擎的约束检查</td><td style="text-align:left">依赖共识算法 (Raft, Paxos) 或同步复制</td><td style="text-align:left">依赖协调器、MQ 或 补偿代码</td></tr><tr><td style="text-align:left"><strong>核心问题</strong></td><td style="text-align:left">“这笔数据合乎逻辑吗？”</td><td style="text-align:left">“我现在读到的是最新的吗？”</td><td style="text-align:left">“这几个系统的数据最后能对上吗？”</td></tr></tbody></table></div><h3 id="举个通俗的例子"><a href="#举个通俗的例子" class="headerlink" title="举个通俗的例子"></a>举个通俗的例子</h3><p>假设你要去买一杯奶茶：</p><ol><li><p><strong>ACID 一致性</strong>：你付了 20 元，店员必须给你一杯 20 元的奶茶。如果店员只给你一杯 10 元的水，或者没收钱就给你奶茶，这就违背了<strong>交易规则</strong>（ACID 破坏）。</p></li><li><p><strong>CAP 一致性</strong>：这家奶茶店有 3 个店员（副本）。店长（主节点）刚刚更新了菜单，把“珍珠奶茶”涨价到 25 元。你问店员 A，他说 25 元；你立刻问店员 B，如果店员 B 还说 20 元，那就是<strong>同步</strong>没做好（CAP 的 C 破坏）。</p></li><li><p><strong>分布式事务一致性</strong>：你在手机 App 上点单。</p><ul><li>你的支付宝扣了钱（支付服务）。</li><li>奶茶店的打印机出了小票（订单服务）。</li><li>如果支付宝扣了钱，但奶茶店没收到单子；或者奶茶店出了单子，支付宝没扣钱，这就是<strong>跨系统</strong>的不一致。分布式事务就是要保证：要么没扣钱也没单子，要么扣了钱也有单子（哪怕中间有几秒延迟）。</li></ul></li></ol><h2 id="线性一致性跟顺序一致性"><a href="#线性一致性跟顺序一致性" class="headerlink" title="线性一致性跟顺序一致性"></a>线性一致性跟顺序一致性</h2><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p><p>•    条件 I：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</p><p>•    条件 II：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>线性一致性的定义，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件 I 和条件 II 之外，还要同时满足一个条件：</p><p>•    条件 III：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>•    它们都试图让系统“表现得像只有一个副本”一样。</p><p>•    它们都保证了程序执行顺序不会被打乱。体现在条件 II 对于进程内各个操作的排序保持上。</p><p>•    线性一致性考虑了时间先后顺序，而顺序一致性没有。</p><p>•    满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</p><p>•    线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</p><p>•    在顺序一致性中，我们有可能读到旧版本的数据。</p><p>具体可以参考这篇博客 <a href="https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA">https://mp.weixin.qq.com/s/3odLhBtebF4cm58hl-87JA</a></p><h2 id="最终一致性又是什么？"><a href="#最终一致性又是什么？" class="headerlink" title="最终一致性又是什么？"></a>最终一致性又是什么？</h2><p>其实最终一致性就不满足CAP理论的C,而是对于AP系统的扩充。</p><p><strong>最终一致性（Eventual Consistency）是 CAP 理论中选择了 AP（可用性 + 分区容错性）策略后，为了弥补缺失的 C（强一致性）而不得不采用的一种“妥协”方案。</strong></p><p>或者更简单点说：<strong>最终一致性是 AP 系统的核心特征。</strong></p><p>我们可以从以下几个层面来剖析这段关系：</p><h3 id="1-CAP-的必然性与“二选一”"><a href="#1-CAP-的必然性与“二选一”" class="headerlink" title="1. CAP 的必然性与“二选一”"></a>1. CAP 的必然性与“二选一”</h3><p>CAP 理论告诉我们，在分布式系统中，<strong>P（分区容错性）是不可避免的</strong>（网线总会断，节点总会挂）。所以我们只能在 C（强一致性/线性一致性）和 A（可用性）之间做选择：</p><ul><li><strong>选择 CP（放弃 A）</strong>：为了保证数据绝对一致，当网络出问题时，我宁愿报错拒绝服务，也不让你读到旧数据。<ul><li><em>结果</em>：这是<strong>强一致性</strong>系统（如 Zookeeper, HBase）。</li></ul></li><li><strong>选择 AP（放弃 C）</strong>：为了保证服务永远可用，哪怕网络出问题了，我也让你读，虽然读到的可能是旧数据。<ul><li><em>结果</em>：这就是<strong>最终一致性</strong>发挥作用的地方（如 DNS, Eureka, Cassandra）。</li></ul></li></ul><h3 id="2-最终一致性在-CAP-图谱中的位置"><a href="#2-最终一致性在-CAP-图谱中的位置" class="headerlink" title="2. 最终一致性在 CAP 图谱中的位置"></a>2. 最终一致性在 CAP 图谱中的位置</h3><p>如果把 CAP 画成一个三角形：</p><ul><li><strong>CAP 中的 C (Consistency)</strong>：指的是<strong>线性一致性</strong>（强一致性）。如果你追求 CAP 的 C，你就必须保证写完立刻能读到。</li><li><strong>最终一致性</strong>：它是<strong>弱一致性</strong>的一种特例。<strong>它不属于 CAP 的 C</strong>。相反，它是当我们<strong>抛弃了 CAP 的 C</strong> 之后，退而求其次追求的目标。</li></ul><blockquote><p><strong>关系公式</strong>：<br><strong>CAP (AP 模式)</strong> = <strong>Availability</strong> (高可用) + <strong>Partition Tolerance</strong> (分区容错) + <strong>Eventual Consistency</strong> (最终一致性)</p></blockquote><h3 id="3-为什么-AP-系统必然导致最终一致性？"><a href="#3-为什么-AP-系统必然导致最终一致性？" class="headerlink" title="3. 为什么 AP 系统必然导致最终一致性？"></a>3. 为什么 AP 系统必然导致最终一致性？</h3><p>让我们推演一下：</p><ol><li><strong>前提 (P)</strong>：系统有两个节点 Node A 和 Node B，它们之间的网络断了。</li><li><strong>抉择 (A)</strong>：我们选择了高可用（Availability），所以当用户向 Node A 写入 <code>x=1</code> 时，Node A 必须接受并返回成功，不能报错。</li><li><strong>后果</strong>：此时，Node A 的数据是 <code>x=1</code>，而 Node B 因为网络断了，数据还是 <code>x=0</code>。</li><li><strong>现状</strong>：此时系统已经<strong>不一致</strong>了（违反了 CAP 的 C）。</li><li><strong>补救 (最终一致性)</strong>：我们不能让 Node B 永远是 <code>0</code>。系统承诺：当网络恢复后，Node A 会后台把 <code>x=1</code> 同步给 Node B。经过一段时间（不确定多久），Node B 最终也会变成 <code>1</code>。</li></ol><p><strong>结论</strong>：因为选择了 A（允许在断网时继续写），必然导致数据暂时不一致。而“最终一致性”就是对这种暂时不一致的<strong>容忍</strong>和对未来的<strong>承诺</strong>。</p><h3 id="4-延伸：BASE-理论"><a href="#4-延伸：BASE-理论" class="headerlink" title="4. 延伸：BASE 理论"></a>4. 延伸：BASE 理论</h3><p>讲到最终一致性与 CAP 的关系，就不得不提 <strong>BASE 理论</strong>。它是对 CAP 中 AP 策略的工程化延伸。：</p><ul><li><strong>BA (Basically Available)</strong>：基本可用（允许响应时间慢一点，或者部分降级）。</li><li><strong>S (Soft state)</strong>：软状态（允许系统存在中间状态，即允许数据同步有延迟）。</li><li><strong>E (Eventual consistency)</strong>：最终一致性（数据最终会变对）。</li></ul><h3 id="5-总结表"><a href="#5-总结表" class="headerlink" title="5. 总结表"></a>5. 总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">CAP 的 C (强一致性)</th><th style="text-align:left">最终一致性 (弱一致性的一种)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CAP 选择</strong></td><td style="text-align:left"><strong>CP</strong> (放弃可用性)</td><td style="text-align:left"><strong>AP</strong> (放弃强一致性)</td></tr><tr><td style="text-align:left"><strong>核心逻辑</strong></td><td style="text-align:left">写操作完成后，所有节点<strong>立刻</strong>可见。</td><td style="text-align:left">写操作完成后，数据<strong>异步</strong>复制，经过一段时间才可见。</td></tr><tr><td style="text-align:left"><strong>用户体验</strong></td><td style="text-align:left">“要么读到最新的，要么系统告诉我报错/超时。”</td><td style="text-align:left">“我可能读到旧的，但系统保证随时能用。”</td></tr><tr><td style="text-align:left"><strong>典型场景</strong></td><td style="text-align:left">银行余额、库存扣减、分布式锁 (Etcd/ZK)</td><td style="text-align:left">社交网络点赞、DNS解析、电商商品浏览量</td></tr><tr><td style="text-align:left"><strong>关系</strong></td><td style="text-align:left"><strong>它是 CAP 定义的一致性标准</strong></td><td style="text-align:left"><strong>它是放弃 CAP 的 C 之后的替代方案</strong></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于CAP这里就不详细说明，本文主要讨论CAP中的 C 即一致性（线性一致性）&lt;/p&gt;
&lt;h2 id=&quot;首先我们要知道什么是CAP的一致性，他跟事务的一致性有什么区别，跟分布式事务里面所谓的一致性又有什么区别？&quot;&gt;&lt;a href=&quot;#首先我们要知道什么是CAP的一致性，他跟</summary>
      
    
    
    
    
    <category term="分布式" scheme="https://nmcb666.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法（四）递归</title>
    <link href="https://nmcb666.vip/posts/38e6282b.html"/>
    <id>https://nmcb666.vip/posts/38e6282b.html</id>
    <published>2026-01-20T15:24:25.000Z</published>
    <updated>2026-02-07T05:35:43.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归相关的题目"><a href="#递归相关的题目" class="headerlink" title="递归相关的题目"></a>递归相关的题目</h1><h2 id="找一个字符串的不重复的子序列"><a href="#找一个字符串的不重复的子序列" class="headerlink" title="找一个字符串的不重复的子序列"></a>找一个字符串的不重复的子序列</h2><p>递归的思路：每次按要这个位置的字符和不要这个位置的字符两种情况去递归，当i = s.length()时，保存当前的子序列。用hashSet去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String[] generatePermutation(String str) &#123;</span><br><span class="line"><span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">f2(s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">char</span>[s.length], <span class="number">0</span>, set);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> set.size();</span><br><span class="line">String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[m];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String cur : set) &#123;</span><br><span class="line">ans[i++] = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// i是当前要处理的字符的索引,path是当前已经保存的路径，size是path的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">char</span>[] path, <span class="type">int</span> size, HashSet&lt;String&gt; set)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">set.add(String.valueOf(path, <span class="number">0</span>, size));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path[size] = s[i];</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size + <span class="number">1</span>, set);</span><br><span class="line">f2(s, i + <span class="number">1</span>, path, size, set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找一个数组中的所有子数组，顺序可以任意"><a href="#找一个数组中的所有子数组，顺序可以任意" class="headerlink" title="找一个数组中的所有子数组，顺序可以任意"></a>找一个数组中的所有子数组，顺序可以任意</h2><p>思路：先将数组排序，然后每次对同一个数讨论，要0个，要1个… 还需要知道对于这个数来说下一个跟自己不同的数的位置，然后调用递归从下个不同的数开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    findSubsetsWithDup(<span class="number">0</span>,nums,<span class="number">0</span>,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findSubsetsWithDup</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span> size,<span class="type">int</span>[] path,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">            temp.add(path[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找出下一个跟自己不同的数的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; nums[j] == nums[i])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要0个</span></span><br><span class="line">        findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        <span class="comment">// 依次要多个</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++)&#123;</span><br><span class="line">            path[size++] = nums[i];</span><br><span class="line">            findSubsetsWithDup(j,nums,size,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。"><a href="#给定一个不含重复数字的数组-nums-，返回其-所有可能的全排列-。你可以-按任意顺序-返回答案。" class="headerlink" title="给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。"></a>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</h2><p>思路： 每次拿一个数跟当前下标的第一个数交换，然后递归调用将下标+1，递归完成后再交换回来。终止条件就算下标==nums.length</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    findPermute(nums,<span class="number">0</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPermute</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            temp.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            findPermute(nums,i+<span class="number">1</span>,ans);</span><br><span class="line">            <span class="comment">// 交换回来</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：如果有重复数字，则需要去重</p><p>思路： 每次递归的时候维护一个set这个set记录哪些数来到过我这个下标，如果发现一个数已经来到过，则不进行交换，也不递归跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">cur.add(num);</span><br><span class="line">&#125;</span><br><span class="line">ans.add(cur);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="comment">// nums[j]没有来到过i位置，才会去尝试</span></span><br><span class="line"><span class="keyword">if</span> (!set.contains(nums[j])) &#123;</span><br><span class="line">set.add(nums[j]);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">f(nums, i + <span class="number">1</span>, ans);</span><br><span class="line">swap(nums, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>思路：维护一个路径数组path[],path的第几个数的值表示第几行的皇后放在第几列，每次循环每一行的列去判断是否合法，如果合法则递归调用下一行，并且size++.终止条件是size == n 即找到合法的一个解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    findSolveNQueens(<span class="number">0</span>,n,path,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findSolveNQueens</span><span class="params">(<span class="type">int</span> size,<span class="type">int</span> n,<span class="type">int</span>[] path,List&lt;List&lt;String&gt;&gt; ans)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(size == n)&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span>path[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span> ;j&lt;pos;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> pos+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依次尝试</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 尝试第i列</span></span><br><span class="line">            <span class="keyword">if</span>(isvalid(i,path,size))&#123;</span><br><span class="line">                <span class="comment">// 合法</span></span><br><span class="line">                path[size] = i;</span><br><span class="line">                findSolveNQueens(size+<span class="number">1</span>,n,path,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isvalid</span> <span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] path,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k&lt; size; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==path[k])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Math.abs(size-k) == Math.abs(i-path[k]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拓展： 利用位运算去判断当前位置是否合法。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://java-ai-nskk.oss-cn-beijing.aliyuncs.com/myblog/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-21%20162737.png" alt="示例图片"/></div><span class="image-caption">示例图片</span></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalNQueens2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n = 5</span></span><br><span class="line"><span class="comment">// 1 &lt;&lt; 5 = 0...100000 - 1</span></span><br><span class="line"><span class="comment">// limit  = 0...011111; </span></span><br><span class="line"><span class="comment">// n = 7</span></span><br><span class="line"><span class="comment">// limit  = 0...01111111; </span></span><br><span class="line"><span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> f2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// limit : 当前是几皇后问题</span></span><br><span class="line"><span class="comment">// 之前皇后的列影响：col</span></span><br><span class="line"><span class="comment">// 之前皇后的右上 -&gt; 左下对角线影响：left</span></span><br><span class="line"><span class="comment">// 之前皇后的左上 -&gt; 右下对角线影响：right</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> col, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (col == limit) &#123;</span><br><span class="line"><span class="comment">// 所有皇后放完了！</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总限制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ban</span> <span class="operator">=</span> col | left | right;</span><br><span class="line"><span class="comment">// ~ban : 1可放皇后，0不能放</span></span><br><span class="line"><span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> limit &amp; (~ban);</span><br><span class="line"><span class="comment">// 放置皇后的尝试！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 一共有多少有效的方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (candidate != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 提取出最右侧的1</span></span><br><span class="line"><span class="comment">// 0 0 1 1 1 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 1 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 1 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">// place : </span></span><br><span class="line"><span class="comment">// 0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">// candidate : </span></span><br><span class="line"><span class="comment">// 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">// 5 4 3 2 1 0</span></span><br><span class="line">place = candidate &amp; (-candidate);</span><br><span class="line">candidate ^= place;</span><br><span class="line">ans += f2(limit, col | place, (left | place) &gt;&gt; <span class="number">1</span>, (right | place) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归相关的题目&quot;&gt;&lt;a href=&quot;#递归相关的题目&quot; class=&quot;headerlink&quot; title=&quot;递归相关的题目&quot;&gt;&lt;/a&gt;递归相关的题目&lt;/h1&gt;&lt;h2 id=&quot;找一个字符串的不重复的子序列&quot;&gt;&lt;a href=&quot;#找一个字符串的不重复的子序列&quot; cla</summary>
      
    
    
    
    
    <category term="算法" scheme="https://nmcb666.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
